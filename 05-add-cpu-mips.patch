From a4eb59ffc65a265c8e029b8fbb01dc844973f295 Mon Sep 17 00:00:00 2001
From: Mike Banon <mikebdp2@gmail.com>
Date: Fri, 29 Nov 2019 17:46:42 +0000
Subject: [PATCH] Add ./cpu/mips/ Atheros files from WR841N(D)v9 u-boot

---
 cpu/mips/ar7100/Makefile          |   22 +
 cpu/mips/ar7100/ag7100.c          |  823 +++++
 cpu/mips/ar7100/ag7100.h          |  239 ++
 cpu/mips/ar7100/ag7100_phy.h      |  257 ++
 cpu/mips/ar7100/ar7100_serial.c   |  178 ++
 cpu/mips/ar7100/meminit.c         |  297 ++
 cpu/mips/ar7240/Makefile          |   61 +
 cpu/mips/ar7240/ag7240.c          |  722 +++++
 cpu/mips/ar7240/ag7240.h          |  237 ++
 cpu/mips/ar7240/ag7240_phy.h      |   69 +
 cpu/mips/ar7240/ag934x.c          |  877 ++++++
 cpu/mips/ar7240/ag934x.h          |  242 ++
 cpu/mips/ar7240/ag934x_phy.h      |  117 +
 cpu/mips/ar7240/ar7240_serial.c   |  142 +
 cpu/mips/ar7240/hornet.h          |   34 +
 cpu/mips/ar7240/hornet_ag7240.c   |  662 ++++
 cpu/mips/ar7240/hornet_ddr_init.S | 4690 +++++++++++++++++++++++++++++
 cpu/mips/ar7240/hornet_serial.c   |  216 ++
 cpu/mips/ar7240/meminit.c         |  558 ++++
 cpu/mips/start_bootstrap.S        |  799 +++++
 20 files changed, 11242 insertions(+)
 create mode 100644 cpu/mips/ar7100/Makefile
 create mode 100644 cpu/mips/ar7100/ag7100.c
 create mode 100644 cpu/mips/ar7100/ag7100.h
 create mode 100644 cpu/mips/ar7100/ag7100_phy.h
 create mode 100644 cpu/mips/ar7100/ar7100_serial.c
 create mode 100644 cpu/mips/ar7100/meminit.c
 create mode 100644 cpu/mips/ar7240/Makefile
 create mode 100644 cpu/mips/ar7240/ag7240.c
 create mode 100644 cpu/mips/ar7240/ag7240.h
 create mode 100644 cpu/mips/ar7240/ag7240_phy.h
 create mode 100644 cpu/mips/ar7240/ag934x.c
 create mode 100644 cpu/mips/ar7240/ag934x.h
 create mode 100644 cpu/mips/ar7240/ag934x_phy.h
 create mode 100644 cpu/mips/ar7240/ar7240_serial.c
 create mode 100644 cpu/mips/ar7240/hornet.h
 create mode 100644 cpu/mips/ar7240/hornet_ag7240.c
 create mode 100755 cpu/mips/ar7240/hornet_ddr_init.S
 create mode 100644 cpu/mips/ar7240/hornet_serial.c
 create mode 100644 cpu/mips/ar7240/meminit.c
 create mode 100644 cpu/mips/start_bootstrap.S

diff --git a/cpu/mips/ar7100/Makefile b/cpu/mips/ar7100/Makefile
new file mode 100644
index 0000000..d7bce6f
--- /dev/null
+++ b/cpu/mips/ar7100/Makefile
@@ -0,0 +1,22 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+START	=
+#OBJS	= ar7100_serial.o ag7100.o ar7100_flash.o meminit.o
+OBJS	= ar7100_serial.o ag7100.o meminit.o
+SOBJS	=
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS) $(OBJS-0)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/mips/ar7100/ag7100.c b/cpu/mips/ar7100/ag7100.c
new file mode 100644
index 0000000..66e7649
--- /dev/null
+++ b/cpu/mips/ar7100/ag7100.c
@@ -0,0 +1,823 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7100_soc.h"
+#include "ag7100.h"
+
+#if defined(CONFIG_CMD_MII)
+#include <miiphy.h>
+#endif
+
+#include "ag7100_phy.h"
+
+#define ag7100_name2mac(name)	   (strcmp(name,"eth0") ? ag7100_unit2mac(1) : ag7100_unit2mac(0))
+
+int ag7100_miiphy_read(char *devname, unsigned char phaddr,
+	       unsigned char reg, unsigned short *value);
+int ag7100_miiphy_write(char *devname, unsigned char phaddr,
+	        unsigned char reg, unsigned short data);
+
+ag7100_mac_t *ag7100_macs[CFG_AG7100_NMACS];
+
+#ifdef AG7100_DEBUG
+int ag7100_txdbg = 0;
+int ag7100_rxdbg = 0;
+
+void pkt_dump(char *id, char *data,int pkt_size) {
+
+    int i;
+    printf("**********Packet dump (%s)******* %p size:%d\n", id, data, pkt_size);
+    for(i=0;i<=pkt_size;i++) {
+       if (!(i%4)) printf(" ");
+       printf("%2.2X", (unsigned)(data[i]&0xff));
+       if(!(i%32)) printf("\n");
+    }
+    printf("\n");
+    printf("***********end***************\n");
+}
+#endif
+pkt_push(uint8_t *pkt,int length)
+{
+   uint8_t *buf;
+   buf = (uint8_t *)malloc(length);
+   memcpy(buf, pkt, length);
+   memcpy(pkt + 2, buf, length);
+   free(buf);
+}
+
+
+ag7100_mac_t *ag7100_unit2mac(int unit)
+{
+    return (unit ? ag7100_macs[1] : ag7100_macs[0]);
+}
+
+static int
+ag7100_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+    ag7100_mac_t *mac = (ag7100_mac_t *)dev->priv;
+
+    ag7100_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+    uint8_t *pkt_buf;
+
+    pkt_buf = (uint8_t *) packet;
+    /* 
+     * Add normal packet headers if its not a control packet 
+     */
+    if (((pkt_buf[0] & 0xff) != 0x7f) && ((pkt_buf[1] & 0xff) != 0x5d)) {
+        pkt_push(pkt_buf,length);
+        length = length + ATHRHDR_LEN;
+        pkt_buf[0] = 0x10;  /* broadcast = 0; from_cpu = 0; reserved = 1; port_num = 0 */
+        pkt_buf[1] = 0x80;  /* reserved = 0b10; priority = 0; type = 0 (normal) */
+    }
+    else {
+        length  = (length - ATHRHDR_LEN);
+        pkt_buf = (uint8_t *) ((uint8_t *)pkt_buf + 2);
+    }
+    f->pkt_size = length;
+    f->pkt_start_addr = virt_to_phys(pkt_buf);
+#else
+    f->pkt_size = length;
+    f->pkt_start_addr = virt_to_phys(packet);
+#endif
+#ifdef AG7100_DEBUG
+    if (ag7100_txdbg) pkt_dump("Tx", packet, length);
+#endif
+    ag7100_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7100_reg_wr(mac, AG7100_DMA_TX_DESC, virt_to_phys(f));
+    ag7100_reg_wr(mac, AG7100_DMA_TX_CTRL, AG7100_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7100_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7100_recv(struct eth_device *dev)
+{
+    int length;
+    ag7100_desc_t *f;
+    ag7100_mac_t *mac;
+ 
+    mac = (ag7100_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7100_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+#ifdef AG7100_DEBUG
+        if (ag7100_rxdbg) pkt_dump("Rx", NetRxPackets[mac->next_rx], length);
+#endif
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7100_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7100_reg_rd(mac, AG7100_DMA_RX_CTRL))) {
+        ag7100_reg_wr(mac, AG7100_DMA_RX_DESC, virt_to_phys(f));
+        ag7100_reg_wr(mac, AG7100_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+#if defined(CFG_ATHRS16_PHY) || defined(CFG_ATHRF1_PHY)
+/*
+ * program the usb pll (misnomer) to genrate appropriate clock
+ * Write 2 into control field
+ * Write pll value 
+ * Write 3 into control field
+ * Write 0 into control field
+ */ 
+#define ag7100_pll_shift(_mac)      (((_mac)->mac_unit) ? 19: 17)
+#define ag7100_pll_offset(_mac)     \
+    (((_mac)->mac_unit) ? AR7100_USB_PLL_GE1_OFFSET : \
+                          AR7100_USB_PLL_GE0_OFFSET)
+static void
+ag7100_set_pll(ag7100_mac_t *mac, unsigned int pll)
+{
+#define ETH_PLL_CONFIG AR7100_USB_PLL_CONFIG
+    uint32_t shift, reg, val;
+
+    shift = ag7100_pll_shift(mac);
+    reg   = ag7100_pll_offset(mac);
+
+    val  = ar7100_reg_rd(ETH_PLL_CONFIG);
+    val &= ~(3 << shift);
+    val |=  (2 << shift);
+    ar7100_reg_wr(ETH_PLL_CONFIG, val);
+    udelay(100);
+
+    ar7100_reg_wr(reg, pll);
+
+    val |=  (3 << shift);
+    ar7100_reg_wr(ETH_PLL_CONFIG, val);
+    udelay(100);
+
+    val &= ~(3 << shift);
+    ar7100_reg_wr(ETH_PLL_CONFIG, val);
+    udelay(100);
+
+    printf("pll reg %#x: %#x  ", reg, ar7100_reg_rd(reg));
+}
+#endif
+
+static void ag7100_hw_start(ag7100_mac_t *mac)
+{
+    u32 mii_ctrl_val;
+#if defined (CFG_AG7100_GE0_GMII)
+    u32 isXGMII0 = 1;
+#else
+    u32 isXGMII0 = 0;
+#endif
+#if defined (CFG_AG7100_GE1_GMII)
+    u32 isXGMII1 = 1;
+#else
+    u32 isXGMII1 = 0;
+#endif
+
+#if defined(CFG_MII0_RGMII)
+    mii_ctrl_val = 0x12; /* this value seems to be incorrect - JK */
+#elif defined(CFG_MII0_MII)
+    mii_ctrl_val = 0x11;
+#elif defined(CFG_MII0_RMII)
+    mii_ctrl_val = 0x13;
+#endif
+
+    ag7100_reg_wr(mac, AG7100_MAC_CFG1, (AG7100_MAC_CFG1_RX_EN |
+		    AG7100_MAC_CFG1_TX_EN));
+
+    ag7100_reg_rmw_set(mac, AG7100_MAC_CFG2, (AG7100_MAC_CFG2_PAD_CRC_EN |
+		         AG7100_MAC_CFG2_LEN_CHECK));
+
+    if (mac->mac_unit == 0) ag7100_set_mac_if(mac, isXGMII0);
+    if (mac->mac_unit == 1) ag7100_set_mac_if(mac, isXGMII1);
+
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_0, 0x1f00);
+
+#if !defined(CFG_BOARD_PB44) && !defined(CFG_BOARD_PB45) && !defined(CFG_BOARD_AP96) && !defined(CFG_BOARD_PB47)
+    if(mac->mac_unit == 0) {
+        ar7100_reg_wr(AR7100_MII0_CTRL, mii_ctrl_val);
+    } else {
+        ar7100_reg_wr(AR7100_MII1_CTRL, mii_ctrl_val);
+    }
+#else
+    /* this is a better way of setting the MII registers than immediately above */
+    //printf("%s: mii_if %#x\n", __func__, mii_if(mac));
+    ar7100_reg_wr(mii_reg(mac), mii_if(mac));
+#endif
+
+    //ag7100_reg_wr(mac, AG7100_MAC_IFCTL, 0x10000);
+    //ag7100_reg_wr(mac, AG7100_MAC_CFG1, 0x005);
+    ag7100_reg_wr(mac, AG7100_MAC_MII_MGMT_CFG, AG7100_MGMT_CFG_CLK_DIV_20);
+
+    ag7100_reg_rmw_set(mac, AG7100_MAC_FIFO_CFG_4, 0x3ffff);
+    ag7100_reg_rmw_set(mac, AG7100_MAC_FIFO_CFG_5, 0x7ffef);
+    ag7100_reg_rmw_clear(mac, AG7100_MAC_FIFO_CFG_5, (1 << 19));
+#ifdef AR9100
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_3, 0x780008);
+#else
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_3, 0x400fff);
+#endif
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_1, 0xfff0000);
+    ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_2, 0x1fff);
+//printf(": cfg1 %#x cfg2 %#x\n", ag7100_reg_rd(mac, AG7100_MAC_CFG1),
+//        ag7100_reg_rd(mac, AG7100_MAC_CFG2));
+
+}
+
+#ifdef CFG_ATHRS16_PHY 
+static int is_setup_done = 0;
+#endif
+static void ag7100_set_mac_from_link(ag7100_mac_t *mac, int speed, int fdx)
+{
+    int is1000 = (speed == _1000BASET);
+    int is100 = (speed == _100BASET);
+
+#ifdef CFG_ATHRS16_PHY 
+    if(!is_setup_done && (mac->speed != speed || mac->duplex != fdx))
+    {
+       phy_mode_setup();
+       is_setup_done = 1;
+    }
+#endif
+
+    mac->speed = speed;
+    mac->duplex = fdx;
+
+    if (is1000) {
+        ag7100_set_mii_ctrl_speed(mac, 2);
+    }
+    else if (is100) {
+        ag7100_set_mii_ctrl_speed(mac, 1);
+    }
+    else {
+        ag7100_set_mii_ctrl_speed(mac, 0);
+    }
+    ag7100_set_mac_if(mac, is1000);
+    ag7100_set_mac_duplex(mac, fdx);
+
+    if (!is1000)
+        ag7100_set_mac_speed(mac, is100);
+    /*
+     * XXX program PLL
+     */
+#if defined(CFG_ATHRS16_PHY) || defined(CFG_ATHRF1_PHY)
+    if (is1000)
+        ag7100_set_pll(mac, 0x110000);
+    else if (is100)
+        ag7100_set_pll(mac, 0x0001099);
+    else
+        ag7100_set_pll(mac, 0x00991099);
+#endif
+
+    mac->link = 1;
+}
+
+static int ag7100_check_link(ag7100_mac_t *mac)
+{
+    u32 link, duplex, speed;
+
+#ifdef AR9100
+    u32 fdx, i;
+
+#if !defined(CFG_ATHRS26_PHY) && !defined(CFG_ATHRHDR_EN)
+    ag7100_phy_link(mac->mac_unit, link, duplex, speed);
+    ag7100_phy_duplex(mac->mac_unit,duplex);
+    ag7100_phy_speed(mac->mac_unit,speed);
+
+    mac->link = link;
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+#else
+     duplex = FULL;
+     speed = _100BASET;
+#endif
+      if (speed == _1000BASET) {
+	    uint32_t shift, reg, val;
+
+        if(!mac->mac_unit){
+            ar7100_reg_wr(AR7100_MII0_CTRL, 0x22);
+	} else {
+	    ar7100_reg_wr(AR7100_MII1_CTRL, 0x22);
+	}
+
+        ag7100_reg_rmw_clear(mac, AG7100_MAC_CFG2, 0xffff);
+        ag7100_reg_rmw_set(mac, AG7100_MAC_CFG2, 0x7215);
+        ag7100_reg_wr(mac, AG7100_MAC_FIFO_CFG_3, 0x780fff);
+
+#define ag7100_pll_shift(_mac)	(((_mac)->mac_unit) ? 22: 20)
+#define ag7100_pll_offset(_mac)	(((_mac)->mac_unit) ? 0xb8050018 : 0xb8050014)
+#define ETH_PLL_CONFIG		0xb8050004
+
+	shift = ag7100_pll_shift(mac);
+	reg = ag7100_pll_offset(mac);
+
+	val  = ar7100_reg_rd(ETH_PLL_CONFIG);
+	val &= ~(3 << shift);
+	val |=  (2 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	if (mac->mac_unit) {
+#if defined(CFG_DUAL_F1E_PHY)
+        	*(volatile int *) 0xb8050018 = 0x1a000000;
+#else
+        	*(volatile int *) 0xb8050018 = 0x1f000000;
+#endif  
+	} else {
+        	*(volatile int *) 0xb8050014 = 0x1a000000;
+	}
+
+	val |=  (3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	val &= ~(3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+
+        ag7100_reg_rmw_set(mac, AG7100_MAC_FIFO_CFG_5, (1 << 19));
+
+        if(mac->mac_unit == 0) {
+            miiphy_write(mac->dev->name, CFG_PHY_ADDR, 0x1f, 0x1);
+            miiphy_write(mac->dev->name, CFG_PHY_ADDR, 0x1c, 0x3000);
+            miiphy_write(mac->dev->name, CFG_PHY_ADDR, 0x1f, 0x0);
+       }
+    } else if (speed == _100BASET) {
+#define ag7100_pll_shift(_mac)	(((_mac)->mac_unit) ? 22: 20)
+#define ag7100_pll_offset(_mac)	(((_mac)->mac_unit) ? 0xb8050018 : 0xb8050014)
+#define ETH_PLL_CONFIG		0xb8050004
+	uint32_t shift, reg, val;
+
+	shift = ag7100_pll_shift(mac);
+	reg = ag7100_pll_offset(mac);
+
+	val  = ar7100_reg_rd(ETH_PLL_CONFIG);
+	val &= ~(3 << shift);
+	val |=  (2 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	if (mac->mac_unit) {
+#if defined(CFG_DUAL_F1E_PHY)
+        	*(volatile int *) 0xb8050018 = 0x13000a44;
+#else
+        	*(volatile int *) 0xb8050018 = 0x1f000000;
+#endif   
+	} else {
+        	*(volatile int *) 0xb8050014 = 0x13000a44;
+	}
+
+	val |=  (3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	val &= ~(3 << shift);
+	ar7100_reg_wr(ETH_PLL_CONFIG, val);
+	udelay(100);
+
+	//printf(": pll reg %#x: %#x  ", reg, ar7100_reg_rd(reg));
+
+        ag7100_reg_rmw_clear(mac, AG7100_MAC_CFG2, 0xffff);
+        ag7100_reg_rmw_set(mac, AG7100_MAC_CFG2, 0x7115);
+    }
+    if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+                    return 1;
+    mac->duplex = duplex;
+    mac->speed = speed;
+    mac->link = 1;
+
+    fdx = (duplex == FULL) ? 1 : 0;
+    printf("dup %d speed %d\n", fdx, speed);
+
+    ag7100_set_mac_duplex(mac,fdx);
+
+    if (speed == _100BASET)
+        ag7100_set_mac_speed(mac, 1);
+    else if (speed == _10BASET)
+        ag7100_set_mac_speed(mac, 0);
+
+    return 1;
+#else
+    ag7100_get_link_status(mac->mac_unit, &link, &duplex, &speed);
+
+    mac->link = link;
+    
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1;
+
+    ag7100_set_mac_from_link(mac, speed, duplex);
+    return 1;
+#endif
+
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7100_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7100_desc_t *fr;
+    ag7100_mac_t *mac = (ag7100_mac_t*)dev->priv;
+
+    if (!ag7100_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7100_rx_give_to_dma(fr);
+    }
+
+    ag7100_reg_wr(mac, AG7100_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7100_reg_wr(mac, AG7100_DMA_RX_CTRL, AG7100_RXE);	/* rx start */
+    udelay(2000);
+
+
+    return 1;
+
+}
+
+static int ag7100_alloc_fifo(int ndesc, ag7100_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7100_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7100_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7100_setup_fifos(ag7100_mac_t *mac)
+{
+    int i;
+
+    if (ag7100_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7100_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7100_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7100_halt(struct eth_device *dev)
+{
+    ag7100_mac_t *mac = (ag7100_mac_t *)dev->priv;
+    ag7100_reg_wr(mac, AG7100_DMA_RX_CTRL, 0);
+    while (ag7100_reg_rd(mac, AG7100_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7100_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7100_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+
+}
+
+static void ag7100_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+
+    eeprom = ag7100_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] == 0xff && mac[5] == 0xff) {
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    }
+}
+
+#ifdef CONFIG_AR9100_MDIO_DEBUG
+int
+ag7100_dump_vsc_regs(ag7100_mac_t *mac)
+{
+
+	unsigned i;
+	unsigned short v;
+	char *fmt[] = {"\t", "\n"};
+
+	printf("IEEE & Standard registers\n");
+	for (i = 0; i < 0x20; i++) {
+		v = 0;
+		ag7100_miiphy_read(mac->dev->name, 0, i, &v);
+		printf("0x%02x: 0x%04x%s", i, v, fmt[i & 1]);
+	}
+
+	printf("Extended registers\n");
+
+	/* Enable extended register set access */
+	ag7100_miiphy_write(mac->dev->name, 0, 0x1f,  0x1);
+	for (i = 16; i <= 30; i++) {
+		v = 0;
+		ag7100_miiphy_read(mac->dev->name, 0, i, &v);
+		printf("0x%02x: 0x%04x%s", i, v, fmt[i & 1]);
+	}
+	ag7100_miiphy_write(mac->dev->name, 0, 0x1f,  0x0);
+	printf("\n");
+}
+#endif
+
+int ag7100_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7100_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_SWITCH_FREQ)
+    u32 pll_value;
+#endif
+
+    printf("ag7100_enet_initialize...\n");
+
+#ifdef AR9100
+   /* Workaround to bring the TX_EN to low */
+
+     i = *(volatile int *) 0xb806001c ;
+    *(volatile int *) 0xb806001c = (i | 0x3300);
+    udelay(10 * 1000);
+     i = *(volatile int *) 0xb806001c ;
+    *(volatile int *) 0xb806001c = (i & 0xffffccff);
+    udelay(10 * 1000);
+    *(volatile int *) 0xb8070000 = 0x13;
+    *(volatile int *) 0xb8070004 = 0x11;
+    udelay(10 * 1000);
+    *(volatile int *) 0xb9000000 = 0x0;
+    *(volatile int *) 0xba000000 = 0x0;
+     i = *(volatile int *) 0xb806001c ;
+    *(volatile int *) 0xb806001c = (i | 0x3300);
+    udelay(10 * 1000);
+#endif
+
+    for (i = 0;i < CFG_AG7100_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7100_macs[i] = (ag7100_mac_t *) malloc(sizeof (ag7100_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7100_macs[i], 0, sizeof(ag7100_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7100_get_ethaddr(dev[i]);
+    
+    ag7100_macs[i]->mac_unit = i;
+    ag7100_macs[i]->mac_base = i ? AR7100_GE1_BASE : AR7100_GE0_BASE ;
+    ag7100_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7100_clean_rx;
+    dev[i]->halt = ag7100_halt;
+    dev[i]->send = ag7100_send;
+    dev[i]->recv = ag7100_recv;
+    dev[i]->priv = (void *)ag7100_macs[i];	
+
+    eth_register(dev[i]);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+    athrs26_reg_dev(dev[i]);
+#endif
+#if defined(CONFIG_CMD_MII)
+    miiphy_register(dev[i]->name, ag7100_miiphy_read, ag7100_miiphy_write);
+#endif
+        /*
+        ** This is the actual reset sequence
+        */
+        
+        mask = i ?(AR7100_RESET_GE1_MAC | AR7100_RESET_GE1_PHY) :
+                  (AR7100_RESET_GE0_MAC | AR7100_RESET_GE0_PHY);
+
+        ar7100_reg_rmw_set(AR7100_RESET, mask);
+        udelay(10000);
+
+        ar7100_reg_rmw_clear(AR7100_RESET, mask);
+        udelay(10000);
+
+    ag7100_hw_start(ag7100_macs[i]);
+    ag7100_setup_fifos(ag7100_macs[i]);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_SWITCH_FREQ)
+    pll_value = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+    mask = pll_value & ~(PLL_CONFIG_PLL_FB_MASK | PLL_CONFIG_REF_DIV_MASK);
+    mask = mask | (0x64 << PLL_CONFIG_PLL_FB_SHIFT) |
+        (0x5 << PLL_CONFIG_REF_DIV_SHIFT) | (1 << PLL_CONFIG_AHB_DIV_SHIFT);
+
+    ar7100_reg_wr_nf(AR7100_CPU_PLL_CONFIG, mask);
+    udelay(10 * 1000);
+#endif
+
+    ag7100_phy_setup(ag7100_macs[i]->mac_unit);
+    udelay(10 * 1000);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_SWITCH_FREQ)
+    ar7100_reg_wr_nf(AR7100_CPU_PLL_CONFIG, pll_value);
+    udelay(10 * 1000);
+#endif
+    {
+        unsigned char *mac = dev[i]->enetaddr;
+
+        printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+               mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+               mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+    }
+    mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+    mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+        (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+    ag7100_reg_wr(ag7100_macs[i], AG7100_GE_MAC_ADDR1, mac_l);
+    ag7100_reg_wr(ag7100_macs[i], AG7100_GE_MAC_ADDR2, mac_h);
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+    	athrs26_reg_init();
+#elif defined(CFG_ATHRS16_PHY)
+    if (ag7100_macs[i]->mac_unit == 1)
+        athrs16_reg_init();
+#endif
+
+    printf("%s up\n",dev[i]->name);
+    }
+
+#ifdef CONFIG_AR9100_MDIO_DEBUG
+    ag7100_dump_vsc_regs(ag7100_macs[i]);
+#endif
+
+    return 1;
+}
+
+#if defined(CONFIG_CMD_MII)
+int ag7100_miiphy_read(char *devname, unsigned char phaddr,
+	       unsigned char reg, unsigned short *value)
+{
+    uint16_t addr = (phaddr << AG7100_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    ag7100_mac_t *mac = ag7100_name2mac(devname);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, AG7100_MGMT_CMD_READ);
+
+    rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    while (rddata) {
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }
+
+    *value = ag7100_reg_rd(mac, AG7100_MII_MGMT_STATUS);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+
+    return 0;
+}
+
+int ag7100_miiphy_write(char *devname, unsigned char phaddr,
+	        unsigned char reg, unsigned short data)
+{
+    uint16_t addr = (phaddr << AG7100_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    ag7100_mac_t *mac = ag7100_name2mac(devname);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CTRL, data);
+
+    rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    while (rddata) {
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }
+    return 0;
+}
+
+#if defined(CFG_ATHRS26_PHY) && defined(CFG_ATHRHDR_EN)
+/***********************************************************************
+ * command line interface:To do individual phy reset
+ */
+
+int do_miiphyreset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int phyUnit;
+	char *p;
+
+	if (argc == 1) {
+		printf("Usage:\n    miiphyreset phyUnit\n");
+		return -1;
+	}
+
+	*p = *argv[1];
+	phyUnit = *p - '0';
+
+	if (phyUnit > 4) {
+		printf("phyUnit to big!\n");
+		return -1;
+	}
+	individual_phyreset(phyUnit);
+	printf("Completed!\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+    miiphyreset ,CFG_MAXARGS, 1, do_miiphyreset,
+    "miiphyreset - Reset phy\n",
+    " port no\n"
+    );
+#endif
+
+#endif		/* CONFIG_CMD_MII */
+
diff --git a/cpu/mips/ar7100/ag7100.h b/cpu/mips/ar7100/ag7100.h
new file mode 100644
index 0000000..3c0013a
--- /dev/null
+++ b/cpu/mips/ar7100/ag7100.h
@@ -0,0 +1,239 @@
+#ifndef _AG7100_H
+#define _AG7100_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7100_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7100_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7100_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7100_mac_t;
+
+#define ag7100_reg_wr(_mac, _x, _y)   ar7100_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7100_reg_rd(_mac, _x)       ar7100_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7100_reg_rmw_set(_mac, _x, _y)   \
+    ar7100_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7100_reg_rmw_clear(_mac, _x, _y)    \
+    ar7100_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+
+#if defined (CFG_AG7100_GE0_GMII)
+    #define     AG7100_MII0_INTERFACE   0x20
+#elif defined (CFG_AG7100_GE0_MII)
+    #define     AG7100_MII0_INTERFACE   0x11
+#elif defined (CFG_AG7100_GE0_RGMII)
+    #define     AG7100_MII0_INTERFACE   0x22
+#elif defined (CFG_AG7100_GE0_RMII)
+    #define     AG7100_MII0_INTERFACE   0x13
+#else
+    #error "GE0 MII type not defined"
+#endif /*defined (AG7100_GE0_GMII)*/
+
+/*
+ * Port 1 may or may not be connected
+ */
+#if defined (CFG_AG7100_GE1_RGMII)
+    #define AG7100_MII1_INTERFACE   0x20
+#elif defined (CFG_AG7100_GE1_RMII)
+    #define AG7100_MII1_INTERFACE   0x21
+#else
+    #define AG7100_MII1_INTERFACE   0xff
+#endif /*AG7100_GE1_RGMII*/
+
+#define mii_reg(_mac)   (AR7100_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? AG7100_MII0_INTERFACE : AG7100_MII1_INTERFACE)
+
+#define ag7100_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7100_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7100_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7100_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7100_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7100_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7100_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7100_MAC_CFG1             0x00
+#define AG7100_MAC_CFG2             0x04
+#define AG7100_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7100_MAC_FIFO_CFG_0      0x48
+#define AG7100_MAC_FIFO_CFG_1      0x4c
+#define AG7100_MAC_FIFO_CFG_2      0x50
+#define AG7100_MAC_FIFO_CFG_3      0x54
+#define AG7100_MAC_FIFO_CFG_4      0x58
+
+#define AG7100_MAC_FIFO_CFG_5      0x5c
+#define AG7100_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7100_MAC_FIFO_RAM_0      0x60
+#define AG7100_MAC_FIFO_RAM_1      0x64
+#define AG7100_MAC_FIFO_RAM_2      0x68
+#define AG7100_MAC_FIFO_RAM_3      0x6c
+#define AG7100_MAC_FIFO_RAM_4      0x70
+#define AG7100_MAC_FIFO_RAM_5      0x74
+#define AG7100_MAC_FIFO_RAM_6      0x78
+#define AG7100_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7100_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7100_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7100_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7100_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7100_MAC_CFG2_FDX            (1 << 0)
+#define AG7100_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7100_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7100_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7100_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7100_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7100_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7100_DMA_TX_CTRL              0x180
+#define AG7100_DMA_TX_DESC              0x184
+#define AG7100_DMA_TX_STATUS            0x188
+#define AG7100_DMA_RX_CTRL              0x18c
+#define AG7100_DMA_RX_DESC              0x190
+#define AG7100_DMA_RX_STATUS            0x194
+#define AG7100_DMA_INTR_MASK            0x198
+#define AG7100_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7100_TXE                      (1 << 0)
+#define AG7100_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7100_TX_STATUS_PKT_SENT       0x1
+#define AG7100_TX_STATUS_URN            0x2
+#define AG7100_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7100_RXE                      (1 << 0)
+
+#define AG7100_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7100_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7100_RX_STATUS_OVF            (1 << 2)
+#define AG7100_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7100_INTR_TX                  (1 << 0)
+#define AG7100_INTR_TX_URN              (1 << 1)
+#define AG7100_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7100_INTR_RX                  (1 << 4)
+#define AG7100_INTR_RX_OVF              (1 << 6)
+#define AG7100_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7100_MAC_MII_MGMT_CFG         0x20
+#define AG7100_MGMT_CFG_CLK_DIV_20      0x06
+
+#define AG7100_MII_MGMT_CMD             0x24
+#define AG7100_MGMT_CMD_READ            0x1
+
+#define AG7100_MII_MGMT_ADDRESS         0x28
+#define AG7100_ADDR_SHIFT               8
+
+#define AG7100_MII_MGMT_CTRL            0x2c
+#define AG7100_MII_MGMT_STATUS          0x30
+
+#define AG7100_MII_MGMT_IND             0x34
+#define AG7100_MGMT_IND_BUSY            (1 << 0)
+#define AG7100_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7100_GE_MAC_ADDR1             0x40
+#define AG7100_GE_MAC_ADDR2             0x44
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7100_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7100_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7100_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7100_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7100_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7100_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7100_reg_rmw_clear(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7100_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7100_reg_rmw_clear(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_IF_1000|      \
+                                          AG7100_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_IF_1000)  \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_FIFO_CFG_5, AG7100_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_CFG2, AG7100_MAC_CFG2_IF_10_100)\
+        ag7100_reg_rmw_clear(_mac, AG7100_MAC_FIFO_CFG_5, AG7100_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7100_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7100_reg_rmw_set(_mac, AG7100_MAC_IFCTL, AG7100_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7100_reg_rmw_clear(_mac, AG7100_MAC_IFCTL, AG7100_MAC_IFCTL_SPEED)\
+}while(0)
+
+ag7100_mac_t *ag7100_unit2mac(int unit);
+
+#endif
diff --git a/cpu/mips/ar7100/ag7100_phy.h b/cpu/mips/ar7100/ag7100_phy.h
new file mode 100644
index 0000000..53301d5
--- /dev/null
+++ b/cpu/mips/ar7100/ag7100_phy.h
@@ -0,0 +1,257 @@
+#ifndef _AG7100_PHY_H
+#define _AG7100_PHY_H
+
+#ifdef CFG_ATHRS26_PHY
+#ifndef AR9100
+#include "../board/ar7100/ap94/athrs26_phy.h"
+
+#define ag7100_phy_setup(unit)          athrs26_phy_setup (unit)
+#define ag7100_phy_is_up(unit)          athrs26_phy_is_up (unit)
+#define ag7100_phy_speed(unit)          athrs26_phy_speed (unit)
+#define ag7100_phy_is_fdx(unit)         athrs26_phy_is_fdx (unit)
+
+static inline unsigned int 
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+  *link=ag7100_phy_is_up(unit);
+  *fdx=ag7100_phy_is_fdx(unit);
+  *speed=ag7100_phy_speed(unit);
+  return 0;
+}
+
+#else
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        athrs26_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif // Hydra or Howl
+#endif
+
+#ifdef CFG_ATHRS16_PHY
+
+#include "../board/ar7100/common/athrs16_phy.h"
+
+#define ag7100_phy_setup(unit)          athrs16_phy_setup (unit)
+#define ag7100_phy_is_up(unit)          athrs16_phy_is_up (unit)
+#define ag7100_phy_speed(unit)          athrs16_phy_speed (unit)
+#define ag7100_phy_is_fdx(unit)         athrs16_phy_is_fdx (unit)
+/*
+#define ag7100_phy_ioctl(unit, args)    athr_ioctl(unit,args)
+#define ag7100_phy_is_lan_pkt           athr_is_lan_pkt
+#define ag7100_phy_set_pkt_port         athr_set_pkt_port
+#define ag7100_phy_tag_len              ATHR_VLAN_TAG_SIZE
+#define ag7100_phy_get_counters         athrs16_get_counters
+*/
+
+static inline unsigned int
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+  *link=ag7100_phy_is_up(unit);
+  *fdx=ag7100_phy_is_fdx(unit);
+  *speed=ag7100_phy_speed(unit);
+  return 0;
+}
+
+static inline int
+ag7100_print_link_status(int unit)
+{
+  return -1;
+}
+
+#endif /* CFG_ATHRS16_PHY */
+
+#ifdef CFG_VSC8201_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        vsc_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif
+
+#ifdef CFG_VSC8601_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        vsc8601_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif
+
+#ifdef CFG_VITESSE_8601_7395_PHY
+
+#include "../board/ar7100/common/vsc73xx.h"
+
+#define ag7100_phy_setup(unit) do { \
+if(unit) \
+	vsc73xx_setup(unit); \
+else \
+	vsc8601_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(unit) \
+	vsc73xx_get_link_status(unit, &link, &fdx, &speed,0); \
+else \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(unit) \
+	vsc73xx_get_link_status(unit, 0, &duplex, 0,0); \
+else \
+	duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(unit) \
+	vsc73xx_get_link_status(unit, 0, 0, &speed,0); \
+else \
+	speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+static inline unsigned int
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+    if (0==unit) {
+        ag7100_phy_link(unit,*link,*fdx,*speed);
+        ag7100_phy_duplex(unit,*fdx);
+        ag7100_phy_speed(unit,*speed);
+    } else
+        return vsc73xx_get_link_status(unit, link, fdx, speed, 0);
+
+    return -1;
+}
+
+#endif
+
+
+#ifdef CFG_IP175B_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        ip_phySetup(unit); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=ip_phyIsUp(unit); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = ip_phyIsFullDuplex(unit); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = ip_phySpeed(unit); \
+} while (0);
+
+#endif
+
+#ifdef CONFIG_ADMTEK_PHY
+
+#define ag7100_phy_setup(unit) do { \
+if(!unit) \
+        miiphy_reset("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+if(!unit) \
+        link=miiphy_link("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+if(!unit) \
+        duplex = miiphy_duplex("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+if(!unit) \
+        speed = miiphy_speed("eth0", CFG_PHY_ADDR); \
+} while (0);
+
+#endif
+
+
+#ifdef CFG_ATHRF1_PHY
+
+#include "../board/ar7100/common/athr_phy.h"
+
+#define ag7100_phy_setup(unit) do { \
+	athr_phy_setup(unit); \
+} while (0);
+
+#define ag7100_phy_duplex(unit,duplex) do { \
+	duplex = athr_phy_is_fdx(unit); \
+} while (0);
+
+#define ag7100_phy_speed(unit,speed) do { \
+	speed = athr_phy_speed(unit); \
+} while (0);
+
+static inline unsigned int 
+ag7100_get_link_status(int unit, int *link, int *fdx, ag7100_phy_speed_t *speed)
+{
+  *link=athr_phy_is_up(unit); 
+  if (*link==0)
+    return 0;   
+  *fdx=athr_phy_is_fdx(unit);
+  *speed=athr_phy_speed(unit);
+  return 0;
+}
+
+#define ag7100_phy_link(unit,link,fdx,speed) do { \
+	ag7100_get_link_status(unit, &link, &fdx, &speed); \
+} while (0);
+
+#endif
+
+#endif /*_AG7100_PHY_H*/
diff --git a/cpu/mips/ar7100/ar7100_serial.c b/cpu/mips/ar7100/ar7100_serial.c
new file mode 100644
index 0000000..3ef6d7d
--- /dev/null
+++ b/cpu/mips/ar7100/ar7100_serial.c
@@ -0,0 +1,178 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <ar7100_soc.h>
+
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+#define         MY_WRITE(y, z)  ((*((volatile u32*)(y))) = z)
+#define         UART16550_READ(y)   ar7100_reg_rd((AR7100_UART_BASE+y))
+#define         UART16550_WRITE(x, z)  ar7100_reg_wr((AR7100_UART_BASE+x), z)
+
+void 
+ar7100_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+#ifndef AR9100
+    u32 pll, pll_div, cpu_div, ahb_div, ddr_div, freq;
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div = 
+        ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT) + 1;
+
+    cpu_div = 
+        ((pll & PLL_CONFIG_CPU_DIV_MASK) >> PLL_CONFIG_CPU_DIV_SHIFT) + 1;
+
+    ddr_div = 
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div = 
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * 40000000; 
+
+    if (cpu_freq)
+        *cpu_freq = freq/cpu_div;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = (freq/cpu_div)/ahb_div;
+
+    /*
+    printf ("cpu_freq = %d\n", freq/cpu_div);
+    printf ("ddr_freq = %d\n", freq/ddr_div);
+    printf ("ahb_freq = %d\n", (freq/cpu_div)/ahb_div);
+    */
+#else
+    u32 pll, pll_div, ahb_div, ddr_div, freq;
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div = 
+        ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT);
+
+    ddr_div = 
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div = 
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * 5000000; 
+
+    if (cpu_freq)
+        *cpu_freq = freq;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = freq/ahb_div;
+#endif
+}
+
+
+void serial_init()
+{
+    u32 div;
+    u32 ahb_freq = 100000000;
+
+    ar7100_sys_frequency  (0, 0, &ahb_freq);  
+    div  = ahb_freq/(16 * CONFIG_BAUDRATE);  
+
+    /*
+     * undocumented. confirm, why write to GPIO for uart?
+     */
+#if 0
+    ar7100_reg_wr(AR7100_GPIO_OE, 0xcff);
+    ar7100_reg_wr(AR7100_GPIO_OUT, 0x3b);
+
+    MY_WRITE(0xb8040028, 0x100);
+#else
+    MY_WRITE(0xb8040000, 0x47f);
+    MY_WRITE(0xb8040008, 0x7f);
+
+    MY_WRITE(0xb8040028, 0x100);
+#endif
+
+    /* 
+     * set DIAB bit 
+     */
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+        
+    /* set divisor */
+    /*UART16550_WRITE(OFS_DIVISOR_LSB, 0x04);
+    UART16550_WRITE(OFS_DIVISOR_MSB, 0x01);*/
+#if 1
+    UART16550_WRITE(OFS_DIVISOR_LSB, (div & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+#else
+    UART16550_WRITE(OFS_DIVISOR_LSB, (0x36 & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, 0);
+#endif
+
+    /* clear DIAB bit*/ 
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x00);
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, 0x3);
+
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    //WRITE(0xb8020008, 0x7);
+    //WRITE(0xb8020010, 0x3);
+}
+
+int serial_tstc (void)
+{
+    return(UART16550_READ(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc()
+{
+    while(!serial_tstc());
+
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n') serial_putc ('\r');
+
+    while (((UART16550_READ(OFS_LINE_STATUS)) & 0x20) == 0x0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/cpu/mips/ar7100/meminit.c b/cpu/mips/ar7100/meminit.c
new file mode 100644
index 0000000..2948f37
--- /dev/null
+++ b/cpu/mips/ar7100/meminit.c
@@ -0,0 +1,297 @@
+/* 
+ * Memory controller config:
+ * Assumes that the caches are initialized.
+ *
+ * 0) Figah out the Tap controller settings.
+ * 1) Figure out whether the interface is 16bit or 32bit.
+ * 2) Size the DRAM
+ *
+ *  0) Tap controller settings
+ *  --------------------------
+ * The Table below provides all possible values of TAP controllers. We need to
+ * find the extreme left and extreme right of the spectrum (of max_udelay and
+ * min_udelay). We then program the TAP to be in the middle.
+ * Note for this we would need to be able to read and write memory. So, 
+ * initially we assume that a 16bit interface, which will always work unless
+ * there is exactly _1_ 32 bit part...for now we assume this is not the case.
+ * 
+ * The algo:
+ * 0) Program the controller in 16bit mode.
+ * 1) Start with the extreme left of the table
+ * 2) Write 0xa4, 0xb5, 0xc6, 0xd7 to 0, 2, 4, 6
+ * 3) Read 0 - this will fetch the entire cacheline.
+ * 4) If the value at address 4 is good, record this table entry, goto 6
+ * 5) Increment to get the next table entry. Goto 2.
+ * 6) Start with extreme right. Do the same as above.
+ *
+ * 1) 16bit or 32bit
+ * -----------------
+ *  31st bit of reg 0x1800_0000 will  determine the mode. By default, 
+ *  controller is set to 32-bit mode. In 32 bit mode, full data bus DQ [31:0] 
+ *  will be used to write 32 bit data. Suppose you have 16bit DDR memory
+ *  (it will have 16bit wide data bus). If you try to write 16 bit DDR in 32 
+ *  bit mode, you are going to miss upper 16 bits of data. Reading to that 
+ *  location will give you only lower 16 bits correctly, upper 16 bits will 
+ *  have some junk value. E.g.,
+ *
+ *  write to 0x0000_0000 0x12345678
+ *  write to 0x0000_1000 0x00000000 (just to discharge DQ[31:16] )
+ *  read from 0x0000_0000
+ *  if u see something like 0x0000_5678 (or XXXX_5678 but not equal to 
+ *  0x12345678) - its a 16 bit interface
+ *
+ *  2) Size the DRAM
+ *  -------------------
+ *  DDR wraps around. Write a pattern to 0x0000_0000. Write an address 
+ *  pattern at 4M, 8M, 16M etc. and check when 0x0000_0000 gets overwritten.
+ *
+ *
+ *  We can use #define's for all these addresses and patterns but its easier
+ *  to see what's going on without :)
+ */
+#include <common.h>
+#include <asm/addrspace.h>
+#include "ar7100_soc.h"
+
+
+uint8_t     tap_settings[] = 
+            {0x40, 0x41, 0x10, 0x12, 0x13, 0x15, 0x1a, 0x1c, 0x1f, 0x2f, 0x3f};
+
+uint16_t    tap_pattern[] = {0xa5, 0xb6, 0xc7, 0xd8};
+
+void
+ar7100_ddr_tap_set(uint8_t set)
+{
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL0, set);
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL1, set);
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL2, set);
+    ar7100_reg_wr_nf(AR7100_DDR_TAP_CONTROL3, set);
+}
+/*
+ * We use 0xa0003000, because the first way is locked into cache to give
+ * us a rudimentary stack
+ */
+void ar7100_ddr_tap_config(void)
+{
+    uint8_t set, prev, dummy;
+    int i, j, k, floor, ceiling;
+    uint16_t *p = 0xa0003000, *p_ca = 0x80003000;
+
+    ar7100_reg_rmw_set(AR7100_DDR_CONFIG, AR7100_DDR_CONFIG_16BIT);
+
+    for(i = 0; i < sizeof(tap_settings); i++) {
+        set = tap_settings[i];
+        ar7100_ddr_tap_set(set);
+
+#ifndef COMPRESSED_UBOOT
+        printf("trying %#x...", set);
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+        for(j = 0; j < 4; j++)
+            *(p + j) = tap_pattern[j];
+
+        /*
+         * get the cacheline
+         */
+        dummy = *p_ca;
+
+        if ((*(p_ca + 2)) == tap_pattern[2]) {
+            floor = i;
+#ifndef COMPRESSED_UBOOT
+            printf("worked; floor %d\n", i);
+#endif /* #ifndef COMPRESSED_UBOOT */
+            break;
+        }
+#ifndef COMPRESSED_UBOOT
+        printf("didnt work written %#x read %#x\n", tap_pattern[2], 
+                *(p_ca + 2));
+#endif /* #ifndef COMPRESSED_UBOOT */
+        flush_cache(p_ca, 8);
+    }
+
+    for(k = sizeof(tap_settings) - 1; k > i; k--) {
+        set = tap_settings[k];
+        ar7100_ddr_tap_set(set);
+
+#ifndef COMPRESSED_UBOOT
+        printf("trying %#x...", set);
+#endif /* #ifndef COMPRESSED_UBOOT */
+        for(j = 0; j < 4; j++)
+            *(p + j) = tap_pattern[j];
+
+        dummy = *p_ca;
+
+        if ((*(p_ca + 2)) == tap_pattern[2]) {
+            ceiling = k;
+#ifndef COMPRESSED_UBOOT
+            printf("worked; ceiling %d\n", k);
+#endif /* #ifndef COMPRESSED_UBOOT */
+            break;
+        }
+#ifndef COMPRESSED_UBOOT
+        printf("didnt work written %#x read %#x\n", tap_pattern[2], 
+                *(p_ca + 2));
+#endif /* #ifndef COMPRESSED_UBOOT */
+        flush_cache(p_ca, 8);
+    }
+    /*
+     * If the min and max delay both worked, lets pick a default
+     */
+#ifndef COMPRESSED_UBOOT
+    printf("floor %d ceil %d size-1 %d\n",
+            floor, ceiling, (sizeof(tap_settings) - 1));
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+    if ((floor == 0) && (ceiling == (sizeof(tap_settings) - 1))) 
+        set = AR7100_DDR_TAP_DEFAULT;
+    else {
+        i = ((ceiling - floor)/2) + floor;
+        set = tap_settings[i];
+#ifndef COMPRESSED_UBOOT
+        printf("i %d\n", i);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    }
+
+#ifndef COMPRESSED_UBOOT
+    printf("Setting Tap to %#x\n", set);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    ar7100_ddr_tap_set(set);
+    udelay(1);
+}
+
+ar7100_ddr_width_t
+ar7100_ddr_get_width()
+{
+    volatile uint32_t *p = 0xa0000000, *p1 = 0xa0001000;
+    uint32_t pat = 0x12345678, rd;
+
+    *p  = pat;
+    *p1 = 0;
+    asm("sync");
+    /*
+     * discharge DQ[31:16]
+     */
+    rd  = *p;
+
+    if (rd == pat)
+        return AR7100_DDR_32B;
+
+    if ((rd & 0xffff) == (pat & 0xffff))
+        return AR7100_DDR_16B_LOW;
+
+    if ((rd & 0xffff0000) == (pat & 0xffff0000))
+        return AR7100_DDR_16B_HIGH;
+
+    /*
+     * If Some'n's hosed this early cant do much; silence the compiler :)
+     */
+#ifndef COMPRESSED_UBOOT
+    printf("something's wrong. rd %#x pat %#x\n", rd, pat);
+#endif /* #ifndef COMPRESSED_UBOOT */
+
+    return AR7100_DDR_32B;
+}
+ 
+/*
+ * We check for size in 4M increments
+ */
+#define AR7100_DDR_SIZE_INCR    (4*1024*1024)
+
+int sanity_mem_check(int mem_size) 
+{
+	int data=0xaaaa5555,i,ret=0;
+        volatile unsigned int *ptr = KSEG1;
+
+	for(i = 0; i < ((mem_size * AR7100_DDR_SIZE_INCR) / 4096) ; i++) {
+		
+		ptr[i] = (data ^ (1  << (i % 16)));
+		 if(i % 16  == 0) 
+			data = ~data;
+	} 
+        data = 0xaaaa5555;
+        for(i = 0; i < ((mem_size * AR7100_DDR_SIZE_INCR) / 4096) ; i++) {
+
+                if(ptr[i] != (data ^ (1  << (i % 16)))) {
+			ret = 1;
+			break;
+		 }
+                 if(i % 16 == 0)
+                        data = ~data;
+        }
+	return ret;
+}
+int
+ar7100_ddr_find_size()
+{
+    uint8_t  *p = KSEG1, pat = 0x77;
+    int i, incr = AR7100_DDR_SIZE_INCR;
+
+    *p = pat;
+
+    for(i = 1; ; i++) {
+        *(p + i * AR7100_DDR_SIZE_INCR) = (uint8_t)(i);
+        if (*p != pat) {
+            break;
+        }
+    }
+    if(i < 4) {
+	udelay(1000);
+        for (;;) {
+            ar7100_reg_wr(AR7100_RESET,
+                        (AR7100_RESET_FULL_CHIP | AR7100_RESET_DDR));
+        }
+    }
+    if(sanity_mem_check(i)) {
+        udelay(1000);
+        for (;;) {
+            ar7100_reg_wr(AR7100_RESET,
+                        (AR7100_RESET_FULL_CHIP | AR7100_RESET_DDR));
+        }
+    }
+    return (i*AR7100_DDR_SIZE_INCR);
+}
+
+void
+ar7100_ddr_initial_config(uint32_t refresh)
+{
+#ifndef COMPRESSED_UBOOT
+    printf("\nsri . . ");
+#endif /* #ifndef COMPRESSED_UBOOT */
+#if 0
+    ar7100_reg_wr(AR7100_RESET, AR7100_RESET_DDR);
+    udelay(10);
+#endif
+#ifndef COMPRESSED_UBOOT
+    ar7100_reg_wr_nf(AR7100_DDR_CONFIG, CFG_DDR_CONFIG_VAL);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONFIG2, CFG_DDR_CONFIG2_VAL);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x8);
+    udelay(1000);
+#ifdef AR9100
+    ar7100_reg_wr_nf(AR7100_DDR_MODE, CFG_DDR_MODE_VAL_INIT);
+    udelay(1000);
+#endif
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x1);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_EXT_MODE, CFG_DDR_EXT_MODE_VAL);
+    udelay(1000);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x2);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x8);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_MODE, CFG_DDR_MODE_VAL);
+    udelay(10000);
+    ar7100_reg_wr_nf(AR7100_DDR_CONTROL, 0x1);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_REFRESH, refresh);
+    udelay(1000);
+    ar7100_reg_wr_nf(AR7100_DDR_RD_DATA_THIS_CYCLE,CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+    udelay(1000);
+}
+
+
+
+
+
diff --git a/cpu/mips/ar7240/Makefile b/cpu/mips/ar7240/Makefile
new file mode 100644
index 0000000..47c71f5
--- /dev/null
+++ b/cpu/mips/ar7240/Makefile
@@ -0,0 +1,61 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+START	=
+#OBJS	= ar7240_serial.o ag7240.o ar7240_flash.o meminit.o
+
+OBJS	= meminit.o 
+
+ifeq ($(BOARD), ap121)
+OBJS	+= hornet_serial.o
+SOBJS	+= hornet_ddr_init.o
+else
+OBJS	+= ar7240_serial.o
+endif
+
+ifneq ($(BUILD_EMU), )
+OBJS    += hornet_ag7240.o
+else
+ifneq ($(findstring db12x,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring reh132,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring dhp,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring aph,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring ap123,$(BOARD)),)
+OBJS    += ag934x.o
+else
+ifneq ($(findstring ap120,$(BOARD)),)
+OBJS    += ag934x.o
+else
+OBJS    += ag7240.o
+endif
+endif
+endif
+endif
+endif
+endif
+endif
+
+SOBJS	+= 
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS) $(OBJS-0)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/mips/ar7240/ag7240.c b/cpu/mips/ar7240/ag7240.c
new file mode 100644
index 0000000..9d8475b
--- /dev/null
+++ b/cpu/mips/ar7240/ag7240.c
@@ -0,0 +1,722 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ag7240.h"
+#include "ag7240_phy.h"
+
+#if defined(CONFIG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern int athrs26_mdc_check(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int unit);
+extern int athrs27_phy_is_up(int unit);
+extern int athrs27_phy_is_fdx(int unit);
+extern int athrs27_phy_speed(int unit);
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_lan(void);
+extern int athrs27_mdc_check(void);
+#endif
+
+#ifdef CONFIG_F1E_PHY
+extern int athr_phy_setup(int unit);
+extern int athr_phy_is_up(int unit);
+extern int athr_phy_is_fdx(int unit);
+extern int athr_phy_speed(int unit);
+extern void athr_reg_init(void);
+#endif
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+ 
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+void ag7240_mii_setup(ag7240_mac_t *mac)
+{
+    u32 mgmt_cfg_val;
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 check_cnt,revid_val;
+#ifdef CFG_ATHRS27_PHY
+    if (is_wasp()) {
+        printf("WASP ----> S27 PHY \n");
+        mgmt_cfg_val = 2;
+        ar7240_reg_wr(0xb8050024, 0x271);	// 25MHz ref clock
+        //ar7240_reg_wr(0xb8050024, 0x570);	// 40MHz ref clock
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        return;
+    }
+#endif
+#ifdef CONFIG_AR7242_S16_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> S16 PHY *\n");
+        mgmt_cfg_val = 4;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        ar7240_reg_rmw_clear(AG7240_ETH_SWITCH_CLK_SPARE, (1 << 6));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+#ifdef CONFIG_F1E_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> F1 PHY *\n");
+        mgmt_cfg_val = 6;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                 mgmt_cfg_val = 0x6;
+                 ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+
+        }
+      else if(is_ar933x()){
+                //GE0 receives Rx/Tx clock, and use S26 phy
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_MII_GE0_SLAVE);
+                mgmt_cfg_val = 0xF;
+                if (mac->mac_unit == 1) {
+                        check_cnt = 0;
+                        while (check_cnt++ < 10) {
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                                if(athrs26_mdc_check() == 0)
+                                        break;
+#endif
+                        }
+                        if(check_cnt == 11)
+                                printf("%s: MDC check failed\n", __func__);
+                }
+      }
+        else { /* Python 1.0 & 1.1 */
+             if (mac->mac_unit == 0) {
+                     check_cnt = 0;
+                     while (check_cnt++ < 10) {
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                             if(athrs26_mdc_check() == 0)
+                                     break;
+#endif
+                     }
+                     if(check_cnt == 11)
+                             printf("%s: MDC check failed\n", __func__);
+             }
+        }
+ 
+    }
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_10_100));
+   }
+   ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+   ag7240_mii_setup(mac);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+#ifdef AG7240_BROADCAST_ENABLE
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xe6be2);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+#endif
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+	   }
+#ifdef CONFIG_F1E_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0e000000);
+	   }
+#else      
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x06000000);
+           }
+#endif
+           break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    if(!is_ar933x())
+        udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_AR7240_EMU
+    eeprom = ag7240_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+#else
+    if (1) {
+#endif 
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag7240_enet_initialize...\n");
+
+    if(is_ar933x() ) {
+        u32 rd = 0x0;
+
+        /* 
+         * To get s26 out of reset, we have to...
+         * bit0~bit3: has to be deasserted
+         * bit4:      has to be asserted
+         */
+        rd = ar7240_reg_rd(AR7240_S26_CLK_CTRL_OFFSET) & ~(0x1f);
+        rd |= 0x10;
+        ar7240_reg_wr(AR7240_S26_CLK_CTRL_OFFSET, rd);
+
+        if(ar7240_reg_rd(AR7240_RESET)!=0)
+            ar7240_reg_wr(AR7240_RESET,0);
+    }
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+    
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+        eth_register(dev[i]);
+#if defined(CONFIG_CMD_MII)
+        miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+
+         ag7240_reg_rmw_set(ag7240_macs[i], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST
+                | AG7240_MAC_CFG1_RX_RST | AG7240_MAC_CFG1_TX_RST);
+
+        if(!i) {
+           mask = (AR7240_RESET_GE0_MAC | AR7240_RESET_GE0_PHY |
+                    AR7240_RESET_GE1_MAC | AR7240_RESET_GE1_PHY);
+
+           if (is_ar7241() || is_ar7242() ||  is_wasp()) {
+                mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+                printf(" wasp  reset mask:%x \n",mask);
+           }
+
+
+           ar7240_reg_rmw_set(AR7240_RESET, mask);
+           if(!is_ar933x())
+               udelay(1000 * 100);
+
+           ar7240_reg_rmw_clear(AR7240_RESET, mask);
+           if(!is_ar933x())
+               udelay(1000 * 100);
+
+           if(!is_ar933x())
+               udelay(10 * 1000);
+        }
+
+        ag7240_hw_start(ag7240_macs[i]);
+        ag7240_setup_fifos(ag7240_macs[i]);
+
+        if(!is_ar933x())
+            udelay(100 * 1000);
+
+        {
+            unsigned char *mac = dev[i]->enetaddr;
+
+            printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+                   mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+                   mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+        }
+        mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+        mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+            (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+        /* if using header for register configuration, we have to     */
+        /* configure s26 register after frame transmission is enabled */
+
+        if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+            if (is_ar7242() || is_wasp()) {
+                athrs16_reg_init();
+            } else
+#endif
+            {
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init();
+#endif
+#ifdef CFG_ATHRS27_PHY
+                printf("s27 reg init \n");
+                athrs27_reg_init();
+#endif
+#ifdef CONFIG_F1E_PHY
+               printf("F1Phy reg init \n");
+               athr_reg_init();
+#endif
+            }
+        } else {
+#ifdef CFG_ATHRS26_PHY
+                printf("athrs26_reg_init_lan\n");
+                athrs26_reg_init_lan();
+#endif
+#ifdef CFG_ATHRS27_PHY
+            printf("s27 reg init lan \n");
+            athrs27_reg_init_lan();
+#endif
+        }
+
+        ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+        printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if defined(CONFIG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0xFFFF;
+
+
+    /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+   if(ii==0)
+      printf("Error!!! Leave ag7240_miiphy_read without polling correct status!\n");
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0xFFFF;
+
+     /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if(ii==0)
+        printf("Error!!! Leave ag7240_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_CMD_MII */
diff --git a/cpu/mips/ar7240/ag7240.h b/cpu/mips/ar7240/ag7240.h
new file mode 100644
index 0000000..5f2a708
--- /dev/null
+++ b/cpu/mips/ar7240/ag7240.h
@@ -0,0 +1,237 @@
+#ifndef _AG7240_H
+#define _AG7240_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7240_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7240_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7240_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7240_mac_t;
+
+#define ag7240_reg_wr(_mac, _x, _y)   ar7240_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7240_reg_rd(_mac, _x)       ar7240_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7240_reg_rmw_set(_mac, _x, _y)   \
+    ar7240_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7240_reg_rmw_clear(_mac, _x, _y)    \
+    ar7240_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET 1000
+#define _100BASET 100
+#define _10BASET 10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7240_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7240_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7240_MAC_CFG1             0x00
+#define AG7240_MAC_CFG2             0x04
+#define AG7240_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7240_MAC_FIFO_CFG_0      0x48
+#define AG7240_MAC_FIFO_CFG_1      0x4c
+#define AG7240_MAC_FIFO_CFG_2      0x50
+#define AG7240_MAC_FIFO_CFG_3      0x54
+#define AG7240_MAC_FIFO_CFG_4      0x58
+
+#define AG7240_MAC_FIFO_CFG_5      0x5c
+#define AG7240_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7240_MAC_FIFO_RAM_0      0x60
+#define AG7240_MAC_FIFO_RAM_1      0x64
+#define AG7240_MAC_FIFO_RAM_2      0x68
+#define AG7240_MAC_FIFO_RAM_3      0x6c
+#define AG7240_MAC_FIFO_RAM_4      0x70
+#define AG7240_MAC_FIFO_RAM_5      0x74
+#define AG7240_MAC_FIFO_RAM_6      0x78
+#define AG7240_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7240_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7240_MAC_CFG1_RX_RST         (1 << 19)
+#define AG7240_MAC_CFG1_TX_RST         (1 << 18)
+#define AG7240_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7240_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7240_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7240_MAC_CFG2_FDX            (1 << 0)
+#define AG7240_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7240_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7240_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7240_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7240_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7240_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7240_DMA_TX_CTRL              0x180
+#define AG7240_DMA_TX_DESC              0x184
+#define AG7240_DMA_TX_STATUS            0x188
+#define AG7240_DMA_RX_CTRL              0x18c
+#define AG7240_DMA_RX_DESC              0x190
+#define AG7240_DMA_RX_STATUS            0x194
+#define AG7240_DMA_INTR_MASK            0x198
+#define AG7240_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7240_TXE                      (1 << 0)
+#define AG7240_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7240_TX_STATUS_PKT_SENT       0x1
+#define AG7240_TX_STATUS_URN            0x2
+#define AG7240_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7240_RXE                      (1 << 0)
+
+#define AG7240_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7240_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7240_RX_STATUS_OVF            (1 << 2)
+#define AG7240_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7240_INTR_TX                  (1 << 0)
+#define AG7240_INTR_TX_URN              (1 << 1)
+#define AG7240_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7240_INTR_RX                  (1 << 4)
+#define AG7240_INTR_RX_OVF              (1 << 6)
+#define AG7240_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7240_MAC_MII_MGMT_CFG         0x20
+#define AG7240_MGMT_CFG_CLK_DIV_20      0x07
+
+#define AG7240_MII_MGMT_CMD             0x24
+#define AG7240_MGMT_CMD_READ            0x1
+
+#define AG7240_MII_MGMT_ADDRESS         0x28
+#define AG7240_ADDR_SHIFT               8
+
+#define AG7240_MII_MGMT_CTRL            0x2c
+#define AG7240_MII_MGMT_STATUS          0x30
+
+#define AG7240_MII_MGMT_IND             0x34
+#define AG7240_MGMT_IND_BUSY            (1 << 0)
+#define AG7240_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7240_GE_MAC_ADDR1             0x40
+#define AG7240_GE_MAC_ADDR2             0x44
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+#define AG7240_ETH_SWITCH_CLK_SPARE     0x18050024
+
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7240_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7240_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7240_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7240_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7240_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7240_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7240_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000|      \
+                                          AG7240_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000)  \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_10_100)\
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7240_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)\
+}while(0)
+
+#endif
diff --git a/cpu/mips/ar7240/ag7240_phy.h b/cpu/mips/ar7240/ag7240_phy.h
new file mode 100644
index 0000000..02ea970
--- /dev/null
+++ b/cpu/mips/ar7240/ag7240_phy.h
@@ -0,0 +1,69 @@
+#ifndef _AG7240_PHY_H
+#define _AG7240_PHY_H
+
+static inline void ag7240_phy_setup(int unit)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        athrs16_phy_setup(unit);
+    } else
+#endif
+    {
+        athrs26_phy_setup(unit);
+#ifdef CONFIG_F1E_PHY
+        athr_phy_setup(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+         *link = athrs16_phy_is_up(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+         *link = athrs27_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+         *link = athrs26_phy_is_up(unit);
+#endif
+#ifdef CONFIG_F1E_PHY
+         *link = athr_phy_is_up(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *duplex = athrs16_phy_is_fdx(unit);
+    } else
+#endif
+    {
+        *duplex = athrs26_phy_is_fdx(unit);
+#ifdef CONFIG_F1E_PHY
+        *duplex = athr_phy_is_fdx(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *speed = athrs16_phy_speed(unit);
+    } else
+#endif
+    {
+        *speed = athrs26_phy_speed(unit);
+#ifdef CONFIG_F1E_PHY
+        *speed = athr_phy_speed(unit);
+#endif
+    }
+}
+
+#endif /*_AG7240_PHY_H*/
diff --git a/cpu/mips/ar7240/ag934x.c b/cpu/mips/ar7240/ag934x.c
new file mode 100644
index 0000000..5de8900
--- /dev/null
+++ b/cpu/mips/ar7240/ag934x.c
@@ -0,0 +1,877 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include "ar7240_soc.h"
+#include "ag934x.h"
+#include "ag934x_phy.h"
+
+#if defined(CONFIG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+
+#ifdef CFG_ATHRS26_PHY
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern int athrs26_mdc_check(void);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int unit);
+extern int athrs27_phy_is_up(int unit);
+extern int athrs27_phy_is_fdx(int unit);
+extern int athrs27_phy_speed(int unit);
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_lan(void);
+extern int athrs27_mdc_check(void);
+#endif
+
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+extern int athr_phy_setup(int unit);
+extern int athr_phy_is_up(int unit);
+extern int athr_phy_is_fdx(int unit);
+extern int athr_phy_speed(int unit);
+extern void athr_reg_init(void);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long 
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+ 
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+void ag7240_mii_setup(ag7240_mac_t *mac)
+{
+    u32 mgmt_cfg_val;
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 check_cnt,revid_val;
+
+    if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+#ifndef CFG_DUAL_PHY_SUPPORT
+        ar7240_reg_wr(AR934X_SWITCH_CLOCK_SPARE, 0x271);
+#endif
+    } else {
+        ar7240_reg_wr(AR934X_SWITCH_CLOCK_SPARE, 0x570);
+    }
+
+#if defined(CONFIG_AR7242_S16_PHY) || defined(CONFIG_ATHRS17_PHY)
+    if (is_wasp() && mac->mac_unit == 0) {
+#ifdef CONFIG_AR7242_S16_PHY
+        printf("WASP  ----> S16 PHY *\n");
+#else
+        printf("WASP  ----> S17 PHY *\n");
+#endif
+        mgmt_cfg_val = 4;
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        udelay(1000);
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+    if (is_wasp()) {
+        printf("WASP ----> S27 PHY \n");
+        mgmt_cfg_val = 2;
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        return;
+    }
+#endif
+
+#ifdef CONFIG_F2E_PHY
+    if (is_wasp()) {
+        printf("WASP  ----> F2 PHY *\n");
+        ar7240_reg_wr(AG7240_ETH_CFG, (AG7240_ETH_CFG_RMII_MASTER_MODE | AG7240_ETH_CFG_RMII_GE0 
+                      | AG7240_ETH_CFG_RMII_HISPD_GE0));
+
+        mgmt_cfg_val = 6;
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_VIR_PHY)
+    if (is_wasp()) {
+#ifdef CONFIG_VIR_PHY
+        printf("WASP  ----> VIR PHY *\n");
+#else
+        printf("WASP  ----> F1 PHY *\n");
+#endif
+        if(mac->mac_unit == 0)
+            ar7240_reg_wr(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+
+        mgmt_cfg_val = 6;
+
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+        ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+        return;
+    }
+#endif
+
+    if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                 mgmt_cfg_val = 0x6;
+                 ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                 ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+
+        }
+      else if(is_ar933x()){
+                //GE0 receives Rx/Tx clock, and use S26 phy
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_MII_GE0_SLAVE);
+                mgmt_cfg_val = 0xF;
+                if (mac->mac_unit == 1) {
+                        check_cnt = 0;
+                        while (check_cnt++ < 10) {
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                                if(athrs26_mdc_check() == 0)
+                                        break;
+#endif
+                        }
+                        if(check_cnt == 11)
+                                printf("%s: MDC check failed\n", __func__);
+                }
+      }
+        else { /* Python 1.0 & 1.1 */
+             if (mac->mac_unit == 0) {
+                     check_cnt = 0;
+                     while (check_cnt++ < 10) {
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                             ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+#ifdef CFG_ATHRS26_PHY
+                             if(athrs26_mdc_check() == 0)
+                                     break;
+#endif
+                     }
+                     if(check_cnt == 11)
+                             printf("%s: MDC check failed\n", __func__);
+             }
+        }
+ 
+    }
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_10_100));
+   }
+   ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+	   }
+#ifdef CONFIG_F1E_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0e000000);
+	   }
+#elif CONFIG_VIR_PHY
+           if (is_wasp() && (mac->mac_unit == 0)) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x82000000);
+               ar7240_reg_wr(AG7240_ETH_CFG,0x000c0001);
+	   }
+#else      
+           if (is_wasp() && (mac->mac_unit == 0) && !is_f2e()) {
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x06000000);
+	   }
+#endif
+          if (is_wasp() && mac->mac_unit == 0 && is_f1e() ) {
+              ar7240_reg_rmw_set(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+              ar7240_reg_rmw_set(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+          }
+
+          break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0) && !is_f2e())
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+	
+           if (is_wasp() && mac->mac_unit == 0 && is_f1e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+           }
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+
+           if ((is_ar7242() || is_wasp()) && (mac->mac_unit == 0) && !is_f2e())
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+
+           if (is_wasp() && mac->mac_unit == 0 && is_f1e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RXD_DELAY);
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG,AG7240_ETH_CFG_RDV_DELAY);
+	       ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1313);
+           }
+	   if (is_f2e()) {
+               ar7240_reg_rmw_clear(AG7240_ETH_CFG, AG7240_ETH_CFG_RMII_HISPD_GE0);
+           }
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+
+/** 
+ * @ when executing TFTP transfers at -10C
+ * @ time taken for auto negotiation and link to settled down
+ * @ is quite high. provide 3 Sec delay for s17 link to settle
+ * @ down. Works fine at room temparature, 0C -3C
+   @ Suggested by systems team.
+ */
+    
+#ifdef  CONFIG_ATHRS17_PHY 
+    udelay(1000 * 3000);
+#endif
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+   
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+    ulong   off, size;
+    nand_info_t *nand;
+    unsigned char ret;
+    	
+    /* 
+     * caldata partition is of 128k 
+     *
+     */
+    nand = &nand_info[nand_curr_device];
+    size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+    
+    /*
+     * Get the Offset of Caldata partition
+     */
+    off = ath_nand_get_cal_offset(getenv("bootargs"));
+    if(off == ATH_CAL_OFF_INVAL) {
+    	printf("Invalid CAL offset \n");
+    	return NULL;
+    }
+    /*
+     * Get the values from flash, and program into the MAC address
+     * registers
+     */
+    ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+    printf(" %d bytes %s: %s\n", size,
+    	       "read", ret ? "ERROR" : "OK");
+    if(ret != 0 ) {
+    	return NULL;
+    }
+
+    return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_AR7240_EMU
+
+#ifdef CONFIG_ATH_NAND_BR
+    unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+    eeprom = ath_eth_mac_addr(sectorBuff);
+    if(eeprom == NULL) {
+        /* mac address will be set to default mac address */
+        mac[0] = 0xff;
+    }
+    else {
+#else  /* CONFIG_ATH_NAND_BR */
+        eeprom = ag7240_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+        if (strcmp(dev->name, "eth0") == 0) {
+            memcpy(mac, eeprom, 6);
+        } else if (strcmp(dev->name, "eth1") == 0) {
+            eeprom += 6;
+            memcpy(mac, eeprom, 6);
+        } else {
+            printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+            return;
+        }
+#ifdef CONFIG_ATH_NAND_BR
+    }
+#endif  /* CONFIG_ATH_NAND_BR */
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+#else
+    if (1) {
+#endif 
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag934x_enet_initialize...\n");
+
+    if(is_ar933x() && (ar7240_reg_rd(AR7240_RESET)!=0))
+         ar7240_reg_wr(AR7240_RESET,0);
+   
+    if(is_ar933x())  //Turn on LED
+        ar7240_reg_wr(AR7240_GPIO_BASE + 0x28 , ar7240_reg_rd(AR7240_GPIO_BASE + 0x28)  | (0xF8));
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+#if !defined(CONFIG_ATH_NAND_BR)
+    mask = AR7240_RESET_GE1_PHY;
+    ar7240_reg_rmw_set(AR7240_RESET, mask);
+    udelay(1000 * 100);
+    ar7240_reg_rmw_clear(AR7240_RESET, mask);
+    udelay(100);
+#endif
+    mask = AR7240_RESET_GE0_PHY;
+    ar7240_reg_rmw_set(AR7240_RESET, mask);
+    udelay(1000 * 100);
+    ar7240_reg_rmw_clear(AR7240_RESET, mask);
+    udelay(100);
+    
+    
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+        eth_register(dev[i]);
+#if defined(CONFIG_CMD_MII)
+        miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+
+         ag7240_reg_rmw_set(ag7240_macs[i], AG7240_MAC_CFG1, AG7240_MAC_CFG1_SOFT_RST
+                | AG7240_MAC_CFG1_RX_RST | AG7240_MAC_CFG1_TX_RST);
+
+        if(!i) {
+           mask = (AR7240_RESET_GE0_MAC  | AR7240_RESET_GE1_MAC);
+
+           if (is_ar7241() || is_ar7242() ||  is_wasp())
+               mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+
+    	   printf(" wasp  reset mask:%x \n",mask);
+
+           ar7240_reg_rmw_set(AR7240_RESET, mask);
+           udelay(1000 * 100);
+
+           ar7240_reg_rmw_clear(AR7240_RESET, mask);
+           udelay(1000 * 100);
+
+           udelay(10 * 1000);
+        }
+
+	ag7240_mii_setup(ag7240_macs[i]);
+
+        /* if using header for register configuration, we have to     */
+        /* configure s26 register after frame transmission is enabled */
+
+        if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+            if (is_ar7242() || is_wasp()) {
+                athrs16_reg_init();
+            } else
+#endif
+            {
+#ifdef  CONFIG_ATHRS17_PHY
+                athrs17_reg_init();
+#endif
+
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init();
+#endif
+#ifdef CFG_ATHRS27_PHY
+                printf("s27 reg init \n");
+                athrs27_reg_init();
+#endif
+#ifdef CONFIG_F1E_PHY
+               printf("F1Phy reg init \n");
+               athr_reg_init();
+#endif
+#ifdef CONFIG_VIR_PHY
+               printf("VIRPhy reg init \n");
+               athr_vir_reg_init();
+#endif
+#ifdef CONFIG_F2E_PHY
+               printf("F2Phy reg init \n");
+               athr_reg_init();
+#endif
+
+            }
+        } else {
+#ifdef CFG_ATHRS26_PHY
+                athrs26_reg_init_lan();
+#endif
+#ifdef CFG_ATHRS27_PHY
+            printf("s27 reg init lan \n");
+            athrs27_reg_init_lan();
+#endif
+        }
+        ag7240_hw_start(ag7240_macs[i]);
+        ag7240_setup_fifos(ag7240_macs[i]);
+
+        udelay(100 * 1000);
+
+        {
+            unsigned char *mac = dev[i]->enetaddr;
+
+            printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+                   mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+                   mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+        }
+        mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+        mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+            (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+        ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+
+        ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+        printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if defined(CONFIG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0xFFFF;
+
+
+    /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+   if(ii==0)
+      printf("Error!!! Leave ag7240_miiphy_read without polling correct status!\n");
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0xFFFF;
+
+     /*
+     * Check for previous transactions are complete. Added to avoid
+     * race condition while running at higher frequencies.
+     */
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if (ii == 0)
+        printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    if(ii==0)
+        printf("Error!!! Leave ag7240_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_CMD_MII */
diff --git a/cpu/mips/ar7240/ag934x.h b/cpu/mips/ar7240/ag934x.h
new file mode 100644
index 0000000..7a9b476
--- /dev/null
+++ b/cpu/mips/ar7240/ag934x.h
@@ -0,0 +1,242 @@
+#ifndef _AG7240_H
+#define _AG7240_H
+
+#include <linux/types.h>
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+    uint32_t    pkt_start_addr;
+
+    uint32_t    is_empty       :  1;
+    uint32_t    res1           : 10;
+    uint32_t    ftpp_override  :  5;
+    uint32_t    res2           :  4;
+    uint32_t    pkt_size       : 12;
+
+    uint32_t    next_desc      ;
+}ag7240_desc_t;
+
+#define NO_OF_TX_FIFOS  8
+#define NO_OF_RX_FIFOS  8
+
+typedef struct {
+    ag7240_desc_t *fifo_tx[NO_OF_TX_FIFOS];
+    ag7240_desc_t *fifo_rx[NO_OF_RX_FIFOS];
+    struct eth_device *dev;
+    u32            next_tx;
+    u32            next_rx;
+    u32            link;
+    u32            duplex;
+    u32            speed;
+    u32		   mac_unit;
+    u32 	   mac_base;
+    
+}ag7240_mac_t;
+
+#define ag7240_reg_wr(_mac, _x, _y)   ar7240_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ag7240_reg_rd(_mac, _x)       ar7240_reg_rd(((_x) + _mac->mac_base))
+
+#define ag7240_reg_rmw_set(_mac, _x, _y)   \
+    ar7240_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ag7240_reg_rmw_clear(_mac, _x, _y)    \
+    ar7240_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET 1000
+#define _100BASET 100
+#define _10BASET 10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)   (AR7240_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)    (((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ag7240_set_mii_ctrl_speed(_mac, _spd)   do {                        \
+    ar7240_reg_rmw_clear(mii_reg(_mac), (3 << 4));                          \
+    ar7240_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));                       \
+}while(0);
+
+#if defined (CFG_MII0_GMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_MII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RGMII)
+#define ag7240_get_mii_if()             0
+#elif defined (CFG_MII0_RMII)
+#define ag7240_get_mii_if()             0
+#endif
+        
+#define MAX_WAIT        1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define AG7240_MAC_CFG1             0x00
+#define AG7240_MAC_CFG2             0x04
+#define AG7240_MAC_IFCTL            0x38
+
+/*
+ * fifo control registers
+ */
+#define AG7240_MAC_FIFO_CFG_0      0x48
+#define AG7240_MAC_FIFO_CFG_1      0x4c
+#define AG7240_MAC_FIFO_CFG_2      0x50
+#define AG7240_MAC_FIFO_CFG_3      0x54
+#define AG7240_MAC_FIFO_CFG_4      0x58
+
+#define AG7240_MAC_FIFO_CFG_5      0x5c
+#define AG7240_BYTE_PER_CLK_EN     (1 << 19)
+
+#define AG7240_MAC_FIFO_RAM_0      0x60
+#define AG7240_MAC_FIFO_RAM_1      0x64
+#define AG7240_MAC_FIFO_RAM_2      0x68
+#define AG7240_MAC_FIFO_RAM_3      0x6c
+#define AG7240_MAC_FIFO_RAM_4      0x70
+#define AG7240_MAC_FIFO_RAM_5      0x74
+#define AG7240_MAC_FIFO_RAM_6      0x78
+#define AG7240_MAC_FIFO_RAM_7      0x7c
+
+/*
+ * fields
+ */
+#define AG7240_MAC_CFG1_SOFT_RST       (1 << 31)
+#define AG7240_MAC_CFG1_RX_RST         (1 << 19)
+#define AG7240_MAC_CFG1_TX_RST         (1 << 18)
+#define AG7240_MAC_CFG1_LOOPBACK       (1 << 8)
+#define AG7240_MAC_CFG1_RX_EN          (1 << 2)
+#define AG7240_MAC_CFG1_TX_EN          (1 << 0)
+
+#define AG7240_MAC_CFG2_FDX            (1 << 0)
+#define AG7240_MAC_CFG2_PAD_CRC_EN     (1 << 2)
+#define AG7240_MAC_CFG2_LEN_CHECK      (1 << 4)
+#define AG7240_MAC_CFG2_HUGE_FRAME_EN  (1 << 5)
+#define AG7240_MAC_CFG2_IF_1000        (1 << 9)
+#define AG7240_MAC_CFG2_IF_10_100      (1 << 8)
+
+#define AG7240_MAC_IFCTL_SPEED         (1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define AG7240_DMA_TX_CTRL              0x180
+#define AG7240_DMA_TX_DESC              0x184
+#define AG7240_DMA_TX_STATUS            0x188
+#define AG7240_DMA_RX_CTRL              0x18c
+#define AG7240_DMA_RX_DESC              0x190
+#define AG7240_DMA_RX_STATUS            0x194
+#define AG7240_DMA_INTR_MASK            0x198
+#define AG7240_DMA_INTR                 0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define AG7240_TXE                      (1 << 0)
+#define AG7240_TX_STATUS_PKTCNT_SHIFT   16
+#define AG7240_TX_STATUS_PKT_SENT       0x1
+#define AG7240_TX_STATUS_URN            0x2
+#define AG7240_TX_STATUS_BUS_ERROR      0x8
+
+#define AG7240_RXE                      (1 << 0)
+
+#define AG7240_RX_STATUS_PKTCNT_MASK    0xff0000
+#define AG7240_RX_STATUS_PKT_RCVD       (1 << 0)
+#define AG7240_RX_STATUS_OVF            (1 << 2)
+#define AG7240_RX_STATUS_BUS_ERROR      (1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define AG7240_INTR_TX                  (1 << 0)
+#define AG7240_INTR_TX_URN              (1 << 1)
+#define AG7240_INTR_TX_BUS_ERROR        (1 << 3)
+#define AG7240_INTR_RX                  (1 << 4)
+#define AG7240_INTR_RX_OVF              (1 << 6)
+#define AG7240_INTR_RX_BUS_ERROR        (1 << 7)
+
+/*
+ * MII registers
+ */
+#define AG7240_MAC_MII_MGMT_CFG         0x20
+#define AG7240_MGMT_CFG_CLK_DIV_20      0x07
+
+#define AG7240_MII_MGMT_CMD             0x24
+#define AG7240_MGMT_CMD_READ            0x1
+
+#define AG7240_MII_MGMT_ADDRESS         0x28
+#define AG7240_ADDR_SHIFT               8
+
+#define AG7240_MII_MGMT_CTRL            0x2c
+#define AG7240_MII_MGMT_STATUS          0x30
+
+#define AG7240_MII_MGMT_IND             0x34
+#define AG7240_MGMT_IND_BUSY            (1 << 0)
+#define AG7240_MGMT_IND_INVALID         (1 << 2)
+
+#define AG7240_GE_MAC_ADDR1             0x40
+#define AG7240_GE_MAC_ADDR2             0x44
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_RMII_GE0         (1<<10)
+#define AG7240_ETH_CFG_RMII_HISPD_GE0   (1<<11)
+#define AG7240_ETH_CFG_RMII_MASTER_MODE (1<<12)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+#define AG7240_ETH_CFG_RXD_DELAY	(1 << 14)
+#define AG7240_ETH_CFG_RDV_DELAY        (1 << 16)
+#define AG7240_ETH_SWITCH_CLK_SPARE     0x18050024
+
+
+/*
+ *  * ownership of descriptors between DMA and cpu
+ *   */
+#define ag7240_rx_owned_by_dma(_ds)     ((_ds)->is_empty == 1)
+#define ag7240_rx_give_to_dma(_ds)      ((_ds)->is_empty = 1)
+#define ag7240_tx_owned_by_dma(_ds)     ((_ds)->is_empty == 0)
+#define ag7240_tx_give_to_dma(_ds)      ((_ds)->is_empty = 0)
+#define ag7240_tx_own(_ds)              ((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ag7240_set_mac_duplex(_mac, _fdx)       do {                         \
+    if ((_fdx))                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)     \
+    else                                                                     \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_FDX)   \
+}while(0)
+
+#define ag7240_set_mac_if(_mac, _isXGMII)    do {                              \
+    ag7240_reg_rmw_clear(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000|      \
+                                          AG7240_MAC_CFG2_IF_10_100);   \
+    if ((_isXGMII)) {                                            \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_1000)  \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+    else {                                                              \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_CFG2, AG7240_MAC_CFG2_IF_10_100)\
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_FIFO_CFG_5, AG7240_BYTE_PER_CLK_EN);\
+    }                                                                       \
+}while(0)
+
+#define ag7240_set_mac_speed(_mac, _is100)   do {                             \
+    if ((_is100))                                                             \
+        ag7240_reg_rmw_set(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)  \
+    else                                                                      \
+        ag7240_reg_rmw_clear(_mac, AG7240_MAC_IFCTL, AG7240_MAC_IFCTL_SPEED)\
+}while(0)
+
+#endif
diff --git a/cpu/mips/ar7240/ag934x_phy.h b/cpu/mips/ar7240/ag934x_phy.h
new file mode 100644
index 0000000..715939c
--- /dev/null
+++ b/cpu/mips/ar7240/ag934x_phy.h
@@ -0,0 +1,117 @@
+#ifndef _AG7240_PHY_H
+#define _AG7240_PHY_H
+
+static inline void ag7240_phy_setup(int unit)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        athrs16_phy_setup(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        athrs17_phy_setup(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+        athrs27_phy_setup(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        athrs26_phy_setup(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        athr_phy_setup(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        athr_vir_phy_setup(unit);
+#endif
+
+    }
+}
+
+static inline void ag7240_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+         *link = athrs16_phy_is_up(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+         *link = athrs17_phy_is_up(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+         *link = athrs27_phy_is_up(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+         *link = athrs26_phy_is_up(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+         *link = athr_phy_is_up(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+         *link = athr_vir_phy_is_up(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *duplex = athrs16_phy_is_fdx(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        *duplex = athrs17_phy_is_fdx(unit);
+    } else
+#endif
+   {
+#ifdef CFG_ATHRS27_PHY
+        *duplex = athrs27_phy_is_fdx(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        *duplex = athrs26_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        *duplex = athr_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        *duplex = athr_vir_phy_is_fdx(unit);
+#endif
+    }
+}
+
+static inline void ag7240_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_AR7242_S16_PHY
+    if ((is_ar7242() || is_wasp()) && (unit==0)) {
+        *speed = athrs16_phy_speed(unit);
+    } else
+#endif
+#ifdef CONFIG_ATHRS17_PHY
+    if (unit == 0) {
+        *speed = athrs17_phy_speed(unit);
+    } else
+#endif
+    {
+#ifdef CFG_ATHRS27_PHY
+        *speed = athrs27_phy_speed(unit);
+#endif
+#ifdef CFG_ATHRS26_PHY
+        *speed = athrs26_phy_speed(unit);
+#endif
+#if defined(CONFIG_F1E_PHY) || defined(CONFIG_F2E_PHY)
+        *speed = athr_phy_speed(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+        *speed = athr_vir_phy_speed(unit);
+#endif
+    }
+}
+
+#endif /*_AG7240_PHY_H*/
diff --git a/cpu/mips/ar7240/ar7240_serial.c b/cpu/mips/ar7240/ar7240_serial.c
new file mode 100644
index 0000000..91a553a
--- /dev/null
+++ b/cpu/mips/ar7240/ar7240_serial.c
@@ -0,0 +1,142 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <ar7240_soc.h>
+
+#define		REG_OFFSET		4
+
+/* === END OF CONFIG === */
+
+/* register offset */
+#define         OFS_RCV_BUFFER          (0*REG_OFFSET)
+#define         OFS_TRANS_HOLD          (0*REG_OFFSET)
+#define         OFS_SEND_BUFFER         (0*REG_OFFSET)
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+#define         MY_WRITE(y, z)  ((*((volatile u32*)(y))) = z)
+#define         UART16550_READ(y)   ar7240_reg_rd((AR7240_UART_BASE+y))
+#define         UART16550_WRITE(x, z)  ar7240_reg_wr((AR7240_UART_BASE+x), z)
+
+void
+ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+    u32 pll, pll_div, ref_div, ahb_div, ddr_div, freq;
+
+    pll = ar7240_reg_rd(AR7240_CPU_PLL_CONFIG);
+
+    pll_div =
+        ((pll & PLL_CONFIG_PLL_DIV_MASK) >> PLL_CONFIG_PLL_DIV_SHIFT);
+
+    ref_div =
+        ((pll & PLL_CONFIG_PLL_REF_DIV_MASK) >> PLL_CONFIG_PLL_REF_DIV_SHIFT);
+
+    ddr_div =
+        ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+
+    ahb_div =
+       (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    freq = pll_div * ref_div * 5000000;
+
+    if (cpu_freq)
+        *cpu_freq = freq;
+
+    if (ddr_freq)
+        *ddr_freq = freq/ddr_div;
+
+    if (ahb_freq)
+        *ahb_freq = freq/ahb_div;
+}
+
+int serial_init(void)
+{
+    u32 div,val;
+    u32 ahb_freq, ddr_freq, cpu_freq;
+
+#ifdef CONFIG_WASP
+    val = ar7240_reg_rd(WASP_BOOTSTRAP_REG);
+
+    if ((val & WASP_REF_CLK_25) == 0) {
+        div = (25 * 1000000) / (16 * CONFIG_BAUDRATE);
+    } else {
+        div = (40 * 1000000) / (16 * CONFIG_BAUDRATE);
+    }
+#else
+
+    ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+
+    div  = ahb_freq/(16 * CONFIG_BAUDRATE);
+
+    MY_WRITE(0xb8040000, 0xcff);
+    MY_WRITE(0xb8040008, 0x3b);
+
+    val = ar7240_reg_rd(0xb8040028);
+    MY_WRITE(0xb8040028,(val | 0x8002));
+
+    MY_WRITE(0xb8040008, 0x2f);
+#endif
+
+    /*
+     * set DIAB bit
+     */
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+
+    /* set divisor */
+    UART16550_WRITE(OFS_DIVISOR_LSB, (div & 0xff));
+    UART16550_WRITE(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+
+    /* clear DIAB bit*/
+    UART16550_WRITE(OFS_LINE_CONTROL, 0x00);
+
+    /* set data format */
+    UART16550_WRITE(OFS_DATA_FORMAT, 0x3);
+
+    UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+    return 0;
+}
+
+int serial_tstc (void)
+{
+    return(UART16550_READ(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc(void)
+{
+    while(!serial_tstc());
+
+    return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n') serial_putc ('\r');
+
+    while (((UART16550_READ(OFS_LINE_STATUS)) & 0x20) == 0x0);
+    UART16550_WRITE(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/cpu/mips/ar7240/hornet.h b/cpu/mips/ar7240/hornet.h
new file mode 100644
index 0000000..d95094d
--- /dev/null
+++ b/cpu/mips/ar7240/hornet.h
@@ -0,0 +1,34 @@
+#ifndef _HORNET_H
+#define _HORNET_H
+
+/*
+ * GE0 AR8021 phy address
+ */
+#define GE0_AR8021_PHY_ADDR             0x0
+
+/*
+ * Ethernet config registers
+ */
+#define AG7240_ETH_CFG                  0x18070000
+#define AG7240_ETH_CFG_RGMII_GE0        (1<<0)
+#define AG7240_ETH_CFG_MII_GE0          (1<<1)
+#define AG7240_ETH_CFG_GMII_GE0         (1<<2)
+#define AG7240_ETH_CFG_MII_GE0_MASTER   (1<<3)
+#define AG7240_ETH_CFG_MII_GE0_SLAVE    (1<<4)
+#define AG7240_ETH_CFG_GE0_ERR_EN       (1<<5)
+#define AG7240_ETH_CFG_SW_ONLY_MODE     (1<<6)
+#define AG7240_ETH_CFG_SW_PHY_SWAP      (1<<7)
+#define AG7240_ETH_CFG_SW_PHY_ADDR_SWAP (1<<8)
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+
+#ifndef ag7240_unit2name
+#define ag7240_unit2name(_unit) _unit ?  "eth1" : "eth0"
+#endif
+
+#endif
diff --git a/cpu/mips/ar7240/hornet_ag7240.c b/cpu/mips/ar7240/hornet_ag7240.c
new file mode 100644
index 0000000..bec55fe
--- /dev/null
+++ b/cpu/mips/ar7240/hornet_ag7240.c
@@ -0,0 +1,662 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ag7240.h"
+#include "ag7240_phy.h"
+
+#if defined(CONFIG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ag7240_unit2mac(_unit)     ag7240_macs[(_unit)]
+#define ag7240_name2mac(name)	   strcmp(name,"eth0") ? ag7240_unit2mac(1) : ag7240_unit2mac(0)
+
+uint16_t ag7240_miiphy_read(char *devname, uint32_t phaddr,
+	       uint8_t reg);
+void  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+	        uint8_t reg, uint16_t data);
+
+ag7240_mac_t *ag7240_macs[CFG_AG7240_NMACS];
+
+extern int athrs26_phy_setup(int unit);
+extern int athrs26_phy_is_up(int unit);
+extern int athrs26_phy_is_fdx(int unit);
+extern int athrs26_phy_speed(int unit);
+extern void athrs26_reg_init(void);
+extern void athrs26_reg_init_lan(void);
+extern void ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq);
+extern int athrs26_mdc_check(void);
+
+#ifdef CONFIG_HORNET_EMU
+#include "hornet.h"
+
+void ar8021_phy_setup(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_is_link_alive(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_is_fdx(u32 ethUnit, u32 phyUnit);
+uint32_t ar8021_phy_speed(u32 ethUnit, u32 phyUnit);
+#endif /* CONFIG_HORNET_EMU */
+
+static int
+ag7240_send(struct eth_device *dev, volatile void *packet, int length)
+{
+    int i;
+
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+
+    ag7240_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+    f->pkt_size = length;
+    f->res1 = 0;
+    f->pkt_start_addr = virt_to_phys(packet);
+
+    ag7240_tx_give_to_dma(f);
+    flush_cache((u32) packet, length);
+    ag7240_reg_wr(mac, AG7240_DMA_TX_DESC, virt_to_phys(f));
+    ag7240_reg_wr(mac, AG7240_DMA_TX_CTRL, AG7240_TXE);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+        udelay(10);
+        if (!ag7240_tx_owned_by_dma(f))
+            break;
+    }
+    if (i == MAX_WAIT)
+        printf("Tx Timed out\n");
+
+    f->pkt_start_addr = 0;
+    f->pkt_size = 0;
+
+    if (++mac->next_tx >= NO_OF_TX_FIFOS)
+        mac->next_tx = 0;
+
+    return (0);
+}
+
+static int ag7240_recv(struct eth_device *dev)
+{
+    int length;
+    ag7240_desc_t *f;
+    ag7240_mac_t *mac;
+
+    mac = (ag7240_mac_t *)dev->priv;
+
+    for (;;) {
+        f = mac->fifo_rx[mac->next_rx];
+        if (ag7240_rx_owned_by_dma(f))
+            break;
+
+        length = f->pkt_size;
+
+        NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+        flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+        ag7240_rx_give_to_dma(f);
+
+        if (++mac->next_rx >= NO_OF_RX_FIFOS)
+            mac->next_rx = 0;
+    }
+
+    if (!(ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL))) {
+        ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(f));
+        ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 1);
+    }
+
+    return (0);
+}
+
+static void ag7240_hw_start(ag7240_mac_t *mac)
+{
+    u32 cpu_freq,ddr_freq,ahb_freq;
+    u32 mgmt_cfg_val;
+    u32 check_cnt,revid_val;
+
+    if(mac->mac_unit)
+    {
+        ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+            AG7240_MAC_CFG1_TX_EN));
+        ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+            AG7240_MAC_CFG2_LEN_CHECK | AG7240_MAC_CFG2_IF_1000));
+    }
+    else {
+
+    ag7240_reg_wr(mac, AG7240_MAC_CFG1, (AG7240_MAC_CFG1_RX_EN |
+		    AG7240_MAC_CFG1_TX_EN));
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_CFG2, (AG7240_MAC_CFG2_PAD_CRC_EN |
+		         AG7240_MAC_CFG2_LEN_CHECK));
+   }
+
+#ifdef AR7240_EMU
+    printf("AG7240_MAC_FIFO_CFG_4\n");
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0xfff0000);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0x1fff);
+#endif
+if ((ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK) == AR7240_REV_1_2) {
+        mgmt_cfg_val = 0x2;
+        if (mac->mac_unit == 0) {
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+        }
+    }
+    else {
+        ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);
+        switch (ahb_freq/1000000) {
+            case 150:
+                     mgmt_cfg_val = 0x7;
+                     break;
+            case 175:
+                     mgmt_cfg_val = 0x5;
+                     break;
+            case 200:
+                     mgmt_cfg_val = 0x4;
+                     break;
+            case 210:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            case 220:
+                      mgmt_cfg_val = 0x9;
+                      break;
+            default:
+                     mgmt_cfg_val = 0x7;
+        }
+        if ((is_ar7241() || is_ar7242())) {
+
+            /* External MII mode */
+            if (mac->mac_unit == 0 && is_ar7242()) {
+                mgmt_cfg_val = 0x6;
+                ar7240_reg_rmw_set(AG7240_ETH_CFG, AG7240_ETH_CFG_RGMII_GE0);
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            }
+#ifndef CONFIG_HORNET_EMU
+            /* Virian */
+            mgmt_cfg_val = 0x4;
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+            ag7240_reg_wr(ag7240_macs[1], AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+            printf("Virian MDC CFG Value ==> %x\n",mgmt_cfg_val);
+#endif
+
+        }
+        else { /* Python 1.0 & 1.1 */
+            if (mac->mac_unit == 0) {
+                check_cnt = 0;
+                while (check_cnt++ < 10) {
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+                    ag7240_reg_wr(mac, AG7240_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+                    if(athrs26_mdc_check() == 0)
+                        break;
+                }
+                if(check_cnt == 11)
+                    printf("%s: MDC check failed\n", __func__);
+            }
+        }
+    }
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_0, 0x1f00);
+
+    ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_4, 0x3ffff);
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_1, 0x10ffff);
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_2, 0xAAA0555);
+
+    /* 
+     * Setting Drop CRC Errors, Pause Frames,Length Error frames 
+     * and Multi/Broad cast frames. 
+     */
+
+#ifdef CONFIG_HORNET_EMU
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0xbefff);
+#else
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_5, 0x7eccf);
+#endif
+
+    ag7240_reg_wr(mac, AG7240_MAC_FIFO_CFG_3, 0x1f00140);
+
+    printf(": cfg1 %#x cfg2 %#x\n", ag7240_reg_rd(mac, AG7240_MAC_CFG1),
+        ag7240_reg_rd(mac, AG7240_MAC_CFG2));
+
+}
+
+static int ag7240_check_link(ag7240_mac_t *mac)
+{
+    u32 link, duplex, speed, fdx;
+
+#ifdef CONFIG_HORNET_EMU
+    link   = ar8021_phy_is_link_alive(0, GE0_AR8021_PHY_ADDR);
+    duplex = ar8021_phy_is_fdx(0, GE0_AR8021_PHY_ADDR);
+    speed  = ar8021_phy_speed(0, GE0_AR8021_PHY_ADDR);
+#else
+    ag7240_phy_link(mac->mac_unit, &link);
+    ag7240_phy_duplex(mac->mac_unit, &duplex);
+    ag7240_phy_speed(mac->mac_unit, &speed);
+#endif
+
+    mac->link = link;
+#ifdef SUPPORT_PLC
+    if(strcmp(mac->dev->name, "eth0") == 0) {
+        printf("ag7240_check_link: %s link forced down\n",mac->dev->name);
+        return 0;
+    }
+#endif
+
+    if(!mac->link) {
+        printf("%s link down\n",mac->dev->name);
+        return 0;
+    }
+
+    switch (speed)
+    {
+       case _1000BASET:
+           ag7240_set_mac_if(mac, 1);
+           ag7240_reg_rmw_set(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1c000000);
+           break;
+
+       case _100BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 1);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+#ifndef CONFIG_HORNET_EMU
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0101);
+#endif
+           break;
+
+       case _10BASET:
+           ag7240_set_mac_if(mac, 0);
+           ag7240_set_mac_speed(mac, 0);
+           ag7240_reg_rmw_clear(mac, AG7240_MAC_FIFO_CFG_5, (1 << 19));
+           if (is_ar7242() && (mac->mac_unit == 0))
+               ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x1616);
+           break;
+
+       default:
+          printf("Invalid speed detected\n");
+          return 0;
+    }
+
+   if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+        return 1; 
+
+    mac->duplex = duplex;
+    mac->speed = speed;
+
+    printf("dup %d speed %d\n", duplex, speed);
+
+    ag7240_set_mac_duplex(mac,duplex);
+
+    return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ag7240_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+    int i;
+    ag7240_desc_t *fr;
+    ag7240_mac_t *mac = (ag7240_mac_t*)dev->priv;
+
+    if (!ag7240_check_link(mac))
+        return 0;
+
+    mac->next_rx = 0;
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        fr = mac->fifo_rx[i];
+        fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+        flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+        ag7240_rx_give_to_dma(fr);
+    }
+
+    ag7240_reg_wr(mac, AG7240_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, AG7240_RXE);	/* rx start */
+    udelay(1000 * 1000);
+
+
+    return 1;
+
+}
+
+static int ag7240_alloc_fifo(int ndesc, ag7240_desc_t ** fifo)
+{
+    int i;
+    u32 size;
+    uchar *p = NULL;
+
+    size = sizeof(ag7240_desc_t) * ndesc;
+    size += CFG_CACHELINE_SIZE - 1;
+
+    if ((p = malloc(size)) == NULL) {
+        printf("Cant allocate fifos\n");
+        return -1;
+    }
+
+    p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+	   ~(CFG_CACHELINE_SIZE - 1));
+    p = UNCACHED_SDRAM(p);
+
+    for (i = 0; i < ndesc; i++)
+        fifo[i] = (ag7240_desc_t *) p + i;
+
+    return 0;
+}
+
+static int ag7240_setup_fifos(ag7240_mac_t *mac)
+{
+    int i;
+
+    if (ag7240_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+        return 1;
+
+    for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+        mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+        ag7240_tx_own(mac->fifo_tx[i]);
+    }
+
+    if (ag7240_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+        return 1;
+
+    for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+        mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+            virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+    }
+
+    return (1);
+}
+
+static void ag7240_halt(struct eth_device *dev)
+{
+    ag7240_mac_t *mac = (ag7240_mac_t *)dev->priv;
+    ag7240_reg_wr(mac, AG7240_DMA_RX_CTRL, 0);
+    while (ag7240_reg_rd(mac, AG7240_DMA_RX_CTRL));
+}
+
+unsigned char *
+ag7240_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+    /*
+    ** BOARDCAL environmental variable has the address of the cal sector
+    */
+    
+    return ((unsigned char *)BOARDCAL);
+    
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+		(KSEG1ADDR(AR7240_SPI_BASE) + (4 * 1024) +
+		flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ag7240_get_ethaddr(struct eth_device *dev)
+{
+    unsigned char *eeprom;
+    unsigned char *mac = dev->enetaddr;
+
+    eeprom = ag7240_mac_addr_loc();
+
+    if (strcmp(dev->name, "eth0") == 0) {
+        memcpy(mac, eeprom, 6);
+    } else if (strcmp(dev->name, "eth1") == 0) {
+        eeprom += 6;
+        memcpy(mac, eeprom, 6);
+    } else {
+        printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+        return;
+    }
+
+    /* Use fixed address if the above address is invalid */
+    if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff)) {
+        mac[0] = 0x00;
+        mac[1] = 0x03;
+        mac[2] = 0x7f;
+        mac[3] = 0x09;
+        mac[4] = 0x0b;
+        mac[5] = 0xad;
+        printf("No valid address in Flash. Using fixed address\n");
+    } else {
+        printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+    }
+}
+
+
+int ag7240_enet_initialize(bd_t * bis)
+{
+    struct eth_device *dev[CFG_AG7240_NMACS];
+    u32 mask, mac_h, mac_l;
+    int i;
+
+    printf("ag7240_enet_initialize...\n");
+
+#ifdef CONFIG_MACH_HORNET
+    ar7240_reg_wr(HORNET_BOOTSTRAP_STATUS, ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) & ~HORNET_BOOTSTRAP_MDIO_SLAVE_MASK);
+#endif
+
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+	
+    if ((ag7240_macs[i] = (ag7240_mac_t *) malloc(sizeof (ag7240_mac_t))) == NULL) {
+        puts("malloc failed\n");
+        return 0;
+    }
+
+    memset(ag7240_macs[i], 0, sizeof(ag7240_macs[i]));
+    memset(dev[i], 0, sizeof(dev[i]));
+
+    sprintf(dev[i]->name, "eth%d", i);
+    ag7240_get_ethaddr(dev[i]);
+    
+    ag7240_macs[i]->mac_unit = i;
+    ag7240_macs[i]->mac_base = i ? AR7240_GE1_BASE : AR7240_GE0_BASE ;
+    ag7240_macs[i]->dev = dev[i];
+
+    dev[i]->iobase = 0;
+    dev[i]->init = ag7240_clean_rx;
+    dev[i]->halt = ag7240_halt;
+    dev[i]->send = ag7240_send;
+    dev[i]->recv = ag7240_recv;
+    dev[i]->priv = (void *)ag7240_macs[i];
+    }
+    for (i = 0;i < CFG_AG7240_NMACS;i++) {
+
+    eth_register(dev[i]);
+
+#if defined(CONFIG_CMD_MII)
+    miiphy_register(dev[i]->name, ag7240_miiphy_read, ag7240_miiphy_write);
+#endif
+    if(!i) {
+        mask = (AR7240_RESET_GE0_MAC | AR7240_RESET_GE0_PHY |
+                AR7240_RESET_GE1_MAC | AR7240_RESET_GE1_PHY);
+
+    if ((is_ar7241() || is_ar7242())) 
+	mask = mask | AR7240_RESET_GE0_MDIO | AR7240_RESET_GE1_MDIO;
+
+
+        ar7240_reg_rmw_set(AR7240_RESET, mask);
+        udelay(1000 * 100);
+
+        ar7240_reg_rmw_clear(AR7240_RESET, mask);
+        udelay(1000 * 100);
+
+    udelay(10 * 1000);
+    }
+    ag7240_hw_start(ag7240_macs[i]);
+    ag7240_setup_fifos(ag7240_macs[i]);
+
+    udelay(100 * 1000);
+
+    {
+        unsigned char *mac = dev[i]->enetaddr;
+
+        printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+               mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+               mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+    }
+    mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+    mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+        (dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+    ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR1, mac_l);
+    ag7240_reg_wr(ag7240_macs[i], AG7240_GE_MAC_ADDR2, mac_h);
+
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+#ifdef CONFIG_HORNET_EMU
+    ar8021_phy_setup(0, GE0_AR8021_PHY_ADDR);
+#else
+    if (ag7240_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef CONFIG_AR7242_S16_PHY
+        if (is_ar7242()) {
+            athrs16_reg_init();
+        } else
+#endif
+        {
+            athrs26_reg_init();
+        }
+    } else {
+        athrs26_reg_init_lan();
+    }
+
+    ag7240_phy_setup(ag7240_macs[i]->mac_unit);
+#endif
+    printf("%s up\n",dev[i]->name);
+    }
+
+    return 1;
+}
+
+#if defined(CONFIG_CMD_MII)
+uint16_t
+ag7240_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+    ag7240_mac_t *mac   = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0x1000;
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, AG7240_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    val = ag7240_reg_rd(mac, AG7240_MII_MGMT_STATUS);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void
+ag7240_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7240_mac_t *mac = ag7240_name2mac(devname);
+    uint16_t      addr  = (phy_addr << AG7240_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0x1000;
+
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_ADDRESS, addr);
+    ag7240_reg_wr(mac, AG7240_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7240_reg_rd(mac, AG7240_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+}
+#endif		/* CONFIG_CMD_MII */
+
+#ifdef CONFIG_HORNET_EMU
+void
+ar8021_phy_setup(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyid1, phyid2;
+
+    phyid1 = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x2);
+    phyid2 = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x3);
+
+    printf("%s Phy ID %x:%x\n", __FUNCTION__, phyid1, phyid2);
+
+    udelay(1000*1000);
+
+    ar7240_reg_rmw_set(AR7240_GPIO_BASE, 0x20);
+    ar7240_reg_rmw_set(AR7240_GPIO_BASE + 0x8, 0x20);
+
+    udelay(1000*1000);
+    ar7240_reg_rmw_clear(AR7240_GPIO_BASE + 0x8, 0x20);
+
+    udelay(1000*1000);
+}
+
+uint32_t
+ar8021_phy_is_link_alive(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+       return 1;
+
+    return 0;
+}
+
+uint32_t
+ar8021_phy_speed(uint32_t ethUnit, uint32_t phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    {
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return _10BASET;
+        case 1:
+            return _100BASET;
+        case 2:
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+    return _10BASET;
+}
+
+uint32_t
+ar8021_phy_is_fdx(u32 ethUnit, u32 phyUnit)
+{
+    uint32_t phyHwStatus;
+
+    phyHwStatus = ag7240_miiphy_read(ag7240_unit2name(ethUnit), phyUnit, 0x11);
+
+    if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+       return 1;
+
+    return 0;
+}
+#endif /* CONFIG_HORNET_EMU */
diff --git a/cpu/mips/ar7240/hornet_ddr_init.S b/cpu/mips/ar7240/hornet_ddr_init.S
new file mode 100755
index 0000000..4247541
--- /dev/null
+++ b/cpu/mips/ar7240/hornet_ddr_init.S
@@ -0,0 +1,4690 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+	.globl hornet_ddr_init
+	.text
+	.align 4
+
+#define set_mem(_mem, _val)                         \
+    li  t9, _mem;                                   \
+    sw  _val, 0(t9);
+
+//============================================
+//   init DDR1 parameter before rel_start
+//===========================================
+hornet_ddr_init:
+
+    //--------DDR_Config_1--------   D.S 0xB8000000 %LONG 0x7fbc8cd0 
+    li t8, CFG_DDR_CONFIG_VAL;
+    set_mem(0xB8000000,t8);
+
+    //--------DDR_Config_2--------  D.S 0xB8000004 %LONG 0x99d0e6a8 
+    li t8, CFG_DDR_CONFIG2_VAL;
+    set_mem(0xB8000004,t8);
+
+    // DDR1 Paramters
+
+    //D.S 0xB8000010 %LONG 0x8           ;      // precharge
+    li t8,0x8;
+    set_mem(0xB8000010,t8);
+
+    //D.S 0xB8000008 %LONG 0x133         ;
+    li t8,CFG_DDR_MODE_VAL_INIT;
+    set_mem(0xB8000008,t8);
+
+    //D.S 0xB8000010 %LONG 0x1           ;      // Write Mode Word in DDR
+    li t8, 0x1;
+    set_mem( 0xB8000010, t8);
+    
+    //D.S 0xB800000C %LONG 0x2           ;      // Enable DLL, High drive strength from DDR
+    li t8, 0x2;
+    set_mem( 0xB800000C , t8);
+
+    //D.S 0xB8000010 %LONG 0x2           ;      // Write Extended Mode Word of DDR
+    li t8, 0x2;
+    set_mem( 0xB8000010, t8);
+
+    //D.S 0xB8000010 %LONG 0x8           ;      // precharge enabled
+    li t8, 0x8;
+    set_mem( 0xB8000010, t8);
+
+    // D.S 0xB8000008 %LONG 0x33          ;      // dll out of reset CAS Latency 3
+    li t8, CFG_DDR_MODE_VAL;
+    set_mem( 0xB8000008, t8);
+
+    //D.S 0xB8000010 %LONG 0x1           ;      // write mode word
+    li t8, 0x1;
+    set_mem( 0xB8000010, t8);
+
+    //D.S 0xB8000014 %LONG 0x4186/0x4270 ;      // Refresh control. Bit 14 is enable. Bits<13:0> Refresh time
+    li t8, CFG_DDR_REFRESH_VAL;
+    set_mem( 0xB8000014, t8);
+
+    //D.S 0xB800001C %LONG 0x08          ;       // DQS 0 Tap Control (needs tuning)
+    li t8, CFG_DDR_TAP0_VAL;
+    set_mem( 0xB800001C, t8);
+
+    //D.S 0xB8000020 %LONG 0x09          ;       // DQS 1 Tap Control (needs tuning)
+    li t8, CFG_DDR_TAP1_VAL;
+    set_mem( 0xB8000020, t8);
+
+    //D.S 0xB8000018 %LONG 0x00ff        ;      // For 16-bit DDR
+    li t8, 0x00ff;
+    set_mem( 0xB8000018, t8);
+
+	nop
+	jr 	ra
+    
+/*
+ * void hornet_ddr_tap_init(void)
+ *
+ * This "function" is used to find the tap settings for the DDR
+ */
+	.globl	hornet_ddr_tap_init
+	.ent	hornet_ddr_tap_init
+hornet_ddr_tap_init: /* { */
+
+#if NEW_DDR_TAP_CAL
+	li	t1,0x80500000 
+	li	t0,0xffffffff 
+	 
+	sw	t0,0x0(t1) 
+	sw	t0,0x4(t1) 
+	sw	t0,0x8(t1) 
+	sw	t0,0xc(t1) 
+	 
+	nop 
+	nop
+
+ddr_pat_init:
+	li 	t8, 0xa0002000
+	li	t0, 0x00
+	li	t1, 0x100	
+write_loop_start:
+	andi    t2, t0, 0x03
+pat_000:
+	li	t3, 0x00
+	bne	t2, t3,pat_001
+	li 	t9, 0x00000000
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_001:
+	li	t3, 0x01
+	bne	t2, t3,pat_002
+	li 	t9, 0x0000ffff
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_002:
+	li	t3, 0x02
+	bne	t2, t3,pat_003
+	li 	t9, 0xffff0000
+	sw	t9, 0x0 (t8)
+	b	pat_004
+
+pat_003:
+	li	t3, 0x03
+	bne	t2, t3,pat_004
+	li 	t9, 0xffffffff
+	sw	t9, 0x0 (t8)
+
+pat_004:
+	andi    t2, t0, 0x0c
+	li	t3, 0x00
+	bne	t2, t3,pat_005
+	li 	t9, 0x00000000
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_005:
+	li	t3, 0x04
+	bne	t2, t3,pat_006
+	li 	t9, 0x0000ffff
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_006:
+	li	t3, 0x08
+	bne	t2, t3,pat_007
+	li 	t9, 0xffff0000
+	sw	t9, 0x4 (t8)
+	b	pat_008
+
+pat_007:
+	li	t3, 0x0c
+	bne	t2, t3,pat_008
+	li 	t9, 0xffffffff
+	sw	t9, 0x4 (t8)
+
+pat_008:
+	andi    t2, t0, 0x30
+	li	t3, 0x00
+	bne	t2, t3,pat_009
+	li 	t9, 0x00000000
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_009:
+	li	t3, 0x10
+	bne	t2, t3,pat_00a
+	li 	t9, 0x0000ffff
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_00a:
+	li	t3, 0x20
+	bne	t2, t3,pat_00b
+	li 	t9, 0xffff0000
+	sw	t9, 0x8 (t8)
+	b	pat_00c
+
+pat_00b:
+	li	t3, 0x30
+	bne	t2, t3,pat_00c
+	li 	t9, 0xffffffff
+	sw	t9, 0x8 (t8)
+
+pat_00c:
+	andi    t2, t0, 0xc0
+	li	t3, 0x00
+	bne	t2, t3,pat_00d
+	li 	t9, 0x00000000
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00d:
+	li	t3, 0x40
+	bne	t2, t3,pat_00e
+	li 	t9, 0x0000ffff
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00e:
+	li	t3, 0x80
+	bne	t2, t3,pat_00f
+	li 	t9, 0xffff0000
+	sw	t9, 0xc (t8)
+	b	pat_done
+
+pat_00f:
+	li	t3, 0xc0
+	bne	t2, t3,pat_done
+	li 	t9, 0xffffffff
+	sw	t9, 0xc (t8)
+
+pat_done:
+
+	addiu	t0, t0, 0x1
+	addiu	t8, t8, 0x10
+	bne	t0, t1, write_loop_start
+	
+
+
+
+###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     ### Start address of the pattern   200
+	li	a2, 0x80003000	     ### End Address of the pattern     220
+	li	t0, 0xb800001c	     ## Tap settings addr
+	lw	a3, 0x0(t0)	     ## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1	     ## $t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x2#li	$t7, 0x200	## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+    #if 0 /* Hornet doesn't have DQS2, DQS3*/
+	sw	t0, 0x24(t8)
+	nop
+	sw	t0, 0x28(t8)
+	nop
+    #endif	
+
+###### t0 stores current tap setting under test
+###### t1 indicates increment or decrement of tap 
+
+pat_read:
+	ori	t2, a0, 0x0	
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+	
+	bne	t5, t6, tap_fail  # jump to fail if not equal
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  #incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+	
+	bne	t3, t4, tap_addr_loop # compare new addr if end addr not reached
+	nop	
+	
+	addiu	t7, t7, -1     # read passed for all locations once hence decrement t7
+	nop
+	bnez	t7, pat_read    # t7 = 0 represents passing of all locations for given tap
+	nop
+	nop
+	
+	bnez	t1, tap_incr     # increment tap if t1 = 1
+	nop
+	nop
+	
+	bnez	t0, tap_decr	  ## $t0=0 implies tap=0 works
+	nop		          ## so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000   ## assigning lower limit = 0
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0     ##adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+tap_decr: 			# decrement t0 by 1 and move to loading this new tap
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20	# limiting upper limit to 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit 	# t1=0 means lower limit detected @ fail else upper limit
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000	# storing lower limit
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0	# storing lower limit# adding lower limit and upper limit
+	nop
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1 
+	li	t1, 0x0	 ## changing to decreasing tap mode	
+	li	t8, 0x80500000 ## storing upper limit
+	sw	t0, 0x4(t8)	
+	ori	t9, t0, 0x0	
+	nop
+	nop
+	nop
+	
+	ori	t0, a3, 0x0 	# loading default tap value 
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  ## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+	li      t8, 0xb8000000  #### Loading Tap Setting
+	nop
+	sw      t5, 0x1c(t8)
+	nop
+	sw      t6, 0x20(t8)
+	nop
+    #if 0 /* Hornet doesn't have DQS2, DQS3*/	
+	sw      t5, 0x24(t8)
+	nop
+	sw      t6, 0x28(t8)
+	nop
+    #endif	
+	nop
+	nop
+#else /* NEW_DDR_TAP_CAL */
+	li	t1,0x80500000 
+	li	t0,0xffffffff 
+	 
+	sw	t0,0x0(t1) 
+	sw	t0,0x4(t1) 
+	sw	t0,0x8(t1) 
+	sw	t0,0xc(t1) 
+	 
+	nop 
+	nop
+
+ddr_pat_init:
+	li 	t0, 0xa0002000
+	
+	li 	t1, 0x00000000
+	sw 	t1, 0x0(t0)
+	nop
+	
+	li 	t1, 0x00000000
+	sw 	t1, 0x4(t0)
+	nop
+	
+	li 	t1, 0x00000000
+	sw	t1, 0x8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x14(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x18(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x24(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x28(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x34(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x38(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x44(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x48(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x54(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x58(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x64(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x68(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x74(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x78(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x84(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x88(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x94(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x98(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x100(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x104(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x108(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x10c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x110(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x114(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x118(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x11c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x120(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x124(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x128(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x12c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x130(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x134(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x138(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x13c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x140(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x144(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x148(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x14c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x150(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x154(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x158(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x15c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x160(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x164(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x168(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x16c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x170(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x174(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x178(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x17c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x180(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x184(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x188(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x18c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x190(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x194(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x198(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x19c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x1e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x1f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x1f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x1fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x200(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x204(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x208(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x20c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x210(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x214(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x218(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x21c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x220(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x224(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x228(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x22c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x230(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x234(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x238(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x23c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x240(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x244(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x248(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x24c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x250(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x254(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x258(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x25c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x260(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x264(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x268(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x26c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x270(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x274(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x278(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x27c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x280(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x284(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x288(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x28c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x290(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x294(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x298(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x29c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2b4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2c4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x2d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2d4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2e4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x2f4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x2f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x2fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x300(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x304(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x308(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x30c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x310(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x314(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x318(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x31c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x320(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x324(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x328(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x32c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x330(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x334(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x338(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x33c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x340(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x344(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x348(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x34c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x350(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x354(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x358(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x35c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x360(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x364(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x368(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x36c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x370(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x374(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x378(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x37c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x380(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x384(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x388(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x38c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x390(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x394(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x398(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x39c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3a4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3a8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3b4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3b8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3c4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3c8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x3d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3d4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3d8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x3e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3e4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3e8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x3f8(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x3fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x400(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x404(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x408(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x40c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x410(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x414(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x418(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x41c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x420(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x424(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x428(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x42c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x430(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x434(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x438(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x43c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x440(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x444(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x448(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x44c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x450(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x454(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x458(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x45c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x460(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x464(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x468(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x46c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x470(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x474(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x478(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x47c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x480(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x484(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x488(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x48c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x490(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x494(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x498(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x49c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4a4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4b4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4c4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4d4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x4e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4e4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x4f4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x4f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x4fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x500(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x504(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x508(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x50c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x510(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x514(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x518(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x51c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x520(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x524(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x528(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x52c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x530(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x534(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x538(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x53c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x540(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x544(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x548(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x54c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x550(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x554(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x558(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x55c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x560(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x564(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x568(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x56c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x570(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x574(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x578(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x57c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x580(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x584(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x588(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x58c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x590(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x594(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x598(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x59c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x5c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x5e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x5f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x5fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x600(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x604(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x608(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x60c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x610(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x614(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x618(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x61c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x620(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x624(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x628(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x62c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x630(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x634(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x638(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x63c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x640(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x644(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x648(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x64c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x650(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x654(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x658(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x65c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x660(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x664(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x668(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x66c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x670(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x674(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x678(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x67c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x680(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x684(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x688(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x68c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x690(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x694(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x698(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x69c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6b4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x6c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6c4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6d4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6e4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x6f4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x6f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x6fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x700(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x704(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x708(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x70c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x710(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x714(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x718(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x71c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x720(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x724(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x728(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x72c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x730(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x734(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x738(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x73c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x740(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x744(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x748(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x74c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x750(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x754(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x758(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x75c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x760(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x764(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x768(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x76c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x770(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x774(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x778(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x77c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x780(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x784(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x788(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x78c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x790(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x794(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x798(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x79c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7a4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7a8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7b4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7b8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x7c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7c4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7c8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7d4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7d8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x7e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7e4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7e8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x7f8(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x7fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x800(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x804(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x808(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x80c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x810(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x814(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x818(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x81c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x820(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x824(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x828(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x82c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x830(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x834(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x838(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x83c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x840(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x844(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x848(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x84c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x850(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x854(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x858(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x85c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x860(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x864(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x868(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x86c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x870(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x874(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x878(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x87c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x880(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x884(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x888(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x88c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x890(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x894(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x898(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x89c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8a4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8a8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8b4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8b8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8c4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8c8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x8d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8d4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8d8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8e4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8e8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x8f4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x8f8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x8fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x900(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x904(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x908(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x90c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x910(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x914(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x918(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x91c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x920(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x924(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x928(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x92c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x930(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x934(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x938(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x93c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x940(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x944(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x948(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x94c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x950(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x954(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x958(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x95c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x960(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x964(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x968(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x96c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x970(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x974(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x978(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x97c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x980(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x984(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x988(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x98c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x990(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x994(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x998(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x99c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9a0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9a4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9a8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9ac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9b0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9b4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9b8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9bc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0x9c0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9c4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9c8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9cc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9d4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9d8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9dc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9e0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9e4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9e8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9ec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9f0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0x9f4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0x9f8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0x9fc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa04(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa08(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa14(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa18(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa24(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa28(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xa30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa34(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa38(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa44(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa48(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa54(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa58(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa64(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa68(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xa70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa74(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa78(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xa80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa84(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa88(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xa90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa94(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa98(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xa9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaa8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xab0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xab4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xab8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xabc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xac0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xac4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xac8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xacc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xad0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xad4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xad8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xadc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xae0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xae4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xae8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xaf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xaf4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xaf8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xafc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb04(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb08(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb14(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb18(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb24(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb28(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb34(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb38(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb44(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb48(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb54(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb58(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb64(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb68(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb74(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb78(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xb80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb84(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb88(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xb90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb94(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xb98(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xb9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xba0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xba4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xba8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbb4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbb8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xbc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbc4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbc8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xbd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbd4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbd8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbe4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbe8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xbf8(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xbfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc04(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc14(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc24(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc34(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc44(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc54(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc64(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc74(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc84(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xc90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xc94(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xc98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xc9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xca0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xca4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xca8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xcb4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcc4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xccc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xcd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcd4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xce0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xce4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xce8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcf4(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xcf8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xcfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd04(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd14(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd24(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd34(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd44(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd54(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd64(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd74(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xd80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd84(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xd94(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xd98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xd9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xda0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xda4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xda8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xdb4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xdc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdc4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdd4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xddc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xde0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xde4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xde8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdf0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdf4(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xdf8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xdfc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe04(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe14(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe24(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe34(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe44(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe54(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe64(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe74(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xe80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe84(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xe90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe94(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xe98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xe9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xea8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xeb4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xeb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xebc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xec0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xec4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xec8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xecc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xed0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xed4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xed8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xedc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xee0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xee4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xee8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xeec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xef0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xef4(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xef8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xefc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf00(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf04(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf08(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf0c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf10(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf14(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf18(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf1c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf20(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf24(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf28(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf2c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf30(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf34(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf38(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf3c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf40(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf44(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf48(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf4c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf50(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf54(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf58(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf5c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf60(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf64(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf68(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf6c(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf70(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf74(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf78(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf7c(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xf80(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf84(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf88(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf8c(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xf90(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xf94(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf98(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xf9c(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfa0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfa4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfa8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfac(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfb0(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfb4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfb8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfbc(t0)
+	nop
+	
+	li	t1, 0x00000000
+	sw	t1, 0xfc0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfc4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfc8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfcc(t0)
+	nop
+	
+	li	t1, 0x0000ffff
+	sw	t1, 0xfd0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfd4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfd8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfdc(t0)
+	nop
+	
+	li	t1, 0xffff0000
+	sw	t1, 0xfe0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfe4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfe8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xfec(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff0(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff4(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xff8(t0)
+	nop
+	
+	li	t1, 0xffffffff
+	sw	t1, 0xffc(t0)
+	nop
+
+
+//###### ddr init over #########
+
+	li	a0, 0xa0002000
+	li	a1, 0x80002000	     //### Start address of the pattern   200
+	li	a2, 0x80003000	     //### End Address of the pattern     220
+	li	t0, 0xb800001c	//## Tap settings addr
+	lw	a3, 0x0(t0)		//## loading default tap value
+	nop
+	ori	t0, a3, 0x0
+	nop
+	li	t1, 0x1		//# t1=1 indicates increasing tap value, 0 = decreasing
+
+load_tap:
+
+	li	t7, 0x200	//## No. of times read has to happen for 1 tap setting
+	li	t8, 0xb8000000	//#### Loading Tap Setting
+	sw	t0, 0x1c(t8)
+	nop
+	sw	t0, 0x20(t8)
+	nop
+
+pat_read:
+	ori	t2, a0, 0x0	
+	nop
+	ori	t3, a1, 0x0
+	nop
+	ori	t4, a2, 0x0
+	nop
+
+tap_addr_loop:
+	lw	t5, 0x0(t2)
+	nop
+	lw	t6, 0x0(t3)
+	nop
+	nop
+	
+	bne	t5, t6, tap_fail
+	nop
+	nop
+	nop
+
+	addiu	t2, t2, 0x4  //#incrementing addr
+	addiu	t3, t3, 0x4
+	nop
+	nop
+	
+	bne	t3, t4, tap_addr_loop
+	nop	
+	
+	addiu	t7, t7, -1
+	nop
+	bnez	t7, pat_read
+	nop
+	nop
+	
+	bnez	t1, tap_incr
+	nop
+	nop
+	
+	bnez	t0, tap_decr	//# t0=0 implies tap=0 works
+	nop		 //# so low limit=0, else decrement tap value
+	nop
+	li	t8, 0x80500000
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0 //#adding lower limit to upper limit (used to calc mid value)
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+tap_decr:
+	addiu	t0, t0 , -1
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_incr:
+	addiu	t0, t0 , 0x1
+	nop
+	xori	v1, t0, 0x20
+	nop
+	bnez	v1, load_tap
+	nop
+	nop
+	b up_limit
+	nop
+	nop
+
+tap_fail:
+	bnez	t1, up_limit 
+	nop
+	nop
+	nop
+	addiu	t0, t0, 0x1
+	nop
+	li	t8, 0x80500000
+	nop
+	sw	t0, 0x0(t8)
+	add	t9, t9, t0
+	nop
+	nop
+	nop
+	
+	b tap_calc
+	nop
+	nop
+
+up_limit:
+	addiu	t0, t0, -1 
+	li	t1, 0x0	 //## changing to decreasing tap mode	
+	li	t8, 0x80500000 //## storing upper limit
+	sw	t0, 0x4(t8)	
+	ori	t9, t0, 0x0	
+	nop
+	nop
+	nop
+	
+	ori	t0, a3, 0x0 	//# loading default tap value 
+	nop
+	b load_tap
+	nop
+	nop
+
+tap_calc:  //## calculating mid value of the tap, storing DQS0, DQS1 in 0x80500008, 0x8050000c resp.
+	li	t7, 0x2
+	nop
+	div	t9, t7
+	nop
+	mfhi	t6
+	mflo	t5
+	nop
+	nop
+	add	t6, t6, t5
+	li	t8, 0x80500000
+	nop
+	sw	t5, 0x8(t8)
+	nop
+	sw	t6, 0xc(t8)
+	nop
+	nop
+        li      t8, 0xb8000000  //#### Loading Tap Setting
+	nop
+        sw      t5, 0x1c(t8)
+        nop
+        sw      t6, 0x20(t8)
+        nop
+	nop
+	nop
+#endif /* SIMPLE_DDR_TAP_CAL */
+
+end:
+	nop
+	nop
+	nop
+	jr 	ra
+
+	.end	hornet_ddr_tap_init
+/* } */
diff --git a/cpu/mips/ar7240/hornet_serial.c b/cpu/mips/ar7240/hornet_serial.c
new file mode 100644
index 0000000..56d8746
--- /dev/null
+++ b/cpu/mips/ar7240/hornet_serial.c
@@ -0,0 +1,216 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <hornet_soc.h>
+
+#define uart_reg_read(x)        ar7240_reg_rd( (AR7240_UART_BASE+x) )
+#define uart_reg_write(x, y)    ar7240_reg_wr( (AR7240_UART_BASE+x), y)
+
+static int
+AthrUartGet(char *__ch_data)
+{
+    u32    rdata;    
+    
+    rdata = uart_reg_read(UARTDATA_ADDRESS);
+
+    if (UARTDATA_UARTRXCSR_GET(rdata)) {
+        *__ch_data = (char)UARTDATA_UARTTXRXDATA_GET(rdata);
+        rdata = UARTDATA_UARTRXCSR_SET(1);
+        uart_reg_write(UARTDATA_ADDRESS, rdata); 
+        return 1;
+    }
+    else {
+        return 0;        
+    }
+}
+
+static void
+AthrUartPut(char __ch_data)
+{
+    u32 rdata;
+
+    do {
+        rdata = uart_reg_read(UARTDATA_ADDRESS);
+    } while (UARTDATA_UARTTXCSR_GET(rdata) == 0);
+    
+    rdata = UARTDATA_UARTTXRXDATA_SET((u32)__ch_data);
+    rdata |= UARTDATA_UARTTXCSR_SET(1);
+
+    uart_reg_write(UARTDATA_ADDRESS, rdata);
+}
+
+void
+ar7240_sys_frequency(u32 *cpu_freq, u32 *ddr_freq, u32 *ahb_freq)
+{
+#ifdef CONFIG_HORNET_EMU
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    *cpu_freq = 48 * 1000000;
+    *ddr_freq = 48 * 1000000;
+    *ahb_freq = 24 * 1000000;    
+    #else
+    *cpu_freq = 80 * 1000000;
+    *ddr_freq = 80 * 1000000;
+    *ahb_freq = 40 * 1000000;
+    #endif
+#else
+    u32     ref_clock_rate, pll_freq;
+    u32     pllreg, clockreg;
+    u32     nint, refdiv, outdiv;
+    u32     cpu_div, ahb_div, ddr_div;
+
+    if ( ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) & HORNET_BOOTSTRAP_SEL_25M_40M_MASK )
+        ref_clock_rate = 40 * 1000000;
+    else
+        ref_clock_rate = 25 * 1000000;
+
+    pllreg   = ar7240_reg_rd(AR7240_CPU_PLL_CONFIG);
+    clockreg = ar7240_reg_rd(AR7240_CPU_CLOCK_CONTROL);    
+    
+    if (clockreg & HORNET_CLOCK_CONTROL_BYPASS_MASK) {
+        /* Bypass PLL */ 
+        pll_freq = ref_clock_rate;
+        cpu_div = ahb_div = ddr_div = 1;
+    }
+    else {
+        nint = (pllreg & HORNET_PLL_CONFIG_NINT_MASK) >> HORNET_PLL_CONFIG_NINT_SHIFT;
+        refdiv = (pllreg & HORNET_PLL_CONFIG_REFDIV_MASK) >> HORNET_PLL_CONFIG_REFDIV_SHIFT;
+        outdiv = (pllreg & HORNET_PLL_CONFIG_OUTDIV_MASK) >> HORNET_PLL_CONFIG_OUTDIV_SHIFT;
+        
+        pll_freq = (ref_clock_rate / refdiv) * nint;
+        
+        if (outdiv == 1)
+            pll_freq /= 2;
+        else if (outdiv == 2)   
+            pll_freq /= 4;                    
+        else if (outdiv == 3)  
+            pll_freq /= 8;             
+        else if (outdiv == 4) 
+            pll_freq /= 16;                
+        else if (outdiv == 5) 
+            pll_freq /= 32;             
+        else if (outdiv == 6)  
+            pll_freq /= 64;              
+        else if (outdiv == 7)  
+            pll_freq /= 128;              
+        else /* outdiv == 0 --> illegal value */                                                                     
+            pll_freq /= 2;   
+            
+        cpu_div = (clockreg & HORNET_CLOCK_CONTROL_CPU_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_CPU_POST_DIV_SHIFT;
+        ddr_div = (clockreg & HORNET_CLOCK_CONTROL_DDR_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_DDR_POST_DIV_SFIFT;
+        ahb_div = (clockreg & HORNET_CLOCK_CONTROL_AHB_POST_DIV_MASK) >> HORNET_CLOCK_CONTROL_AHB_POST_DIV_SFIFT;
+        
+        /*
+         * b00 : div by 1, b01 : div by 2, b10 : div by 3, b11 : div by 4
+         */
+        cpu_div++;
+        ddr_div++;
+        ahb_div++;                              
+    }
+    
+    *cpu_freq = pll_freq / cpu_div;
+    *ddr_freq = pll_freq / ddr_div;
+    *ahb_freq = pll_freq / ahb_div;
+#endif
+}
+
+int serial_init(void)
+{
+    u32 rdata;
+    u32 baudRateDivisor, clock_step;
+    u32 fcEnable = 0; 
+    u32 ahb_freq, ddr_freq, cpu_freq;
+
+    ar7240_sys_frequency(&cpu_freq, &ddr_freq, &ahb_freq);    
+
+    /* GPIO Configuration */
+    ar7240_reg_wr(AR7240_GPIO_OE, 0xcff);
+    rdata = ar7240_reg_rd(AR7240_GPIO_OUT);
+    rdata |= 0x400; // GPIO 10 (UART_SOUT) must output 1
+    ar7240_reg_wr(AR7240_GPIO_OUT, rdata);
+
+    rdata = ar7240_reg_rd(AR7240_GPIO_FUNC);
+    /* GPIO_FUN, bit1/UART_EN, bit2/UART_RTS_CTS_EN, bit15(disable_s26_uart) */
+    rdata |= (0x3<<1)|(0x1<<15); 
+    ar7240_reg_wr(AR7240_GPIO_FUNC, rdata);
+    
+    /* Get reference clock rate, then set baud rate to 115200 */
+#ifndef CONFIG_HORNET_EMU
+
+    rdata = ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS);
+    rdata &= HORNET_BOOTSTRAP_SEL_25M_40M_MASK;
+
+    if (rdata)
+        baudRateDivisor = ( 40000000 / (16*115200) ) - 1; // 40 MHz clock is taken as UART clock        
+    else
+        baudRateDivisor = ( 25000000 / (16*115200) ) - 1; // 25 MHz clock is taken as UART clock	        
+#else
+    baudRateDivisor = ( ahb_freq / (16*115200) ) - 1; // 40 MHz clock is taken as UART clock 
+#endif
+ 
+    clock_step = 8192;
+    
+	rdata = UARTCLOCK_UARTCLOCKSCALE_SET(baudRateDivisor) | UARTCLOCK_UARTCLOCKSTEP_SET(clock_step);
+	uart_reg_write(UARTCLOCK_ADDRESS, rdata);    
+    
+    /* Config Uart Controller */
+#if 1 /* No interrupt */
+	rdata = UARTCS_UARTDMAEN_SET(0) | UARTCS_UARTHOSTINTEN_SET(0) | UARTCS_UARTHOSTINT_SET(0)
+	        | UARTCS_UARTSERIATXREADY_SET(0) | UARTCS_UARTTXREADYORIDE_SET(~fcEnable) 
+	        | UARTCS_UARTRXREADYORIDE_SET(~fcEnable) | UARTCS_UARTHOSTINTEN_SET(0);
+#else    
+	rdata = UARTCS_UARTDMAEN_SET(0) | UARTCS_UARTHOSTINTEN_SET(0) | UARTCS_UARTHOSTINT_SET(0)
+	        | UARTCS_UARTSERIATXREADY_SET(0) | UARTCS_UARTTXREADYORIDE_SET(~fcEnable) 
+	        | UARTCS_UARTRXREADYORIDE_SET(~fcEnable) | UARTCS_UARTHOSTINTEN_SET(1);
+#endif	        	        
+	        
+    /* is_dte == 1 */
+    rdata = rdata | UARTCS_UARTINTERFACEMODE_SET(2);   
+    
+	if (fcEnable) {
+	   rdata = rdata | UARTCS_UARTFLOWCONTROLMODE_SET(2); 
+	}
+	
+    /* invert_fc ==0 (Inverted Flow Control) */
+    //rdata = rdata | UARTCS_UARTFLOWCONTROLMODE_SET(3);
+    
+    /* parityEnable == 0 */
+    //rdata = rdata | UARTCS_UARTPARITYMODE_SET(2); -->Parity Odd  
+    //rdata = rdata | UARTCS_UARTPARITYMODE_SET(3); -->Parity Even
+    uart_reg_write(UARTCS_ADDRESS, rdata);
+    
+    return 0;
+}
+
+int serial_tstc (void)
+{
+    return (UARTDATA_UARTRXCSR_GET(uart_reg_read(UARTDATA_ADDRESS)));
+}
+
+u8 serial_getc(void)
+{
+    char    ch_data;
+
+    while (!AthrUartGet(&ch_data))  ;
+
+    return (u8)ch_data;
+}
+
+
+void serial_putc(u8 byte)
+{
+    if (byte == '\n')   AthrUartPut('\r');
+
+    AthrUartPut((char)byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/cpu/mips/ar7240/meminit.c b/cpu/mips/ar7240/meminit.c
new file mode 100644
index 0000000..4d9ebec
--- /dev/null
+++ b/cpu/mips/ar7240/meminit.c
@@ -0,0 +1,558 @@
+/* 
+ * Memory controller config:
+ * Assumes that the caches are initialized.
+ *
+ * 0) Figah out the Tap controller settings.
+ * 1) Figure out whether the interface is 16bit or 32bit.
+ * 2) Size the DRAM
+ *
+ *  0) Tap controller settings
+ *  --------------------------
+ * The Table below provides all possible values of TAP controllers. We need to
+ * find the extreme left and extreme right of the spectrum (of max_udelay and
+ * min_udelay). We then program the TAP to be in the middle.
+ * Note for this we would need to be able to read and write memory. So, 
+ * initially we assume that a 16bit interface, which will always work unless
+ * there is exactly _1_ 32 bit part...for now we assume this is not the case.
+ * 
+ * The algo:
+ * 0) Program the controller in 16bit mode.
+ * 1) Start with the extreme left of the table
+ * 2) Write 0xa4, 0xb5, 0xc6, 0xd7 to 0, 2, 4, 6
+ * 3) Read 0 - this will fetch the entire cacheline.
+ * 4) If the value at address 4 is good, record this table entry, goto 6
+ * 5) Increment to get the next table entry. Goto 2.
+ * 6) Start with extreme right. Do the same as above.
+ *
+ * 1) 16bit or 32bit
+ * -----------------
+ *  31st bit of reg 0x1800_0000 will  determine the mode. By default, 
+ *  controller is set to 32-bit mode. In 32 bit mode, full data bus DQ [31:0] 
+ *  will be used to write 32 bit data. Suppose you have 16bit DDR memory
+ *  (it will have 16bit wide data bus). If you try to write 16 bit DDR in 32 
+ *  bit mode, you are going to miss upper 16 bits of data. Reading to that 
+ *  location will give you only lower 16 bits correctly, upper 16 bits will 
+ *  have some junk value. E.g.,
+ *
+ *  write to 0x0000_0000 0x12345678
+ *  write to 0x0000_1000 0x00000000 (just to discharge DQ[31:16] )
+ *  read from 0x0000_0000
+ *  if u see something like 0x0000_5678 (or XXXX_5678 but not equal to 
+ *  0x12345678) - its a 16 bit interface
+ *
+ *  2) Size the DRAM
+ *  -------------------
+ *  DDR wraps around. Write a pattern to 0x0000_0000. Write an address 
+ *  pattern at 4M, 8M, 16M etc. and check when 0x0000_0000 gets overwritten.
+ *
+ *
+ *  We can use #define's for all these addresses and patterns but its easier
+ *  to see what's going on without :)
+ */
+#include <common.h>
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+uint8_t     tap_settings[] = 
+            {0x40, 0x41, 0x10, 0x12, 0x13, 0x15, 0x1a, 0x1c, 0x1f, 0x2f, 0x3f};
+
+uint16_t    tap_pattern[] = {0xa5, 0xb6, 0xc7, 0xd8};
+
+void
+ar7240_ddr_tap_set(uint8_t set)
+{
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL0, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL1, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL2, set);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL3, set);
+}
+
+/*
+ * We check for size in 4M increments
+ */
+#define AR7240_DDR_SIZE_INCR    (4*1024*1024)
+int
+ar7240_ddr_find_size(void)
+{
+    uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+    int i;
+
+    *p = pat;
+
+    for(i = 1; ; i++) {
+        *(p + i * AR7240_DDR_SIZE_INCR) = (uint8_t)(i);
+        if (*p != pat) {
+            break;
+        }
+    }
+
+    return (i*AR7240_DDR_SIZE_INCR);
+}
+
+#ifndef CONFIG_WASP
+void
+ar7240_ddr_initial_config(uint32_t refresh)
+{
+	int ddr2 = 0,ddr_config;
+	int ddr_config2,ext_mod,ddr2_ext_mod;
+	int mod_val,mod_val_init;
+
+	prmsg("\nsri\n");
+#if 0
+	ar7240_reg_wr(AR7240_RESET, AR7240_RESET_DDR);
+	udelay(10);
+#endif
+	ddr2 = ((ar7240_reg_rd(0xb8050020) & 0x1) == 0);
+#ifdef ENABLE_DYNAMIC_CONF
+	if(*(volatile int *)CFG_DDR_MAGIC_F == CFG_DDR_MAGIC){
+		ddr_config = CFG_DDR_CONFIG_VAL_F;
+		ddr_config2 = CFG_DDR_CONFIG2_VAL_F;
+		ext_mod = CFG_DDR_EXT_MODE_VAL_F;
+		ddr2_ext_mod = ext_mod;
+	}
+	else
+#endif
+	{
+#ifdef CONFIG_SUPPORT_AR7241
+		if (is_ar7241() || is_ar7242()) {
+			if (ddr2) {
+				prmsg("%s(%d): virian ddr2 init\n", __func__, __LINE__);
+				ddr_config	= CFG_7241_DDR2_CONFIG_VAL;
+				ddr_config2	= CFG_7241_DDR2_CONFIG2_VAL;
+				ext_mod		= CFG_7241_DDR2_EXT_MODE_VAL;
+				ddr2_ext_mod	= CFG_DDR2_EXT_MODE_VAL;
+				mod_val_init	= CFG_7241_DDR2_MODE_VAL_INIT;
+				mod_val		= CFG_7241_DDR2_MODE_VAL;
+			} else {
+				prmsg("%s(%d): virian ddr1 init\n", __func__, __LINE__);
+				ddr_config	= CFG_7241_DDR1_CONFIG_VAL;
+				ddr_config2	= CFG_7241_DDR1_CONFIG2_VAL;
+				ext_mod		= CFG_7241_DDR1_EXT_MODE_VAL;
+				ddr2_ext_mod	= CFG_DDR2_EXT_MODE_VAL;
+				mod_val_init	= CFG_7241_DDR1_MODE_VAL_INIT;
+				mod_val		= CFG_7241_DDR1_MODE_VAL;
+			}
+		}
+		else
+#endif
+		{
+			prmsg("%s(%d): python ddr init\n", __func__, __LINE__);
+			ddr_config = CFG_DDR_CONFIG_VAL;
+			ddr_config2 = CFG_DDR_CONFIG2_VAL;
+			ext_mod = CFG_DDR_EXT_MODE_VAL;
+#ifndef CONFIG_WASP_EMU
+			ddr2_ext_mod = CFG_DDR2_EXT_MODE_VAL;
+#endif
+			mod_val_init = CFG_DDR_MODE_VAL_INIT;
+			mod_val = CFG_DDR_MODE_VAL;
+		}
+	}
+
+	if (ddr2) {
+		ar7240_reg_wr_nf(0xb800008c, 0xA59);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x10);
+		udelay(10);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x20);
+		udelay(10);
+	}
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG, ddr_config);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2 | 0x80);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+	udelay(10);
+
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val_init);
+	udelay(1000);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+	udelay(10);
+
+	if (ddr2) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, ddr2_ext_mod);
+	} else {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, ext_mod);
+	}
+
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_REFRESH, refresh);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE,
+				CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+	udelay(100);
+}
+#else
+int /* ram type */
+wasp_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR)
+	int		ddr_config, ddr_config2, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+
+	prmsg("\nsri\n");
+	prmsg("Wasp 1.%d\n", ar7240_reg_rd(AR7240_REV_ID) & 0xf);
+
+	switch(WASP_RAM_TYPE(ar7240_reg_rd(WASP_BOOTSTRAP_REG))) {
+	case 0:
+	case 1:	// SDRAM
+		/*
+		XXX XXX XXX XXX XXX XXX XXX XXX XXX
+		Boot strap select is not working. In some boards,
+		ddr2 shows up as sdram. Hence ignoring the foll.
+		break statement.
+		XXX XXX XXX XXX XXX XXX XXX XXX XXX
+		break;
+		*/
+		prmsg("%s(%d): Wasp sdram\n", __func__, __LINE__);
+		ddr_config	= CFG_934X_SDRAM_CONFIG_VAL;
+		ddr_config2	= CFG_934X_SDRAM_CONFIG2_VAL;
+		mod_val_init	= CFG_934X_SDRAM_MODE_VAL_INIT;
+		mod_val		= CFG_934X_SDRAM_MODE_VAL;
+		cycle_val	= CFG_SDRAM_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_SDRAM_TAP_VAL;
+
+		ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, 0x13b);
+		udelay(100);
+
+		ar7240_reg_wr_nf(AR7240_DDR_DEBUG_RD_CNTL, 0x3000001f);
+		udelay(100);
+
+		type = 0;
+
+		break;
+	case 2: // ddr2
+		ddr_config	= CFG_934X_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_934X_DDR2_CONFIG2_VAL;
+		ext_mod		= CFG_934X_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_934X_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_934X_DDR2_MODE_VAL;
+		cycle_val	= CFG_DDR2_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_DDR2_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+							/* NAND Clear */
+			if (ar7240_reg_rd(WASP_BOOTSTRAP_REG) & (1 << 3)) {
+				prmsg("32");
+				cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32;
+				ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, (1 << 6));
+			} else {
+				prmsg("16");
+				cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+				ar7240_reg_rmw_set(AR7240_DDR_CTL_CONFIG, (1 << 6));
+				ar7240_reg_rmw_clear(AR7240_DDR_CTL_CONFIG, (0xf << 2));
+			}
+		} else {
+#if DDR2_32BIT_SUPPORT
+			prmsg("32");
+			ar7240_reg_wr_nf(AR7240_DDR_CTL_CONFIG, 0);
+#else
+			prmsg("16");
+#endif
+		}
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		type = 1;
+
+		break;
+	case 3: // ddr1
+		prmsg("%s(%d): Wasp (16bit) ddr1 init\n", __func__, __LINE__);
+		ddr_config	= CFG_934X_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_934X_DDR1_CONFIG2_VAL;
+		ext_mod		= CFG_934X_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_934X_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_934X_DDR1_MODE_VAL;
+		cycle_val	= CFG_DDR1_RD_DATA_THIS_CYCLE_VAL;
+		tap_val		= CFG_934X_DDR1_TAP_VAL;
+		type = 2;
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 1;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET(2 * cas);
+
+			if (type == 1) {
+				uint32_t tmp;
+				tmp = ar7240_reg_rd(AR7240_DDR_DDR2_CONFIG);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#else
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == 1) {
+				uint32_t tmp;
+				tmp = ar7240_reg_rd(AR7240_DDR_DDR2_CONFIG);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, cycle_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_BURST, 0x74444444);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_BURST2, 0x222);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_AHB_MASTER_TIMEOUT, 0xfffff);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG, ddr_config);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2);
+	udelay(100);
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, CFG_934X_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+	ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, ddr_config2 | 0x80); // CKE enable
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x10); // EMR2
+		udelay(10);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x20); // EMR3
+		udelay(10);
+	}
+	if (type != 0) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x2);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR DLL enable
+		udelay(10);
+	}
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val_init);
+	udelay(1000);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1); // MR Write
+	udelay(10);
+
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8); // Precharge
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4); // Auto Refresh
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4); // Auto Refresh
+	udelay(10);
+	ar7240_reg_wr_nf(AR7240_DDR_MODE, mod_val);
+	udelay(100);
+	ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1); // MR Write
+	udelay(10);
+	if (type == 1) {
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, CFG_934X_DDR2_EXT_MODE_VAL_INIT);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR write
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, CFG_934X_DDR2_EXT_MODE_VAL);
+		udelay(100);
+		ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ar7240_reg_wr_nf(AR7240_DDR_REFRESH, refresh);
+	udelay(100);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, tap_val);
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, tap_val);
+
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+						/* NAND Clear */
+		if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & (1 << 3)) && type) {
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, tap_val);
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, tap_val);
+		}
+	} else {
+#if DDR2_32BIT_SUPPORT
+		if (type != 0) {
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, tap_val);
+			ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, tap_val);
+		}
+#endif
+	}
+		prmsg("%s(%d): Wasp ddr init done\n", __func__, __LINE__);
+
+#if (CFG_PLL_FREQ == CFG_PLL_600_500_250) || \
+    (CFG_PLL_FREQ == CFG_PLL_500_500_250)
+	// PMU2 ddr ldo tune
+	ar7240_reg_rmw_set(0xb8116c44, (0x3 << 19));
+	udelay(100);
+#endif
+	return type;
+#else
+	return 0;
+#endif
+}
+#endif
+
+#ifdef CONFIG_HORNET_EMU
+void
+ar7240_ddr_initial_config_for_fpga(void)
+{
+ #ifdef CONFIG_HORNET_EMU_HARDI
+    /* HARDI FPGA board */
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);      
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4100);
+    udelay(10);  
+        
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG, 0x7fd68cd0);    /* Cas Latency 7 */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, 0x959ec6a8);   /* Gate Open 5 */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_DDR2_CONFIG, 0x858);    /* Disable DDR2, set Write Latency */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);       
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);       
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x133);           /* Mode Word Settings  */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x0);         /* Extended Mode Word Settings */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, 0xff);  /* DDR read data capture bit mask */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);          /* precharge all */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x4);          /* Auto-Refresh */
+    udelay(10);        
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x133);           /* Mode Word Settings  */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */    
+    udelay(10); 
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x382);       /* Extended Mode Word Settings */     
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x402);       /* Extended Mode Word Settings */     
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);          /* EMR update */
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x33);            /* Mode Word Settings  */
+    udelay(10);    
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);          /* MR update */    
+    udelay(10);
+    #ifdef CONFIG_HORNET_EMU_HARDI_WLAN
+    /* 
+     * Emulation board reference clock is 48 MHz(20.833ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/20.833 = 375 = 0x177 clock cycles     
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4177);
+    #else
+    /* 
+     * Emulation board reference clock is 80 MHz(12.5ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/12.5 = 625 = 0x271 clock cycles
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4271);
+    #endif
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL0, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL1, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL2, 0x0);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_TAP_CONTROL3, 0x0);
+    udelay(10);
+ #else
+    /* EBU FPGA board */
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG, 0xc7bc8cd0); /* Cas Latency 8 */
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONFIG2, 0x95d0e6a8); /* Gate Open 5 */
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x123);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_EXT_MODE, 0x1);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x2);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x8);
+    udelay(10);
+    ar7240_reg_wr_nf(AR7240_DDR_MODE, 0x23);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_CONTROL, 0x1);
+    udelay(10);
+    /* 
+     * Emulation board reference clock is 80 MHz(12.5ns)
+     * DDR request 64ms has 8192 refresh
+     * So each refresh interval is 64ms/8192 = 7812.5 ns
+     * i.e ddr have to refresh in 7812.5/12.5 = 625 = 0x271 clock cycles     
+     */
+    ar7240_reg_wr_nf(AR7240_DDR_REFRESH, 0x4271);
+    udelay(100);
+    ar7240_reg_wr_nf(AR7240_DDR_RD_DATA_THIS_CYCLE, 0x00ff);
+    udelay(100);
+ #endif
+}
+#endif
diff --git a/cpu/mips/start_bootstrap.S b/cpu/mips/start_bootstrap.S
new file mode 100644
index 0000000..b4bbbb4
--- /dev/null
+++ b/cpu/mips/start_bootstrap.S
@@ -0,0 +1,799 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+#define AR7100_SPI_CLOCK  0xbf000004
+
+#define ATH_APB_BASE				0xB8000000  /* KSEG1ADDR(0x18000000) */
+#define ATH_GPIO_BASE				(ATH_APB_BASE+0x00040000)
+#define ATH_GPIO_OE					(ATH_GPIO_BASE+0x0)
+#define ATH_GPIO_OUT				(ATH_GPIO_BASE+0x8)
+#define ATH_GPIO_OUT_FUNCTION0		(ATH_GPIO_BASE+0x2c)
+#define ATH_GPIO_OUT_FUNCTION1		(ATH_GPIO_BASE+0x30)
+#define ATH_GPIO_OUT_FUNCTION2		(ATH_GPIO_BASE+0x34)
+#define ATH_GPIO_OUT_FUNCTION3		(ATH_GPIO_BASE+0x38)
+#define ATH_GPIO_OUT_FUNCTION4		(ATH_GPIO_BASE+0x3c)
+#define ATH_GPIO_OUT_FUNCTION5		(ATH_GPIO_BASE+0x40)
+#define ATH_GPIO_FUNCTION			(ATH_GPIO_BASE+0X6C)
+
+#define RVECENT(f,n) \
+   b f; nop
+
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+
+	.globl _start_bootstrap
+	.text
+_start_bootstrap:
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+	RVECENT(romReserved,2)
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+	.align 4
+reset:
+#if 1/* below will turn on all leds for a while */
+	li	a1, ATH_GPIO_FUNCTION
+	lw	v1, 0(a1)
+	li	v0, (1 << 1)	/* we use GPIO3,so disable JTAG */
+	or	v1, v1, v0
+	sw	v1, 0(a1)
+	
+	li	a1, ATH_GPIO_FUNCTION
+	lw	v1, 0(a1)
+	li	v0, (~(1 << 6))	/* we use GPIO4,so disable AHB_CLK/2 */
+	and v1, v1, v0
+	sw	v1, 0(a1)	
+
+	/* GPIO init */
+	li	a1, ATH_GPIO_OE
+	lw	v1, 0(a1)
+	/* GPIO 3,4,11,13~16, but GPIO3 is not used yet */
+	li  v0, (~((1 << 3) | (1 << 4) | (1 << 11) | (1 << 13) | (1 << 14) | (1 << 15) | (1 << 16)))
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OE */
+
+	/* set gpio funtion for gpio3 */
+	li	a1, ATH_GPIO_OUT_FUNCTION0
+	lw	v1, 0(a1)
+	li	v0, 0x00ffffff
+	and v1, v1, v0
+	sw	v1, 0(a1)	/* set v1 value to ATH_GPIO_OUT_FUNCTION0 */
+
+	/* set gpio funtion for gpio4 */
+	li	a1, ATH_GPIO_OUT_FUNCTION1
+	lw	v1, 0(a1)
+	li	v0, 0xffffff00
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION1 */
+
+
+	/* set gpio funtion for gpio11 */
+	li	a1, ATH_GPIO_OUT_FUNCTION2
+	lw	v1, 0(a1)
+	li	v0, 0x00ffffff
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION2 */
+
+	/* set gpio funtion for gpio13~15 */
+	li	a1, ATH_GPIO_OUT_FUNCTION3
+	lw	v1, 0(a1)
+	li	v0, 0x000000ff
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION3 */
+
+	/* set gpio funtion for gpio16 */
+	li	a1, ATH_GPIO_OUT_FUNCTION4
+	lw	v1, 0(a1)
+	li	v0, 0xffffff00
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT_FUNCTION4 */
+
+	/* turn on leds */
+	li	a1, ATH_GPIO_OUT
+	lw	v1, 0(a1)
+	/*GPIO 3,4,11,13~16 */
+	li  v0, (~((1 << 3) | (1 << 4) | (1 << 11) | (1 << 13) | (1 << 14) | (1 << 15) | (1 << 16)))
+	and v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT */
+
+	/* wait for a while, for leds' bootup blink*/
+	li a1, 0
+	li v1, 0x40000
+1:
+	addi a1, a1, 1
+	bne a1, v1, 1b
+	nop
+
+	/* turn off leds */
+	li	a1, ATH_GPIO_OUT
+	lw	v1, 0(a1)
+	/*GPIO 3,4,11,13~16 */
+	li  v0, ((1 << 3) | (1 << 4) | (1 << 11) | (1 << 13) | (1 << 14) | (1 << 15) | (1 << 16))
+	or	v1, v1, v0
+	sw	v1, 0(a1)		/* set v1 value to ATH_GPIO_OUT */
+#endif
+
+	/*
+	 * Clearing CP0 registers - This is generally required for the MIPS-24k
+     * core used by Atheros.
+	 */
+	mtc0	zero, $0
+	mtc0	zero, $1
+	mtc0	zero, $2
+	mtc0	zero, $3
+	mtc0	zero, $4
+	mtc0	zero, $5
+	mtc0	zero, $6
+	mtc0	zero, $7
+	mtc0	zero, $8
+	mtc0	zero, $9
+	mtc0	zero, $10
+	mtc0	zero, $11
+	li	t0, 0x10000004
+	mtc0	t0, $12
+	mtc0	zero, $13
+	mtc0	zero, $14
+	mtc0	zero, $15
+	mtc0	zero, $16
+	mtc0	zero, $17
+	mtc0	zero, $18
+	mtc0	zero, $19
+	mtc0	zero, $20
+	mtc0	zero, $21
+	mtc0	zero, $22
+#ifndef CONFIG_HORNET_EMU
+	mtc0	zero, $23
+#endif
+	mtc0	zero, $24
+	mtc0	zero, $25
+	mtc0	zero, $26
+	mtc0	zero, $27
+	mtc0	zero, $28
+#if defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	mtc0	zero, $29	# C0_TagHi
+	mtc0	zero, $28, 2	# C0_DTagLo
+	mtc0	zero, $29, 2	# C0_DTagHi
+#endif
+
+	/*
+	 * Clear watch registers.
+	 */
+
+	mtc0	zero, CP0_WATCHLO
+	mtc0	zero, CP0_WATCHHI
+
+	/* STATUS register */
+	mfc0	k0, CP0_STATUS
+	li	k1, ~ST0_IE
+	and	k0, k1
+        mtc0	zero, CP0_CAUSE
+	mtc0	k0, CP0_STATUS
+
+	/* CAUSE register */
+	mtc0	zero, CP0_CAUSE
+
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+	/* CONFIG0 register */
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+
+
+    /* Initialize GOT pointer.*/
+	bal     1f
+	nop
+	.word   _GLOBAL_OFFSET_TABLE_
+	1:
+	move    gp, ra
+	lw      t1, 0(ra)
+	move	gp, t1
+
+#if defined(CONFIG_MACH_HORNET) && defined(CONFIG_HORNET_1_1_WAR)
+/**************************************************************************/
+/*
+ * WAR: Hornet 1.1 currently need a reset once we boot to let the resetb has
+ *      enough time to stable, so that trigger reset at 1st boot, system team
+ *      is investigaing the issue, will remove in short
+ */
+
+do_reset_normal:
+
+    li  t7, 0xbd000000
+    lw  t8, 0(t7)            // t8 : value of 0xbd000000
+    li  t9, 0x12345678
+    bne t8, t9, do_reset     // if value of 0xbd000000 != 0x12345678 , go to do_reset
+    nop
+    li  t9, 0xffffffff
+    sw  t9, 0(t7) 
+    b   normal_path
+    nop
+
+do_reset:
+    sw  t9, 0(t7)
+    li  t7, 0xb806001c       // load reset register 0x1806001c
+    lw  t8, 0(t7)
+    li  t9, 0x1000000        // bit24, fullchip reset
+    or  t8, t8, t9
+    sw  t8, 0(t7)
+do_reset_loop:    
+    b   do_reset_loop
+    nop
+
+normal_path:
+#endif /* CONFIG_MACH_HORNET */
+
+/**************************************************************************/
+
+	/* Initialize any external memory.
+	 */
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	la      t9, lowlevel_init
+	jalr    t9
+	nop
+	nop
+
+#if defined(CONFIG_MACH_HORNET)
+	la      t9, hornet_ddr_init
+	jalr    t9
+	nop
+	nop
+
+#if 0
+	la      t9, hornet_ddr_tap_init
+	jalr    t9
+	nop
+#endif
+
+#endif
+
+	la	t0, rel_start
+	j	t0
+	nop
+#endif
+
+rel_start:
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x)
+	/* REMAP_DISABLE */
+	li	a0, AR7100_SPI_CLOCK
+	li	t0, 0x43
+	sw	t0, 0(a0)
+#endif
+
+#if defined(CONFIG_AR9100) && defined(CFG_HOWL_1_2)
+    /* Disable remap for parallel flash */
+    li  t7, AR9100_FLASH_CONFIG;
+    lw  t8, 0(t7);
+    li  t9, 0xffbf0000;
+    and t8, t8, t9;
+    li  t9, 0x22fc;
+    or  t8, t8, t9;
+    li  t9, 0xffcfffff; /* scale = 0 */
+    and t8, t8, t9;
+    sw  t8, 0(t7);
+
+#endif
+
+	/* Initialize caches...
+	 */
+	la      t9, simple_mips_cache_reset
+	jalr    t9
+	nop
+
+	/* ... and enable them.
+	 */
+	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+
+#if !defined(CFG_INIT_STACK_IN_SRAM)
+#if !defined(CONFIG_AR7100) && !defined(CONFIG_AR7240)
+	/* Set up temporary stack.
+	 */
+	li	a0, CFG_INIT_SP_OFFSET
+	la      t9, mips_cache_lock
+	jalr    t9
+	nop
+#endif
+
+#if defined(CONFIG_AR7100) || defined(CONFIG_AR7240)
+	la	t9, mips_cache_lock_24k
+	jalr	t9
+	nop
+#endif
+#endif /* CFG_INIT_STACK_IN_SRAM */
+
+	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+#ifdef CFG_INIT_STACK_IN_SRAM
+	li	t0, CFG_INIT_SRAM_SP_OFFSET	/* Setup stack in SRAM */
+#endif
+	la	sp, 0(t0)
+
+	la	t9, bootstrap_board_init_f
+	j	t9
+	nop
+
+
+/*
+ * void bootstrap_relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	bootstrap_relocate_code
+	.ent	bootstrap_relocate_code
+bootstrap_relocate_code:
+	move	sp, a0		/* Set new stack pointer		*/
+
+	li	t0, BOOTSTRAP_CFG_MONITOR_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data_bootsrap	*/
+
+	/*
+	 * Ideally, following line is not needed. However,
+	 * the behaviour is flaky without it. U-boot boots on
+	 * some boards, and doesn't on some boards. Even on the
+	 * boards it boots, it doesn't boot all the time.
+	 *
+	 * Adding 256k to what needs to be read in actually.
+	 * This introduces some delay that seems to help boot.
+	 */
+	/* if flush cache before jump to ddr, it will be ok.
+		so no need to add 256k, by huangwenzhong, 2013-10-10.
+	*/
+	/*
+	li	t3, (256 << 10)
+
+	add	t2, t3
+	*/
+	move	t1, a2
+
+	/*
+	 * Fix GOT pointer:
+	 *
+	 * New GOT-PTR = (old GOT-PTR - BOOTSTRAP_CFG_MONITOR_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, BOOTSTRAP_CFG_MONITOR_BASE
+	add	gp, a2			/* gp now adjusted		*/
+	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
+
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+1:
+	lw	t3, 0(t0)
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4			/* delay slot			*/
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+	bal mips_cache_flush/*  by huangwenzhong, 10Oct13 */
+	nop
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start_bootstrap
+	j	t0
+	nop
+
+	.word	uboot_end_data_bootstrap
+	.word	uboot_end_bootstrap
+	.word	num_got_entries
+
+in_ram:
+	/* Now we want to update GOT.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	addi	t4, gp, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data_bootstrap	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end_bootstrap		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, bootstrap_board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	bootstrap_relocate_code
+
+
+
+.globl	ath_ddr_tap_cal
+.type   ath_ddr_tap_cal, @function
+
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+	nop					// This nop fixes "Warning: macro instruction expanded into multiple instructions in a branch delay slot"
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+#ifdef CONFIG_MACH_QCA953x
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+#else // Wasp & Scorpion ...
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+#endif
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+	nop					// This nop fixes "Warning: macro instruction expanded into multiple instructions in a branch delay slot"
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+	nop					// This nop fixes "Warning: macro instruction expanded into multiple instructions in a branch delay slot"
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+	nop					// This nop fixes "Warning: macro instruction expanded into multiple instructions in a branch delay slot"
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+	jr	ra
+	nop
+
+
+
+	/* Exception handlers.
+	 */
+romReserved:
+	b romReserved
+
+romExcHandle:
+	b romExcHandle
-- 
2.17.1


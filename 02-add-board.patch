From bfc1a27dcc9228e4252249b994a0087d9ed393ab Mon Sep 17 00:00:00 2001
From: Mike Banon <mikebdp2@gmail.com>
Date: Tue, 10 Dec 2019 16:46:44 +0000
Subject: [PATCH] Add ./board/* Atheros files from WR841N(D)v9 u-boot

---
 board/ar7100/ap81/Makefile                    |   23 +
 board/ar7100/ap81/ap81.c                      |  150 ++
 board/ar7100/ap81/config.mk                   |    5 +
 board/ar7100/ap81/flash.c                     |   29 +
 board/ar7100/ap81/u-boot.lds                  |   42 +
 board/ar7100/ap83/Makefile                    |   23 +
 board/ar7100/ap83/ap83.c                      |  153 ++
 board/ar7100/ap83/config.mk                   |    6 +
 board/ar7100/ap83/flash.c                     |   29 +
 board/ar7100/ap83/u-boot.lds                  |   42 +
 board/ar7100/ap94/Makefile                    |   18 +
 board/ar7100/ap94/ap94.c                      |  106 ++
 board/ar7100/ap94/ap94_pci.c                  |  430 +++++
 board/ar7100/ap94/athrs26_phy.c               |  745 ++++++++
 board/ar7100/ap94/athrs26_phy.h               |  115 ++
 board/ar7100/ap94/config.mk                   |    5 +
 board/ar7100/ap94/lowlevel_init.S             |  218 +++
 board/ar7100/ap94/u-boot.lds                  |   42 +
 board/ar7100/ap96/Makefile                    |   19 +
 board/ar7100/ap96/ap96.c                      |  201 +++
 board/ar7100/ap96/config.mk                   |    5 +
 board/ar7100/ap96/u-boot.lds                  |   40 +
 board/ar7100/common/ar7100_flash.c            |  181 ++
 board/ar7100/common/ar7100_flash.h            |   62 +
 board/ar7100/common/ar9100_pflash.c           |  325 ++++
 board/ar7100/common/athr_phy.h                |   80 +
 board/ar7100/common/athrf1_phy.c              |  196 ++
 board/ar7100/common/athrs16_phy.c             |  680 +++++++
 board/ar7100/common/athrs16_phy.h             |  103 ++
 board/ar7100/common/athrs26_phy.c             |  827 +++++++++
 board/ar7100/common/athrs26_phy.h             |  133 ++
 .../g5_Plus1_2_29a_unmanaged_Atheros_v5.c     |  511 ++++++
 .../g5_Plus1_2_29b_unmanaged_Atheros_v5.c     |  511 ++++++
 .../g5_Plus1_2_31_unmanaged_Atheros_v3.c      |  521 ++++++
 .../g5_Plus1_2_31_unmanaged_Atheros_v4.c      |  509 ++++++
 .../g5e_Plus1_2_29a_unmanaged_Atheros_v3.c    |  513 ++++++
 board/ar7100/common/generic_i2c.c             |  460 +++++
 board/ar7100/common/generic_i2c.h             |   84 +
 board/ar7100/common/generic_spi.c             |  355 ++++
 board/ar7100/common/generic_spi.h             |   48 +
 board/ar7100/common/ipPhy.c                   |  843 +++++++++
 board/ar7100/common/ipPhy.h                   |  172 ++
 board/ar7100/common/lowlevel_init.S           |  247 +++
 board/ar7100/common/lowlevel_init_ar9100.S    |  150 ++
 board/ar7100/common/phy.h                     |   28 +
 board/ar7100/common/vsc73xx.c                 | 1208 +++++++++++++
 board/ar7100/common/vsc73xx.h                 |  168 ++
 board/ar7100/common/vsc8601_phy.c             | 1226 +++++++++++++
 board/ar7100/common/vsc8601_phy.h             |   19 +
 board/ar7100/common/vsc_phy.c                 |   15 +
 board/ar7100/pb42/Makefile                    |   18 +
 board/ar7100/pb42/config.mk                   |    5 +
 board/ar7100/pb42/flash.c                     |   28 +
 board/ar7100/pb42/pb42.c                      |   72 +
 board/ar7100/pb42/u-boot.lds                  |   42 +
 board/ar7100/pb44/Makefile                    |   13 +
 board/ar7100/pb44/config.mk                   |   10 +
 board/ar7100/pb44/lowlevel_init.S             |  428 +++++
 board/ar7100/pb44/pb44.c                      |  233 +++
 board/ar7100/pb44/pb44_pci.c                  |  372 ++++
 board/ar7100/pb44/u-boot-bootstrap.lds        |   61 +
 board/ar7100/pb44/u-boot.lds                  |   40 +
 board/ar7100/pb47/Makefile                    |   13 +
 board/ar7100/pb47/config.mk                   |    5 +
 board/ar7100/pb47/lowlevel_init.S             |  428 +++++
 board/ar7100/pb47/pb47.c                      |  220 +++
 board/ar7100/pb47/pb47_pci.c                  |  366 ++++
 board/ar7100/pb47/u-boot.lds                  |   40 +
 board/ar7100/tb225/Makefile                   |   18 +
 board/ar7100/tb225/config.mk                  |    5 +
 board/ar7100/tb225/flash.c                    |   26 +
 board/ar7100/tb225/tb225.c                    |   55 +
 board/ar7100/tb225/u-boot.lds                 |   42 +
 board/ar7100/tb243/Makefile                   |   18 +
 board/ar7100/tb243/config.mk                  |    6 +
 board/ar7100/tb243/tb243.c                    |   83 +
 board/ar7100/tb243/u-boot.lds                 |   42 +
 board/ar7240/ap101-2.6.31/Makefile            |   18 +
 board/ar7240/ap101-2.6.31/ap101-2.6.31.c      |   71 +
 board/ar7240/ap101-2.6.31/config.mk           |    5 +
 board/ar7240/ap101-2.6.31/flash.c             |   35 +
 board/ar7240/ap101-2.6.31/u-boot.lds          |   42 +
 board/ar7240/ap101-small/Makefile             |   18 +
 board/ar7240/ap101-small/ap101-small.c        |   71 +
 board/ar7240/ap101-small/config.mk            |    5 +
 board/ar7240/ap101-small/flash.c              |   35 +
 board/ar7240/ap101-small/u-boot.lds           |   42 +
 board/ar7240/ap101/Makefile                   |   18 +
 board/ar7240/ap101/ap101.c                    |   71 +
 board/ar7240/ap101/config.mk                  |    5 +
 board/ar7240/ap101/flash.c                    |   35 +
 board/ar7240/ap101/u-boot.lds                 |   42 +
 board/ar7240/ap111-2.6.31/Makefile            |   18 +
 board/ar7240/ap111-2.6.31/ap111-2.6.31.c      |   71 +
 board/ar7240/ap111-2.6.31/config.mk           |    5 +
 board/ar7240/ap111-2.6.31/flash.c             |   35 +
 board/ar7240/ap111-2.6.31/u-boot.lds          |   42 +
 board/ar7240/ap111/Makefile                   |   18 +
 board/ar7240/ap111/ap111.c                    |   71 +
 board/ar7240/ap111/config.mk                  |    5 +
 board/ar7240/ap111/flash.c                    |   35 +
 board/ar7240/ap111/u-boot.lds                 |   42 +
 board/ar7240/ap120/Makefile                   |   68 +
 board/ar7240/ap120/ap120.c                    |  177 ++
 board/ar7240/ap120/config.mk                  |   19 +
 board/ar7240/ap120/flash.c                    |   30 +
 board/ar7240/ap120/u-boot-bootstrap.lds       |   61 +
 board/ar7240/ap120/u-boot.lds                 |   42 +
 board/ar7240/ap121/Makefile                   |   22 +
 board/ar7240/ap121/ap121.c                    |  142 ++
 board/ar7240/ap121/config.mk                  |   10 +
 board/ar7240/ap121/flash.c                    |   28 +
 board/ar7240/ap121/hornet_pll_init.S          |  377 ++++
 board/ar7240/ap121/u-boot-bootstrap.lds       |   62 +
 board/ar7240/ap121/u-boot.lds                 |   42 +
 board/ar7240/ap123/Makefile                   |   68 +
 board/ar7240/ap123/ap123.c                    |  171 ++
 board/ar7240/ap123/config.mk                  |   19 +
 board/ar7240/ap123/flash.c                    |   30 +
 board/ar7240/ap123/u-boot-bootstrap.lds       |   61 +
 board/ar7240/ap123/u-boot.lds                 |   42 +
 board/ar7240/ap91-2MB/Makefile                |   18 +
 board/ar7240/ap91-2MB/ap91-2MB.c              |   75 +
 board/ar7240/ap91-2MB/ar9285gpio.c            |  140 ++
 board/ar7240/ap91-2MB/config.mk               |   10 +
 board/ar7240/ap91-2MB/flash.c                 |   28 +
 board/ar7240/ap91-2MB/u-boot-bootstrap.lds    |   62 +
 board/ar7240/ap91-2MB/u-boot.lds              |   42 +
 board/ar7240/ap91-2x8/Makefile                |   18 +
 board/ar7240/ap91-2x8/ap91-2x8.c              |   75 +
 board/ar7240/ap91-2x8/config.mk               |   10 +
 board/ar7240/ap91-2x8/flash.c                 |   28 +
 board/ar7240/ap91-2x8/u-boot-bootstrap.lds    |   62 +
 board/ar7240/ap91-2x8/u-boot.lds              |   42 +
 board/ar7240/ap91-router/Makefile             |   18 +
 board/ar7240/ap91-router/ap91-router.c        |   58 +
 board/ar7240/ap91-router/config.mk            |   13 +
 board/ar7240/ap91-router/flash.c              |   28 +
 board/ar7240/ap91-router/u-boot-bootstrap.lds |   62 +
 board/ar7240/ap91-router/u-boot.lds           |   42 +
 board/ar7240/ap91/Makefile                    |   18 +
 board/ar7240/ap91/ap91.c                      |   70 +
 board/ar7240/ap91/ar9285gpio.c                |  152 ++
 board/ar7240/ap91/config.mk                   |    5 +
 board/ar7240/ap91/flash.c                     |   28 +
 board/ar7240/ap91/u-boot-bootstrap.lds        |   62 +
 board/ar7240/ap91/u-boot.lds                  |   42 +
 board/ar7240/ap93-hgw/Makefile                |   18 +
 board/ar7240/ap93-hgw/ap93-hgw.c              |   53 +
 board/ar7240/ap93-hgw/config.mk               |    5 +
 board/ar7240/ap93-hgw/flash.c                 |   28 +
 board/ar7240/ap93-hgw/u-boot.lds              |   42 +
 board/ar7240/ap93/Makefile                    |   18 +
 board/ar7240/ap93/ap93.c                      |   60 +
 board/ar7240/ap93/config.mk                   |    5 +
 board/ar7240/ap93/flash.c                     |   28 +
 board/ar7240/ap93/u-boot.lds                  |   42 +
 board/ar7240/ap98/Makefile                    |   18 +
 board/ar7240/ap98/ap98.c                      |   87 +
 board/ar7240/ap98/config.mk                   |   13 +
 board/ar7240/ap98/flash.c                     |   38 +
 board/ar7240/ap98/u-boot-bootstrap.lds        |   62 +
 board/ar7240/ap98/u-boot.lds                  |   42 +
 board/ar7240/ap99-2.6.31/Makefile             |   18 +
 board/ar7240/ap99-2.6.31/ap99-2.6.31.c        |   73 +
 board/ar7240/ap99-2.6.31/config.mk            |   10 +
 board/ar7240/ap99-2.6.31/flash.c              |   35 +
 board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds |   62 +
 board/ar7240/ap99-2.6.31/u-boot.lds           |   42 +
 board/ar7240/ap99-hgw/Makefile                |   18 +
 board/ar7240/ap99-hgw/ap99-hgw.c              |   83 +
 board/ar7240/ap99-hgw/config.mk               |   13 +
 board/ar7240/ap99-hgw/flash.c                 |   38 +
 board/ar7240/ap99-hgw/u-boot-bootstrap.lds    |   62 +
 board/ar7240/ap99-hgw/u-boot.lds              |   42 +
 board/ar7240/ap99-ivi/Makefile                |   18 +
 board/ar7240/ap99-ivi/ap99-ivi.c              |   83 +
 board/ar7240/ap99-ivi/config.mk               |   13 +
 board/ar7240/ap99-ivi/flash.c                 |   38 +
 board/ar7240/ap99-ivi/u-boot-bootstrap.lds    |   61 +
 board/ar7240/ap99-ivi/u-boot.lds              |   42 +
 board/ar7240/ap99-small/Makefile              |   18 +
 board/ar7240/ap99-small/ap99-small.c          |   71 +
 board/ar7240/ap99-small/config.mk             |    5 +
 board/ar7240/ap99-small/flash.c               |   35 +
 board/ar7240/ap99-small/u-boot.lds            |   42 +
 board/ar7240/ap99-test/ap99-test.c            |   71 +
 board/ar7240/ap99/Makefile                    |   18 +
 board/ar7240/ap99/ap99.c                      |   86 +
 board/ar7240/ap99/config.mk                   |   13 +
 board/ar7240/ap99/flash.c                     |   38 +
 board/ar7240/ap99/u-boot-bootstrap.lds        |   62 +
 board/ar7240/ap99/u-boot.lds                  |   42 +
 board/ar7240/aph126/Makefile                  |   62 +
 board/ar7240/aph126/aph126.c                  |  163 ++
 board/ar7240/aph126/config.mk                 |   19 +
 board/ar7240/aph126/flash.c                   |   28 +
 board/ar7240/aph126/u-boot-bootstrap.lds      |   61 +
 board/ar7240/aph126/u-boot.lds                |   42 +
 board/ar7240/aph128/Makefile                  |   62 +
 board/ar7240/aph128/aph128.c                  |  175 ++
 board/ar7240/aph128/config.mk                 |   19 +
 board/ar7240/aph128/flash.c                   |   28 +
 board/ar7240/aph128/u-boot-bootstrap.lds      |   61 +
 board/ar7240/aph128/u-boot.lds                |   42 +
 board/ar7240/ar7240_emu/Makefile              |   18 +
 board/ar7240/ar7240_emu/ar7240_emu.c          |  144 ++
 board/ar7240/ar7240_emu/config.mk             |    5 +
 board/ar7240/ar7240_emu/flash.c               |   28 +
 board/ar7240/ar7240_emu/u-boot.lds            |   42 +
 board/ar7240/common/ar7240_flash.c            |  249 +++
 board/ar7240/common/ar7240_flash.h            |   64 +
 board/ar7240/common/ar7240_pci.c              |  584 ++++++
 board/ar7240/common/ar7240_s26_phy.c          |  915 ++++++++++
 board/ar7240/common/ar7240_s26_phy.h          |  119 ++
 board/ar7240/common/ath_nand.c                | 1597 +++++++++++++++++
 board/ar7240/common/athr_s27_phy.c            |  877 +++++++++
 board/ar7240/common/athr_s27_phy.h            |  208 +++
 board/ar7240/common/athrs16_phy.c             |  684 +++++++
 board/ar7240/common/athrs16_phy.h             |  141 ++
 board/ar7240/common/athrs17_phy.c             |  625 +++++++
 board/ar7240/common/athrs17_phy.h             |  107 ++
 board/ar7240/common/athrs_vir_phy.c           |  122 ++
 board/ar7240/common/athrsf1_phy.c             |  433 +++++
 board/ar7240/common/athrsf1_phy.h             |   26 +
 board/ar7240/common/athrsf2_phy.c             |  377 ++++
 board/ar7240/common/lowlevel_init.S           |  213 +++
 board/ar7240/common/lowlevel_init_934x-1.1.S  |  406 +++++
 board/ar7240/common/lowlevel_init_934x.S      |  182 ++
 board/ar7240/common/phy.h                     |   19 +
 board/ar7240/cus136/Makefile                  |   18 +
 board/ar7240/cus136/config.mk                 |    5 +
 board/ar7240/cus136/cus136.c                  |   70 +
 board/ar7240/cus136/flash.c                   |   28 +
 board/ar7240/cus136/u-boot.lds                |   42 +
 board/ar7240/db12x-extender/.depend           |  220 +++
 board/ar7240/db12x-extender/Makefile          |   62 +
 board/ar7240/db12x-extender/config.mk         |   19 +
 board/ar7240/db12x-extender/db12x-extender.c  |  136 ++
 board/ar7240/db12x-extender/flash.c           |   28 +
 .../db12x-extender/u-boot-bootstrap.lds       |   61 +
 board/ar7240/db12x-extender/u-boot.lds        |   42 +
 board/ar7240/db12x-hybrid/Makefile            |   68 +
 board/ar7240/db12x-hybrid/config.mk           |   19 +
 board/ar7240/db12x-hybrid/db12x-hybrid.c      |  170 ++
 board/ar7240/db12x-hybrid/flash.c             |   30 +
 .../ar7240/db12x-hybrid/u-boot-bootstrap.lds  |   61 +
 board/ar7240/db12x-hybrid/u-boot.lds          |   42 +
 board/ar7240/db12x/Makefile                   |   78 +
 board/ar7240/db12x/config.mk                  |   35 +
 board/ar7240/db12x/db12x.c                    |  131 ++
 board/ar7240/db12x/extra.c                    |   89 +
 board/ar7240/db12x/flash.c                    |   30 +
 board/ar7240/db12x/u-boot-bootstrap.lds       |   61 +
 board/ar7240/db12x/u-boot.lds                 |   42 +
 board/ar7240/dhp1565/Makefile                 |   62 +
 board/ar7240/dhp1565/config.mk                |   19 +
 board/ar7240/dhp1565/dhp1565.c                |  171 ++
 board/ar7240/dhp1565/flash.c                  |   28 +
 board/ar7240/dhp1565/u-boot-bootstrap.lds     |   61 +
 board/ar7240/dhp1565/u-boot.lds               |   42 +
 board/ar7240/mi93/Makefile                    |   18 +
 board/ar7240/mi93/config.mk                   |    5 +
 board/ar7240/mi93/flash.c                     |   35 +
 board/ar7240/mi93/mi93.c                      |   67 +
 board/ar7240/mi93/u-boot.lds                  |   42 +
 board/ar7240/pb90/Makefile                    |   18 +
 board/ar7240/pb90/config.mk                   |    5 +
 board/ar7240/pb90/flash.c                     |   28 +
 board/ar7240/pb90/pb90.c                      |   59 +
 board/ar7240/pb90/u-boot.lds                  |   42 +
 board/ar7240/pb92/Makefile                    |   18 +
 board/ar7240/pb92/config.mk                   |   10 +
 board/ar7240/pb92/flash.c                     |   28 +
 board/ar7240/pb92/pb92.c                      |   75 +
 board/ar7240/pb92/u-boot-bootstrap.lds        |   62 +
 board/ar7240/pb92/u-boot.lds                  |   42 +
 board/ar7240/pb93/Makefile                    |   18 +
 board/ar7240/pb93/config.mk                   |    5 +
 board/ar7240/pb93/flash.c                     |   28 +
 board/ar7240/pb93/pb93.c                      |   72 +
 board/ar7240/pb93/u-boot.lds                  |   42 +
 board/ar7240/pb9x-2.6.31/Makefile             |   18 +
 board/ar7240/pb9x-2.6.31/config.mk            |   10 +
 board/ar7240/pb9x-2.6.31/flash.c              |   28 +
 board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c        |   86 +
 board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds |   62 +
 board/ar7240/pb9x-2.6.31/u-boot.lds           |   42 +
 board/ar7240/pb9x-2x8/Makefile                |   18 +
 board/ar7240/pb9x-2x8/config.mk               |   10 +
 board/ar7240/pb9x-2x8/flash.c                 |   28 +
 board/ar7240/pb9x-2x8/pb9x-2x8.c              |   75 +
 board/ar7240/pb9x-2x8/u-boot-bootstrap.lds    |   62 +
 board/ar7240/pb9x-2x8/u-boot.lds              |   42 +
 board/ar7240/pb9x/Makefile                    |   18 +
 board/ar7240/pb9x/config.mk                   |   10 +
 board/ar7240/pb9x/flash.c                     |   28 +
 board/ar7240/pb9x/pb9x.c                      |   86 +
 board/ar7240/pb9x/u-boot-bootstrap.lds        |   62 +
 board/ar7240/pb9x/u-boot.lds                  |   42 +
 board/ar7240/reh132/Makefile                  |   62 +
 board/ar7240/reh132/config.mk                 |   19 +
 board/ar7240/reh132/flash.c                   |   28 +
 board/ar7240/reh132/reh132.c                  |  176 ++
 board/ar7240/reh132/u-boot-bootstrap.lds      |   61 +
 board/ar7240/reh132/u-boot.lds                |   42 +
 board/ar7240/tb327/Makefile                   |   18 +
 board/ar7240/tb327/config.mk                  |    5 +
 board/ar7240/tb327/flash.c                    |   28 +
 board/ar7240/tb327/tb327.c                    |   52 +
 board/ar7240/tb327/u-boot.lds                 |   42 +
 board/ar7240/wasp_emu/Makefile                |   18 +
 board/ar7240/wasp_emu/config.mk               |    9 +
 board/ar7240/wasp_emu/flash.c                 |   28 +
 board/ar7240/wasp_emu/u-boot.lds              |   42 +
 board/ar7240/wasp_emu/wasp_emu.c              |   69 +
 board/ar7240/wrt54g/Makefile                  |   18 +
 board/ar7240/wrt54g/config.mk                 |    5 +
 board/ar7240/wrt54g/flash.c                   |   42 +
 board/ar7240/wrt54g/u-boot.lds                |   42 +
 board/ar7240/wrt54g/wrt54g.c                  |   73 +
 board/atheros/aph131/Makefile                 |   58 +
 board/atheros/aph131/aph131.c                 |  143 ++
 board/atheros/aph131/config.mk                |   35 +
 board/atheros/aph131/extra.c                  |  103 ++
 board/atheros/aph131/flash.c                  |   32 +
 board/atheros/aph131/u-boot-bootstrap.lds     |   61 +
 board/atheros/aph131/u-boot.lds               |   42 +
 board/atheros/board953x/Makefile              |   68 +
 board/atheros/board953x/board953x.c           |  145 ++
 board/atheros/board953x/config.mk             |   23 +
 board/atheros/board953x/extra.c               |   55 +
 board/atheros/board953x/flash.c               |   30 +
 board/atheros/board953x/u-boot-bootstrap.lds  |   61 +
 board/atheros/board953x/u-boot.lds            |   42 +
 board/atheros/board955x/Makefile              |   97 +
 board/atheros/board955x/board955x.c           |  143 ++
 board/atheros/board955x/config.mk             |   35 +
 board/atheros/board955x/extra.c               |  103 ++
 board/atheros/board955x/flash.c               |   32 +
 board/atheros/board955x/u-boot-bootstrap.lds  |   61 +
 board/atheros/board955x/u-boot.lds            |   42 +
 board/atheros/common/953x.S                   |  153 ++
 board/atheros/common/955x.S                   |  155 ++
 board/atheros/common/ath_flash.c              |  322 ++++
 board/atheros/common/ath_flash.h              |   53 +
 board/atheros/common/ath_nand.c               | 1593 ++++++++++++++++
 board/atheros/common/ath_pci.c                |  421 +++++
 board/atheros/common/athr_ar8033_phy.c        |  155 ++
 board/atheros/common/athr_s27_phy.c           |  877 +++++++++
 board/atheros/common/athr_s27_phy.h           |  208 +++
 board/atheros/common/athrs17_lpbk.c           |  290 +++
 board/atheros/common/athrs17_phy.c            |  713 ++++++++
 board/atheros/common/athrs17_phy.h            |  553 ++++++
 board/atheros/common/athrs_ar8033_phy.h       |   87 +
 board/atheros/common/athrs_vir_phy.c          |  122 ++
 board/atheros/common/athrsf1_phy.c            |  433 +++++
 board/atheros/common/athrsf1_phy.h            |   26 +
 board/atheros/common/init-953x.c              |  381 ++++
 board/atheros/common/init-955x.c              |  458 +++++
 board/atheros/common/phy.h                    |   17 +
 board/atheros/common/qca-eth-953x.c           |  681 +++++++
 board/atheros/common/qca-eth-953x.h           |  349 ++++
 board/atheros/common/qca-eth-953x_phy.h       |   73 +
 board/atheros/common/qca-eth-955x.c           |  977 ++++++++++
 board/atheros/common/qca-eth-955x.h           |  407 +++++
 board/atheros/common/qca-eth-955x_phy.h       |  102 ++
 board/atheros/common/rgmii-cal-955x.c         |  600 +++++++
 board/atheros/common/serial.c                 |   88 +
 board/atheros/common/tap-953x.S               |  183 ++
 board/atheros/common/tap-955x.S               |  185 ++
 board/atheros/scoemu/Makefile                 |   73 +
 board/atheros/scoemu/config.mk                |   19 +
 board/atheros/scoemu/flash.c                  |   32 +
 board/atheros/scoemu/scoemu.c                 |  121 ++
 board/atheros/scoemu/u-boot.lds               |   42 +
 board/atheros/tb6xx/Makefile                  |   73 +
 board/atheros/tb6xx/config.mk                 |   19 +
 board/atheros/tb6xx/flash.c                   |   32 +
 board/atheros/tb6xx/tb6xx.c                   |  126 ++
 board/atheros/tb6xx/u-boot.lds                |   42 +
 381 files changed, 46549 insertions(+)
 create mode 100644 board/ar7100/ap81/Makefile
 create mode 100644 board/ar7100/ap81/ap81.c
 create mode 100755 board/ar7100/ap81/config.mk
 create mode 100644 board/ar7100/ap81/flash.c
 create mode 100755 board/ar7100/ap81/u-boot.lds
 create mode 100644 board/ar7100/ap83/Makefile
 create mode 100644 board/ar7100/ap83/ap83.c
 create mode 100644 board/ar7100/ap83/config.mk
 create mode 100644 board/ar7100/ap83/flash.c
 create mode 100755 board/ar7100/ap83/u-boot.lds
 create mode 100644 board/ar7100/ap94/Makefile
 create mode 100644 board/ar7100/ap94/ap94.c
 create mode 100644 board/ar7100/ap94/ap94_pci.c
 create mode 100644 board/ar7100/ap94/athrs26_phy.c
 create mode 100644 board/ar7100/ap94/athrs26_phy.h
 create mode 100755 board/ar7100/ap94/config.mk
 create mode 100755 board/ar7100/ap94/lowlevel_init.S
 create mode 100755 board/ar7100/ap94/u-boot.lds
 create mode 100644 board/ar7100/ap96/Makefile
 create mode 100644 board/ar7100/ap96/ap96.c
 create mode 100644 board/ar7100/ap96/config.mk
 create mode 100755 board/ar7100/ap96/u-boot.lds
 create mode 100644 board/ar7100/common/ar7100_flash.c
 create mode 100644 board/ar7100/common/ar7100_flash.h
 create mode 100644 board/ar7100/common/ar9100_pflash.c
 create mode 100644 board/ar7100/common/athr_phy.h
 create mode 100644 board/ar7100/common/athrf1_phy.c
 create mode 100644 board/ar7100/common/athrs16_phy.c
 create mode 100644 board/ar7100/common/athrs16_phy.h
 create mode 100644 board/ar7100/common/athrs26_phy.c
 create mode 100644 board/ar7100/common/athrs26_phy.h
 create mode 100644 board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c
 create mode 100644 board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c
 create mode 100644 board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c
 create mode 100644 board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c
 create mode 100644 board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c
 create mode 100644 board/ar7100/common/generic_i2c.c
 create mode 100644 board/ar7100/common/generic_i2c.h
 create mode 100644 board/ar7100/common/generic_spi.c
 create mode 100644 board/ar7100/common/generic_spi.h
 create mode 100644 board/ar7100/common/ipPhy.c
 create mode 100644 board/ar7100/common/ipPhy.h
 create mode 100644 board/ar7100/common/lowlevel_init.S
 create mode 100644 board/ar7100/common/lowlevel_init_ar9100.S
 create mode 100644 board/ar7100/common/phy.h
 create mode 100644 board/ar7100/common/vsc73xx.c
 create mode 100644 board/ar7100/common/vsc73xx.h
 create mode 100644 board/ar7100/common/vsc8601_phy.c
 create mode 100644 board/ar7100/common/vsc8601_phy.h
 create mode 100644 board/ar7100/common/vsc_phy.c
 create mode 100644 board/ar7100/pb42/Makefile
 create mode 100755 board/ar7100/pb42/config.mk
 create mode 100644 board/ar7100/pb42/flash.c
 create mode 100644 board/ar7100/pb42/pb42.c
 create mode 100755 board/ar7100/pb42/u-boot.lds
 create mode 100644 board/ar7100/pb44/Makefile
 create mode 100644 board/ar7100/pb44/config.mk
 create mode 100755 board/ar7100/pb44/lowlevel_init.S
 create mode 100644 board/ar7100/pb44/pb44.c
 create mode 100644 board/ar7100/pb44/pb44_pci.c
 create mode 100644 board/ar7100/pb44/u-boot-bootstrap.lds
 create mode 100644 board/ar7100/pb44/u-boot.lds
 create mode 100644 board/ar7100/pb47/Makefile
 create mode 100644 board/ar7100/pb47/config.mk
 create mode 100755 board/ar7100/pb47/lowlevel_init.S
 create mode 100644 board/ar7100/pb47/pb47.c
 create mode 100644 board/ar7100/pb47/pb47_pci.c
 create mode 100644 board/ar7100/pb47/u-boot.lds
 create mode 100644 board/ar7100/tb225/Makefile
 create mode 100644 board/ar7100/tb225/config.mk
 create mode 100644 board/ar7100/tb225/flash.c
 create mode 100644 board/ar7100/tb225/tb225.c
 create mode 100644 board/ar7100/tb225/u-boot.lds
 create mode 100644 board/ar7100/tb243/Makefile
 create mode 100755 board/ar7100/tb243/config.mk
 create mode 100644 board/ar7100/tb243/tb243.c
 create mode 100755 board/ar7100/tb243/u-boot.lds
 create mode 100644 board/ar7240/ap101-2.6.31/Makefile
 create mode 100644 board/ar7240/ap101-2.6.31/ap101-2.6.31.c
 create mode 100755 board/ar7240/ap101-2.6.31/config.mk
 create mode 100644 board/ar7240/ap101-2.6.31/flash.c
 create mode 100755 board/ar7240/ap101-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/ap101-small/Makefile
 create mode 100644 board/ar7240/ap101-small/ap101-small.c
 create mode 100755 board/ar7240/ap101-small/config.mk
 create mode 100644 board/ar7240/ap101-small/flash.c
 create mode 100755 board/ar7240/ap101-small/u-boot.lds
 create mode 100644 board/ar7240/ap101/Makefile
 create mode 100644 board/ar7240/ap101/ap101.c
 create mode 100755 board/ar7240/ap101/config.mk
 create mode 100644 board/ar7240/ap101/flash.c
 create mode 100755 board/ar7240/ap101/u-boot.lds
 create mode 100644 board/ar7240/ap111-2.6.31/Makefile
 create mode 100644 board/ar7240/ap111-2.6.31/ap111-2.6.31.c
 create mode 100755 board/ar7240/ap111-2.6.31/config.mk
 create mode 100644 board/ar7240/ap111-2.6.31/flash.c
 create mode 100755 board/ar7240/ap111-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/ap111/Makefile
 create mode 100644 board/ar7240/ap111/ap111.c
 create mode 100755 board/ar7240/ap111/config.mk
 create mode 100644 board/ar7240/ap111/flash.c
 create mode 100755 board/ar7240/ap111/u-boot.lds
 create mode 100644 board/ar7240/ap120/Makefile
 create mode 100644 board/ar7240/ap120/ap120.c
 create mode 100755 board/ar7240/ap120/config.mk
 create mode 100644 board/ar7240/ap120/flash.c
 create mode 100644 board/ar7240/ap120/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap120/u-boot.lds
 create mode 100644 board/ar7240/ap121/Makefile
 create mode 100644 board/ar7240/ap121/ap121.c
 create mode 100644 board/ar7240/ap121/config.mk
 create mode 100644 board/ar7240/ap121/flash.c
 create mode 100755 board/ar7240/ap121/hornet_pll_init.S
 create mode 100644 board/ar7240/ap121/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/ap121/u-boot.lds
 create mode 100644 board/ar7240/ap123/Makefile
 create mode 100644 board/ar7240/ap123/ap123.c
 create mode 100755 board/ar7240/ap123/config.mk
 create mode 100644 board/ar7240/ap123/flash.c
 create mode 100644 board/ar7240/ap123/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap123/u-boot.lds
 create mode 100644 board/ar7240/ap91-2MB/Makefile
 create mode 100644 board/ar7240/ap91-2MB/ap91-2MB.c
 create mode 100644 board/ar7240/ap91-2MB/ar9285gpio.c
 create mode 100755 board/ar7240/ap91-2MB/config.mk
 create mode 100644 board/ar7240/ap91-2MB/flash.c
 create mode 100644 board/ar7240/ap91-2MB/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91-2MB/u-boot.lds
 create mode 100644 board/ar7240/ap91-2x8/Makefile
 create mode 100644 board/ar7240/ap91-2x8/ap91-2x8.c
 create mode 100755 board/ar7240/ap91-2x8/config.mk
 create mode 100644 board/ar7240/ap91-2x8/flash.c
 create mode 100644 board/ar7240/ap91-2x8/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91-2x8/u-boot.lds
 create mode 100644 board/ar7240/ap91-router/Makefile
 create mode 100644 board/ar7240/ap91-router/ap91-router.c
 create mode 100755 board/ar7240/ap91-router/config.mk
 create mode 100644 board/ar7240/ap91-router/flash.c
 create mode 100644 board/ar7240/ap91-router/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91-router/u-boot.lds
 create mode 100644 board/ar7240/ap91/Makefile
 create mode 100644 board/ar7240/ap91/ap91.c
 create mode 100644 board/ar7240/ap91/ar9285gpio.c
 create mode 100755 board/ar7240/ap91/config.mk
 create mode 100644 board/ar7240/ap91/flash.c
 create mode 100644 board/ar7240/ap91/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap91/u-boot.lds
 create mode 100644 board/ar7240/ap93-hgw/Makefile
 create mode 100644 board/ar7240/ap93-hgw/ap93-hgw.c
 create mode 100755 board/ar7240/ap93-hgw/config.mk
 create mode 100644 board/ar7240/ap93-hgw/flash.c
 create mode 100755 board/ar7240/ap93-hgw/u-boot.lds
 create mode 100644 board/ar7240/ap93/Makefile
 create mode 100644 board/ar7240/ap93/ap93.c
 create mode 100755 board/ar7240/ap93/config.mk
 create mode 100644 board/ar7240/ap93/flash.c
 create mode 100755 board/ar7240/ap93/u-boot.lds
 create mode 100644 board/ar7240/ap98/Makefile
 create mode 100644 board/ar7240/ap98/ap98.c
 create mode 100755 board/ar7240/ap98/config.mk
 create mode 100644 board/ar7240/ap98/flash.c
 create mode 100644 board/ar7240/ap98/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap98/u-boot.lds
 create mode 100644 board/ar7240/ap99-2.6.31/Makefile
 create mode 100644 board/ar7240/ap99-2.6.31/ap99-2.6.31.c
 create mode 100644 board/ar7240/ap99-2.6.31/config.mk
 create mode 100644 board/ar7240/ap99-2.6.31/flash.c
 create mode 100644 board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/ap99-hgw/Makefile
 create mode 100644 board/ar7240/ap99-hgw/ap99-hgw.c
 create mode 100755 board/ar7240/ap99-hgw/config.mk
 create mode 100644 board/ar7240/ap99-hgw/flash.c
 create mode 100644 board/ar7240/ap99-hgw/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99-hgw/u-boot.lds
 create mode 100644 board/ar7240/ap99-ivi/Makefile
 create mode 100644 board/ar7240/ap99-ivi/ap99-ivi.c
 create mode 100755 board/ar7240/ap99-ivi/config.mk
 create mode 100644 board/ar7240/ap99-ivi/flash.c
 create mode 100644 board/ar7240/ap99-ivi/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99-ivi/u-boot.lds
 create mode 100644 board/ar7240/ap99-small/Makefile
 create mode 100644 board/ar7240/ap99-small/ap99-small.c
 create mode 100644 board/ar7240/ap99-small/config.mk
 create mode 100644 board/ar7240/ap99-small/flash.c
 create mode 100755 board/ar7240/ap99-small/u-boot.lds
 create mode 100644 board/ar7240/ap99-test/ap99-test.c
 create mode 100644 board/ar7240/ap99/Makefile
 create mode 100644 board/ar7240/ap99/ap99.c
 create mode 100755 board/ar7240/ap99/config.mk
 create mode 100644 board/ar7240/ap99/flash.c
 create mode 100644 board/ar7240/ap99/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/ap99/u-boot.lds
 create mode 100644 board/ar7240/aph126/Makefile
 create mode 100644 board/ar7240/aph126/aph126.c
 create mode 100644 board/ar7240/aph126/config.mk
 create mode 100644 board/ar7240/aph126/flash.c
 create mode 100644 board/ar7240/aph126/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/aph126/u-boot.lds
 create mode 100644 board/ar7240/aph128/Makefile
 create mode 100644 board/ar7240/aph128/aph128.c
 create mode 100644 board/ar7240/aph128/config.mk
 create mode 100644 board/ar7240/aph128/flash.c
 create mode 100644 board/ar7240/aph128/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/aph128/u-boot.lds
 create mode 100644 board/ar7240/ar7240_emu/Makefile
 create mode 100644 board/ar7240/ar7240_emu/ar7240_emu.c
 create mode 100755 board/ar7240/ar7240_emu/config.mk
 create mode 100644 board/ar7240/ar7240_emu/flash.c
 create mode 100755 board/ar7240/ar7240_emu/u-boot.lds
 create mode 100644 board/ar7240/common/ar7240_flash.c
 create mode 100644 board/ar7240/common/ar7240_flash.h
 create mode 100644 board/ar7240/common/ar7240_pci.c
 create mode 100644 board/ar7240/common/ar7240_s26_phy.c
 create mode 100644 board/ar7240/common/ar7240_s26_phy.h
 create mode 100644 board/ar7240/common/ath_nand.c
 create mode 100644 board/ar7240/common/athr_s27_phy.c
 create mode 100644 board/ar7240/common/athr_s27_phy.h
 create mode 100644 board/ar7240/common/athrs16_phy.c
 create mode 100644 board/ar7240/common/athrs16_phy.h
 create mode 100644 board/ar7240/common/athrs17_phy.c
 create mode 100644 board/ar7240/common/athrs17_phy.h
 create mode 100644 board/ar7240/common/athrs_vir_phy.c
 create mode 100644 board/ar7240/common/athrsf1_phy.c
 create mode 100644 board/ar7240/common/athrsf1_phy.h
 create mode 100644 board/ar7240/common/athrsf2_phy.c
 create mode 100644 board/ar7240/common/lowlevel_init.S
 create mode 100644 board/ar7240/common/lowlevel_init_934x-1.1.S
 create mode 100644 board/ar7240/common/lowlevel_init_934x.S
 create mode 100644 board/ar7240/common/phy.h
 create mode 100644 board/ar7240/cus136/Makefile
 create mode 100755 board/ar7240/cus136/config.mk
 create mode 100644 board/ar7240/cus136/cus136.c
 create mode 100644 board/ar7240/cus136/flash.c
 create mode 100755 board/ar7240/cus136/u-boot.lds
 create mode 100644 board/ar7240/db12x-extender/.depend
 create mode 100644 board/ar7240/db12x-extender/Makefile
 create mode 100644 board/ar7240/db12x-extender/config.mk
 create mode 100644 board/ar7240/db12x-extender/db12x-extender.c
 create mode 100644 board/ar7240/db12x-extender/flash.c
 create mode 100644 board/ar7240/db12x-extender/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/db12x-extender/u-boot.lds
 create mode 100644 board/ar7240/db12x-hybrid/Makefile
 create mode 100644 board/ar7240/db12x-hybrid/config.mk
 create mode 100644 board/ar7240/db12x-hybrid/db12x-hybrid.c
 create mode 100644 board/ar7240/db12x-hybrid/flash.c
 create mode 100644 board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/db12x-hybrid/u-boot.lds
 create mode 100644 board/ar7240/db12x/Makefile
 create mode 100755 board/ar7240/db12x/config.mk
 create mode 100644 board/ar7240/db12x/db12x.c
 create mode 100644 board/ar7240/db12x/extra.c
 create mode 100644 board/ar7240/db12x/flash.c
 create mode 100644 board/ar7240/db12x/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/db12x/u-boot.lds
 create mode 100644 board/ar7240/dhp1565/Makefile
 create mode 100644 board/ar7240/dhp1565/config.mk
 create mode 100644 board/ar7240/dhp1565/dhp1565.c
 create mode 100644 board/ar7240/dhp1565/flash.c
 create mode 100644 board/ar7240/dhp1565/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/dhp1565/u-boot.lds
 create mode 100644 board/ar7240/mi93/Makefile
 create mode 100755 board/ar7240/mi93/config.mk
 create mode 100644 board/ar7240/mi93/flash.c
 create mode 100644 board/ar7240/mi93/mi93.c
 create mode 100755 board/ar7240/mi93/u-boot.lds
 create mode 100644 board/ar7240/pb90/Makefile
 create mode 100755 board/ar7240/pb90/config.mk
 create mode 100644 board/ar7240/pb90/flash.c
 create mode 100644 board/ar7240/pb90/pb90.c
 create mode 100755 board/ar7240/pb90/u-boot.lds
 create mode 100644 board/ar7240/pb92/Makefile
 create mode 100755 board/ar7240/pb92/config.mk
 create mode 100644 board/ar7240/pb92/flash.c
 create mode 100644 board/ar7240/pb92/pb92.c
 create mode 100644 board/ar7240/pb92/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/pb92/u-boot.lds
 create mode 100644 board/ar7240/pb93/Makefile
 create mode 100755 board/ar7240/pb93/config.mk
 create mode 100644 board/ar7240/pb93/flash.c
 create mode 100644 board/ar7240/pb93/pb93.c
 create mode 100755 board/ar7240/pb93/u-boot.lds
 create mode 100644 board/ar7240/pb9x-2.6.31/Makefile
 create mode 100644 board/ar7240/pb9x-2.6.31/config.mk
 create mode 100644 board/ar7240/pb9x-2.6.31/flash.c
 create mode 100644 board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c
 create mode 100644 board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/pb9x-2.6.31/u-boot.lds
 create mode 100644 board/ar7240/pb9x-2x8/Makefile
 create mode 100755 board/ar7240/pb9x-2x8/config.mk
 create mode 100644 board/ar7240/pb9x-2x8/flash.c
 create mode 100644 board/ar7240/pb9x-2x8/pb9x-2x8.c
 create mode 100644 board/ar7240/pb9x-2x8/u-boot-bootstrap.lds
 create mode 100755 board/ar7240/pb9x-2x8/u-boot.lds
 create mode 100644 board/ar7240/pb9x/Makefile
 create mode 100644 board/ar7240/pb9x/config.mk
 create mode 100644 board/ar7240/pb9x/flash.c
 create mode 100644 board/ar7240/pb9x/pb9x.c
 create mode 100644 board/ar7240/pb9x/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/pb9x/u-boot.lds
 create mode 100644 board/ar7240/reh132/Makefile
 create mode 100644 board/ar7240/reh132/config.mk
 create mode 100644 board/ar7240/reh132/flash.c
 create mode 100644 board/ar7240/reh132/reh132.c
 create mode 100644 board/ar7240/reh132/u-boot-bootstrap.lds
 create mode 100644 board/ar7240/reh132/u-boot.lds
 create mode 100644 board/ar7240/tb327/Makefile
 create mode 100755 board/ar7240/tb327/config.mk
 create mode 100644 board/ar7240/tb327/flash.c
 create mode 100644 board/ar7240/tb327/tb327.c
 create mode 100755 board/ar7240/tb327/u-boot.lds
 create mode 100644 board/ar7240/wasp_emu/Makefile
 create mode 100755 board/ar7240/wasp_emu/config.mk
 create mode 100644 board/ar7240/wasp_emu/flash.c
 create mode 100755 board/ar7240/wasp_emu/u-boot.lds
 create mode 100644 board/ar7240/wasp_emu/wasp_emu.c
 create mode 100644 board/ar7240/wrt54g/Makefile
 create mode 100755 board/ar7240/wrt54g/config.mk
 create mode 100644 board/ar7240/wrt54g/flash.c
 create mode 100755 board/ar7240/wrt54g/u-boot.lds
 create mode 100644 board/ar7240/wrt54g/wrt54g.c
 create mode 100644 board/atheros/aph131/Makefile
 create mode 100644 board/atheros/aph131/aph131.c
 create mode 100755 board/atheros/aph131/config.mk
 create mode 100644 board/atheros/aph131/extra.c
 create mode 100644 board/atheros/aph131/flash.c
 create mode 100644 board/atheros/aph131/u-boot-bootstrap.lds
 create mode 100755 board/atheros/aph131/u-boot.lds
 create mode 100755 board/atheros/board953x/Makefile
 create mode 100755 board/atheros/board953x/board953x.c
 create mode 100755 board/atheros/board953x/config.mk
 create mode 100755 board/atheros/board953x/extra.c
 create mode 100755 board/atheros/board953x/flash.c
 create mode 100755 board/atheros/board953x/u-boot-bootstrap.lds
 create mode 100755 board/atheros/board953x/u-boot.lds
 create mode 100644 board/atheros/board955x/Makefile
 create mode 100644 board/atheros/board955x/board955x.c
 create mode 100755 board/atheros/board955x/config.mk
 create mode 100644 board/atheros/board955x/extra.c
 create mode 100644 board/atheros/board955x/flash.c
 create mode 100644 board/atheros/board955x/u-boot-bootstrap.lds
 create mode 100755 board/atheros/board955x/u-boot.lds
 create mode 100755 board/atheros/common/953x.S
 create mode 100644 board/atheros/common/955x.S
 create mode 100644 board/atheros/common/ath_flash.c
 create mode 100644 board/atheros/common/ath_flash.h
 create mode 100644 board/atheros/common/ath_nand.c
 create mode 100644 board/atheros/common/ath_pci.c
 create mode 100644 board/atheros/common/athr_ar8033_phy.c
 create mode 100755 board/atheros/common/athr_s27_phy.c
 create mode 100755 board/atheros/common/athr_s27_phy.h
 create mode 100644 board/atheros/common/athrs17_lpbk.c
 create mode 100644 board/atheros/common/athrs17_phy.c
 create mode 100644 board/atheros/common/athrs17_phy.h
 create mode 100644 board/atheros/common/athrs_ar8033_phy.h
 create mode 100644 board/atheros/common/athrs_vir_phy.c
 create mode 100755 board/atheros/common/athrsf1_phy.c
 create mode 100755 board/atheros/common/athrsf1_phy.h
 create mode 100755 board/atheros/common/init-953x.c
 create mode 100644 board/atheros/common/init-955x.c
 create mode 100644 board/atheros/common/phy.h
 create mode 100755 board/atheros/common/qca-eth-953x.c
 create mode 100755 board/atheros/common/qca-eth-953x.h
 create mode 100755 board/atheros/common/qca-eth-953x_phy.h
 create mode 100644 board/atheros/common/qca-eth-955x.c
 create mode 100644 board/atheros/common/qca-eth-955x.h
 create mode 100644 board/atheros/common/qca-eth-955x_phy.h
 create mode 100644 board/atheros/common/rgmii-cal-955x.c
 create mode 100644 board/atheros/common/serial.c
 create mode 100755 board/atheros/common/tap-953x.S
 create mode 100644 board/atheros/common/tap-955x.S
 create mode 100644 board/atheros/scoemu/Makefile
 create mode 100755 board/atheros/scoemu/config.mk
 create mode 100644 board/atheros/scoemu/flash.c
 create mode 100644 board/atheros/scoemu/scoemu.c
 create mode 100755 board/atheros/scoemu/u-boot.lds
 create mode 100644 board/atheros/tb6xx/Makefile
 create mode 100755 board/atheros/tb6xx/config.mk
 create mode 100644 board/atheros/tb6xx/flash.c
 create mode 100644 board/atheros/tb6xx/tb6xx.c
 create mode 100755 board/atheros/tb6xx/u-boot.lds

diff --git a/board/ar7100/ap81/Makefile b/board/ar7100/ap81/Makefile
new file mode 100644
index 0000000000..9057cbd772
--- /dev/null
+++ b/board/ar7100/ap81/Makefile
@@ -0,0 +1,23 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+ifeq ($(CONFIG_AP81_CARRIER_CUS109), 1)
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o ../common/athrf1_phy.o
+else
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o ../common/athrs26_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_ar9100.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap81/ap81.c b/board/ar7100/ap81/ap81.c
new file mode 100644
index 0000000000..8b0ac718f5
--- /dev/null
+++ b/board/ar7100/ap81/ap81.c
@@ -0,0 +1,150 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+extern const char version_string[];
+
+void
+ar7100_usb_initial_config(void)
+{
+    ar7100_reg_wr_nf(AR7100_USB_PLL_CONFIG, 0x00001030);
+}
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    int i;
+#if 0
+    ar7100_ddr_width_t width;
+#endif
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x0);
+#endif
+
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here!
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+*/
+#ifndef AR9100
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+#endif
+#if 0
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+#endif
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 25));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 16));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3f << 19);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    *(volatile int *)0xb8050014 = 0x13000a44;
+/*
+    *(volatile int *)0xb8050014 = 0x13000044;
+    *(volatile int *)0xb8050014 = 0x13111321;
+    *(volatile int *)0xb8050014 = 0x00111321;
+    *(volatile int *)0xb8050014 = 0x00001344;
+    *(volatile int *)0xb8050014 = 0x14000044;
+    *(volatile int *)0xb8050014 = 0x14000f44;
+    *(volatile int *)0xb8050014 = 0x00001044;
+    *(volatile int *)0xb8050014 = 0x14001044;
+    *(volatile int *)0xb8050014 = 0x14001f44;
+    *(volatile int *)0xb8050014 = 0x1f001044;
+    *(volatile int *)0xb8050014 = 0x1f001f44;
+*/
+
+    *(volatile int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3b << 19));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3 << 20);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3 << 20));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    /* Temp addition - check with Ravi */
+    *(volatile unsigned int *)0xb8080008 = 0x00000040;
+    udelay(100);
+
+    ar7100_usb_initial_config();
+
+    i = ar7100_ddr_find_size();
+
+    printf ("\n\n%s\n\n", version_string);
+    printf("AP81 (ar7100) U-boot\n");
+    printf("sri\n");
+
+    return i;
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+	return 0;
+}
diff --git a/board/ar7100/ap81/config.mk b/board/ar7100/ap81/config.mk
new file mode 100755
index 0000000000..3c410579c0
--- /dev/null
+++ b/board/ar7100/ap81/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/ap81/flash.c b/board/ar7100/ap81/flash.c
new file mode 100644
index 0000000000..511ee49298
--- /dev/null
+++ b/board/ar7100/ap81/flash.c
@@ -0,0 +1,29 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %dMB, sector count = %d\n",
+                (CFG_FLASH_SIZE >> 20), flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/ap81/u-boot.lds b/board/ar7100/ap81/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/ap81/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/ap83/Makefile b/board/ar7100/ap83/Makefile
new file mode 100644
index 0000000000..0c8432990b
--- /dev/null
+++ b/board/ar7100/ap83/Makefile
@@ -0,0 +1,23 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+
+ifeq ($(SERIAL_FLASH),YES)
+OBJS	= $(BOARD).o ../common/ar7100_flash.o ../common/vsc8601_phy.o ../common/generic_spi.o ../common/vsc73xx.o ../ap83/flash.o
+else
+OBJS	= $(BOARD).o ../common/ar9100_pflash.o ../common/vsc8601_phy.o ../common/generic_spi.o ../common/vsc73xx.o
+endif
+SOBJS	= ../common/lowlevel_init_ar9100.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap83/ap83.c b/board/ar7100/ap83/ap83.c
new file mode 100644
index 0000000000..79a93eeb61
--- /dev/null
+++ b/board/ar7100/ap83/ap83.c
@@ -0,0 +1,153 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+int ap83_board_version;
+
+void
+ar7100_usb_initial_config(void)
+{
+    ar7100_reg_wr_nf(AR7100_USB_PLL_CONFIG, 0x00001030);
+}
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    int i;
+#if 0
+    ar7100_ddr_width_t width;
+#endif
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x0);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x0);
+#endif
+
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here!
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+*/
+#ifndef AR9100
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+#endif
+#if 0
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+#endif
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 25));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 16));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3f << 19);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    *(volatile int *)0xb8050014 = 0x13000a44;
+/*
+    *(volatile int *)0xb8050014 = 0x13000044;
+    *(volatile int *)0xb8050014 = 0x13111321;
+    *(volatile int *)0xb8050014 = 0x00111321;
+    *(volatile int *)0xb8050014 = 0x00001344;
+    *(volatile int *)0xb8050014 = 0x14000044;
+    *(volatile int *)0xb8050014 = 0x14000f44;
+    *(volatile int *)0xb8050014 = 0x00001044;
+    *(volatile int *)0xb8050014 = 0x14001044;
+    *(volatile int *)0xb8050014 = 0x14001f44;
+    *(volatile int *)0xb8050014 = 0x1f001044;
+    *(volatile int *)0xb8050014 = 0x1f001f44;
+*/
+
+    *(volatile int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3b << 19));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3 << 20);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3 << 20));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    /* Temp addition - check with Mani */
+    *(volatile unsigned int *)0xb8080008 = 0x00000060;
+    udelay(100);
+
+    ar7100_usb_initial_config();
+
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+#define AP83_BOARD_NUM_ADDR ((char *)0xbf7f1244)
+
+    ap83_board_version = (AP83_BOARD_NUM_ADDR[0] - '0') +
+                    ((AP83_BOARD_NUM_ADDR[1] - '0') * 10);
+
+    printf("AP83-%d (ar9100) U-boot " ATH_AP83_UBOOT_VERSION "\n",
+           ap83_board_version);
+
+    return 0;
+}
diff --git a/board/ar7100/ap83/config.mk b/board/ar7100/ap83/config.mk
new file mode 100644
index 0000000000..36591ccd48
--- /dev/null
+++ b/board/ar7100/ap83/config.mk
@@ -0,0 +1,6 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+SERIAL_FLASH = NO
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/ap83/flash.c b/board/ar7100/ap83/flash.c
new file mode 100644
index 0000000000..511ee49298
--- /dev/null
+++ b/board/ar7100/ap83/flash.c
@@ -0,0 +1,29 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %dMB, sector count = %d\n",
+                (CFG_FLASH_SIZE >> 20), flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/ap83/u-boot.lds b/board/ar7100/ap83/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/ap83/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/ap94/Makefile b/board/ar7100/ap94/Makefile
new file mode 100644
index 0000000000..a1a3e4472e
--- /dev/null
+++ b/board/ar7100/ap94/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o ../common/ar7100_flash.o athrs26_phy.o ap94_pci.o ../common/generic_spi.o
+SOBJS	= lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap94/ap94.c b/board/ar7100/ap94/ap94.c
new file mode 100644
index 0000000000..c9e1001f80
--- /dev/null
+++ b/board/ar7100/ap94/ap94.c
@@ -0,0 +1,106 @@
+/*****************************************************************************/
+/*! file ap94.c
+** /brief Boot support for AP94 board
+**
+**  This provides the support code required for the AP94 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the AP94.
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x50C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x67;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+int checkboard (void)
+{
+
+    printf("AP94 (ar7100) U-boot " ATH_AP83_UBOOT_VERSION "\n");
+    return 0;
+}
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/ap94/ap94_pci.c b/board/ar7100/ap94/ap94_pci.c
new file mode 100644
index 0000000000..4e9a10853d
--- /dev/null
+++ b/board/ar7100/ap94/ap94_pci.c
@@ -0,0 +1,430 @@
+/*****************************************************************************/
+/*! file ap94_pci.c
+** /brief PCI support for AP94 board
+**
+**  This provides the support code required for PCI support on the AP94
+**  board in the U-Boot environment.  This board is a Hydra based system
+**  with two Merlin WLAN interfaces.  This file also contains the support
+**  for initialization of the Merlin radios on the PCi bus, required for
+**  pre-configuration for use by Linux.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7100_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+/*
+ * Mask table, bits to mask for quantity of size 1, 2 or 4 bytes.
+ * 0 and 3 are not valid indexes...
+ */
+static uint32_t bytemask[] = {
+	/*0*/	0,
+	/*1*/	0xff,
+	/*2*/	0xffff,
+	/*3*/	0,
+	/*4*/	0xffffffff,
+};
+
+static void crp_read(uint32_t ad_cbe, uint32_t *data);
+static void crp_write(uint32_t ad_cbe, uint32_t data);
+static int  ar7100_check_error(int verbose);
+static int  ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data);
+static int  ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data);
+static uint32_t ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where);
+static uint32_t local_byte_lane_enable_bits(uint32_t n, int size);
+static int  ar7100_local_read_config(int where, int size, uint32_t *value);
+static int  ar7100_local_write_config(int where, int size, uint32_t value);
+
+/*
+** This is where the merlin devices in slot 0 and 1 are initialized.
+** Note that for other boards derived from AP-94 this should be customized
+** for the board in question
+**
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+    u32     val;
+    u32     addr;
+    u32     BaseAddr[2] = {0x10000000, 0x10010000};
+    u32     CalAddr[2] = {MERLIN24CAL, MERLIN50CAL};
+    u16     *calData;
+    int     i;
+
+    /*
+    ** For AP94, we have two Merlins that need to be initialized. Set the device ID for now
+    */
+
+    for( i=0 ; i<2; i++ )
+    {
+        calData = (u16 *)CalAddr[i];
+
+        if(calData[0] != 0xa55a)
+        {
+            /*
+            ** Board is not calibrated.
+            */
+
+            printf("BOARD IS NOT CALIBRATED!!!\n");
+            return;
+        }
+
+        /*
+        ** Need to setup the PCI device to access the internal registers
+        */
+
+        ar7100_pci_write_config(&hose,PCI_BDF(0,i,0),0x10,BaseAddr[i]);
+        ar7100_pci_write_config(&hose,PCI_BDF(0,i,0),0x04,0x6);
+
+        /*
+        ** Set pointer to first reg address
+        */
+
+        calData += 3;
+
+        while(*calData != 0xffff)
+        {
+            addr = BaseAddr[i] + *calData++;
+            val  = *calData++;
+            val |= (*calData++) << 16;
+
+            ar7100_reg_wr(addr,val);
+        }
+    }
+
+    return;
+}
+
+/*
+ * Read from PCI config space (host ctrl)
+ */
+static void crp_read(uint32_t ad_cbe, uint32_t *data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, ad_cbe);
+	*data     =  ar7100_reg_rd(AR7100_PCI_CRP_RDDATA);
+}
+
+/*
+ * Write to PCI config space (host ctrl)
+ */
+static void crp_write(uint32_t ad_cbe, uint32_t data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, (AR7100_CRP_CMD_WRITE | ad_cbe));
+	ar7100_reg_wr(AR7100_PCI_CRP_WRDATA, data);
+}
+
+
+/*
+ * Check for PCI errors (aborts, parity etc.), for configuration cycles
+ * PCI error reg: 1:0
+ * AHB error reg: 0
+ * Both write-back-1 to clear.
+ */
+static int
+ar7100_check_error(int verbose)
+{
+    uint32_t error = 0, trouble = 0, status;
+
+    error = ar7100_reg_rd(AR7100_PCI_ERROR) & 3;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("PCI error %d at PCI addr 0x%x status %#x\n",
+                    error, ar7100_reg_rd(AR7100_PCI_ERROR_ADDRESS),
+                    status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_ERROR, error);
+        ar7100_local_write_config(PCI_STATUS, 2, status);
+        /*
+         * flush
+         */
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+        trouble = 1;
+    }
+
+    error = 0;
+    error = ar7100_reg_rd(AR7100_PCI_AHB_ERROR) & 1;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("AHB error %d at AHB address 0x%x status %#x\n",
+                   ar7100_reg_rd(AR7100_PCI_AHB_ERROR_ADDRESS), status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_AHB_ERROR, error);
+        trouble = 1;
+    }
+
+    return trouble;
+}
+
+static int
+ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/*
+     * the result of the read is now in CFG_RDATA
+     */
+    if (!ar7100_check_error(0))
+        *data = ar7100_reg_rd(AR7100_PCI_CFG_RDDATA);
+    else {
+        *data = 0xffffffff;
+        retval = 1;
+    }
+
+	return retval;
+}
+
+static int
+ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/*
+     * execute the write by writing to CFG_WDATA
+     */
+    ar7100_reg_wr(AR7100_PCI_CFG_WRDATA, data);
+
+    if (ar7100_check_error(0))
+        retval = 1;
+
+	return retval;
+}
+
+/*
+ * This is assuming idsel of device 0 is connected to Address line 17
+ * Address for type 0 config is as follows:
+ * AD:
+ *  1:0 00 indicates type zero transaction
+ *  7:2    indicates the target config dword
+ *  10:8   indicates the target function within the physical device
+ *  31:11  are reserved (and most probably used to connect idsels)
+ */
+static uint32_t
+ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where)
+{
+	uint32_t addr;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = (1 << (AR7100_PCI_IDSEL_ADLINE_START + PCI_DEV(devfn))) |
+               ((PCI_FUNC(devfn)) << 8)                                 |
+		       (where & ~3);
+	} else {
+		/* type 1 */
+		addr = (bus_num << 16) | ((PCI_DEV(devfn)) << 11) |
+			((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;
+	}
+
+	return addr;
+}
+
+
+static uint32_t
+local_byte_lane_enable_bits(uint32_t n, int size)
+{
+	if (size == 1)
+		return (0xf & ~BIT(n)) << 20;
+	if (size == 2)
+		return (0xf & ~(BIT(n) | BIT(n+1))) << 20;
+	if (size == 4)
+		return 0;
+	return 0xffffffff;
+}
+
+static int
+ar7100_local_read_config(int where, int size, uint32_t *value)
+{
+	uint32_t n, data;
+
+	/*printk("ar7100_local_read_config from %d size %d\n", where, size);*/
+	n = where % 4;
+	crp_read(where & ~3, &data);
+	*value = (data >> (8*n)) & bytemask[size];
+	/*printk("ar7100_local_read_config read %#x\n", *value);*/
+
+	return 0;
+}
+
+static int
+ar7100_local_write_config(int where, int size, uint32_t value)
+{
+	uint32_t n, byte_enables, data;
+
+	n = where % 4;
+	byte_enables = local_byte_lane_enable_bits(n, size);
+	if (byte_enables == 0xffffffff)
+		return -1;
+	data = value << (8*n);
+	crp_write((where & ~3) | byte_enables, data);
+
+	return 0;
+}
+
+
+static int ar7100_pci_read_config(struct pci_controller *hose,
+			      pci_dev_t dev, int offset, u32* value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_read(addr, AR7100_CFG_CMD_READ, value);
+
+	return 0;
+}
+
+
+static int
+ar7100_pci_write_config(struct pci_controller *hose, pci_dev_t dev, int offset, u32 value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_write(addr, AR7100_CFG_CMD_WRITE, value);
+	return 0;
+}
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7100 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+void pci_init_board (void)
+{
+    uint32_t cmd, val;
+
+    ar7100_reg_rmw_set(AR7100_RESET,
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(2000);
+
+    ar7100_reg_rmw_clear(AR7100_RESET,
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(2000);
+
+    ar7100_write_pci_window(0);
+    ar7100_write_pci_window(1);
+    ar7100_write_pci_window(2);
+    ar7100_write_pci_window(3);
+    ar7100_write_pci_window(4);
+    ar7100_write_pci_window(5);
+    ar7100_write_pci_window(6);
+    ar7100_write_pci_window(7);
+
+    udelay(2000);
+
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+          PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+    ar7100_local_write_config(PCI_COMMAND, 4, cmd);
+
+    /*
+     * clear any lingering errors and register core error IRQ
+     */
+    ar7100_check_error(0);
+
+    /*
+    ** Now, configure for u-boot tools
+    */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region( &hose.regions[0],
+		            0x80000000,
+		            0x00000000,
+		            32 * 1024 * 1024,
+		            PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region( &hose.regions[1],
+		            0x10000000,
+		            0x10000000,
+		            128 * 1024 * 1024,
+		            PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(&hose,
+		pci_hose_read_config_byte_via_dword,
+		pci_hose_read_config_word_via_dword,
+		ar7100_pci_read_config,
+		pci_hose_write_config_byte_via_dword,
+		pci_hose_write_config_word_via_dword,
+		ar7100_pci_write_config);
+
+    plat_dev_init();
+
+    return 0;
+}
diff --git a/board/ar7100/ap94/athrs26_phy.c b/board/ar7100/ap94/athrs26_phy.c
new file mode 100644
index 0000000000..edba6bdccf
--- /dev/null
+++ b/board/ar7100/ap94/athrs26_phy.c
@@ -0,0 +1,745 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <miiphy.h>
+#include "../cpu/mips/ar7100/ag7100.h"
+#include "ar7100_soc.h"
+#include "athrs26_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_LAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+/*****************************Device ID***************************/
+#define DEVICE_ID_OFFSET 0x0
+#define LOAD_EEPROM_E_BOFFSET 16
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     1,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr26_init_flag = 0;
+static unsigned int old_ahb_div = 0;
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs26_phy_is_link_alive(int phyUnit);
+static uint32_t athrs26_reg_read(uint16_t reg_addr);
+static void athrs26_reg_write(uint16_t reg_addr, uint32_t reg_val);
+
+#define get_field_val(_reg, _mask, _shift, _res_reg)     \
+    do { \
+        unsigned int temp;	\
+        temp = ar7100_reg_rd(_reg); \
+        temp &= (unsigned int)_mask;\
+        _res_reg  = temp >> _shift; \
+    } while (0)
+
+#define set_field_val(_reg, _mask, _shift, _val)                \
+    do { \
+        unsigned int temp; \
+        temp = ar7100_reg_rd(_reg); \
+        temp &= ~_mask;  \
+        temp |= _val << _shift;  \
+        ar7100_reg_wr(_reg, temp);\
+    } while (0)
+
+/****************************
+**
+****************************/
+
+uint16_t phy_reg_read(int unit, uint32_t phy_addr, uint8_t reg)
+{
+    ag7100_mac_t *mac   = ag7100_unit2mac(0);
+    uint16_t      addr  = (phy_addr << AG7100_ADDR_SHIFT) | reg, val;
+    volatile int           rddata;
+    uint16_t      ii = 0x1000;
+
+//    ag7100_choose_phy(phy_addr);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, AG7100_MGMT_CMD_READ);
+
+    do
+    {
+        udelay(5);
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+
+    val = ag7100_reg_rd(mac, AG7100_MII_MGMT_STATUS);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CMD, 0x0);
+
+    return val;
+}
+
+void phy_reg_write(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+    ag7100_mac_t *mac   = ag7100_unit2mac(0);
+    uint16_t      addr  = (phy_addr << AG7100_ADDR_SHIFT) | reg;
+    volatile int rddata;
+    uint16_t      ii = 0x1000;
+
+//    ag7100_choose_phy(phy_addr);
+
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_ADDRESS, addr);
+    ag7100_reg_wr(mac, AG7100_MII_MGMT_CTRL, data);
+
+    do
+    {
+        rddata = ag7100_reg_rd(mac, AG7100_MII_MGMT_IND) & 0x1;
+    }while(rddata && --ii);
+}
+
+void ag7100_ahb_feq_adjust(void)
+{
+    unsigned int pll_fb = 0, ahb_div = 0, cpu_div = 0, mask = 0;
+
+    mask = PLL_CONFIG_PLL_FB_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_PLL_FB_SHIFT, pll_fb);
+
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div);
+
+    mask = PLL_CONFIG_CPU_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_CPU_DIV_SHIFT, cpu_div);
+
+    ahb_div = ( (2*pll_fb + 2)/(5*cpu_div + 5) + 1)/2 - 1;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, ahb_div);
+}
+
+void ag7100_ahb_feq_restore(void)
+{
+    unsigned int mask = 0;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div);
+}
+
+void athrs26_reg_init()
+{
+    if (athr26_init_flag)
+        return;
+
+    athrs26_reg_write(0x200, 0x200);
+    athrs26_reg_write(0x300, 0x200);
+    athrs26_reg_write(0x400, 0x200);
+    athrs26_reg_write(0x500, 0x200);
+    athrs26_reg_write(0x600, 0x7d);
+
+#ifdef S26_VER_1_0
+    phyRegWrite(ATHR_PHYBASE(0), 0, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 0, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 1, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 1, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 2, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 2, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 3, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 3, 30, 0);
+    phyRegWrite(ATHR_PHYBASE(0), 4, 29, 41);
+    phyRegWrite(ATHR_PHYBASE(0), 4, 30, 0);
+#endif
+
+    athrs26_reg_write(0x38, 0xc000050e);
+#ifdef HEADER_EN
+    athrs26_reg_write(0x104, 0x4804);
+#else
+    athrs26_reg_write(0x104, 0x4004);
+#endif
+
+    athrs26_reg_write(0x60, 0xffffffff);
+    athrs26_reg_write(0x64, 0xaaaaaaaa);
+    athrs26_reg_write(0x68, 0x55555555);
+    athrs26_reg_write(0x6c, 0x0);
+    athrs26_reg_write(0x70, 0x41af);
+
+    athr26_init_flag = 1;
+}
+
+
+static unsigned int phy_val_saved = 0;
+/******************************************************************************
+*
+* athrs26_phy_off - power off the phy to change its speed
+*
+* Power off the phy
+*/
+void athrs26_phy_off(ag7100_mac_t *mac)
+{
+    if (mac->mac_unit == ENET_UNIT_LAN)
+        return;
+
+    phy_val_saved = phy_reg_read(0, ATHR_PHY4_ADDR, ATHR_PHY_CONTROL);
+    phy_reg_write(0, ATHR_PHY4_ADDR, ATHR_PHY_CONTROL, phy_val_saved | 0x800);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_on - power on the phy after speed changed
+*
+* Power on the phy
+*/
+void athrs26_phy_on(ag7100_mac_t *mac)
+{
+    if ((mac->mac_unit == ENET_UNIT_LAN) || (phy_val_saved == 0))
+        return;
+
+    phy_reg_write(0, ATHR_PHY4_ADDR, ATHR_PHY_CONTROL, phy_val_saved & 0xf7ff);
+}
+
+/******************************************************************************
+*
+* athrs26_mac_speed_set - set mac in s26 speed mode (actually RMII mode)
+*
+* Set mac speed mode
+*/
+void athrs26_mac_speed_set(ag7100_mac_t *mac, ag7100_phy_speed_t speed)
+{
+    uint32_t reg_val;
+
+    if ((mac->mac_unit == ENET_UNIT_LAN))
+        return;
+
+    reg_val = athrs26_reg_read(0x600);
+
+    switch (speed) {
+        case AG7100_PHY_SPEED_100TX:
+            athrs26_reg_write (0x600, (reg_val & 0xfffffffc) | 0x1);
+            break;
+
+        case AG7100_PHY_SPEED_10T:
+            athrs26_reg_write (0x600, (reg_val & 0xfffffffc));
+            break;
+
+        default:
+            break;
+    }
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL athrs26_phy_setup(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint16_t    timeout;
+    int         liveLinks = 0;
+    uint32_t    phyBase = 0;
+    BOOL        foundPhy = FALSE;
+    uint32_t    phyAddr = 0;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    DEBUGOUT("start auto negogiation on each phy\n");
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        DEBUGOUT("PHY Base: 0x%x PHY Addr: 0x%x\n",phyBase,phyAddr);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+    if (!foundPhy) {
+        DEBUGOUT("No PHY's configured for this ethUnit\n");
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(100);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    DEBUGOUT("associated PHY\n");
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DEBUGOUT("Port %d, Neg Success\n", phyUnit);
+                break;
+            }
+            if (timeout == 0) {
+                DEBUGOUT("Port %d, Negogiation timeout\n", phyUnit);
+                break;
+            }
+            if (--timeout == 0) {
+                DEBUGOUT("Port %d, Negogiation timeout\n", phyUnit);
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    DEBUGOUT("Initialize software status\n");
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DEBUGOUT("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                       ATHR_PHYADDR(phyUnit),
+                       ATHR_PHY_SPEC_STATUS));
+    }
+
+    if (ethUnit == ENET_UNIT_LAN) {
+        ag7100_ahb_feq_adjust();
+        athrs26_reg_init();
+        ag7100_ahb_feq_restore();
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int         phyUnit;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    uint16_t    phyHwStatus;
+    int         ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7100_PHY_SPEED_10T, AG7100_PHY_SPEED_100TX;
+*               AG7100_PHY_SPEED_1000T;
+*/
+
+int
+athrs26_phy_speed(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    int         ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return AG7100_PHY_SPEED_100TX;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return AG7100_PHY_SPEED_10T;
+            case 1:
+                return AG7100_PHY_SPEED_100TX;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return AG7100_PHY_SPEED_10T;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int athrs26_phy_is_up(int ethUnit)
+{
+    int             phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t  *lastStatus;
+    int             linkCount   = 0;
+    int             lostLinks   = 0;
+    int             gainedLinks = 0;
+    uint32_t        phyBase;
+    uint32_t        phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DEBUGOUT("\nenet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DEBUGOUT("\nenet%d port%d up\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return(linkCount);
+
+//    if (linkCount == 0) {
+//        if (lostLinks) {
+//            /* We just lost the last link for this MAC */
+//            phyLinkLost(ethUnit);
+//        }
+//    } else {
+//        if (gainedLinks == linkCount) {
+//            /* We just gained our first link(s) for this MAC */
+//            phyLinkGained(ethUnit);
+//        }
+//    }
+}
+
+static uint32_t
+athrs26_reg_read(uint16_t reg_addr)
+{
+    uint16_t reg_word_addr;
+    uint32_t phy_addr, phy_val0, phy_val1, phy_val;
+    uint8_t phy_reg;
+
+    /* read the first 16 bits*/
+    reg_word_addr = (reg_addr / 4) * 2;
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val0 = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val0);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val0 = phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read the second 16 bits*/
+    reg_word_addr++;
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val1 = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val1);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val1 = phy_reg_read(0, phy_addr, phy_reg);
+    phy_val = ((phy_val1 << 16) | phy_val0);
+    return phy_val;
+}
+
+static void
+athrs26_reg_write(uint16_t reg_addr, uint32_t reg_val)
+{
+    uint16_t reg_word_addr, phy_val;
+    uint32_t phy_addr;
+    uint8_t phy_reg;
+
+    /* write the first 16 bits*/
+    reg_word_addr = (reg_addr / 4) * 2;
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val = reg_val & 0xffff;
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write the second 16 bits*/
+    reg_word_addr++;
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit4-0 of reg address */
+    phy_val = (reg_val >> 16) & 0xffff;
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
diff --git a/board/ar7100/ap94/athrs26_phy.h b/board/ar7100/ap94/athrs26_phy.h
new file mode 100644
index 0000000000..8b6777533d
--- /dev/null
+++ b/board/ar7100/ap94/athrs26_phy.h
@@ -0,0 +1,115 @@
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+
+#define BOOL			u_int32_t
+#define HEADER_LEN	2
+#define HEADER_MAX_DATA	10
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)	sysMsDelay(_x)
+
+#undef S26_VER_1_0
+/* Ken: for debug output */
+//#define DEBUGOUT(fmt,args...)	printf(fmt ,##args)
+#define DEBUGOUT(fmt,args...)
+
+
+/* before define HEADER_REG_CONF, please make sure you also enable s26's */
+/* HEADER_EN on CPU port in bootloader, or the configuration will fail */
+#ifndef CONFIG_AR9100
+#undef HEADER_REG_CONF
+#else
+#define HEADER_REG_CONF 1
+#endif
+#ifdef HEADER_REG_CONF
+#define HEADER_EN
+#endif
+typedef enum {
+    AG7100_PHY_SPEED_10T,
+    AG7100_PHY_SPEED_100TX,
+    AG7100_PHY_SPEED_1000T,
+}ag7100_phy_speed_t;
+
+
+void athrs26_reg_init(void);
+int athrs26_phy_is_up(int unit);
+int athrs26_phy_is_fdx(int unit);
+int athrs26_phy_speed(int unit);
+BOOL athrs26_phy_setup(int unit);
+void athrs26_phy_off(ag7100_mac_t *mac);
+void athrs26_phy_on(ag7100_mac_t *mac);
+void athrs26_mac_speed_set(ag7100_mac_t *mac, ag7100_phy_speed_t speed);
+
+#endif /* _ATHRS26_PHY_H */
diff --git a/board/ar7100/ap94/config.mk b/board/ar7100/ap94/config.mk
new file mode 100755
index 0000000000..4a032b7f0c
--- /dev/null
+++ b/board/ar7100/ap94/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/ap94/lowlevel_init.S b/board/ar7100/ap94/lowlevel_init.S
new file mode 100755
index 0000000000..4a33cf96e5
--- /dev/null
+++ b/board/ar7100/ap94/lowlevel_init.S
@@ -0,0 +1,218 @@
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**
+**
+**
+**  Copyright (c) 200x Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+	pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting the mode register
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
+ /* end of file */
diff --git a/board/ar7100/ap94/u-boot.lds b/board/ar7100/ap94/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/ap94/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/ap96/Makefile b/board/ar7100/ap96/Makefile
new file mode 100644
index 0000000000..62ad424c42
--- /dev/null
+++ b/board/ar7100/ap96/Makefile
@@ -0,0 +1,19 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o ../common/ar7100_flash.o ../common/generic_spi.o \
+	../common/athrs16_phy.o ../ap94/ap94_pci.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/ap96/ap96.c b/board/ar7100/ap96/ap96.c
new file mode 100644
index 0000000000..dbaac95185
--- /dev/null
+++ b/board/ar7100/ap96/ap96.c
@@ -0,0 +1,201 @@
+/*****************************************************************************/
+/*! file ap96.c
+** /brief Boot support for AP96 board
+**
+**  This provides the support code required for the AP96 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces and S16 GigE interfaces.
+**
+**  Code derived from AP94
+**
+**  AP96 is similar to AP94 in all respects except the ethernet interfaces.
+**  AP94 has S26, while AP96 uses S16. PB45 also uses S16, but PB45 has a
+**  32 bit wide memory bus and two mini-PCI slots whereas AP94 and AP96
+**  have a 16 bit wide memory bus and WLAN interfaces on the board. So,
+**  while PB45 doesn't have a caldata partition in flash, AP94 and AP96
+**  will have the radio calibration of the WLAN interfaces in Flash ROM.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+extern flash_info_t flash_info[];
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the PB45.
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x50C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x67;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+int checkboard (void)
+{
+
+    printf("AP96 (ar7100) U-boot " ATH_AP96_UBOOT_VERSION "\n");
+    return 0;
+}
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
+
+#if(0) // defined(CONFIG_CMD_BSP)
+
+/**********************************************************************************
+** do_mac_setting
+**
+** This is the executable portion of the progmac command.  This will process the
+** MAC address strings, and program them into the appropriate flash sector..
+**
+*/
+
+int do_mac (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    char    sectorBuff[65536];
+    int     serno;
+
+    /*
+    ** Argv[1] contains the value string.  Convert to binary, and program the
+    ** values in flash
+    */
+
+    serno = simple_strtoul(argv[1],0,10);
+
+    /*
+    ** If the serial number is less than 0, or greater than 0x1fff, it's out of range
+    */
+
+    if(serno < 0 || serno > 0x1fff)
+    {
+        printf("Serno out of range\n",serno);
+        return 1;
+    }
+
+    /*
+    ** Create the 24 bit number that composes the lower 3 bytes of the MAC address
+    */
+
+    serno = 0xFFFFFF & ( (ATHEROS_PRODUCT_ID << 13) | (serno & 0x1fff));
+
+    /*
+    ** Get the values from flash, and program into the MAC address registers
+    */
+
+    memcpy(sectorBuff,(void *)BOARDCAL, 65536);
+
+    /*
+    ** Set the first and second values
+    */
+
+    sectorBuff[0] = 0x00;
+    sectorBuff[1] = 0x03;
+    sectorBuff[2] = 0x7f;
+
+    sectorBuff[3] = 0xFF & (serno >> 16);
+    sectorBuff[4] = 0xFF & (serno >> 8);
+    sectorBuff[5] = 0xFF &  serno;
+
+    /*
+    ** Increment by 1 for the second MAC address
+    */
+
+    serno++;
+    memcpy(&sectorBuff[6],&sectorBuff[0],3);
+    sectorBuff[3] = 0xFF & (serno >> 16);
+    sectorBuff[4] = 0xFF & (serno >> 8);
+    sectorBuff[5] = 0xFF &  serno;
+
+    flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+    write_buff(flash_info,sectorBuff, BOARDCAL, 65536);
+
+    return 0;
+}
+
+U_BOOT_CMD(none, 2, 0, do_mac,NULL,NULL);
+
+
+U_BOOT_CMD(
+    progmac, 2, 0, do_mac,
+    "progmac - Set ethernet MAC addresses\n",
+    "progmac <serno> - Program the MAC addresses\n"
+    "                <serno> is the value of the last\n"
+    "                4 digits (decimal) of the serial number\n"
+);
+
+#endif
diff --git a/board/ar7100/ap96/config.mk b/board/ar7100/ap96/config.mk
new file mode 100644
index 0000000000..4a032b7f0c
--- /dev/null
+++ b/board/ar7100/ap96/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/ap96/u-boot.lds b/board/ar7100/ap96/u-boot.lds
new file mode 100755
index 0000000000..9ac25bead9
--- /dev/null
+++ b/board/ar7100/ap96/u-boot.lds
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/common/ar7100_flash.c b/board/ar7100/common/ar7100_flash.c
new file mode 100644
index 0000000000..6aa770c1ea
--- /dev/null
+++ b/board/ar7100/common/ar7100_flash.c
@@ -0,0 +1,181 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7100_soc.h"
+#include "ar7100_flash.h"
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#define display(x)  ;
+
+#define AR7100_SPI_CMD_WRITE_SR     0x01
+
+/*
+ * statics
+ */
+static void ar7100_spi_write_enable(void);
+static void ar7100_spi_poll(void);
+static void ar7100_spi_write_page(uint32_t addr, uint8_t *data, int len);
+static void ar7100_spi_sector_erase(uint32_t addr);
+static void ar7100_spi_flash_unblock();
+
+static void
+ar7100_spi_flash_unblock()
+{
+    ar7100_spi_write_enable();
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_WRITE_SR);
+    ar7100_spi_bit_banger(0x0);
+    ar7100_spi_go();
+    ar7100_spi_poll();
+}
+
+static void
+read_id()
+{
+    u32 rd = 0x777777;
+
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS);
+    ar7100_spi_bit_banger(0x9f);
+    ar7100_spi_delay_8();
+    ar7100_spi_delay_8();
+    ar7100_spi_delay_8();
+    ar7100_spi_done();
+    /* rd = ar7100_reg_rd(AR7100_SPI_RD_STATUS); */
+    rd = ar7100_reg_rd(AR7100_SPI_READ);
+    printf("id read %#x\n", rd);
+}
+
+unsigned long
+flash_init (void)
+{
+    int i;
+    u32 rd = 0x666666;
+
+    ar7100_reg_wr_nf(AR7100_SPI_CLOCK, 0x43);
+    ar7100_spi_flash_unblock();
+    read_id();
+/*
+    rd = ar7100_reg_rd(AR7100_SPI_RD_STATUS);
+    printf ("rd = %x\n", rd);
+    if (rd & 0x80) {
+    }
+*/
+
+    /*
+     * hook into board specific code to fill flash_info
+     */
+    return (flash_get_geom(&flash_info));
+}
+
+
+void flash_print_info (flash_info_t *info)
+{
+    printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+    int i, sector_size = info->size/info->sector_count;
+
+    printf("\nFirst %#x last %#x sector size %#x\n",
+           s_first, s_last, sector_size);
+
+    for (i = s_first; i <= s_last; i++) {
+        printf("\b\b\b\b%4d", i);
+        ar7100_spi_sector_erase(i * sector_size);
+    }
+    ar7100_spi_done();
+    printf("\n");
+
+    return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+    int total = 0, len_this_lp, bytes_this_page;
+    ulong dst;
+    uchar *src;
+
+    printf ("write addr: %x\n", addr);
+    addr = addr - CFG_FLASH_BASE;
+
+    while(total < len) {
+        src              = source + total;
+        dst              = addr   + total;
+        bytes_this_page  = AR7100_SPI_PAGE_SIZE - (addr % AR7100_SPI_PAGE_SIZE);
+        len_this_lp      = ((len - total) > bytes_this_page) ? bytes_this_page
+                                                             : (len - total);
+        ar7100_spi_write_page(dst, src, len_this_lp);
+        total += len_this_lp;
+    }
+
+    ar7100_spi_done();
+
+    return 0;
+}
+
+static void
+ar7100_spi_write_enable()
+{
+    ar7100_reg_wr_nf(AR7100_SPI_FS, 1);
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS);
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_WREN);
+    ar7100_spi_go();
+}
+
+static void
+ar7100_spi_poll()
+{
+    int rd;
+
+    do {
+        ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS);
+        ar7100_spi_bit_banger(AR7100_SPI_CMD_RD_STATUS);
+        ar7100_spi_delay_8();
+        rd = (ar7100_reg_rd(AR7100_SPI_RD_STATUS) & 1);
+    }while(rd);
+}
+
+static void
+ar7100_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+    int i;
+    uint8_t ch;
+
+    display(0x77);
+    ar7100_spi_write_enable();
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_PAGE_PROG);
+    ar7100_spi_send_addr(addr);
+
+    for(i = 0; i < len; i++) {
+        ch = *(data + i);
+        ar7100_spi_bit_banger(ch);
+    }
+
+    ar7100_spi_go();
+    display(0x66);
+    ar7100_spi_poll();
+    display(0x6d);
+}
+
+static void
+ar7100_spi_sector_erase(uint32_t addr)
+{
+    ar7100_spi_write_enable();
+    ar7100_spi_bit_banger(AR7100_SPI_CMD_SECTOR_ERASE);
+    ar7100_spi_send_addr(addr);
+    ar7100_spi_go();
+    display(0x7d);
+    ar7100_spi_poll();
+}
diff --git a/board/ar7100/common/ar7100_flash.h b/board/ar7100/common/ar7100_flash.h
new file mode 100644
index 0000000000..d6a810fa24
--- /dev/null
+++ b/board/ar7100/common/ar7100_flash.h
@@ -0,0 +1,62 @@
+#ifndef _FLASH_H
+#define _FLASH_H
+
+#include "ar7100_soc.h"
+
+#define AR7100_SPI_FS           0x1f000000
+#define AR7100_SPI_CLOCK        0x1f000004
+#define AR7100_SPI_WRITE        0x1f000008
+#define AR7100_SPI_READ         0x1f000000
+#define AR7100_SPI_RD_STATUS    0x1f00000c
+
+#define AR7100_SPI_CS_DIS       0x70000
+#define AR7100_SPI_CE_LOW       0x60000
+#define AR7100_SPI_CE_HIGH      0x60100
+
+#define AR7100_SPI_CMD_WREN         0x06
+#define AR7100_SPI_CMD_RD_STATUS    0x05
+#define AR7100_SPI_CMD_FAST_READ    0x0b
+#define AR7100_SPI_CMD_PAGE_PROG    0x02
+#define AR7100_SPI_CMD_SECTOR_ERASE 0xd8
+
+#define AR7100_SPI_SECTOR_SIZE      (1024*64)
+#define AR7100_SPI_PAGE_SIZE        256
+
+
+#define display(_x)     ar7100_reg_wr_nf(0x18040008, (_x))
+
+/*
+ * primitives
+ */
+
+#define ar7100_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ar7100_spi_bit_banger(_byte)  do {        \
+    int i;                                      \
+    for(i = 0; i < 8; i++) {                    \
+        ar7100_reg_wr_nf(AR7100_SPI_WRITE,      \
+                        AR7100_SPI_CE_LOW | ar7100_be_msb(_byte, i));  \
+        ar7100_reg_wr_nf(AR7100_SPI_WRITE,      \
+                        AR7100_SPI_CE_HIGH | ar7100_be_msb(_byte, i)); \
+    }       \
+}while(0);
+
+#define ar7100_spi_go() do {        \
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CE_LOW); \
+    ar7100_reg_wr_nf(AR7100_SPI_WRITE, AR7100_SPI_CS_DIS); \
+}while(0);
+
+
+#define ar7100_spi_send_addr(_addr) do {                    \
+    ar7100_spi_bit_banger(((addr & 0xff0000) >> 16));                 \
+    ar7100_spi_bit_banger(((addr & 0x00ff00) >> 8));                 \
+    ar7100_spi_bit_banger(addr & 0x0000ff);                 \
+}while(0);
+
+#define ar7100_spi_delay_8()    ar7100_spi_bit_banger(0)
+#define ar7100_spi_done()       ar7100_reg_wr_nf(AR7100_SPI_FS, 0)
+
+
+unsigned long  flash_get_geom (flash_info_t *flash_info);
+
+#endif /*_FLASH_H*/
diff --git a/board/ar7100/common/ar9100_pflash.c b/board/ar7100/common/ar9100_pflash.c
new file mode 100644
index 0000000000..9d1708b08b
--- /dev/null
+++ b/board/ar7100/common/ar9100_pflash.c
@@ -0,0 +1,325 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7100_soc.h"
+
+//----------------------------------------------------------------------------
+// Common device details.
+#define FLASHWORD(_x)			((CFG_FLASH_WORD_SIZE)(_x))
+
+#define FLASH_Read_ID                   FLASHWORD( 0x90 )
+#define FLASH_Read_ID_Exit              FLASHWORD( 0xF0 )
+#define FLASH_Reset                     FLASHWORD( 0xFF )
+#define FLASH_Program                   FLASHWORD( 0xA0 )
+#define FLASH_Block_Erase               FLASHWORD( 0x30 )
+
+#define FLASH_Data                      FLASHWORD( 0x80 )	// Data complement
+#define FLASH_Busy                      FLASHWORD( 0x44 )	// "Toggle" bit
+#define FLASH_Err                       FLASHWORD( 0x20 )
+#define FLASH_Sector_Erase_Timer        FLASHWORD( 0x08 )
+
+#define FLASH_Setup_Code1               FLASHWORD( 0xAA )
+#define FLASH_Setup_Code2               FLASHWORD( 0x55 )
+#define FLASH_Setup_Erase               FLASHWORD( 0x80 )
+#define AMD_SPANSION			0x227e
+#define VENDOR_ID(x)			(ushort) ((x & 0x00ff0000) >> 16)
+#define DEVICE_ID(x)			(ushort) (x & 0x0000ffff)
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+typedef struct ar9100_flash_geom {
+    ushort vendor_id;
+    ushort device_id;
+    char *name;
+    ulong nsectors;
+    ulong sector_size;
+    ulong size;
+} ar9100_flash_geom_t;
+
+ar9100_flash_geom_t flash_geom_tbl[] = {
+    {0x00bf, 0x2780, "SST-39VF400", 8, 0x01000, 0x080000},	/* 512 KB */
+    {0x00bf, 0x2782, "SST-39VF160", 32, 0x01000, 0x200000},	/* 2 MB   */
+    {0x00bf, 0x236b, "SST-39VF6401", 128, 0x01000, 0x800000},	/* 8 MB   */
+    {0x00bf, 0x236a, "SST-39VF6402", 128, 0x01000, 0x800000},	/* 8 MB   */
+    {0x00bf, 0x236d, "SST-39VF6402", 128, 0x01000, 0x800000},	/* 8 MB   */
+    {0x0001, 0x227e, "AMD-SPANSION", 128, 0x02000, 0x1000000},	/* 16 MB  */
+    {0xffff, 0xffff, NULL, 0, 0}	/* end list */
+};
+
+
+/*
+ * statics
+ */
+static int write_word(flash_info_t * info, ulong dest, ulong data);
+static ulong read_id(void);
+
+unsigned long flash_init(void)
+{
+    ulong sector_size;
+    ar9100_flash_geom_t *geom;
+    ushort venid, devid;
+
+    int i;
+
+    flash_info->flash_id = read_id();
+    venid = VENDOR_ID(flash_info->flash_id);
+    devid = DEVICE_ID(flash_info->flash_id);
+
+    for (i = 0; flash_geom_tbl[i].name != NULL; i++) {
+        if (venid == flash_geom_tbl[i].vendor_id &&
+            devid == flash_geom_tbl[i].device_id) {
+            break;
+        }
+    }
+
+    geom = &flash_geom_tbl[i];
+    if (geom->name == NULL) {
+        printf("Unknown flash device\n");
+        return -1;
+    }
+    flash_info->size = geom->size;	/* bytes */
+    flash_info->sector_count = geom->nsectors;
+    sector_size = (geom->sector_size * 16); /* One Erase block size */
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * sector_size);
+        flash_info->protect[i] = 0;
+    }
+    flash_print_info(flash_info);
+
+    return (flash_info->size);
+}
+
+
+void flash_print_info(flash_info_t * info)
+{
+    printf("Name: ");
+    switch (DEVICE_ID(info->flash_id))
+    {
+    case 0x2780: printf ("SST-39VF400");            break;
+    case 0x2782: printf ("SST-39VF160");            break;
+    case 0x236b: printf ("SST-39VF6401");           break;
+    case 0x236a: printf ("SST-39VF6402");           break;
+    case 0x236d: printf ("SST-39VF6402");           break;
+    case 0x227e: printf ("AMD-SPANSION");           break;
+    default:     printf ("Unknown Vendor ");        break;
+    }
+
+    printf(" Flash id: 0x%X, Size: %lu bytes.\n", info->flash_id, info->size);
+}
+
+int flash_erase(flash_info_t * info, int s_first, int s_last)
+{
+    int i = s_first;
+    volatile CFG_FLASH_WORD_SIZE *ROM =
+        (volatile CFG_FLASH_WORD_SIZE *) (info->start[0]);
+    int timeout;
+
+    printf("First %#x last %#x\n", s_first, s_last);
+
+    for (i = s_first; i <= s_last; i++) {
+        CFG_FLASH_WORD_SIZE state, prev_state, rd_data;
+        volatile CFG_FLASH_WORD_SIZE *addr_ptr =
+            (volatile CFG_FLASH_WORD_SIZE *) (info->start[i]);
+
+        // Program data [byte] - 6 step sequence
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+        ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Erase;
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+        ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+        *addr_ptr = FLASH_Block_Erase;
+
+        printf("\b\b\b\b\b %3d\%",(( ((i-s_first) + 1) * 100) / ((s_last-s_first) + 1 )) );
+
+#if 1
+            // Wait for erase completion.
+            timeout = 10000000;
+            while (timeout) {
+		state = *addr_ptr;
+		if (FLASHWORD(0xffff) == state) {
+			break;
+		}
+		timeout--;
+            }
+#else
+            // Wait for completion (bit 6 stops toggling)
+            timeout = 5000000;
+            prev_state = *addr_ptr & FLASH_Busy;
+
+            while (timeout) {
+		rd_data = *addr_ptr;
+		state = rd_data & FLASH_Busy;
+		if ((prev_state == state) && (rd_data == FLASHWORD(0xffff))) {
+			break;
+	       }
+	       timeout--;
+	       prev_state = state;
+           }
+#endif
+        if (!timeout){
+	    printf("Error erasing flash...\n");
+            return -1;
+        }
+    }
+        printf("\n");
+
+    return 0;
+}
+
+/*
+ * Copy memory to flash, returns:
+ * Assumption: Caller has already erased the appropriate sectors.
+ * 0 - OK
+ * 1 - write timeout
+ */
+int write_buff(flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+    ulong cp, wp, data;
+    int i, l, rc, j=0, count;
+
+    wp = (addr & ~3);   /* get lower word aligned address */
+    count=cnt;
+    printf("\n");
+
+    /*
+     * handle unaligned start bytes
+     */
+    if ((l = addr - wp) != 0) {
+        data = 0;
+        for (i = 0, cp = wp; i < l; ++i, ++cp) {
+            data = (data << 8) | (*(uchar *) cp);
+        }
+        for (; i < 4 && cnt > 0; ++i) {
+            data = (data << 8) | *src++;
+            --cnt;
+            ++cp;
+        }
+        for (; cnt == 0 && i < 4; ++i, ++cp) {
+            data = (data << 8) | (*(uchar *) cp);
+        }
+
+        if ((rc = write_word(info, wp, data)) != 0) {
+            return (rc);
+        }
+	j = j + 4;
+        wp += 4;
+    }
+
+    /*
+     * handle word aligned part
+     */
+    while (cnt >= 4) {
+        data = 0;
+        for (i = 0; i < 4; ++i) {
+            data = (data << 8) | *src++;
+        }
+        if(!(j%1024))
+	   printf("\b\b\b\b\b %3d\%",((j * 100) / count));
+        if ((rc = write_word(info, wp, data)) != 0) {
+            return (rc);
+        }
+        wp += 4;
+        cnt -= 4;
+        j += 4;
+    }
+
+    printf("\b\b\b\b\b %3d\%\n",(((j + 4) * 100 ) / count));
+    if (cnt == 0) {
+        return (0);
+    }
+
+    /*
+     * handle unaligned tail bytes
+     */
+    data = 0;
+    for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {
+        data = (data << 8) | *src++;
+        --cnt;
+    }
+    for (; i < 4; ++i, ++cp) {
+        data = (data << 8) | (*(uchar *) cp);
+    }
+    return (write_word(info, wp, data));
+}
+
+static int write_word(flash_info_t * info, ulong dest, ulong data)
+{
+    volatile CFG_FLASH_WORD_SIZE *ROM =
+        (CFG_FLASH_WORD_SIZE *) (info->start[0]);
+    volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+    CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+    int i;
+
+    /* Check if Flash is (sufficiently) erased */
+    if ((*((vu_long *) dest) & data) != data) {
+        return (2);
+    }
+
+    for (i = 0; i < 4 / sizeof(CFG_FLASH_WORD_SIZE); i++) {
+        CFG_FLASH_WORD_SIZE state, prev_state;
+        int timeout;
+
+        ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+        ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+        ROM[CFG_FLASH_ADDR0] = FLASH_Program;
+        dest2[i] = data2[i];
+
+#if 1
+            timeout = 10000000;
+            while (timeout) {
+		if (dest2[i] == data2[i]) {
+			 break;
+		}
+		timeout--;
+            }
+#else
+            // Wait for completion (bit 6 stops toggling)
+            timeout = 5000000;
+            prev_state = dest2[i] & FLASH_Busy;
+            while (timeout) {
+		state = dest2[i] & FLASH_Busy;
+		if (prev_state == state) {
+			break;
+		}
+		timeout--;
+		prev_state = state;
+            }
+#endif
+
+        if (!timeout) {
+		printf("Error while Writing into flash...\n");
+            return -1;
+	}
+    }
+
+    return (0);
+}
+
+static ulong read_id()
+{
+    volatile CFG_FLASH_WORD_SIZE *ROM;
+    ulong id;
+
+    ROM = (volatile CFG_FLASH_WORD_SIZE *) CFG_FLASH_BASE;
+
+    ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+    ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+    ROM[CFG_FLASH_ADDR0] = FLASH_Read_ID;
+
+    udelay(10000);
+
+    id = ROM[0];
+    id = (id << 16) | (ROM[1] & 0xffff);
+
+    ROM[CFG_FLASH_ADDR0] = FLASH_Setup_Code1;
+    ROM[CFG_FLASH_ADDR1] = FLASH_Setup_Code2;
+    ROM[CFG_FLASH_ADDR0] = FLASH_Read_ID_Exit;
+
+    udelay(10000);
+    return id;
+}
diff --git a/board/ar7100/common/athr_phy.h b/board/ar7100/common/athr_phy.h
new file mode 100644
index 0000000000..87825fa52e
--- /dev/null
+++ b/board/ar7100/common/athr_phy.h
@@ -0,0 +1,80 @@
+#ifndef _ATHR_PHY_H
+#define _ATHR_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit);
+int athr_phy_speed(int unit);
+int athr_phy_setup(int unit);
+
+typedef enum {
+	AG7100_PHY_SPEED_10T,
+	AG7100_PHY_SPEED_100TX,
+	AG7100_PHY_SPEED_1000T,
+}ag7100_phy_speed_t;
+
+#endif /* _ATHR_PHY_H */
diff --git a/board/ar7100/common/athrf1_phy.c b/board/ar7100/common/athrf1_phy.c
new file mode 100644
index 0000000000..31b43673b7
--- /dev/null
+++ b/board/ar7100/common/athrf1_phy.c
@@ -0,0 +1,196 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright c 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+#ifdef __BDI
+#include "bdi.h"
+#endif
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "ar7100_soc.h"
+
+#include "athr_phy.h"
+#define MODULE_NAME "ATHRF1E"
+
+#define mdelay(_x)         udelay((_x)*1000)
+
+typedef struct {
+  int              is_enet_port;
+  int              mac_unit;
+  unsigned int     phy_addr;
+}athr_phy_t;
+
+athr_phy_t phy_info[] = {
+#ifdef CFG_BOARD_PB47
+    {is_enet_port: 1,
+     mac_unit    : 1,
+     phy_addr    : 0x00}
+#else
+    {is_enet_port: 1,
+     mac_unit    : 0,
+     phy_addr    : 0x00},
+    {is_enet_port: 1,
+     mac_unit    : 1,
+     phy_addr    : 0x01}
+#endif
+};
+
+static athr_phy_t *
+athr_phy_find(int unit)
+{
+    int i;
+    athr_phy_t *phy;
+
+    for(i = 0; i < sizeof(phy_info)/sizeof(athr_phy_t); i++) {
+        phy = &phy_info[i];
+
+        if (phy->is_enet_port && (phy->mac_unit == unit))
+            return phy;
+    }
+
+    return NULL;
+}
+
+/* N.B.: On AR7100, MDC/MDIO is only on MAC0. So, trying to access PHY
+ * registers using MAC1 is futile. Reads will give incorrect values and
+ * writes do not take effect. So, always use as shown below:
+ *
+ *    phy_reg_read(0, ...) phy_reg_write(0, ...) OR
+ *    ag7100_miiphy_read("eth0", ...) ag7100_miiphy_write("eth1", ...)
+ */
+int
+athr_phy_setup(int unit)
+{
+    athr_phy_t *phy = athr_phy_find(unit);
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+
+    if (!phy) {
+        printf(MODULE_NAME": \nNo phy found for unit %d\n", unit);
+        return;
+    }
+
+     /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+
+    phy_reg_write(0, phy->phy_addr, ATHR_AUTONEG_ADVERT,
+                  ATHR_ADVERTISE_ALL);
+
+    phy_reg_write(0, phy->phy_addr, ATHR_1000BASET_CONTROL,
+                  ATHR_ADVERTISE_1000FULL);
+
+    /* delay rx_clk */
+    phy_reg_write(0, phy->phy_addr, 0x1D, 0x0);
+    phy_reg_write(0, phy->phy_addr, 0x1E, 0x34E); /* 0x24E - no delay, 0x34E - 2ns delay */
+
+    /* delay tx_clk */
+    phy_reg_write(0, phy->phy_addr, 0x1D, 0x5);
+    phy_reg_write(0, phy->phy_addr, 0x1E, 0x3D47); /* 0x3C47 - no delay, 0x3D47 - 1.5ns delay */
+
+    /* Reset PHYs*/
+    phy_reg_write(0, phy->phy_addr, ATHR_PHY_CONTROL,
+                  ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                  | ATHR_CTRL_SOFTWARE_RESET);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (timeout=20; timeout; mdelay(150), timeout--) {
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_CONTROL, &phyHwStatus);
+
+        if (!ATHR_RESET_DONE(phyHwStatus))
+            continue;
+
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_STATUS, &phyHwStatus);
+        if (ATHR_AUTONEG_DONE(phyHwStatus)) {
+                printf(MODULE_NAME": Port %d, Auto-Negotiation Success\n", unit);
+                break;
+        }
+    }
+    if (timeout == 0)
+        printf(MODULE_NAME": Port %d, Auto-Negotiation timeout\n", unit);
+}
+
+int
+athr_phy_is_up(int unit)
+{
+    uint16_t status;
+    athr_phy_t *phy = athr_phy_find(unit);
+
+    if (!phy)
+        return 0;
+
+    phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS, &status);
+
+    if (status & ATHR_STATUS_LINK_PASS)
+        return 1;
+
+    return 0;
+}
+
+int
+athr_phy_is_fdx(int unit)
+{
+    uint16_t status;
+    athr_phy_t *phy = athr_phy_find(unit);
+    int ii = 200;
+
+    if (!phy)
+        return 0;
+    do {
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS, &status);
+        mdelay(10);
+    } while((!(status & ATHR_STATUS_RESOVLED)) && --ii);
+
+    if (status & ATHER_STATUS_FULL_DEPLEX)
+        status = FULL;
+    else
+        status = HALF;
+
+    return (status);
+}
+int
+athr_phy_speed(int unit)
+{
+    uint16_t status;
+    athr_phy_t *phy = athr_phy_find(unit);
+    int ii = 200;
+
+    if (!phy)
+        return 0;
+    do {
+        phy_reg_read(0, phy->phy_addr, ATHR_PHY_SPEC_STATUS, &status);
+        mdelay(10);
+    }while((!(status & ATHR_STATUS_RESOVLED)) && --ii);
+
+    status = ((status & ATHER_STATUS_LINK_MASK) >> ATHER_STATUS_LINK_SHIFT);
+
+    switch(status) {
+    case 0:
+        return _10BASET;
+    case 1:
+        return _100BASET;
+    case 2:
+        return _1000BASET;
+    default:
+        printf(MODULE_NAME": Unkown speed read!\n");
+    }
+    return -1;
+}
diff --git a/board/ar7100/common/athrs16_phy.c b/board/ar7100/common/athrs16_phy.c
new file mode 100644
index 0000000000..ffc28669cf
--- /dev/null
+++ b/board/ar7100/common/athrs16_phy.c
@@ -0,0 +1,680 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <asm/addrspace.h>
+#include "phy.h"
+#include "ar7100_soc.h"
+#include "../cpu/mips/ar7100/ag7100.h"
+#include "../cpu/mips/ar7100/ag7100_phy.h"
+
+
+/* PHY selections and access functions */
+
+#if 0
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+#endif
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X) printf X
+
+#define DRV_DEBUG_PHYERROR  0x00000001
+#define DRV_DEBUG_PHYCHANGE 0x00000002
+#define DRV_DEBUG_PHYSETUP  0x00000004
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+/*depend on connection between cpu mac and s16 mac*/
+#ifdef CFG_BOARD_PB45
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+#elif CFG_BOARD_AP96
+#define ENET_UNIT_LAN 0  /* AR7100's MAC 0 is connected to LAN */
+#define ENET_UNIT_WAN 1  /* AR7100's MAC 1 is connected to WAN */
+#else
+#error "CFG_BOARD_ not defined!"
+#endif
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+#define MODULE_NAME "ATHRS16"
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr16_init_flag = 0;
+#define ATHR_GLOBALREGBASE    0
+
+//#define ATHR_PHY_MAX (sizeof(athrPhyInfo) / sizeof(athrPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs16_phy_is_link_alive(int phyUnit);
+static uint32_t athrs16_reg_read(uint32_t reg_addr);
+static void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+#ifdef CFG_BOARD_PB45
+/* PB45 runs at PLL_680_340_170, and ag7100_ahb_feq_adjust lowers the
+** AHB frequency from 170 to about 113MHz and it didn't appear that
+** performing s16 register init at 170MHz causes a problem
+*/
+void ag7100_ahb_feq_adjust(void) {}
+void ag7100_ahb_feq_restore(void) {}
+#else
+#define get_field_val(_reg, _mask, _shift, _res_reg)     \
+    do { \
+        unsigned int temp;	\
+        temp = ar7100_reg_rd(_reg); \
+        temp &= (unsigned int)_mask;\
+        _res_reg  = temp >> _shift; \
+    } while (0)
+
+#define set_field_val(_reg, _mask, _shift, _val)                \
+    do { \
+        unsigned int temp; \
+        temp = ar7100_reg_rd(_reg); \
+        temp &= ~_mask;  \
+        temp |= _val << _shift;  \
+        ar7100_reg_wr(_reg, temp);\
+    } while (0)
+
+static unsigned int old_ahb_div = 0;
+
+void ag7100_ahb_feq_adjust(void)
+{
+    unsigned int pll_fb = 0, ahb_div = 0, cpu_div = 0, mask = 0;
+
+    mask = PLL_CONFIG_PLL_FB_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_PLL_FB_SHIFT, pll_fb);
+
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div);
+
+    mask = PLL_CONFIG_CPU_DIV_MASK;
+    get_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_CPU_DIV_SHIFT, cpu_div);
+
+    //ahb_div = ((((pll_fb + 1) * 40)*2/(200*(cpu_div + 1))) + 1)/2 - 1;
+    ahb_div = ( (2*pll_fb + 2)/(5*cpu_div + 5) + 1)/2 - 1;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, ahb_div);
+}
+
+void ag7100_ahb_feq_restore(void)
+{
+    unsigned int mask = 0;
+    mask = PLL_CONFIG_AHB_DIV_MASK;
+    set_field_val(AR7100_CPU_PLL_CONFIG, mask, PLL_CONFIG_AHB_DIV_SHIFT, old_ahb_div);
+}
+#endif
+
+void phy_mode_setup()
+{
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+    /*rx delay*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+    /*tx delay*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+
+}
+
+void athrs16_reg_init()
+{
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+#ifdef CFG_BOARD_PB45
+    athrs16_reg_write(0x208, 0x2fd0001);  /* vlan */
+    athrs16_reg_write(0x108, 0x2be0001);  /* vlan */
+#elif CFG_BOARD_AP96
+    athrs16_reg_write(0x8, 0x012e1bea);
+#endif
+
+    athrs16_reg_write(0x100, 0x7e);
+    athrs16_reg_write(0x200, 0x200);
+    athrs16_reg_write(0x300, 0x200);
+    athrs16_reg_write(0x400, 0x200);
+    athrs16_reg_write(0x500, 0x200);
+#ifdef CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x200);
+#elif CFG_BOARD_AP96
+    athrs16_reg_write(0x600, 0x0);
+#endif
+
+    athrs16_reg_write(0x38, 0xc000050e);
+
+#ifdef HEADER_EN
+    athrs16_reg_write(0x104, 0x4804);
+#else
+    athrs16_reg_write(0x104, 0x4004);
+#endif
+
+    athrs16_reg_write(0x60, 0xffffffff);
+    athrs16_reg_write(0x64, 0xaaaaaaaa);
+    athrs16_reg_write(0x68, 0x55555555);
+    athrs16_reg_write(0x6c, 0x0);
+
+    athrs16_reg_write(0x70, 0x41af);
+
+    athr16_init_flag = 1;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs16_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs16_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs16_phy_setup(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint16_t    timeout;
+    int         liveLinks = 0;
+    uint32_t    phyBase = 0;
+    BOOL        foundPhy = FALSE;
+    uint32_t    phyAddr = 0;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+    /*
+     * Wait up to .75 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                       ATHR_PHYADDR(phyUnit),
+                       ATHR_PHY_SPEC_STATUS)));
+    }
+
+    if (ethUnit == ENET_UNIT_LAN) {
+        ag7100_ahb_feq_adjust();
+        athrs16_reg_init();
+        ag7100_ahb_feq_restore();
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs16_phy_is_fdx(int ethUnit)
+{
+    int         phyUnit;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    uint16_t    phyHwStatus;
+    int         ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+	sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs16_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7100_PHY_SPEED_10T, AG7100_PHY_SPEED_100TX;
+*               AG7100_PHY_SPEED_1000T;
+*/
+
+int
+athrs16_phy_speed(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    int         ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return AG7100_PHY_SPEED_1000T;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return AG7100_PHY_SPEED_10T;
+            case 1:
+                return AG7100_PHY_SPEED_100TX;
+            case 2:
+                return AG7100_PHY_SPEED_1000T;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return AG7100_PHY_SPEED_10T;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs16_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+}
+
+static uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;
+}
+
+static void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
diff --git a/board/ar7100/common/athrs16_phy.h b/board/ar7100/common/athrs16_phy.h
new file mode 100644
index 0000000000..b4bf5be25c
--- /dev/null
+++ b/board/ar7100/common/athrs16_phy.h
@@ -0,0 +1,103 @@
+
+#ifndef _ATHRS16_PHY_H
+#define _ATHRS16_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_ATHRS16_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs16_reg_init(void);
+int athrs16_phy_is_up(int unit);
+int athrs16_phy_is_fdx(int unit);
+int athrs16_phy_speed(int unit);
+BOOL athrs16_phy_setup(int unit);
+
+typedef enum {
+    AG7100_PHY_SPEED_10T = 10,
+    AG7100_PHY_SPEED_100TX = 100,
+    AG7100_PHY_SPEED_1000T = 1000,
+}ag7100_phy_speed_t;
+
+#endif
diff --git a/board/ar7100/common/athrs26_phy.c b/board/ar7100/common/athrs26_phy.c
new file mode 100644
index 0000000000..043dc61431
--- /dev/null
+++ b/board/ar7100/common/athrs26_phy.c
@@ -0,0 +1,827 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "ar7100_soc.h"
+#include "athrs26_phy.h"
+
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#ifdef DEBUG
+#define DRV_DEBUG 1
+#endif
+#define DRV_DEBUG 1
+
+#define DRV_DEBUG_PHYERROR  0x00000001
+#define DRV_DEBUG_PHYCHANGE 0x00000002
+#define DRV_DEBUG_PHYSETUP  0x00000004
+
+#if DRV_DEBUG
+int athrPhyDebug = DRV_DEBUG_PHYERROR;
+
+#define DRV_LOG(FLG, X0, X1, X2, X3, X4, X5, X6)    \
+{                                                   \
+    if (athrPhyDebug & (FLG)) {                       \
+        logMsg(X0, X1, X2, X3, X4, X5, X6);         \
+    }                                               \
+}
+
+#define DRV_MSG(x,a,b,c,d,e,f)                      \
+    logMsg(x,a,b,c,d,e,f)
+
+#define DRV_PRINT(FLG, X)                           \
+{                                                   \
+    if (athrPhyDebug & (FLG)) {                       \
+        printf X;                                   \
+    }                                               \
+}
+
+#else /* !DRV_DEBUG */
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+#endif
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_LAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     1,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+#ifdef CFG_ATHRHDR_EN
+typedef struct {
+    uint8_t data[ATHRHDR_MAX_DATA];
+    uint8_t len;
+    uint32_t seq;
+} cmd_resp_t;
+
+typedef struct {
+ uint16_t reg_addr;
+ uint16_t cmd_len;
+ uint8_t *reg_data;
+}cmd_write_t;
+
+static cmd_write_t cmd_write,cmd_read;
+static cmd_resp_t cmd_resp;
+static struct eth_device *lan_mac;
+//static atomic_t seqcnt = ATOMIC_INIT(0);
+static int  seqcnt = 0;
+static int cmd = 1;
+//volatile uchar AthrHdrPkt[60];
+#endif
+
+#define ATHR_GLOBALREGBASE    0
+
+//#define ATHR_PHY_MAX (sizeof(athrPhyInfo) / sizeof(athrPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL       athrs26_phy_is_link_alive(int phyUnit);
+static uint32_t athrs26_reg_read(uint16_t reg_addr);
+static void athrs26_reg_write(uint16_t reg_addr,
+                              uint32_t reg_val);
+
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+
+void athrs26_reg_init()
+{
+
+    athrs26_reg_write(0x200, 0x200);
+    athrs26_reg_write(0x300, 0x200);
+    athrs26_reg_write(0x400, 0x200);
+    athrs26_reg_write(0x500, 0x200);
+    athrs26_reg_write(0x600, 0x7d);
+
+#ifdef S26_VER_1_0
+    phy_reg_write(0, 0, 29, 41);
+    phy_reg_write(0, 0, 30, 0);
+    phy_reg_write(0, 1, 29, 41);
+    phy_reg_write(0, 1, 30, 0);
+    phy_reg_write(0, 2, 29, 41);
+    phy_reg_write(0, 2, 30, 0);
+    phy_reg_write(0, 3, 29, 41);
+    phy_reg_write(0, 3, 30, 0);
+    phy_reg_write(0, 4, 29, 41);
+    phy_reg_write(0, 4, 30, 0);
+#endif
+
+    athrs26_reg_write(0x38, 0xc000050e);
+
+#ifdef CFG_ATHRHDR_EN
+    athrs26_reg_write(0x104, 0x4804);
+#else
+    athrs26_reg_write(0x104, 0x4004);
+#endif
+
+    athrs26_reg_write(0x60, 0xffffffff);
+    athrs26_reg_write(0x64, 0xaaaaaaaa);
+    athrs26_reg_write(0x68, 0x55555555);
+    athrs26_reg_write(0x6c, 0x0);
+
+    athrs26_reg_write(0x70, 0x41af);
+}
+
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/*****************************************************************************
+*Following fucntion accepts ethUnit as parameter and  restarts autonegotiation
+* on corresponding port.
+*
+**/
+individual_phyreset(int ethUnit)
+{   uint32_t    phyBase = 0;
+    uint32_t    phyAddr = 0;
+
+    phyBase = ATHR_PHYBASE(ethUnit);
+    phyAddr = ATHR_PHYADDR(ethUnit);
+    printf("Resetting phy on port %d...\n",ethUnit);
+    phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      (ATHR_CTRL_AUTONEGOTIATION_ENABLE |ATHR_CTRL_RESTART_AUTONEGOTIATION));
+    return 0;
+}
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs26_phy_setup(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint16_t    timeout;
+    int         liveLinks = 0;
+    uint32_t    phyBase = 0;
+    BOOL        foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    uint32_t  regVal;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+    /*
+     * Wait up to .75 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL, &phyHwStatus);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        phy_reg_read(ATHR_PHYBASE(phyUnit), ATHR_PHYADDR(phyUnit),
+                    ATHR_PHY_SPEC_STATUS, &regVal);
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n", ethUnit, regVal));
+    }
+#if 0
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+    athrs26_reg_write(0x200, 0x200);
+    athrs26_reg_write(0x300, 0x200);
+    athrs26_reg_write(0x400, 0x200);
+    athrs26_reg_write(0x500, 0x200);
+    athrs26_reg_write(0x600, 0x200);
+	athrs26_reg_write(0x38, 0x50e);
+#endif
+#ifndef CFG_ATHRHDR_EN
+/* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+        athrs26_reg_init();
+#endif
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1  --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int         phyUnit;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    uint16_t    phyHwStatus;
+    int         ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+	    sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7100_PHY_SPEED_10T, AG7100_PHY_SPEED_100TX;
+*               AG7100_PHY_SPEED_1000T;
+*/
+
+BOOL
+athrs26_phy_speed(int ethUnit)
+{
+    int         phyUnit;
+    uint16_t    phyHwStatus;
+    uint32_t    phyBase;
+    uint32_t    phyAddr;
+    int         ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _100BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phy_reg_read(phyBase, phyAddr,
+                                           ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+                sysMsDelay(10);
+            }while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+            case 2:
+                return _1000BASET;
+            default:
+                DRV_PRINT(DRV_DEBUG_PHYERROR, ("Unkown speed read!\n"));
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs26_phy_is_up(int ethUnit)
+{
+    int             phyUnit;
+    uint16_t        phyHwStatus;
+    athrPhyInfo_t  *lastStatus;
+    int             linkCount   = 0;
+    int             lostLinks   = 0;
+    int             gainedLinks = 0;
+    uint32_t        phyBase;
+    uint32_t        phyAddr;
+#ifdef CFG_ATHRHDR_REG
+    /* if using header to config s26, the link of MAC0 should always be up */
+    if (ethUnit == ENET_UNIT_LAN)
+        return 1;
+#endif
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS, &phyHwStatus);
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS, &phyHwStatus);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+            /* Check for AutoNegotiation complete */
+            if (ATHR_AUTONEG_DONE(phyHwStatus)) {
+                //printk("autoneg done\n");
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if 0
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+#ifdef CFG_ATHRHDR_EN
+void athr_hdr_timeout(void){
+	printf("%s\n",__func__);
+	eth_halt();
+        NetState = NETLOOP_FAIL;
+}
+
+void athr_hdr_handler(uchar *recv_pkt, unsigned dest, unsigned src, unsigned len){
+	header_receive_pkt(recv_pkt);
+	NetState = NETLOOP_SUCCESS;
+}
+static int
+athrs26_header_config_reg (struct eth_device *dev, uint8_t wr_flag,
+                           uint16_t reg_addr, uint16_t cmd_len,
+                           uint8_t *val)
+{
+    at_header_t at_header;
+    reg_cmd_t reg_cmd;
+    uchar *AthrHdrPkt;
+
+    AthrHdrPkt = NetTxPacket - 2;
+
+    if(AthrHdrPkt == NULL) {
+		printf("Null packet\n");
+		return;
+    }
+    memset(AthrHdrPkt,0,62);
+
+    /*fill at_header*/
+    at_header.reserved0 = 0x10;  //default
+    at_header.priority = 0;
+    at_header.type = 0x5;
+    at_header.broadcast = 0;
+    at_header.from_cpu = 1;
+    at_header.reserved1 = 0x01; //default
+    at_header.port_num = 0;
+
+    AthrHdrPkt[2] = at_header.port_num;
+    AthrHdrPkt[2] |= at_header.reserved1 << 4;
+    AthrHdrPkt[2] |= at_header.from_cpu << 6;
+    AthrHdrPkt[2] |= at_header.broadcast << 7;
+
+    AthrHdrPkt[3] = at_header.type;
+    AthrHdrPkt[3] |= at_header.priority << 4;
+    AthrHdrPkt[3] |= at_header.reserved0 << 6;
+
+
+    /*fill reg cmd*/
+    if(cmd_len > 4)
+        cmd_len = 4;//only support 32bits register r/w
+
+    reg_cmd.reg_addr = reg_addr&0x3FFFC;
+    reg_cmd.cmd_len = cmd_len;
+    reg_cmd.cmd = wr_flag;
+    reg_cmd.reserved2 = 0x5; //default
+    reg_cmd.seq_num = seqcnt;
+
+    AthrHdrPkt[4] = reg_cmd.reg_addr & 0xff;
+    AthrHdrPkt[5] = (reg_cmd.reg_addr & 0xff00) >> 8;
+    AthrHdrPkt[6] = (reg_cmd.reg_addr & 0x30000) >> 16;
+    AthrHdrPkt[6] |= reg_cmd.cmd_len << 4;
+    AthrHdrPkt[7] = reg_cmd.cmd << 4;
+    AthrHdrPkt[7] |= reg_cmd.reserved2 << 5;
+    AthrHdrPkt[8] = (reg_cmd.seq_num & 0x7f) << 1;
+    AthrHdrPkt[9] = (reg_cmd.seq_num & 0x7f80) >> 7;
+    AthrHdrPkt[10] = (reg_cmd.seq_num & 0x7f8000) >> 15;
+    AthrHdrPkt[11] = (reg_cmd.seq_num & 0x7f800000) >> 23;
+
+    /*fill reg data*/
+    if(!wr_flag)//write
+        memcpy((AthrHdrPkt + 12), val, cmd_len);
+
+   /* add identify for header */
+    AthrHdrPkt[0] = 0x7f;
+    AthrHdrPkt[1] = 0x5d;
+
+
+    /*start xmit*/
+    if(dev == NULL) {
+	printf("ERROR device not found\n");
+	return -1;
+    }
+    header_xmit(dev, AthrHdrPkt ,62);
+    return 0;
+}
+void athr_hdr_func(void) {
+
+   NetSetTimeout (1 * CFG_HZ,athr_hdr_timeout );
+   NetSetHandler (athr_hdr_handler);
+
+   if(cmd)
+	athrs26_header_config_reg(lan_mac, cmd, cmd_read.reg_addr, cmd_read.cmd_len, cmd_read.reg_data);
+   else
+        athrs26_header_config_reg(lan_mac, cmd, cmd_write.reg_addr, cmd_write.cmd_len, cmd_write.reg_data);
+}
+static int
+athrs26_header_write_reg(uint16_t reg_addr, uint16_t cmd_len, uint8_t *reg_data)
+{
+    int i = 2;
+    cmd_write.reg_addr = reg_addr;
+    cmd_write.cmd_len = cmd_len;
+    cmd_write.reg_data = reg_data;
+    cmd = 0;
+    seqcnt++;
+
+    do {
+	if (NetLoop(ATHRHDR) >= 0) /* polls for read/write ack from PHY */
+	   break;
+    } while (i--);
+
+    return i;
+}
+
+static int
+athrs26_header_read_reg(uint16_t reg_addr, uint16_t cmd_len, uint8_t *reg_data)
+{
+    int i = 2;
+
+    cmd_read.reg_addr = reg_addr;
+    cmd_read.cmd_len = cmd_len;
+    cmd_read.reg_data = reg_data;
+    cmd = 1;
+    seqcnt++;
+
+    do {
+        if (NetLoop(ATHRHDR) >= 0) /* polls for read/write ack from PHY */
+           break;
+    } while (i--);
+
+    if ((i==0) || (seqcnt != cmd_resp.seq) || (cmd_len != cmd_resp.len)) {
+        return -1;
+    }
+    memcpy (cmd_read.reg_data, cmd_resp.data, cmd_len);
+    return 0;
+}
+int header_receive_pkt(uchar *recv_pkt)
+{
+    cmd_resp.len = recv_pkt[4] >> 4;
+    if (cmd_resp.len > 10)
+        goto out;
+
+    cmd_resp.seq = recv_pkt[6] >> 1;
+    cmd_resp.seq |= recv_pkt[7] << 7;
+    cmd_resp.seq |= recv_pkt[8] << 15;
+    cmd_resp.seq |= recv_pkt[9] << 23;
+
+    if (cmd_resp.seq < seqcnt)
+        goto out;
+    memcpy (cmd_resp.data, (recv_pkt + 10), cmd_resp.len);
+out:
+     return 0;
+}
+
+void athrs26_reg_dev(struct eth_device *mac)
+{
+    lan_mac = mac;
+}
+
+#endif
+
+static uint32_t
+athrs26_reg_read(uint16_t reg_addr)
+{
+#ifndef CFG_ATHRHDR_REG
+    uint16_t reg_word_addr = reg_addr / 2, phy_val;
+    uint32_t phy_addr;
+    uint8_t phy_reg;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit 4-0 of reg address*/
+    phy_reg_read(0, phy_addr, phy_reg, &phy_val);
+
+    return phy_val;
+#else
+    uint8_t reg_data[4];
+
+    memset (reg_data, 0, 4);
+    athrs26_header_read_reg(reg_addr, 4, reg_data);
+    return (reg_data[0] | (reg_data[1] << 8) | (reg_data[2] << 16) | (reg_data[3] << 24));
+#endif
+}
+
+static void
+athrs26_reg_write(uint16_t reg_addr, uint32_t reg_val)
+{
+#ifndef CFG_ATHRHDR_REG
+    uint16_t reg_word_addr = reg_addr / 2, phy_val;
+    uint32_t phy_addr;
+    uint8_t phy_reg;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (reg_word_addr >> 8) & 0x1ff;         /* bit16-8 of reg address*/
+    phy_reg_write (0, phy_addr, phy_reg, phy_val);
+
+    /* read register with low address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = reg_word_addr & 0x1f;                 /* bit 4-0 of reg address */
+    phy_reg_write (0, phy_addr, phy_reg, reg_val);
+#else
+    uint8_t reg_data[4];
+
+    memset (reg_data, 0, 4);
+    reg_data[0] = (uint8_t)(0x00ff & reg_val);
+    reg_data[1] = (uint8_t)((0xff00 & reg_val) >> 8);
+    reg_data[2] = (uint8_t)((0xff0000 & reg_val) >> 16);
+    reg_data[3] = (uint8_t)((0xff000000 & reg_val) >> 24);
+
+    athrs26_header_write_reg (reg_addr, 4, reg_data);
+#endif
+
+}
diff --git a/board/ar7100/common/athrs26_phy.h b/board/ar7100/common/athrs26_phy.h
new file mode 100644
index 0000000000..e815678b16
--- /dev/null
+++ b/board/ar7100/common/athrs26_phy.h
@@ -0,0 +1,133 @@
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#ifndef BOOL
+#define BOOL    int
+#define TRUE    1
+#define FALSE   0
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+#undef S26_VER_1_0
+
+#ifdef CFG_ATHRHDR_EN
+
+#include <net.h>
+#define header_xmit(dev,pkt,len) dev->send(dev,pkt,len) //dev_queue_xmit(skb)
+#define header_recv_ack(dev) dev->recv(dev) //dev_queue_xmit(skb)
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} ATHR_HDR_TYPE;
+
+typedef struct {
+    uint16_t    reserved0;
+    uint16_t    priority;
+    uint16_t    type ;
+    uint16_t    broadcast;
+    uint16_t    from_cpu;
+    uint16_t    reserved1;
+    uint16_t    port_num;
+}at_header_t;
+
+typedef struct {
+    uint64_t    reg_addr;
+    uint64_t    reserved0;
+    uint64_t    cmd_len;
+    uint64_t    reserved1;
+    uint64_t    cmd;
+    uint64_t    reserved2;
+    uint64_t    seq_num;
+}reg_cmd_t;
+void athrs26_reg_init(void);
+int header_receive_pkt(uchar *pkt);
+void athrs26_reg_dev(struct eth_device *mac);
+
+#endif
+
+int athrs26_phy_is_up(int unit);
+int athrs26_phy_is_fdx(int unit);
+int athrs26_phy_speed(int unit);
+BOOL athrs26_phy_setup(int unit);
+
+#endif /* _ATHRS26_PHY_H */
diff --git a/board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c b/board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c
new file mode 100644
index 0000000000..1aea750379
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_29a_unmanaged_Atheros_v5.c
@@ -0,0 +1,511 @@
+static unsigned char g5_Plus1_2_29a_unmanaged_Atheros_v5 [] = {
+0x02, 0x0b, 0x1e, 0x8f, 0x2e, 0x12, 0x1f, 0xa1, 0x12, 0x09, 0xbf, 0x50, 0x03, 0x7f, 0x01, 0x22,
+0xe5, 0x2e, 0xb4, 0x06, 0x03, 0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22, 0x02, 0x19, 0xbb, 0x75, 0x22,
+0x01, 0x80, 0xfe, 0x02, 0x14, 0xc6, 0xae, 0x05, 0xad, 0x07, 0x75, 0x3c, 0x06, 0xee, 0x70, 0x04,
+0x7f, 0x01, 0x80, 0x02, 0x7f, 0x00, 0x8f, 0x3d, 0x7b, 0x19, 0x7f, 0x20, 0x02, 0x17, 0x6c, 0x22,
+0x00, 0x01, 0xc1, 0x00, 0x00, 0x00, 0x8f, 0x24, 0x8d, 0x25, 0x8b, 0x26, 0xe5, 0x26, 0x7b, 0xff,
+0x60, 0x06, 0x7a, 0x12, 0x79, 0x74, 0x80, 0x04, 0x7a, 0x12, 0x79, 0x73, 0x12, 0x19, 0xe0, 0x7b,
+0xff, 0x7a, 0x12, 0x79, 0x75, 0x12, 0x19, 0xe0, 0xe5, 0x24, 0xc3, 0x94, 0x07, 0x40, 0x08, 0xe4,
+0xf5, 0x24, 0x75, 0x27, 0x06, 0x80, 0x11, 0xe5, 0x26, 0x60, 0x0a, 0x53, 0x24, 0xfe, 0xe5, 0x24,
+0x04, 0xf5, 0x27, 0x80, 0x03, 0x85, 0x24, 0x27, 0xe5, 0x25, 0xb4, 0xff, 0x05, 0x75, 0x29, 0x07,
+0x80, 0x0f, 0xaf, 0x25, 0x74, 0x01, 0xa8, 0x07, 0x08, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+0x29, 0x7b, 0x0d, 0x12, 0x03, 0x2b, 0x7b, 0x0e, 0x12, 0x03, 0x2b, 0x12, 0x03, 0x66, 0x12, 0x1b,
+0x33, 0x12, 0x09, 0x43, 0xe5, 0x24, 0x90, 0x1f, 0xb6, 0x93, 0xf5, 0x30, 0xe5, 0x26, 0x60, 0x1e,
+0xe5, 0x24, 0x24, 0x01, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x07, 0xee, 0x64, 0x80, 0x94,
+0x80, 0x50, 0x08, 0xe5, 0x24, 0xa3, 0x93, 0xf5, 0x31, 0x80, 0x03, 0x75, 0x31, 0x07, 0x7e, 0x00,
+0x7f, 0x02, 0x7d, 0xff, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x2a, 0x12, 0x05, 0x2e, 0x75, 0x28, 0x02,
+0xe5, 0x28, 0xf4, 0x70, 0x03, 0x02, 0x02, 0x50, 0x74, 0x01, 0x7e, 0x00, 0xa8, 0x28, 0x08, 0x80,
+0x05, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x29, 0x70, 0x03, 0x02, 0x02,
+0x4b, 0xe5, 0x28, 0xd3, 0x94, 0x02, 0x40, 0x03, 0x02, 0x01, 0xec, 0xaf, 0x30, 0x12, 0x1e, 0x80,
+0x40, 0x03, 0x02, 0x02, 0x4b, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x07, 0xe5, 0x31, 0xc3, 0x94,
+0x07, 0x40, 0x07, 0xe5, 0x26, 0x60, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x30, 0x64, 0x06, 0x70, 0x1b,
+0xe5, 0x28, 0x70, 0x09, 0x12, 0x03, 0x5d, 0x20, 0xe4, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x28, 0xb4,
+0x01, 0x09, 0x12, 0x03, 0x5d, 0x20, 0xe6, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x26, 0x60, 0x67, 0xe5,
+0x28, 0xc3, 0x94, 0x02, 0x50, 0x6f, 0xe5, 0x31, 0x64, 0x06, 0x70, 0x25, 0xe5, 0x28, 0x70, 0x0e,
+0x7d, 0x01, 0xaf, 0x31, 0x12, 0x13, 0x0d, 0xee, 0x20, 0xe4, 0x03, 0x02, 0x02, 0x4b, 0xe5, 0x28,
+0xb4, 0x01, 0x0e, 0x7d, 0x01, 0xaf, 0x31, 0x12, 0x13, 0x0d, 0xee, 0x20, 0xe6, 0x03, 0x02, 0x02,
+0x4b, 0x12, 0x03, 0x70, 0xe4, 0xf5, 0x2e, 0xf5, 0x2f, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 0x50, 0x07,
+0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x40, 0x2e, 0xe5, 0x2f, 0xc3, 0x94, 0x03, 0x50, 0x27, 0x7f, 0x0a,
+0x12, 0x1d, 0x5e, 0x05, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x03, 0x70, 0x05,
+0x2f, 0xe4, 0xf5, 0x2e, 0x80, 0xd3, 0xe5, 0x28, 0x44, 0x90, 0xfd, 0xaf, 0x30, 0x12, 0x13, 0xb6,
+0x7f, 0x0a, 0x12, 0x1e, 0xfb, 0xad, 0x28, 0xaf, 0x30, 0x12, 0x10, 0xc8, 0xe5, 0x26, 0x60, 0x07,
+0xad, 0x28, 0xaf, 0x31, 0x12, 0x10, 0xc8, 0x7f, 0x05, 0x12, 0x1e, 0xfb, 0xe5, 0x26, 0x60, 0x41,
+0xad, 0x31, 0x12, 0x03, 0x4e, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80, 0x02,
+0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0xad, 0x30, 0xaf, 0x31, 0x12, 0x0f,
+0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x06, 0x08, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc,
+0x12, 0x1b, 0x4a, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2b, 0x4f, 0xf5, 0x2b, 0x80,
+0x1a, 0xad, 0x30, 0x12, 0x03, 0x4e, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80,
+0x02, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x15, 0x28, 0x02, 0x00, 0xf0,
+0xe4, 0xf5, 0x2d, 0xe5, 0x26, 0x70, 0x07, 0xe5, 0x2d, 0xc3, 0x94, 0x01, 0x40, 0x11, 0xe5, 0x26,
+0x70, 0x03, 0x02, 0x02, 0xfd, 0xe5, 0x2d, 0xc3, 0x94, 0x02, 0x40, 0x03, 0x02, 0x02, 0xfd, 0x12,
+0x1f, 0x19, 0x7f, 0x04, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x04, 0x12, 0x1d,
+0x23, 0xe4, 0xf5, 0x28, 0xe5, 0x28, 0x25, 0xe0, 0xff, 0x74, 0x2a, 0x25, 0x2d, 0xf8, 0xe6, 0xfe,
+0xa8, 0x07, 0x08, 0x80, 0x02, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x03, 0xf5, 0x2c, 0xb4, 0x03, 0x07,
+0x7f, 0x08, 0x12, 0x1d, 0x23, 0x80, 0x24, 0xe5, 0x2c, 0x7b, 0xff, 0x70, 0x09, 0x7a, 0x12, 0x79,
+0x8e, 0x12, 0x19, 0xe0, 0x80, 0x15, 0x7a, 0x12, 0x79, 0x97, 0x12, 0x19, 0xe0, 0xaf, 0x2c, 0xe4,
+0xfc, 0xfd, 0xfe, 0x12, 0x0e, 0x3b, 0x7f, 0x20, 0x12, 0x1f, 0xc8, 0x05, 0x28, 0xe5, 0x28, 0xc3,
+0x94, 0x03, 0x40, 0xb0, 0xe5, 0x2d, 0x70, 0x0b, 0xaf, 0x30, 0x12, 0x1e, 0x80, 0x50, 0x10, 0xaf,
+0x30, 0x80, 0x09, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x05, 0xaf, 0x31, 0x12, 0x1f, 0x2d, 0x05,
+0x24, 0xe5, 0x24, 0xd3, 0x95, 0x27, 0x50, 0x05, 0x05, 0x2d, 0x02, 0x02, 0x53, 0xe5, 0x24, 0xd3,
+0x95, 0x27, 0x50, 0x03, 0x02, 0x00, 0xb4, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x9e, 0x12, 0x19, 0xe0,
+0x7b, 0x0d, 0x12, 0x03, 0x3e, 0x12, 0x09, 0x43, 0x7b, 0x0e, 0x12, 0x03, 0x3e, 0x12, 0x09, 0x43,
+0x12, 0x03, 0x66, 0x7f, 0x5f, 0x12, 0x1b, 0x35, 0x02, 0x09, 0x43, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00, 0x12, 0x09, 0x43, 0x22, 0xe4, 0xfd,
+0x7f, 0x40, 0x12, 0x09, 0x3c, 0x7f, 0x5f, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00, 0x22, 0xaf, 0x30,
+0x12, 0x0f, 0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x06, 0x08, 0x22, 0x7d, 0x01, 0xaf,
+0x30, 0x12, 0x13, 0x0d, 0xee, 0x22, 0x7b, 0x0f, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c, 0x22,
+0xab, 0x28, 0xad, 0x31, 0xaf, 0x30, 0x12, 0x18, 0xd6, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a,
+0x83, 0xe0, 0x22, 0x50, 0x02, 0xe7, 0x22, 0xbb, 0xfe, 0x02, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83,
+0xe4, 0x93, 0x22, 0xbb, 0x01, 0x06, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x02, 0xf7, 0x22,
+0xbb, 0xfe, 0x01, 0xf3, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9,
+0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd,
+0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c,
+0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf,
+0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd,
+0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x08, 0x75, 0x82, 0x00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99,
+0xe5, 0x82, 0x98, 0x40, 0x0c, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc,
+0x0f, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22,
+0xb8, 0x00, 0xc1, 0xb9, 0x00, 0x59, 0xba, 0x00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd,
+0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x03, 0x99, 0x40, 0x04, 0xeb, 0x99, 0xfb, 0x0f,
+0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33,
+0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x05, 0x9b, 0xe9, 0x9a, 0x40, 0x07, 0xec,
+0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0x0f, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75,
+0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33,
+0xc8, 0x10, 0xd7, 0x07, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0x0a, 0xed, 0x9b, 0xfd, 0xec, 0x9a,
+0xfc, 0xe8, 0x99, 0xf8, 0x0f, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8,
+0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce, 0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb,
+0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22,
+0xe8, 0x60, 0x0f, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff,
+0xd8, 0xf1, 0x22, 0xe8, 0x60, 0x0f, 0xef, 0xc3, 0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc, 0x08, 0xe6, 0xfd, 0x08, 0xe6, 0xfe, 0x08, 0xe6,
+0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x01, 0x93, 0xfd, 0x74, 0x02, 0x93, 0xfe, 0x74, 0x03, 0x93,
+0xff, 0x22, 0xec, 0xf6, 0x08, 0xed, 0xf6, 0x08, 0xee, 0xf6, 0x08, 0xef, 0xf6, 0x22, 0xef, 0x4e,
+0x60, 0x12, 0xef, 0x60, 0x01, 0x0e, 0xed, 0xbb, 0x01, 0x0b, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3,
+0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50, 0x07, 0xf7, 0x09, 0xdf, 0xfc, 0xa9, 0xf0, 0x22,
+0xbb, 0xfe, 0xfc, 0xf3, 0x09, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64,
+0x20, 0x60, 0x09, 0xe5, 0x24, 0x64, 0x0d, 0x60, 0x03, 0x7f, 0x01, 0x22, 0xe4, 0xf5, 0x19, 0xfe,
+0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 0x00, 0x79, 0x52, 0x12, 0x05, 0x2e, 0x12, 0x1e, 0xe5, 0x75,
+0x25, 0x0a, 0xe4, 0xf5, 0x27, 0xa8, 0x1a, 0xe6, 0x64, 0x30, 0x70, 0x1b, 0xe8, 0x04, 0xf8, 0xe6,
+0xff, 0x12, 0x1c, 0x44, 0xbf, 0x58, 0x10, 0x75, 0x25, 0x10, 0x05, 0x1a, 0x05, 0x1a, 0xa8, 0x1a,
+0xe6, 0xb4, 0x20, 0x03, 0x7f, 0x01, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 0x20, 0x60, 0x06,
+0xe5, 0x24, 0x64, 0x0d, 0x70, 0x7c, 0xe5, 0x27, 0xd3, 0x94, 0x00, 0x40, 0x6a, 0xe4, 0xf5, 0x35,
+0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x26, 0xe5, 0x26, 0xc3, 0x95, 0x27, 0x50, 0x3a, 0xaf,
+0x25, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0x12, 0x03, 0xa5,
+0xc0, 0x04, 0xa9, 0x05, 0xaa, 0x06, 0xab, 0x07, 0x74, 0x28, 0x25, 0x26, 0xf8, 0xe6, 0xff, 0xe4,
+0xfc, 0xfd, 0xfe, 0xd0, 0x00, 0xeb, 0x2f, 0xf5, 0x35, 0xee, 0x3a, 0xf5, 0x34, 0xed, 0x39, 0xf5,
+0x33, 0xec, 0x38, 0xf5, 0x32, 0x05, 0x26, 0x80, 0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x04, 0x50, 0x17,
+0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xab, 0x19, 0x05, 0x19, 0xeb, 0x25, 0xe0, 0x25,
+0xe0, 0x24, 0x52, 0xf8, 0x12, 0x05, 0x22, 0xe5, 0x24, 0x64, 0x0d, 0x60, 0x03, 0x02, 0x05, 0x7c,
+0xff, 0x22, 0xaf, 0x24, 0x12, 0x19, 0x95, 0x8f, 0x24, 0xe5, 0x24, 0xf4, 0x60, 0x1d, 0xe5, 0x27,
+0xc3, 0x94, 0x0a, 0x50, 0x19, 0xaf, 0x27, 0x05, 0x27, 0x74, 0x28, 0x2f, 0xf8, 0xa6, 0x24, 0xe5,
+0x24, 0xd3, 0x94, 0x09, 0x40, 0x08, 0x75, 0x25, 0x10, 0x80, 0x03, 0x7f, 0x01, 0x22, 0x05, 0x1a,
+0x02, 0x05, 0xa7, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x05, 0x1a, 0x12, 0x05, 0x5a, 0xef, 0x60, 0x03,
+0x7f, 0x01, 0x22, 0xaf, 0x23, 0x12, 0x1c, 0x44, 0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60,
+0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x03, 0x02, 0x07, 0x25, 0x24, 0xfd, 0x60, 0x28,
+0x04, 0x60, 0x03, 0x02, 0x07, 0x60, 0x12, 0x0e, 0xb1, 0x02, 0x07, 0x63, 0x12, 0x1f, 0x0f, 0x12,
+0x1a, 0x15, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xc0, 0x05, 0x12, 0x1a, 0x0d, 0xd0, 0x05, 0xd0, 0x07,
+0x12, 0x09, 0x28, 0x12, 0x1c, 0x12, 0x80, 0x3e, 0xe5, 0x19, 0xc3, 0x94, 0x04, 0x50, 0x03, 0x02,
+0x07, 0x63, 0x12, 0x1a, 0x15, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xc0, 0x05, 0x12, 0x1a, 0x0d, 0xd0,
+0x05, 0xd0, 0x07, 0x12, 0x09, 0x3c, 0x78, 0x5e, 0x12, 0x05, 0x06, 0x12, 0x09, 0x43, 0x02, 0x07,
+0x63, 0x12, 0x1f, 0x0f, 0x78, 0x52, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xd0, 0x07,
+0x12, 0x13, 0x0d, 0x12, 0x1d, 0xfc, 0x12, 0x1f, 0x19, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x03,
+0x40, 0x61, 0x78, 0x52, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x12, 0x1a, 0x05, 0xc0, 0x05, 0x12, 0x1a,
+0x0d, 0xaa, 0x06, 0x78, 0x5e, 0x12, 0x05, 0x06, 0x8e, 0x3d, 0x8f, 0x3e, 0xd0, 0x05, 0xd0, 0x07,
+0x12, 0x19, 0x49, 0x80, 0x3e, 0x78, 0x52, 0x12, 0x05, 0x06, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x04,
+0x70, 0x2b, 0x78, 0x56, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x78, 0x5a, 0x12, 0x05, 0x06, 0xad, 0x07,
+0xd0, 0x07, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x56, 0x12, 0x05, 0x06, 0xc0, 0x07, 0x78, 0x5a, 0x12,
+0x05, 0x06, 0xad, 0x07, 0xd0, 0x07, 0x7b, 0x01, 0x12, 0x00, 0x46, 0x80, 0x06, 0x7f, 0x01, 0x22,
+0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22, 0x8f, 0x2a, 0x7f, 0x01, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30,
+0x04, 0x7e, 0x01, 0x80, 0x02, 0x7e, 0x00, 0xed, 0x54, 0x03, 0xfc, 0xbc, 0x02, 0x04, 0x7c, 0x01,
+0x80, 0x02, 0x7c, 0x00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x07, 0xef, 0x60, 0x04, 0x7d, 0x01, 0x80,
+0x02, 0x7d, 0x00, 0xef, 0x60, 0x03, 0xee, 0x70, 0x03, 0xed, 0x60, 0x04, 0x7f, 0x01, 0x80, 0x02,
+0x7f, 0x00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18, 0x84, 0x7b, 0x08, 0xad, 0x2a, 0x7f,
+0x20, 0x12, 0x09, 0x3c, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff, 0xad, 0x30, 0x7c, 0x00, 0x12, 0x09,
+0x59, 0x12, 0x09, 0x43, 0x7b, 0x0c, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0xe5, 0x34, 0xfe,
+0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 0x00, 0x12, 0x09, 0x59, 0x12, 0x09, 0x43, 0xe5, 0x2b, 0x60,
+0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xb6, 0x12, 0x08, 0x52, 0x7f, 0xff, 0x7e, 0x00, 0x7d, 0x03,
+0x7c, 0x00, 0x12, 0x09, 0x43, 0x85, 0x2a, 0x3c, 0xe4, 0xf5, 0x3d, 0x7b, 0x12, 0x80, 0x1d, 0x75,
+0x2d, 0x17, 0x75, 0x2e, 0x9e, 0x12, 0x08, 0x52, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00,
+0x12, 0x09, 0x43, 0x85, 0x2a, 0x3c, 0x75, 0x3d, 0x01, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12,
+0x17, 0x6c, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x09,
+0x3c, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x05, 0x12, 0x12, 0x09, 0x43, 0x74, 0x04, 0x25,
+0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x05, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x06, 0x40,
+0xd4, 0x22, 0x7b, 0x04, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x22, 0x8f, 0x2b, 0x8c, 0x2c,
+0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x0a, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5,
+0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x11, 0x92, 0x8f, 0x31, 0x8e,
+0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x12, 0x09, 0x1e, 0xe5, 0x31, 0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe,
+0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44, 0x20, 0xfc, 0x12, 0x09,
+0x43, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12, 0x1e, 0xb7, 0x12, 0x09,
+0x1e, 0x7f, 0x30, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x20, 0x12, 0x09, 0x43, 0x85, 0x2b, 0x3c, 0x75,
+0x3d, 0x01, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x02, 0x17, 0x6c, 0xaf, 0x2b, 0x12, 0x1f, 0x6d,
+0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x04, 0xf3, 0xec, 0x44, 0x08, 0xfc, 0xe5, 0x31, 0x4f,
+0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5,
+0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f,
+0xac, 0x2e, 0x12, 0x09, 0x43, 0xaf, 0x2b, 0x12, 0x1b, 0x51, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf,
+0x2b, 0x12, 0x18, 0xfd, 0xe5, 0x2b, 0xb4, 0x06, 0x04, 0xff, 0x12, 0x16, 0xcf, 0x22, 0xe4, 0xfb,
+0xad, 0x2b, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x22, 0xef, 0x2d, 0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8,
+0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b,
+0x8b, 0x4c, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5,
+0x4c, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe, 0xed, 0xff, 0x22, 0x01,
+0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x09, 0x5f, 0xb4, 0x08, 0x00,
+0x50, 0x03, 0x93, 0xff, 0x22, 0x94, 0x08, 0x93, 0xfe, 0x22, 0xef, 0x90, 0x09, 0x5f, 0x93, 0xff,
+0x22, 0x90, 0x09, 0x5f, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x01, 0x0e, 0x89, 0x82, 0x8a, 0x83,
+0xe0, 0x5e, 0xbd, 0x00, 0x02, 0x80, 0x01, 0x4f, 0xf0, 0x22, 0xbb, 0x00, 0x0b, 0xe9, 0xf8, 0xe6,
+0x5e, 0xbd, 0x00, 0x02, 0x80, 0x01, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13,
+0x54, 0x03, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x07, 0x5f, 0xff, 0x12, 0x09, 0x81, 0x22, 0x90,
+0x09, 0x5f, 0xef, 0x93, 0xff, 0xbb, 0x01, 0x07, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x80, 0x06, 0xbb,
+0x00, 0x08, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x02, 0xd3, 0x22, 0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f,
+0x13, 0x13, 0x13, 0x54, 0x03, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x07, 0x5f, 0xff, 0x12, 0x09,
+0xbf, 0x22, 0x8f, 0x36, 0xe5, 0x36, 0x64, 0x06, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17,
+0x12, 0x17, 0xce, 0xaf, 0x36, 0x12, 0x17, 0xfe, 0x12, 0x0a, 0x7f, 0x7a, 0x02, 0x12, 0x0a, 0x75,
+0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0x0f, 0x7a, 0x00, 0x7d,
+0x02, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x01, 0xaf, 0x36, 0x12, 0x17,
+0xce, 0x7b, 0xa4, 0x7a, 0x8f, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x12, 0x0a, 0x7f, 0x7a,
+0x00, 0x12, 0x0a, 0x75, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x36, 0x02, 0x17, 0xce, 0xaf, 0x36,
+0x12, 0x0d, 0xc4, 0xaf, 0x36, 0x12, 0x1c, 0xa3, 0x7b, 0x64, 0x7a, 0x00, 0x7d, 0x1b, 0xaf, 0x36,
+0x12, 0x17, 0xce, 0x75, 0x3d, 0x00, 0x75, 0x3e, 0x0f, 0x7b, 0x03, 0x7a, 0x00, 0x7d, 0x1e, 0xaf,
+0x36, 0x12, 0x19, 0x49, 0x22, 0x7b, 0x12, 0x7d, 0x08, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x7b,
+0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x5c,
+0x12, 0x1a, 0x59, 0x12, 0x0b, 0x0a, 0x12, 0x1f, 0x53, 0x7a, 0xaf, 0x12, 0x0a, 0xec, 0x75, 0x3d,
+0x00, 0x75, 0x3e, 0x0c, 0x7d, 0x11, 0x12, 0x0b, 0x00, 0x7a, 0x8f, 0x12, 0x0a, 0xec, 0x7a, 0xaf,
+0x12, 0x0a, 0xf6, 0x75, 0x3d, 0x00, 0x75, 0x3e, 0x0c, 0x7d, 0x12, 0x12, 0x0b, 0x00, 0x7a, 0x8f,
+0x12, 0x0a, 0xf6, 0x7a, 0xaf, 0x12, 0x0b, 0x14, 0x75, 0x3d, 0x01, 0x75, 0x3e, 0x80, 0x7b, 0x00,
+0x7a, 0x01, 0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x8f, 0x12, 0x0b, 0x14, 0xaf, 0x38,
+0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x64, 0x12, 0x0b, 0x0a, 0x02, 0x1f, 0x65, 0x7b, 0x8a, 0x7d, 0x10,
+0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22,
+0x7b, 0x08, 0x7a, 0x00, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x22, 0x7d, 0x08, 0xaf, 0x38, 0x12, 0x19,
+0x49, 0xaf, 0x38, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x78, 0xfe,
+0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x4f, 0x00, 0x75, 0x50, 0x00, 0x75, 0x81, 0xa7, 0x02, 0x0b, 0x6b,
+0x02, 0x0b, 0xb0, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x03, 0xf6, 0x80, 0x01, 0xf2,
+0x08, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x07, 0x24, 0x0c, 0xc8, 0xc3, 0x33,
+0xc4, 0x54, 0x0f, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x04, 0xf4, 0x56, 0x80, 0x01, 0x46, 0xf6, 0xdf,
+0xe4, 0x80, 0x0b, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x2d, 0xe4, 0x7e,
+0x01, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x09, 0x54, 0x1f, 0xfe, 0xe4, 0x93,
+0xa3, 0x60, 0x01, 0x0e, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3,
+0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca,
+0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe,
+0x12, 0x1f, 0xce, 0x12, 0x18, 0xae, 0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x01,
+0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d, 0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd,
+0x7f, 0xe0, 0x12, 0x10, 0x60, 0x12, 0x1d, 0x4b, 0x12, 0x1c, 0x75, 0xd2, 0xaf, 0x7f, 0x14, 0x12,
+0x1d, 0x5e, 0x12, 0x0d, 0x46, 0x12, 0x1f, 0xcf, 0x12, 0x1a, 0x8f, 0xef, 0x70, 0x03, 0x30, 0x07,
+0x03, 0x12, 0x00, 0x1e, 0x12, 0x1a, 0xd1, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x03, 0x12, 0x00, 0x1e,
+0x12, 0x17, 0x04, 0x12, 0x1c, 0x2b, 0x30, 0x07, 0x16, 0xc2, 0x07, 0x7b, 0x16, 0xe4, 0xfd, 0x7f,
+0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x09, 0x43, 0x12,
+0x0c, 0x3f, 0x30, 0x00, 0x08, 0xc2, 0x00, 0x12, 0x1e, 0x0b, 0x12, 0x1b, 0xde, 0x30, 0x01, 0xd6,
+0xc2, 0x01, 0x12, 0x1d, 0xdd, 0x12, 0x1c, 0x8c, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x12,
+0x15, 0xba, 0x40, 0x03, 0x02, 0x0c, 0xc4, 0x75, 0x1a, 0x62, 0x12, 0x1e, 0xe5, 0x12, 0x1a, 0x1f,
+0x75, 0x27, 0x1e, 0x75, 0x28, 0x72, 0x12, 0x15, 0x05, 0xef, 0x70, 0x04, 0xf5, 0x22, 0x80, 0x4a,
+0x12, 0x1a, 0x1f, 0x75, 0x27, 0x1e, 0x75, 0x28, 0x78, 0x12, 0x15, 0x05, 0xef, 0x70, 0x36, 0x74,
+0x07, 0x25, 0x1a, 0xf5, 0x1a, 0x12, 0x05, 0x5a, 0xef, 0x60, 0x02, 0x80, 0x06, 0xe5, 0x19, 0x64,
+0x02, 0x60, 0x05, 0x75, 0x22, 0x01, 0x80, 0x18, 0x78, 0x52, 0x12, 0x05, 0x06, 0xc0, 0x06, 0xc0,
+0x07, 0x12, 0x1a, 0x05, 0xac, 0x06, 0xd0, 0x07, 0xd0, 0x06, 0x12, 0x0f, 0xf7, 0x12, 0x1d, 0x71,
+0xe4, 0xf5, 0x22, 0x80, 0x05, 0x12, 0x06, 0x63, 0x8f, 0x22, 0xe5, 0x22, 0x60, 0x13, 0x12, 0x1e,
+0xc4, 0x50, 0x05, 0x12, 0x1d, 0xed, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x54, 0x12, 0x19,
+0xe0, 0xe4, 0xf5, 0x18, 0x22, 0x8f, 0x23, 0x74, 0xa0, 0x2f, 0xf8, 0xe6, 0x24, 0xfe, 0x60, 0x2a,
+0x14, 0x60, 0x5c, 0x24, 0x02, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x05, 0x7d, 0x04, 0xaf, 0x23, 0x12,
+0x17, 0xce, 0x7b, 0x00, 0x7a, 0x06, 0x7d, 0x09, 0xaf, 0x23, 0x12, 0x17, 0xce, 0xaf, 0x23, 0x12,
+0x1e, 0x1a, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x02, 0x22, 0x30, 0x09, 0x48, 0xaf, 0x23, 0x12,
+0x1e, 0x9c, 0x50, 0x41, 0x12, 0x1f, 0xa1, 0x7d, 0x01, 0xaf, 0x23, 0x12, 0x09, 0x81, 0xaf, 0x23,
+0x12, 0x1c, 0x5d, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0x8b, 0xad, 0x24, 0xaf, 0x23,
+0x12, 0x15, 0xf6, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x03, 0xaf, 0x23, 0x02, 0x1f, 0xcb, 0x30,
+0x09, 0x13, 0xaf, 0x23, 0x12, 0x1e, 0x9c, 0x40, 0x0c, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x02,
+0xaf, 0x23, 0x12, 0x1b, 0x6e, 0x22, 0x12, 0x00, 0x3f, 0xe4, 0x75, 0x26, 0xc0, 0xf5, 0x25, 0xf5,
+0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x23, 0xaf, 0x22, 0x12, 0x09, 0xdc,
+0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x02, 0x7f, 0x60, 0x12, 0x09, 0x3c, 0xe4, 0x25, 0x22, 0xff, 0xe4,
+0x34, 0x04, 0xfe, 0xe4, 0x34, 0x01, 0xfd, 0xe4, 0x34, 0x01, 0xfc, 0x12, 0x09, 0x43, 0x7f, 0x02,
+0x12, 0x1d, 0x5e, 0x05, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0x0f, 0x40, 0xc9, 0x7f, 0x03, 0x12, 0x1e,
+0xfb, 0x12, 0x1f, 0x93, 0x12, 0x1e, 0xda, 0x7f, 0x04, 0x12, 0x1e, 0xfb, 0x75, 0x3c, 0x01, 0x75,
+0x3d, 0x01, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x6c, 0x7f, 0x14, 0x12, 0x1d, 0x5e,
+0x7b, 0x04, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c, 0x7f, 0x5f, 0x12, 0x1f, 0x9a, 0x12, 0x09,
+0x43, 0x02, 0x14, 0x44, 0x8f, 0x37, 0x12, 0x0a, 0x8b, 0xaf, 0x37, 0x12, 0x12, 0xb1, 0x75, 0x3d,
+0x00, 0x75, 0x3e, 0x40, 0x7b, 0x40, 0x7d, 0x12, 0x12, 0x0e, 0x31, 0x12, 0x1f, 0x5c, 0x75, 0x3d,
+0x0f, 0x75, 0x3e, 0xc0, 0x7b, 0x40, 0x7a, 0x02, 0x7d, 0x16, 0xaf, 0x37, 0x12, 0x19, 0x49, 0x75,
+0x3d, 0x60, 0x75, 0x3e, 0x00, 0x7b, 0x00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x37, 0x12, 0x19, 0x49,
+0x75, 0x3d, 0x00, 0x75, 0x3e, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0x0e, 0x31, 0x12, 0x1f, 0x4a,
+0x75, 0x3d, 0xe0, 0x12, 0x1a, 0x4f, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x12, 0x1f, 0x65,
+0x75, 0x3d, 0xe0, 0x75, 0x3e, 0x0e, 0x7b, 0x02, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x37, 0x02, 0x19,
+0x49, 0x7a, 0x00, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x22, 0x8f, 0x35, 0x8e, 0x34, 0x8d,
+0x33, 0x8c, 0x32, 0xe4, 0xf5, 0x40, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x35, 0xaa, 0x34, 0xa9,
+0x33, 0xa8, 0x32, 0xd3, 0x12, 0x04, 0xcf, 0x40, 0x37, 0xe4, 0x7b, 0x0a, 0xfa, 0xf9, 0xf8, 0xaf,
+0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0x12, 0x04, 0x30, 0xaf, 0x03, 0x74, 0x36, 0x25, 0x40,
+0xf8, 0xa6, 0x07, 0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xe4, 0x7b, 0x0a, 0xfa, 0xf9,
+0xf8, 0x12, 0x04, 0x30, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0x05, 0x40, 0x80, 0xb6,
+0xe5, 0x40, 0x70, 0x05, 0x7f, 0x30, 0x02, 0x1d, 0x84, 0x15, 0x40, 0xe5, 0x40, 0xf4, 0x60, 0x10,
+0x74, 0x36, 0x25, 0x40, 0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0x84, 0x15, 0x40, 0x80, 0xeb,
+0x22, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x29, 0x12, 0x19, 0xe0, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a,
+0x12, 0x79, 0x66, 0x12, 0x19, 0xe0, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x28, 0x12,
+0x1c, 0x12, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x6b, 0x12, 0x19, 0xe0, 0xe4, 0xf5,
+0x24, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x03, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1e, 0x64,
+0x7f, 0x02, 0x12, 0x1d, 0x23, 0x7f, 0x01, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xa8, 0xe4,
+0xfc, 0xfd, 0xfe, 0x12, 0x0e, 0x3b, 0x7f, 0x03, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xaf,
+0x12, 0x1a, 0xb0, 0x12, 0x1f, 0x19, 0x05, 0x24, 0xe5, 0x24, 0xc3, 0x94, 0x07, 0x40, 0xc2, 0x22,
+0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x7f, 0x06, 0x12, 0x1b, 0x35,
+0x12, 0x09, 0x43, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0x75, 0x3d, 0x01, 0xe4, 0xfd,
+0x7f, 0x40, 0x12, 0x17, 0x6c, 0x7f, 0x02, 0x12, 0x1e, 0xfb, 0xaf, 0x33, 0x12, 0x1a, 0x6e, 0x7f,
+0x0a, 0x12, 0x1f, 0x85, 0x12, 0x1e, 0xcf, 0x40, 0x05, 0x12, 0x1f, 0xbd, 0x50, 0xf6, 0x12, 0x1f,
+0xbd, 0x40, 0x13, 0xad, 0x33, 0xaf, 0x32, 0x12, 0x13, 0x66, 0xef, 0x70, 0x04, 0xf5, 0x34, 0x80,
+0x08, 0x75, 0x34, 0x01, 0x80, 0x03, 0x75, 0x34, 0x02, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c,
+0x1b, 0xe4, 0xf5, 0x3d, 0xfd, 0x7f, 0x40, 0x12, 0x17, 0x6c, 0xaf, 0x34, 0x22, 0x8f, 0x0a, 0xc3,
+0xed, 0x94, 0x40, 0xec, 0x94, 0x00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe,
+0xef, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0x0b, 0x80, 0x1c, 0xed, 0x24,
+0x03, 0xff, 0xe4, 0x3c, 0xfe, 0xef, 0x78, 0x02, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30,
+0xe0, 0x05, 0x75, 0x0b, 0x01, 0x80, 0x03, 0xe4, 0xf5, 0x0b, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94,
+0x00, 0x40, 0x0e, 0xae, 0x04, 0xaf, 0x05, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x04, 0xf3, 0x80,
+0x08, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x40, 0x7c, 0x00, 0x12, 0x15, 0x42, 0x7f, 0x20, 0x7e, 0x05,
+0x7d, 0x00, 0x7c, 0x00, 0x02, 0x15, 0x42, 0x8e, 0x23, 0x8f, 0x24, 0x8c, 0x25, 0x8d, 0x26, 0x7f,
+0x0a, 0x12, 0x1d, 0x37, 0x12, 0x1f, 0x37, 0x40, 0x52, 0x12, 0x1e, 0x38, 0xe4, 0xff, 0x12, 0x1d,
+0xa8, 0x7f, 0x02, 0x12, 0x1a, 0x29, 0xe5, 0x23, 0xff, 0x12, 0x1a, 0x29, 0xaf, 0x24, 0x12, 0x1a,
+0x29, 0xe4, 0xf5, 0x27, 0x12, 0x1f, 0x37, 0x40, 0x24, 0x12, 0x1e, 0xc4, 0x50, 0xfb, 0x12, 0x1d,
+0xed, 0x12, 0x1a, 0x29, 0x05, 0x24, 0xe5, 0x24, 0x70, 0x02, 0x05, 0x23, 0xe5, 0x26, 0x15, 0x26,
+0x70, 0x02, 0x15, 0x25, 0x05, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x20, 0x40, 0xd7, 0x7f, 0x01, 0x12,
+0x1d, 0xa8, 0x12, 0x1c, 0xba, 0xef, 0x30, 0xe0, 0xab, 0x80, 0xf7, 0xe4, 0xff, 0x02, 0x1d, 0x37,
+0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39, 0xe5, 0x38, 0x55, 0x3c,
+0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a, 0xf5, 0x36, 0x12, 0x09,
+0x28, 0xa8, 0x04, 0xa9, 0x05, 0xaa, 0x06, 0xab, 0x07, 0xaf, 0x3d, 0xae, 0x3c, 0xad, 0x3b, 0xac,
+0x3a, 0x12, 0x04, 0xc2, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d, 0xfd, 0xe8, 0x5c, 0xfc,
+0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37, 0x4d, 0xf5, 0x37, 0xe5,
+0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0x09, 0x3c, 0xaf, 0x39, 0xae,
+0x38, 0xad, 0x37, 0xac, 0x36, 0x02, 0x09, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x19, 0xad, 0x32,
+0x7f, 0x20, 0x12, 0x09, 0x3c, 0x12, 0x1b, 0x33, 0x12, 0x09, 0x43, 0xe5, 0x33, 0x44, 0x10, 0xfd,
+0xaf, 0x32, 0x12, 0x11, 0x92, 0xef, 0xf5, 0x37, 0xee, 0xf5, 0x36, 0xed, 0x44, 0x01, 0xf5, 0x35,
+0xec, 0x44, 0x10, 0xf5, 0x34, 0x12, 0x11, 0x23, 0xe5, 0x37, 0x44, 0x30, 0xff, 0xe5, 0x36, 0xfe,
+0xe5, 0x35, 0xfd, 0xe5, 0x34, 0x44, 0x20, 0xfc, 0x12, 0x09, 0x43, 0x12, 0x11, 0x23, 0xaf, 0x37,
+0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0x12, 0x09, 0x43, 0xe5, 0x32, 0xb4, 0x06, 0x04, 0xff, 0x12,
+0x16, 0xcf, 0x22, 0xe4, 0xfb, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x22, 0x7f, 0x0a, 0x12,
+0x1d, 0x37, 0xe4, 0xff, 0xfe, 0x12, 0x19, 0x6f, 0xef, 0x7f, 0x00, 0xfe, 0xc0, 0x07, 0xc0, 0x06,
+0x0f, 0x7e, 0x00, 0x12, 0x19, 0x6f, 0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5,
+0x1c, 0x24, 0x01, 0xff, 0xe4, 0x35, 0x1b, 0xfe, 0x12, 0x19, 0x6f, 0x8f, 0x1d, 0xe4, 0xff, 0x12,
+0x1d, 0x37, 0xe5, 0x1c, 0x15, 0x1c, 0x70, 0x02, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95,
+0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11, 0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d,
+0x0f, 0xbf, 0x00, 0x01, 0x0e, 0x80, 0xe6, 0xe5, 0x1d, 0x70, 0x04, 0x7f, 0x01, 0x80, 0x02, 0x7f,
+0x00, 0x22, 0xef, 0x64, 0x06, 0xef, 0x64, 0x06, 0x70, 0x24, 0xbd, 0x10, 0x08, 0x7f, 0x43, 0x7e,
+0x04, 0x7d, 0x04, 0xfc, 0x22, 0xed, 0x70, 0x04, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x04, 0x7f,
+0x42, 0x80, 0x24, 0xbd, 0x01, 0x04, 0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10,
+0x06, 0x7f, 0x44, 0x7e, 0x04, 0x80, 0x12, 0xed, 0x70, 0x08, 0x7f, 0x44, 0x7e, 0x04, 0xfd, 0x7c,
+0x80, 0x22, 0xbd, 0x11, 0x09, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x04, 0x7c, 0x00, 0x22, 0xbd, 0x01,
+0x09, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x01, 0x7d, 0x06,
+0x7c, 0x00, 0x22, 0x8f, 0x2c, 0x7f, 0x32, 0x12, 0x1f, 0x85, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20,
+0x12, 0x09, 0x28, 0x78, 0x08, 0x12, 0x04, 0xe0, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc,
+0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x04, 0xcf, 0x70, 0x32, 0x7b, 0x0c, 0xfd, 0x7f, 0xa0, 0x12,
+0x09, 0x28, 0xc0, 0x04, 0xc0, 0x05, 0xc0, 0x06, 0xc0, 0x07, 0xaf, 0x2c, 0x12, 0x09, 0x7a, 0xe4,
+0xfc, 0xfd, 0xfe, 0xd0, 0x03, 0xd0, 0x02, 0xd0, 0x01, 0xd0, 0x00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb,
+0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x04, 0xcf, 0x60, 0x03, 0x7f, 0x01, 0x22, 0x12, 0x1f, 0xbd, 0x50,
+0xa9, 0x7f, 0x00, 0x22, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
+0x61, 0x6e, 0x64, 0x0d, 0x0a, 0x00, 0x69, 0x64, 0x3a, 0x20, 0x00, 0x00, 0x50, 0x00, 0x4d, 0x00,
+0x50, 0x20, 0x00, 0x00, 0x00, 0x0d, 0x0a, 0x20, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x20, 0x40,
+0x31, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x30, 0x00, 0x4f, 0x6b,
+0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x00, 0x0d, 0x0a,
+0x54, 0x65, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x0d, 0x0a,
+0x00, 0x8f, 0x38, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x59, 0x12, 0x12, 0xf9, 0x12, 0x1f, 0x53, 0x7a,
+0xb6, 0x12, 0x13, 0x03, 0x75, 0x3d, 0xff, 0x75, 0x3e, 0x07, 0x7b, 0x03, 0x7a, 0x00, 0x7d, 0x12,
+0xaf, 0x38, 0x12, 0x19, 0x49, 0x75, 0x3d, 0x00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 0x00, 0x7d,
+0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x96, 0x12, 0x13, 0x03, 0xaf, 0x38, 0x12, 0x1f, 0x5c,
+0x12, 0x1a, 0x64, 0x12, 0x12, 0xf9, 0x02, 0x1f, 0x65, 0x7d, 0x08, 0xaf, 0x38, 0x12, 0x19, 0x49,
+0xaf, 0x38, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x3f, 0x8d,
+0x40, 0x12, 0x1f, 0xa8, 0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xaf, 0x8f, 0x46, 0x7b, 0x01, 0xad,
+0x45, 0x7f, 0x60, 0x12, 0x09, 0x3c, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44,
+0x04, 0xfc, 0xef, 0x45, 0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x09, 0x59, 0x12, 0x09, 0x43, 0xaf,
+0x45, 0x12, 0x1b, 0x13, 0x7b, 0x02, 0xad, 0x45, 0x7f, 0x60, 0x12, 0x09, 0x28, 0x8f, 0x44, 0x8e,
+0x43, 0x8d, 0x42, 0x8c, 0x41, 0xe5, 0x42, 0x54, 0x01, 0xfd, 0xed, 0x70, 0x05, 0xae, 0x43, 0xaf,
+0x44, 0x22, 0xe4, 0xfe, 0xff, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xf5, 0x38, 0xfb, 0x7a, 0x00,
+0x79, 0x39, 0x12, 0x14, 0x86, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x03, 0x75, 0x38, 0x01, 0xe5, 0x39,
+0x65, 0x35, 0x60, 0x03, 0x75, 0x38, 0x01, 0xe5, 0x38, 0x70, 0x25, 0xf5, 0x37, 0x12, 0x1c, 0xfb,
+0xa8, 0x04, 0xa9, 0x05, 0xaa, 0x06, 0xab, 0x07, 0xe4, 0x25, 0x36, 0x12, 0x1b, 0x3c, 0xc3, 0x12,
+0x04, 0xcf, 0x60, 0x03, 0x75, 0x38, 0x01, 0x05, 0x37, 0xe5, 0x37, 0xc3, 0x94, 0x1f, 0x40, 0xdd,
+0x12, 0x1d, 0x0f, 0xaf, 0x38, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17,
+0xce, 0xe5, 0x36, 0x54, 0x03, 0xff, 0x70, 0x06, 0xf5, 0x37, 0xf5, 0x38, 0x80, 0x14, 0xbf, 0x01,
+0x08, 0x75, 0x37, 0x20, 0x75, 0x38, 0x00, 0x80, 0x09, 0xbf, 0x02, 0x06, 0x75, 0x37, 0x00, 0x75,
+0x38, 0x40, 0xe5, 0x36, 0x30, 0xe4, 0x03, 0x43, 0x37, 0x01, 0xe5, 0x36, 0x30, 0xe7, 0x03, 0x43,
+0x37, 0x40, 0xab, 0x38, 0xaa, 0x37, 0xe4, 0xfd, 0xaf, 0x35, 0x02, 0x17, 0xce, 0x8f, 0x27, 0x12,
+0x1f, 0x53, 0x7b, 0xf0, 0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xce, 0x7d, 0x11, 0xaf,
+0x27, 0x12, 0x13, 0x0d, 0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0x0f, 0x48, 0x54,
+0x1f, 0xff, 0xc3, 0x94, 0x10, 0x40, 0x06, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12,
+0x1f, 0x5c, 0x75, 0x3d, 0x03, 0x12, 0x1a, 0x67, 0x7d, 0x0c, 0xaf, 0x27, 0x12, 0x19, 0x49, 0xaf,
+0x27, 0x02, 0x1f, 0x65, 0x75, 0x27, 0x01, 0x7b, 0x06, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c,
+0x7f, 0x80, 0x7e, 0x01, 0x7d, 0x00, 0x7c, 0x00, 0x12, 0x09, 0x43, 0x7b, 0x07, 0xe4, 0xfd, 0x7f,
+0x40, 0x12, 0x09, 0x3c, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34,
+0xc2, 0xfc, 0x12, 0x09, 0x43, 0x7f, 0x01, 0x7e, 0x26, 0x12, 0x16, 0x65, 0x05, 0x27, 0xe5, 0x27,
+0xd3, 0x94, 0x0f, 0x40, 0xc2, 0x22, 0x8b, 0x3a, 0x8a, 0x3b, 0x89, 0x3c, 0xe4, 0xf5, 0x08, 0xf5,
+0x09, 0x12, 0x14, 0xba, 0xe5, 0x3d, 0x54, 0x3f, 0xf5, 0x41, 0x85, 0x3e, 0x42, 0xe5, 0x3b, 0x45,
+0x3c, 0x45, 0x3a, 0x60, 0x10, 0xe5, 0x40, 0x54, 0x07, 0xab, 0x3a, 0xaa, 0x3b, 0xa9, 0x3c, 0x12,
+0x03, 0x93, 0x12, 0x14, 0xba, 0xae, 0x41, 0xaf, 0x42, 0x22, 0x12, 0x1c, 0xfb, 0x8f, 0x40, 0x8e,
+0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29,
+0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x01, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 0x00,
+0xb5, 0x15, 0x08, 0xea, 0xb5, 0x14, 0x04, 0xd2, 0x05, 0x80, 0x0e, 0x74, 0x80, 0x25, 0x1e, 0xf8,
+0xa6, 0x17, 0xe5, 0x1e, 0x04, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x04, 0xc2, 0x99, 0xd2, 0x06,
+0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8b, 0x23, 0x8a, 0x24, 0x89, 0x25, 0xab, 0x26, 0xaa, 0x27, 0xa9,
+0x28, 0x12, 0x03, 0x7a, 0xf5, 0x29, 0x70, 0x02, 0xff, 0x22, 0x74, 0x01, 0x25, 0x28, 0xf5, 0x28,
+0xe4, 0x35, 0x27, 0xf5, 0x27, 0xab, 0x23, 0x05, 0x25, 0xe5, 0x25, 0xaa, 0x24, 0x70, 0x02, 0x05,
+0x24, 0x14, 0xf9, 0x12, 0x03, 0x7a, 0xff, 0x12, 0x1c, 0x44, 0xef, 0x65, 0x29, 0x60, 0xcc, 0x7f,
+0x01, 0x22, 0x8f, 0x3a, 0x8e, 0x39, 0x8d, 0x38, 0x8c, 0x37, 0x20, 0x08, 0x30, 0x7b, 0xc0, 0xad,
+0x0a, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0xaf, 0x3a, 0xae, 0x39, 0xad, 0x38, 0xac, 0x37, 0x12, 0x09,
+0x43, 0xe4, 0x78, 0xa7, 0xf6, 0x7b, 0xc8, 0xad, 0x0a, 0x7f, 0x20, 0x12, 0x09, 0x28, 0xee, 0x30,
+0xe0, 0x0b, 0x78, 0xa7, 0x06, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x08, 0x22, 0x12, 0x19,
+0x23, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x09, 0x7a, 0xef, 0xf4, 0xff, 0xef, 0x55,
+0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a, 0x24, 0x80, 0xfb,
+0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40, 0x12, 0x10, 0x60,
+0x05, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x07, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xc4, 0x50, 0x35, 0x12,
+0x1d, 0xed, 0xef, 0x64, 0x0a, 0x60, 0x2d, 0xbf, 0x08, 0x0b, 0xe5, 0x18, 0xd3, 0x94, 0x00, 0x40,
+0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0x0a, 0xae, 0x18, 0x05, 0x18,
+0x74, 0x62, 0x2e, 0xf8, 0xa6, 0x07, 0xbf, 0x0d, 0x0b, 0xe5, 0x18, 0xb4, 0x1e, 0x04, 0x78, 0x7f,
+0x76, 0x0d, 0xd3, 0x22, 0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x06, 0x60, 0x2d,
+0xe5, 0x26, 0x54, 0x03, 0xff, 0xbf, 0x02, 0x05, 0xaf, 0x25, 0x12, 0x13, 0xfd, 0xe5, 0x26, 0x54,
+0x03, 0x70, 0x1a, 0xaf, 0x25, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49,
+0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49, 0xaf, 0x25, 0x12, 0x1f, 0x65, 0x22, 0xaf, 0x0b,
+0x15, 0x0b, 0xef, 0xd3, 0x94, 0x00, 0x40, 0x0d, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55,
+0x12, 0x15, 0x42, 0x80, 0xe9, 0x30, 0x08, 0x09, 0x75, 0x3c, 0x01, 0x12, 0x16, 0x58, 0xc2, 0x08,
+0x22, 0xe4, 0xf5, 0x3c, 0x12, 0x16, 0x58, 0x22, 0x75, 0x3d, 0x01, 0x7b, 0xc4, 0xad, 0x0a, 0x7f,
+0x20, 0x12, 0x17, 0x6c, 0x22, 0x8e, 0x28, 0x8f, 0x29, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+0x09, 0x3c, 0xae, 0x28, 0xaf, 0x29, 0xe4, 0xfc, 0xfd, 0x12, 0x09, 0x43, 0x7f, 0x0a, 0x12, 0x1f,
+0x85, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x28, 0xef, 0x54, 0x07, 0x60, 0x0a, 0x12,
+0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x04, 0x12, 0x1f, 0xc5, 0x22, 0x8f, 0x28, 0x8d, 0x29, 0xe5, 0x29,
+0xf4, 0x60, 0x29, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x06,
+0x7d, 0x00, 0x7c, 0x00, 0x12, 0x09, 0x43, 0xad, 0x29, 0xaf, 0x28, 0x12, 0x07, 0x66, 0xe4, 0xfd,
+0xaf, 0x28, 0x12, 0x00, 0x26, 0x7d, 0x01, 0xaf, 0x28, 0x12, 0x1e, 0xb7, 0x02, 0x15, 0x7e, 0x8f,
+0x38, 0x75, 0x3c, 0x05, 0x75, 0x3d, 0x01, 0x7b, 0x19, 0xad, 0x38, 0x7f, 0x20, 0x12, 0x17, 0x6c,
+0xe5, 0x38, 0xb4, 0x06, 0x0e, 0x75, 0x3c, 0x02, 0x75, 0x3d, 0x01, 0x7b, 0x19, 0xfd, 0x7f, 0x20,
+0x12, 0x17, 0x6c, 0x7b, 0x05, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x22, 0x12, 0x1f,
+0x9a, 0x02, 0x09, 0x43, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40,
+0x12, 0x09, 0x3c, 0x7f, 0x00, 0x12, 0x1f, 0x9a, 0x12, 0x09, 0x43, 0xe5, 0x22, 0xb4, 0x06, 0x05,
+0x7d, 0x12, 0xff, 0x80, 0x04, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0x8b, 0x05, 0x22, 0xe5, 0x22,
+0xc3, 0x94, 0x07, 0x40, 0xd2, 0x02, 0x15, 0x7e, 0x8b, 0x2b, 0x8a, 0x2c, 0x89, 0x2d, 0xe4, 0xf5,
+0x2e, 0xab, 0x2b, 0x05, 0x2d, 0xe5, 0x2d, 0xaa, 0x2c, 0x70, 0x02, 0x05, 0x2c, 0x14, 0xf9, 0x12,
+0x03, 0x7a, 0xff, 0x12, 0x1b, 0xf9, 0xe5, 0x2e, 0xc3, 0x94, 0x05, 0x50, 0x05, 0x7f, 0x2d, 0x12,
+0x1f, 0xc8, 0x05, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x06, 0x40, 0xd6, 0x22, 0x8f, 0x39, 0x8d, 0x3a,
+0x8b, 0x3b, 0x12, 0x09, 0x28, 0x8f, 0x41, 0x8e, 0x40, 0x8d, 0x3f, 0x8c, 0x3e, 0x7b, 0x00, 0x7a,
+0x00, 0x79, 0x3e, 0xad, 0x3d, 0xaf, 0x3c, 0x12, 0x09, 0xa9, 0xab, 0x3b, 0xad, 0x3a, 0xaf, 0x39,
+0x12, 0x09, 0x3c, 0xaf, 0x41, 0xae, 0x40, 0xad, 0x3f, 0xac, 0x3e, 0x02, 0x09, 0x43, 0x00, 0x00,
+0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x15, 0x00, 0x10, 0x00, 0x15, 0x00, 0x12,
+0x00, 0x15, 0x00, 0x14, 0x00, 0x15, 0x00, 0x00, 0x10, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a,
+0x00, 0x18, 0x00, 0x0b, 0x00, 0x18, 0x00, 0x0c, 0x00, 0x18, 0x00, 0x0d, 0x00, 0x18, 0x8f, 0x3f,
+0x8d, 0x40, 0x8a, 0x41, 0x8b, 0x42, 0x12, 0x1f, 0xa8, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f, 0xaf,
+0x8f, 0x44, 0x7b, 0x01, 0xad, 0x43, 0x7f, 0x60, 0x12, 0x09, 0x3c, 0xab, 0x44, 0xad, 0x40, 0xaf,
+0x42, 0xae, 0x41, 0x12, 0x1f, 0x05, 0x12, 0x09, 0x43, 0xaf, 0x43, 0x02, 0x1b, 0x13, 0x8f, 0x37,
+0x7b, 0x00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0xce, 0x7f, 0x02, 0x12, 0x1d, 0x5e, 0xe4, 0xf5,
+0x38, 0xe4, 0xfd, 0xaf, 0x37, 0x12, 0x13, 0x0d, 0xee, 0x30, 0xe7, 0x10, 0x05, 0x38, 0xe5, 0x38,
+0xd3, 0x94, 0xc8, 0x50, 0x07, 0x7f, 0x01, 0x12, 0x1d, 0x5e, 0x80, 0xe5, 0x22, 0xc1, 0x05, 0xc1,
+0x04, 0x01, 0x1e, 0x00, 0x01, 0x1f, 0x00, 0xc1, 0x00, 0xc1, 0x01, 0x01, 0x0e, 0x00, 0xc1, 0x02,
+0xc1, 0x03, 0x01, 0x0c, 0x0a, 0x01, 0x0d, 0x64, 0xc1, 0x07, 0x01, 0x0f, 0x00, 0xc1, 0x08, 0x01,
+0x18, 0x00, 0x01, 0x4d, 0x00, 0x01, 0x51, 0x00, 0x00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c,
+0x27, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x3c, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28,
+0xac, 0x27, 0x12, 0x09, 0x43, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x09, 0x28, 0xef, 0x54,
+0x03, 0x70, 0xf2, 0x22, 0xe4, 0xfe, 0xee, 0x90, 0x00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6,
+0x04, 0x0e, 0xbe, 0x06, 0xf1, 0xed, 0x24, 0x05, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0x0d,
+0xed, 0x24, 0x04, 0xf8, 0x06, 0xe6, 0x70, 0x05, 0xed, 0x24, 0x03, 0xf8, 0x06, 0x22, 0x7b, 0x17,
+0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0xff, 0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12,
+0x09, 0x43, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x9b, 0x7e, 0x22, 0x7d,
+0x00, 0x7c, 0x00, 0x02, 0x09, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x8b, 0x34, 0x12, 0x1f, 0x2d, 0xaf,
+0x33, 0x12, 0x1f, 0x2d, 0x7f, 0x05, 0x12, 0x1e, 0xfb, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x32,
+0x12, 0x13, 0xb6, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x33, 0x02, 0x13, 0xb6, 0x8f, 0x32, 0xed,
+0x70, 0x02, 0x80, 0x01, 0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x02, 0xf5, 0x37, 0xf5, 0x36, 0x75,
+0x3d, 0xff, 0x75, 0x3c, 0x0f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x02, 0xad, 0x32, 0x7f, 0x20, 0x12,
+0x10, 0x60, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 0x00, 0x03, 0xef, 0x60, 0x0d,
+0x7b, 0x00, 0x7a, 0x00, 0x79, 0x2c, 0x7d, 0x01, 0xaf, 0x2d, 0x12, 0x09, 0x81, 0x05, 0x2d, 0xe5,
+0x2d, 0xc3, 0x94, 0x07, 0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b,
+0x3c, 0x12, 0x13, 0x0d, 0xe5, 0x3e, 0xf4, 0xfd, 0xe5, 0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42,
+0x3c, 0xee, 0x42, 0x3b, 0xab, 0x3c, 0xaa, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x02, 0x17, 0xce, 0x8e,
+0x48, 0x8f, 0x49, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x03, 0x12, 0x1a, 0x29, 0xe5, 0x48, 0xff,
+0x12, 0x1a, 0x29, 0xaf, 0x49, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x4a, 0x7f, 0x01, 0x12,
+0x1d, 0xa8, 0xaf, 0x4a, 0x22, 0x12, 0x1c, 0x44, 0x74, 0x30, 0xd3, 0x9f, 0x50, 0x0a, 0xef, 0x94,
+0x39, 0x50, 0x05, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f, 0x50, 0x0a, 0xef, 0x94,
+0x46, 0x50, 0x05, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92,
+0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x03, 0xd5, 0x0c, 0x15, 0x75, 0x0c, 0x0a, 0xd2, 0x00, 0xd5,
+0x0d, 0x05, 0x75, 0x0d, 0x64, 0xd2, 0x01, 0x30, 0x02, 0x05, 0xd5, 0x0e, 0x02, 0xc2, 0x02, 0x32,
+0x8b, 0x32, 0x8a, 0x33, 0x89, 0x34, 0xab, 0x32, 0xaa, 0x33, 0xa9, 0x34, 0x12, 0x03, 0x7a, 0x60,
+0x13, 0x05, 0x34, 0xe5, 0x34, 0x70, 0x02, 0x05, 0x33, 0x14, 0xf9, 0x12, 0x03, 0x7a, 0xff, 0x12,
+0x1d, 0x84, 0x80, 0xe2, 0x22, 0x78, 0x56, 0x12, 0x05, 0x06, 0xad, 0x07, 0x22, 0x78, 0x5a, 0x12,
+0x05, 0x06, 0xab, 0x07, 0x22, 0x78, 0x52, 0x12, 0x05, 0x06, 0x78, 0x05, 0x02, 0x04, 0xf3, 0xa9,
+0x1a, 0x7a, 0x00, 0x7b, 0x00, 0x75, 0x26, 0xff, 0x22, 0x8f, 0x29, 0xe4, 0xf5, 0x2a, 0xe5, 0x29,
+0x54, 0x80, 0xff, 0x12, 0x1d, 0xba, 0xe5, 0x29, 0x25, 0xe0, 0xf5, 0x29, 0x12, 0x1f, 0x75, 0x12,
+0x1f, 0x7d, 0x05, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x08, 0x40, 0xe3, 0x22, 0x75, 0x3d, 0x60, 0x75,
+0x3e, 0x00, 0x7b, 0x00, 0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3d, 0x02, 0x75, 0x3e, 0x00, 0x7b,
+0x00, 0x7a, 0x02, 0x22, 0x75, 0x3d, 0x02, 0x75, 0x3e, 0x00, 0xe4, 0xfb, 0xfa, 0x22, 0x8f, 0x35,
+0x7d, 0x80, 0x7c, 0x00, 0x12, 0x0f, 0x8d, 0xe4, 0xf5, 0x36, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x3c,
+0x12, 0x15, 0x42, 0x05, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x02, 0x16, 0x2e, 0x7b,
+0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x28, 0xec, 0x54, 0x0f, 0xfc, 0x7b, 0xe9, 0x7a, 0x50,
+0x79, 0x38, 0x78, 0x07, 0xc3, 0x12, 0x04, 0xcf, 0x60, 0x03, 0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22,
+0x8f, 0x32, 0xe5, 0x32, 0xd3, 0x94, 0x09, 0x40, 0x0b, 0xe5, 0x32, 0x75, 0xf0, 0x0a, 0x84, 0x12,
+0x1f, 0x23, 0x80, 0x02, 0x7f, 0x20, 0x12, 0x1d, 0x84, 0xe5, 0x32, 0x12, 0x1f, 0x23, 0x02, 0x1d,
+0x84, 0xe4, 0xf5, 0x4e, 0x7f, 0x03, 0x12, 0x1e, 0xfb, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e,
+0x80, 0x50, 0x05, 0xaf, 0x22, 0x12, 0x09, 0xf2, 0x05, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x07, 0x40,
+0xeb, 0x22, 0xe4, 0xf5, 0x29, 0xe5, 0x2a, 0x25, 0xe0, 0xf5, 0x2a, 0x12, 0x1f, 0x75, 0x12, 0x1d,
+0xcc, 0xef, 0x42, 0x2a, 0x12, 0x1f, 0x7d, 0x05, 0x29, 0xe5, 0x29, 0xc3, 0x94, 0x08, 0x40, 0xe5,
+0xaf, 0x2a, 0x22, 0x8f, 0x47, 0x7f, 0x05, 0x12, 0x1f, 0x85, 0xe4, 0xfb, 0xad, 0x47, 0x7f, 0x60,
+0x12, 0x09, 0x28, 0xef, 0x54, 0x0b, 0x60, 0x0a, 0x12, 0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x02, 0x12,
+0x1f, 0xc5, 0x22, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00, 0x22, 0xff, 0xe4, 0x34, 0x56,
+0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x03, 0xa8, 0x06, 0x08,
+0x22, 0xad, 0x07, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x01, 0x75, 0x36, 0x10, 0xf5, 0x3d,
+0xf5, 0x3c, 0x75, 0x3b, 0x01, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x02, 0x10, 0x60, 0x8f, 0x25,
+0x12, 0x1f, 0xa1, 0xe4, 0xfd, 0x12, 0x09, 0x81, 0xaf, 0x25, 0x12, 0x1e, 0x80, 0x50, 0x05, 0xaf,
+0x25, 0x12, 0x1f, 0x41, 0x7d, 0xff, 0xaf, 0x25, 0x02, 0x1b, 0x8b, 0x8f, 0x26, 0x8d, 0x27, 0xe5,
+0x26, 0x64, 0x05, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 0x00, 0xaf, 0x26, 0x12, 0x1d, 0x96, 0xad,
+0x27, 0xaf, 0x26, 0x12, 0x16, 0x9a, 0x22, 0xbf, 0x06, 0x03, 0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12,
+0x13, 0x0d, 0xef, 0x13, 0x13, 0x13, 0x54, 0x03, 0xfe, 0xef, 0x30, 0xe5, 0x03, 0x43, 0x06, 0x10,
+0xaf, 0x06, 0x22, 0x8f, 0x2b, 0x12, 0x1e, 0x56, 0x7d, 0x01, 0xaf, 0x2b, 0x12, 0x1e, 0xaa, 0xaf,
+0x2b, 0x12, 0x09, 0x7a, 0x12, 0x11, 0xf3, 0xe4, 0xfd, 0xaf, 0x2b, 0x02, 0x1e, 0xaa, 0xe4, 0xf5,
+0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x50, 0x05, 0xaf, 0x22, 0x12, 0x0c, 0xc5, 0x05, 0x22, 0xe5,
+0x22, 0xc3, 0x94, 0x07, 0x40, 0xeb, 0xc2, 0x09, 0x22, 0x8f, 0x2f, 0xe5, 0x2f, 0xc4, 0x54, 0x0f,
+0xff, 0x12, 0x1e, 0x47, 0x12, 0x1d, 0x84, 0xe5, 0x2f, 0x54, 0x0f, 0xff, 0x12, 0x1e, 0x47, 0x02,
+0x1d, 0x84, 0x8f, 0x28, 0x8e, 0x27, 0x8d, 0x26, 0x8c, 0x25, 0x78, 0x10, 0x12, 0x04, 0xe0, 0x12,
+0x1d, 0xfc, 0xe5, 0x28, 0xff, 0xe5, 0x27, 0xfe, 0x02, 0x1d, 0xfc, 0xe4, 0xf5, 0x22, 0xaf, 0x22,
+0x12, 0x1e, 0xf0, 0x74, 0xa0, 0x25, 0x22, 0xf8, 0xa6, 0x07, 0x05, 0x22, 0xe5, 0x22, 0xc3, 0x94,
+0x07, 0x40, 0xeb, 0x22, 0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0x0c,
+0xef, 0x64, 0x80, 0x94, 0xfa, 0x50, 0x05, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12,
+0x1b, 0xa7, 0x8f, 0x26, 0x7d, 0x05, 0xaf, 0x25, 0x12, 0x13, 0x0d, 0xee, 0x30, 0xe2, 0x03, 0x43,
+0x26, 0x20, 0xaf, 0x26, 0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x02, 0x75, 0xcd, 0xff, 0x75, 0xcc,
+0x02, 0x75, 0xc8, 0x34, 0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0x8f, 0xef,
+0x60, 0x05, 0x7f, 0x05, 0x12, 0x1f, 0xc5, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x05, 0x7f, 0x06, 0x12,
+0x1f, 0xc5, 0x22, 0x8f, 0x37, 0x12, 0x1f, 0x5c, 0x75, 0x3d, 0x03, 0x12, 0x1a, 0x5c, 0x7d, 0x0c,
+0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x02, 0x1f, 0x65, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f,
+0x05, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x28, 0x7f, 0x01, 0x12, 0x1d, 0xa8, 0xaf, 0x28,
+0x22, 0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x05, 0x22, 0xe5, 0x22, 0xc3,
+0x94, 0x07, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc,
+0x01, 0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x08, 0xfd, 0xe5, 0x09,
+0xfb, 0x7f, 0x80, 0x12, 0x09, 0x28, 0x05, 0x09, 0xe5, 0x09, 0x70, 0x02, 0x05, 0x08, 0x22, 0xe4,
+0xfb, 0x7d, 0x04, 0x7f, 0x80, 0x12, 0x09, 0x3c, 0x7f, 0x00, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00,
+0x02, 0x09, 0x43, 0x8f, 0x32, 0xaf, 0x32, 0x15, 0x32, 0xef, 0xd3, 0x94, 0x00, 0x40, 0x07, 0x7f,
+0x20, 0x12, 0x1d, 0x84, 0x80, 0xef, 0x22, 0x8f, 0x51, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12,
+0x09, 0x3c, 0xaf, 0x51, 0xe4, 0xfc, 0xfd, 0xfe, 0x02, 0x09, 0x43, 0x53, 0x89, 0x0f, 0x43, 0x89,
+0x10, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x03,
+0xae, 0x07, 0x1f, 0xee, 0xd3, 0x94, 0x00, 0x40, 0x07, 0x30, 0x03, 0xfd, 0xc2, 0x03, 0x80, 0xf0,
+0x22, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x09, 0x3c, 0x7f, 0x01, 0x12, 0x1f, 0x9a, 0x12,
+0x09, 0x43, 0x80, 0xfe, 0xc2, 0x06, 0x8f, 0x99, 0x7f, 0x02, 0x12, 0x1f, 0x85, 0x20, 0x06, 0x05,
+0x12, 0x1f, 0xbd, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1b, 0xc3, 0xad,
+0x2a, 0xac, 0x29, 0xaf, 0x28, 0x02, 0x08, 0x5c, 0xef, 0x60, 0x06, 0xe5, 0x51, 0x44, 0x02, 0x80,
+0x04, 0xe5, 0x51, 0x54, 0xfd, 0xff, 0x12, 0x1d, 0x37, 0x22, 0xef, 0x60, 0x06, 0xe5, 0x51, 0x44,
+0x01, 0x80, 0x04, 0xe5, 0x51, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x37, 0x22, 0x7b, 0x35, 0xe4, 0xfd,
+0x7f, 0xe0, 0x12, 0x09, 0x28, 0xef, 0x54, 0x10, 0xc4, 0x54, 0x0f, 0xff, 0x22, 0x05, 0x0f, 0xe5,
+0x0f, 0xc3, 0x94, 0x96, 0x40, 0x06, 0xe4, 0xf5, 0x0f, 0x12, 0x1f, 0x8c, 0x22, 0x74, 0x80, 0x25,
+0x1f, 0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x04, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x29, 0x8f, 0x2a,
+0xe5, 0x29, 0xff, 0x12, 0x1b, 0xf9, 0xaf, 0x2a, 0x02, 0x1b, 0xf9, 0x05, 0x4d, 0xe5, 0x4d, 0xc3,
+0x94, 0x0a, 0x40, 0x05, 0xe4, 0xf5, 0x4d, 0xd2, 0x09, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 0x00,
+0x7b, 0x00, 0x7a, 0x12, 0xe4, 0xfd, 0x02, 0x19, 0x49, 0x4c, 0x75, 0x74, 0x20, 0x32, 0x2e, 0x32,
+0x39, 0x62, 0x5f, 0x61, 0x74, 0x68, 0x00, 0x00, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x06, 0x12,
+0x1a, 0x29, 0x7f, 0x01, 0x02, 0x1d, 0xa8, 0xef, 0xc3, 0x94, 0x0a, 0xef, 0x50, 0x04, 0x24, 0x30,
+0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x07, 0x75, 0x3c, 0x10, 0xe4, 0xf5, 0x3d, 0xfb, 0x7f,
+0x20, 0x02, 0x17, 0x6c, 0x7d, 0x25, 0x12, 0x18, 0x84, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x25, 0x02,
+0x17, 0x38, 0x45, 0x52, 0x41, 0x53, 0x45, 0x00, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x00,
+0xef, 0x90, 0x1e, 0x95, 0x93, 0xd3, 0x94, 0x01, 0x50, 0x02, 0x80, 0x01, 0xc3, 0x22, 0x00, 0x01,
+0x02, 0x03, 0x04, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x7d, 0x01, 0x12, 0x13,
+0x0d, 0xef, 0x30, 0xe2, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x22, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x0e,
+0xe4, 0xfd, 0x7f, 0xa0, 0x02, 0x17, 0x6c, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x10, 0xe4, 0xfd, 0x7f,
+0x40, 0x02, 0x17, 0x6c, 0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x22, 0xe5,
+0xaa, 0x54, 0x03, 0x60, 0x03, 0xd3, 0x80, 0x01, 0xc3, 0x22, 0x7f, 0x03, 0x7e, 0x00, 0x7d, 0x00,
+0x7c, 0x00, 0x02, 0x18, 0x59, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x04, 0x05, 0x1a, 0x80, 0xf6, 0x22,
+0x12, 0x1e, 0x80, 0x50, 0x03, 0x7f, 0x01, 0x22, 0x7f, 0x00, 0x22, 0xc2, 0x02, 0x8f, 0x0e, 0xd2,
+0x02, 0x20, 0x02, 0xfd, 0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f,
+0x30, 0x12, 0x1d, 0x84, 0x7f, 0x78, 0x02, 0x1d, 0x84, 0x7f, 0x0d, 0x12, 0x1d, 0x84, 0x7f, 0x0a,
+0x02, 0x1d, 0x84, 0x75, 0xf0, 0x0a, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x35, 0x12,
+0x17, 0xfe, 0xaf, 0x35, 0x02, 0x09, 0xf2, 0xd3, 0xe5, 0x26, 0x94, 0x00, 0xe5, 0x25, 0x94, 0x00,
+0x22, 0xef, 0x64, 0x06, 0x60, 0x03, 0x12, 0x1c, 0xa3, 0x22, 0x7b, 0x01, 0x7a, 0x00, 0x7d, 0x1f,
+0x02, 0x17, 0xce, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x02, 0x17, 0xce, 0x7b, 0x30, 0x7a, 0x2a,
+0x7d, 0x1f, 0x02, 0x17, 0xce, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x02, 0x17, 0xce, 0x7d, 0x32, 0x12,
+0x18, 0x84, 0xaf, 0x37, 0x22, 0xe5, 0x51, 0x44, 0x04, 0xff, 0x02, 0x1d, 0x37, 0xe5, 0x51, 0x54,
+0xfb, 0xff, 0x02, 0x1d, 0x37, 0xc2, 0x02, 0x8f, 0x0e, 0xd2, 0x02, 0x22, 0x7f, 0x03, 0x7e, 0x00,
+0x02, 0x16, 0x65, 0x7f, 0x05, 0x7e, 0x00, 0x02, 0x16, 0x65, 0x7e, 0x00, 0x7d, 0x00, 0x7c, 0x00,
+0x22, 0x7b, 0x00, 0x7a, 0x00, 0x79, 0x4e, 0x22, 0xef, 0x90, 0x1e, 0x95, 0x93, 0xff, 0x22, 0xef,
+0x90, 0x1e, 0x8e, 0x93, 0xff, 0x22, 0x00, 0x01, 0x02, 0x03, 0x04, 0x06, 0x05, 0xa2, 0x02, 0xb3,
+0x22, 0x12, 0x11, 0x2d, 0x22, 0xd2, 0x07, 0x22, 0x02, 0x1d, 0x84, 0x02, 0x15, 0x7e, 0x22, 0x22
+};
diff --git a/board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c b/board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c
new file mode 100644
index 0000000000..fe133f380b
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_29b_unmanaged_Atheros_v5.c
@@ -0,0 +1,511 @@
+static unsigned char g5_Plus1_2_29b_unmanaged_Atheros_v5 [] = {
+	0x2, 0xb, 0x1e, 0x8f, 0x2e, 0x12, 0x1f, 0xa1, 0x12, 0x9, 0xbf, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x19, 0xbb, 0x75, 0x22,
+	0x1, 0x80, 0xfe, 0x2, 0x14, 0xc6, 0xae, 0x5, 0xad, 0x7, 0x75, 0x3c, 0x6, 0xee, 0x70, 0x4,
+	0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x3d, 0x7b, 0x19, 0x7f, 0x20, 0x2, 0x17, 0x6c, 0x22,
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x24, 0x8d, 0x25, 0x8b, 0x26, 0xe5, 0x26, 0x7b, 0xff,
+	0x60, 0x6, 0x7a, 0x12, 0x79, 0x74, 0x80, 0x4, 0x7a, 0x12, 0x79, 0x73, 0x12, 0x19, 0xe0, 0x7b,
+	0xff, 0x7a, 0x12, 0x79, 0x75, 0x12, 0x19, 0xe0, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4,
+	0xf5, 0x24, 0x75, 0x27, 0x6, 0x80, 0x11, 0xe5, 0x26, 0x60, 0xa, 0x53, 0x24, 0xfe, 0xe5, 0x24,
+	0x4, 0xf5, 0x27, 0x80, 0x3, 0x85, 0x24, 0x27, 0xe5, 0x25, 0xb4, 0xff, 0x5, 0x75, 0x29, 0x7,
+	0x80, 0xf, 0xaf, 0x25, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+	0x29, 0x7b, 0xd, 0x12, 0x3, 0x2b, 0x7b, 0xe, 0x12, 0x3, 0x2b, 0x12, 0x3, 0x66, 0x12, 0x1b,
+	0x33, 0x12, 0x9, 0x43, 0xe5, 0x24, 0x90, 0x1f, 0xb6, 0x93, 0xf5, 0x30, 0xe5, 0x26, 0x60, 0x1e,
+	0xe5, 0x24, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94,
+	0x80, 0x50, 0x8, 0xe5, 0x24, 0xa3, 0x93, 0xf5, 0x31, 0x80, 0x3, 0x75, 0x31, 0x7, 0x7e, 00,
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x2a, 0x12, 0x5, 0x2e, 0x75, 0x28, 0x2,
+	0xe5, 0x28, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x28, 0x8, 0x80,
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x29, 0x70, 0x3, 0x2, 0x2,
+	0x4b, 0xe5, 0x28, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x30, 0x12, 0x1e, 0x80,
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x7, 0xe5, 0x31, 0xc3, 0x94,
+	0x7, 0x40, 0x7, 0xe5, 0x26, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x1b,
+	0xe5, 0x28, 0x70, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28, 0xb4,
+	0x1, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x26, 0x60, 0x67, 0xe5,
+	0x28, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x31, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x28, 0x70, 0xe,
+	0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0xd, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28,
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0xd, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2,
+	0x4b, 0x12, 0x3, 0x70, 0xe4, 0xf5, 0x2e, 0xf5, 0x2f, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 0x50, 0x7,
+	0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x40, 0x2e, 0xe5, 0x2f, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa,
+	0x12, 0x1d, 0x5e, 0x5, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x70, 0x5,
+	0x2f, 0xe4, 0xf5, 0x2e, 0x80, 0xd3, 0xe5, 0x28, 0x44, 0x90, 0xfd, 0xaf, 0x30, 0x12, 0x13, 0xb6,
+	0x7f, 0xa, 0x12, 0x1e, 0xfb, 0xad, 0x28, 0xaf, 0x30, 0x12, 0x10, 0xc8, 0xe5, 0x26, 0x60, 0x7,
+	0xad, 0x28, 0xaf, 0x31, 0x12, 0x10, 0xc8, 0x7f, 0x5, 0x12, 0x1e, 0xfb, 0xe5, 0x26, 0x60, 0x41,
+	0xad, 0x31, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80, 0x2,
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0xad, 0x30, 0xaf, 0x31, 0x12, 0xf,
+	0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc,
+	0x12, 0x1b, 0x4a, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2b, 0x4f, 0xf5, 0x2b, 0x80,
+	0x1a, 0xad, 0x30, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x4a, 0x80,
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x15, 0x28, 0x2, 00, 0xf0,
+	0xe4, 0xf5, 0x2d, 0xe5, 0x26, 0x70, 0x7, 0xe5, 0x2d, 0xc3, 0x94, 0x1, 0x40, 0x11, 0xe5, 0x26,
+	0x70, 0x3, 0x2, 0x2, 0xfd, 0xe5, 0x2d, 0xc3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x2, 0xfd, 0x12,
+	0x1f, 0x19, 0x7f, 0x4, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x4, 0x12, 0x1d,
+	0x23, 0xe4, 0xf5, 0x28, 0xe5, 0x28, 0x25, 0xe0, 0xff, 0x74, 0x2a, 0x25, 0x2d, 0xf8, 0xe6, 0xfe,
+	0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2c, 0xb4, 0x3, 0x7,
+	0x7f, 0x8, 0x12, 0x1d, 0x23, 0x80, 0x24, 0xe5, 0x2c, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x12, 0x79,
+	0x8e, 0x12, 0x19, 0xe0, 0x80, 0x15, 0x7a, 0x12, 0x79, 0x97, 0x12, 0x19, 0xe0, 0xaf, 0x2c, 0xe4,
+	0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x3b, 0x7f, 0x20, 0x12, 0x1f, 0xc8, 0x5, 0x28, 0xe5, 0x28, 0xc3,
+	0x94, 0x3, 0x40, 0xb0, 0xe5, 0x2d, 0x70, 0xb, 0xaf, 0x30, 0x12, 0x1e, 0x80, 0x50, 0x10, 0xaf,
+	0x30, 0x80, 0x9, 0xaf, 0x31, 0x12, 0x1e, 0x80, 0x50, 0x5, 0xaf, 0x31, 0x12, 0x1f, 0x2d, 0x5,
+	0x24, 0xe5, 0x24, 0xd3, 0x95, 0x27, 0x50, 0x5, 0x5, 0x2d, 0x2, 0x2, 0x53, 0xe5, 0x24, 0xd3,
+	0x95, 0x27, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x9e, 0x12, 0x19, 0xe0,
+	0x7b, 0xd, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x43, 0x7b, 0xe, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x43,
+	0x12, 0x3, 0x66, 0x7f, 0x5f, 0x12, 0x1b, 0x35, 0x2, 0x9, 0x43, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x9, 0x3c, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x43, 0x22, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0x9, 0x3c, 0x7f, 0x5f, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x30,
+	0x12, 0xf, 0x20, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf,
+	0x30, 0x12, 0x13, 0xd, 0xee, 0x22, 0x7b, 0xf, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 0x22,
+	0xab, 0x28, 0xad, 0x31, 0xaf, 0x30, 0x12, 0x18, 0xd6, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a,
+	0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb, 0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83,
+	0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22,
+	0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9,
+	0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd,
+	0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c,
+	0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf,
+	0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd,
+	0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75, 0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+	0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99,
+	0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc,
+	0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22,
+	0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd,
+	0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+	0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf,
+	0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33,
+	0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec,
+	0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75,
+	0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33,
+	0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a,
+	0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8,
+	0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce, 0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb,
+	0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22,
+	0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff,
+	0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3, 0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+	0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc, 0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6,
+	0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93, 0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93,
+	0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8, 0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e,
+	0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb, 0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3,
+	0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50, 0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22,
+	0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64,
+	0x20, 0x60, 0x9, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe,
+	0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79, 0x52, 0x12, 0x5, 0x2e, 0x12, 0x1e, 0xe5, 0x75,
+	0x25, 0xa, 0xe4, 0xf5, 0x27, 0xa8, 0x1a, 0xe6, 0x64, 0x30, 0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6,
+	0xff, 0x12, 0x1c, 0x44, 0xbf, 0x58, 0x10, 0x75, 0x25, 0x10, 0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a,
+	0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 0x20, 0x60, 0x6,
+	0xe5, 0x24, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x27, 0xd3, 0x94, 00, 0x40, 0x6a, 0xe4, 0xf5, 0x35,
+	0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x26, 0xe5, 0x26, 0xc3, 0x95, 0x27, 0x50, 0x3a, 0xaf,
+	0x25, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0x12, 0x3, 0xa5,
+	0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0x74, 0x28, 0x25, 0x26, 0xf8, 0xe6, 0xff, 0xe4,
+	0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5, 0x35, 0xee, 0x3a, 0xf5, 0x34, 0xed, 0x39, 0xf5,
+	0x33, 0xec, 0x38, 0xf5, 0x32, 0x5, 0x26, 0x80, 0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x17,
+	0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xab, 0x19, 0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25,
+	0xe0, 0x24, 0x52, 0xf8, 0x12, 0x5, 0x22, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x2, 0x5, 0x7c,
+	0xff, 0x22, 0xaf, 0x24, 0x12, 0x19, 0x95, 0x8f, 0x24, 0xe5, 0x24, 0xf4, 0x60, 0x1d, 0xe5, 0x27,
+	0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x27, 0x5, 0x27, 0x74, 0x28, 0x2f, 0xf8, 0xa6, 0x24, 0xe5,
+	0x24, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x25, 0x10, 0x80, 0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a,
+	0x2, 0x5, 0xa7, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x5, 0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x3,
+	0x7f, 0x1, 0x22, 0xaf, 0x23, 0x12, 0x1c, 0x44, 0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60,
+	0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x3, 0x2, 0x7, 0x25, 0x24, 0xfd, 0x60, 0x28,
+	0x4, 0x60, 0x3, 0x2, 0x7, 0x60, 0x12, 0xe, 0xb1, 0x2, 0x7, 0x63, 0x12, 0x1f, 0xf, 0x12,
+	0x1a, 0x15, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xc0, 0x5, 0x12, 0x1a, 0xd, 0xd0, 0x5, 0xd0, 0x7,
+	0x12, 0x9, 0x28, 0x12, 0x1c, 0x12, 0x80, 0x3e, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x3, 0x2,
+	0x7, 0x63, 0x12, 0x1a, 0x15, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xc0, 0x5, 0x12, 0x1a, 0xd, 0xd0,
+	0x5, 0xd0, 0x7, 0x12, 0x9, 0x3c, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x12, 0x9, 0x43, 0x2, 0x7,
+	0x63, 0x12, 0x1f, 0xf, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xd0, 0x7,
+	0x12, 0x13, 0xd, 0x12, 0x1d, 0xfc, 0x12, 0x1f, 0x19, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3,
+	0x40, 0x61, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x5, 0xc0, 0x5, 0x12, 0x1a,
+	0xd, 0xaa, 0x6, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x8e, 0x3d, 0x8f, 0x3e, 0xd0, 0x5, 0xd0, 0x7,
+	0x12, 0x19, 0x49, 0x80, 0x3e, 0x78, 0x52, 0x12, 0x5, 0x6, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x4,
+	0x70, 0x2b, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12, 0x5, 0x6, 0xad, 0x7,
+	0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12,
+	0x5, 0x6, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1, 0x12, 00, 0x46, 0x80, 0x6, 0x7f, 0x1, 0x22,
+	0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a, 0x7f, 0x1, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30,
+	0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed, 0x54, 0x3, 0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1,
+	0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x7, 0xef, 0x60, 0x4, 0x7d, 0x1, 0x80,
+	0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70, 0x3, 0xed, 0x60, 0x4, 0x7f, 0x1, 0x80, 0x2,
+	0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18, 0x84, 0x7b, 0x8, 0xad, 0x2a, 0x7f,
+	0x20, 0x12, 0x9, 0x3c, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff, 0xad, 0x30, 0x7c, 00, 0x12, 0x9,
+	0x59, 0x12, 0x9, 0x43, 0x7b, 0xc, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0xe5, 0x34, 0xfe,
+	0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12, 0x9, 0x59, 0x12, 0x9, 0x43, 0xe5, 0x2b, 0x60,
+	0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xb6, 0x12, 0x8, 0x52, 0x7f, 0xff, 0x7e, 00, 0x7d, 0x3,
+	0x7c, 00, 0x12, 0x9, 0x43, 0x85, 0x2a, 0x3c, 0xe4, 0xf5, 0x3d, 0x7b, 0x12, 0x80, 0x1d, 0x75,
+	0x2d, 0x17, 0x75, 0x2e, 0x9e, 0x12, 0x8, 0x52, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00,
+	0x12, 0x9, 0x43, 0x85, 0x2a, 0x3c, 0x75, 0x3d, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12,
+	0x17, 0x6c, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9,
+	0x3c, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x5, 0x12, 0x12, 0x9, 0x43, 0x74, 0x4, 0x25,
+	0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x5, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40,
+	0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x22, 0x8f, 0x2b, 0x8c, 0x2c,
+	0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0xa, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5,
+	0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x11, 0x92, 0x8f, 0x31, 0x8e,
+	0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x12, 0x9, 0x1e, 0xe5, 0x31, 0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe,
+	0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44, 0x20, 0xfc, 0x12, 0x9,
+	0x43, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12, 0x1e, 0xb7, 0x12, 0x9,
+	0x1e, 0x7f, 0x30, 0x7e, 00, 0x7d, 00, 0x7c, 0x20, 0x12, 0x9, 0x43, 0x85, 0x2b, 0x3c, 0x75,
+	0x3d, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x6c, 0xaf, 0x2b, 0x12, 0x1f, 0x6d,
+	0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x4, 0xf3, 0xec, 0x44, 0x8, 0xfc, 0xe5, 0x31, 0x4f,
+	0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5,
+	0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f,
+	0xac, 0x2e, 0x12, 0x9, 0x43, 0xaf, 0x2b, 0x12, 0x1b, 0x51, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf,
+	0x2b, 0x12, 0x18, 0xfd, 0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x16, 0xcf, 0x22, 0xe4, 0xfb,
+	0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x22, 0xef, 0x2d, 0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8,
+	0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b,
+	0x8b, 0x4c, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5,
+	0x4c, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe, 0xed, 0xff, 0x22, 0x1,
+	0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x9, 0x5f, 0xb4, 0x8, 00,
+	0x50, 0x3, 0x93, 0xff, 0x22, 0x94, 0x8, 0x93, 0xfe, 0x22, 0xef, 0x90, 0x9, 0x5f, 0x93, 0xff,
+	0x22, 0x90, 0x9, 0x5f, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x1, 0xe, 0x89, 0x82, 0x8a, 0x83,
+	0xe0, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22, 0xbb, 00, 0xb, 0xe9, 0xf8, 0xe6,
+	0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13,
+	0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 0x81, 0x22, 0x90,
+	0x9, 0x5f, 0xef, 0x93, 0xff, 0xbb, 0x1, 0x7, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x80, 0x6, 0xbb,
+	00, 0x8, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22, 0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f,
+	0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9,
+	0xbf, 0x22, 0x8f, 0x36, 0xe5, 0x36, 0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17,
+	0x12, 0x17, 0xce, 0xaf, 0x36, 0x12, 0x17, 0xfe, 0x12, 0xa, 0x7f, 0x7a, 0x2, 0x12, 0xa, 0x75,
+	0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0xf, 0x7a, 00, 0x7d,
+	0x2, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x36, 0x12, 0x17,
+	0xce, 0x7b, 0xa4, 0x7a, 0x8f, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x12, 0xa, 0x7f, 0x7a,
+	00, 0x12, 0xa, 0x75, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x36, 0x2, 0x17, 0xce, 0xaf, 0x36,
+	0x12, 0xd, 0xc4, 0xaf, 0x36, 0x12, 0x1c, 0xa3, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x36,
+	0x12, 0x17, 0xce, 0x75, 0x3d, 00, 0x75, 0x3e, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf,
+	0x36, 0x12, 0x19, 0x49, 0x22, 0x7b, 0x12, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x7b,
+	0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x5c,
+	0x12, 0x1a, 0x59, 0x12, 0xb, 0xa, 0x12, 0x1f, 0x53, 0x7a, 0xaf, 0x12, 0xa, 0xec, 0x75, 0x3d,
+	00, 0x75, 0x3e, 0xc, 0x7d, 0x11, 0x12, 0xb, 00, 0x7a, 0x8f, 0x12, 0xa, 0xec, 0x7a, 0xaf,
+	0x12, 0xa, 0xf6, 0x75, 0x3d, 00, 0x75, 0x3e, 0xc, 0x7d, 0x12, 0x12, 0xb, 00, 0x7a, 0x8f,
+	0x12, 0xa, 0xf6, 0x7a, 0xaf, 0x12, 0xb, 0x14, 0x75, 0x3d, 0x1, 0x75, 0x3e, 0x80, 0x7b, 00,
+	0x7a, 0x1, 0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x8f, 0x12, 0xb, 0x14, 0xaf, 0x38,
+	0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x64, 0x12, 0xb, 0xa, 0x2, 0x1f, 0x65, 0x7b, 0x8a, 0x7d, 0x10,
+	0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22,
+	0x7b, 0x8, 0x7a, 00, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x22, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19,
+	0x49, 0xaf, 0x38, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x78, 0xfe,
+	0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x4f, 00, 0x75, 0x50, 00, 0x75, 0x81, 0xa7, 0x2, 0xb, 0x6b,
+	0x2, 0xb, 0xb0, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2,
+	0x8, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33,
+	0xc4, 0x54, 0xf, 0x44, 0x20, 0xc8, 0x83, 0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf,
+	0xe4, 0x80, 0xb, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x2d, 0xe4, 0x7e,
+	0x1, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93,
+	0xa3, 0x60, 0x1, 0xe, 0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3,
+	0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca,
+	0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe,
+	0x12, 0x1f, 0xce, 0x12, 0x18, 0xae, 0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1,
+	0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d, 0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd,
+	0x7f, 0xe0, 0x12, 0x10, 0x60, 0x12, 0x1d, 0x4b, 0x12, 0x1c, 0x75, 0xd2, 0xaf, 0x7f, 0x14, 0x12,
+	0x1d, 0x5e, 0x12, 0xd, 0x46, 0x12, 0x1f, 0xcf, 0x12, 0x1a, 0x8f, 0xef, 0x70, 0x3, 0x30, 0x7,
+	0x3, 0x12, 00, 0x1e, 0x12, 0x1a, 0xd1, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x3, 0x12, 00, 0x1e,
+	0x12, 0x17, 0x4, 0x12, 0x1c, 0x2b, 0x30, 0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f,
+	0xe0, 0x12, 0x9, 0x3c, 0x7f, 00, 0x7e, 00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x43, 0x12,
+	0xc, 0x3f, 0x30, 00, 0x8, 0xc2, 00, 0x12, 0x1e, 0xb, 0x12, 0x1b, 0xde, 0x30, 0x1, 0xd6,
+	0xc2, 0x1, 0x12, 0x1d, 0xdd, 0x12, 0x1c, 0x8c, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x12,
+	0x15, 0xba, 0x40, 0x3, 0x2, 0xc, 0xc4, 0x75, 0x1a, 0x62, 0x12, 0x1e, 0xe5, 0x12, 0x1a, 0x1f,
+	0x75, 0x27, 0x1e, 0x75, 0x28, 0x72, 0x12, 0x15, 0x5, 0xef, 0x70, 0x4, 0xf5, 0x22, 0x80, 0x4a,
+	0x12, 0x1a, 0x1f, 0x75, 0x27, 0x1e, 0x75, 0x28, 0x78, 0x12, 0x15, 0x5, 0xef, 0x70, 0x36, 0x74,
+	0x7, 0x25, 0x1a, 0xf5, 0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x2, 0x80, 0x6, 0xe5, 0x19, 0x64,
+	0x2, 0x60, 0x5, 0x75, 0x22, 0x1, 0x80, 0x18, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x6, 0xc0,
+	0x7, 0x12, 0x1a, 0x5, 0xac, 0x6, 0xd0, 0x7, 0xd0, 0x6, 0x12, 0xf, 0xf7, 0x12, 0x1d, 0x71,
+	0xe4, 0xf5, 0x22, 0x80, 0x5, 0x12, 0x6, 0x63, 0x8f, 0x22, 0xe5, 0x22, 0x60, 0x13, 0x12, 0x1e,
+	0xc4, 0x50, 0x5, 0x12, 0x1d, 0xed, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x54, 0x12, 0x19,
+	0xe0, 0xe4, 0xf5, 0x18, 0x22, 0x8f, 0x23, 0x74, 0xa0, 0x2f, 0xf8, 0xe6, 0x24, 0xfe, 0x60, 0x2a,
+	0x14, 0x60, 0x5c, 0x24, 0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d, 0x4, 0xaf, 0x23, 0x12,
+	0x17, 0xce, 0x7b, 00, 0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17, 0xce, 0xaf, 0x23, 0x12,
+	0x1e, 0x1a, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9, 0x48, 0xaf, 0x23, 0x12,
+	0x1e, 0x9c, 0x50, 0x41, 0x12, 0x1f, 0xa1, 0x7d, 0x1, 0xaf, 0x23, 0x12, 0x9, 0x81, 0xaf, 0x23,
+	0x12, 0x1c, 0x5d, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0x8b, 0xad, 0x24, 0xaf, 0x23,
+	0x12, 0x15, 0xf6, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23, 0x2, 0x1f, 0xcb, 0x30,
+	0x9, 0x13, 0xaf, 0x23, 0x12, 0x1e, 0x9c, 0x40, 0xc, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x2,
+	0xaf, 0x23, 0x12, 0x1b, 0x6e, 0x22, 0x12, 00, 0x3f, 0xe4, 0x75, 0x26, 0xc0, 0xf5, 0x25, 0xf5,
+	0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf, 0x22, 0x12, 0x9, 0xdc,
+	0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x2, 0x7f, 0x60, 0x12, 0x9, 0x3c, 0xe4, 0x25, 0x22, 0xff, 0xe4,
+	0x34, 0x4, 0xfe, 0xe4, 0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12, 0x9, 0x43, 0x7f, 0x2,
+	0x12, 0x1d, 0x5e, 0x5, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9, 0x7f, 0x3, 0x12, 0x1e,
+	0xfb, 0x12, 0x1f, 0x93, 0x12, 0x1e, 0xda, 0x7f, 0x4, 0x12, 0x1e, 0xfb, 0x75, 0x3c, 0x1, 0x75,
+	0x3d, 0x1, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x6c, 0x7f, 0x14, 0x12, 0x1d, 0x5e,
+	0x7b, 0x4, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 0x7f, 0x5f, 0x12, 0x1f, 0x9a, 0x12, 0x9,
+	0x43, 0x2, 0x14, 0x44, 0x8f, 0x37, 0x12, 0xa, 0x8b, 0xaf, 0x37, 0x12, 0x12, 0xb1, 0x75, 0x3d,
+	00, 0x75, 0x3e, 0x40, 0x7b, 0x40, 0x7d, 0x12, 0x12, 0xe, 0x31, 0x12, 0x1f, 0x5c, 0x75, 0x3d,
+	0xf, 0x75, 0x3e, 0xc0, 0x7b, 0x40, 0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x37, 0x12, 0x19, 0x49, 0x75,
+	0x3d, 0x60, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x37, 0x12, 0x19, 0x49,
+	0x75, 0x3d, 00, 0x75, 0x3e, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0xe, 0x31, 0x12, 0x1f, 0x4a,
+	0x75, 0x3d, 0xe0, 0x12, 0x1a, 0x4f, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x12, 0x1f, 0x65,
+	0x75, 0x3d, 0xe0, 0x75, 0x3e, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x37, 0x2, 0x19,
+	0x49, 0x7a, 00, 0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x22, 0x8f, 0x35, 0x8e, 0x34, 0x8d,
+	0x33, 0x8c, 0x32, 0xe4, 0xf5, 0x40, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x35, 0xaa, 0x34, 0xa9,
+	0x33, 0xa8, 0x32, 0xd3, 0x12, 0x4, 0xcf, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf,
+	0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0x12, 0x4, 0x30, 0xaf, 0x3, 0x74, 0x36, 0x25, 0x40,
+	0xf8, 0xa6, 0x7, 0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xe4, 0x7b, 0xa, 0xfa, 0xf9,
+	0xf8, 0x12, 0x4, 0x30, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0x5, 0x40, 0x80, 0xb6,
+	0xe5, 0x40, 0x70, 0x5, 0x7f, 0x30, 0x2, 0x1d, 0x84, 0x15, 0x40, 0xe5, 0x40, 0xf4, 0x60, 0x10,
+	0x74, 0x36, 0x25, 0x40, 0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0x84, 0x15, 0x40, 0x80, 0xeb,
+	0x22, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x29, 0x12, 0x19, 0xe0, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a,
+	0x12, 0x79, 0x66, 0x12, 0x19, 0xe0, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x28, 0x12,
+	0x1c, 0x12, 0x12, 0x1f, 0x19, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x6b, 0x12, 0x19, 0xe0, 0xe4, 0xf5,
+	0x24, 0xaf, 0x24, 0x12, 0x1a, 0xb0, 0x7f, 0x3, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1e, 0x64,
+	0x7f, 0x2, 0x12, 0x1d, 0x23, 0x7f, 0x1, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xa8, 0xe4,
+	0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x3b, 0x7f, 0x3, 0x12, 0x1d, 0x23, 0xaf, 0x24, 0x12, 0x1f, 0xaf,
+	0x12, 0x1a, 0xb0, 0x12, 0x1f, 0x19, 0x5, 0x24, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0xc2, 0x22,
+	0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x7f, 0x6, 0x12, 0x1b, 0x35,
+	0x12, 0x9, 0x43, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0x75, 0x3d, 0x1, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0x17, 0x6c, 0x7f, 0x2, 0x12, 0x1e, 0xfb, 0xaf, 0x33, 0x12, 0x1a, 0x6e, 0x7f,
+	0xa, 0x12, 0x1f, 0x85, 0x12, 0x1e, 0xcf, 0x40, 0x5, 0x12, 0x1f, 0xbd, 0x50, 0xf6, 0x12, 0x1f,
+	0xbd, 0x40, 0x13, 0xad, 0x33, 0xaf, 0x32, 0x12, 0x13, 0x66, 0xef, 0x70, 0x4, 0xf5, 0x34, 0x80,
+	0x8, 0x75, 0x34, 0x1, 0x80, 0x3, 0x75, 0x34, 0x2, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c,
+	0x1b, 0xe4, 0xf5, 0x3d, 0xfd, 0x7f, 0x40, 0x12, 0x17, 0x6c, 0xaf, 0x34, 0x22, 0x8f, 0xa, 0xc3,
+	0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe,
+	0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24,
+	0x3, 0xff, 0xe4, 0x3c, 0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30,
+	0xe0, 0x5, 0x75, 0xb, 0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94,
+	00, 0x40, 0xe, 0xae, 0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xf3, 0x80,
+	0x8, 0x7f, 00, 0x7e, 00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x15, 0x42, 0x7f, 0x20, 0x7e, 0x5,
+	0x7d, 00, 0x7c, 00, 0x2, 0x15, 0x42, 0x8e, 0x23, 0x8f, 0x24, 0x8c, 0x25, 0x8d, 0x26, 0x7f,
+	0xa, 0x12, 0x1d, 0x37, 0x12, 0x1f, 0x37, 0x40, 0x52, 0x12, 0x1e, 0x38, 0xe4, 0xff, 0x12, 0x1d,
+	0xa8, 0x7f, 0x2, 0x12, 0x1a, 0x29, 0xe5, 0x23, 0xff, 0x12, 0x1a, 0x29, 0xaf, 0x24, 0x12, 0x1a,
+	0x29, 0xe4, 0xf5, 0x27, 0x12, 0x1f, 0x37, 0x40, 0x24, 0x12, 0x1e, 0xc4, 0x50, 0xfb, 0x12, 0x1d,
+	0xed, 0x12, 0x1a, 0x29, 0x5, 0x24, 0xe5, 0x24, 0x70, 0x2, 0x5, 0x23, 0xe5, 0x26, 0x15, 0x26,
+	0x70, 0x2, 0x15, 0x25, 0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x20, 0x40, 0xd7, 0x7f, 0x1, 0x12,
+	0x1d, 0xa8, 0x12, 0x1c, 0xba, 0xef, 0x30, 0xe0, 0xab, 0x80, 0xf7, 0xe4, 0xff, 0x2, 0x1d, 0x37,
+	0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39, 0xe5, 0x38, 0x55, 0x3c,
+	0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a, 0xf5, 0x36, 0x12, 0x9,
+	0x28, 0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d, 0xae, 0x3c, 0xad, 0x3b, 0xac,
+	0x3a, 0x12, 0x4, 0xc2, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d, 0xfd, 0xe8, 0x5c, 0xfc,
+	0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37, 0x4d, 0xf5, 0x37, 0xe5,
+	0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0x9, 0x3c, 0xaf, 0x39, 0xae,
+	0x38, 0xad, 0x37, 0xac, 0x36, 0x2, 0x9, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x19, 0xad, 0x32,
+	0x7f, 0x20, 0x12, 0x9, 0x3c, 0x12, 0x1b, 0x33, 0x12, 0x9, 0x43, 0xe5, 0x33, 0x44, 0x10, 0xfd,
+	0xaf, 0x32, 0x12, 0x11, 0x92, 0xef, 0xf5, 0x37, 0xee, 0xf5, 0x36, 0xed, 0x44, 0x1, 0xf5, 0x35,
+	0xec, 0x44, 0x10, 0xf5, 0x34, 0x12, 0x11, 0x23, 0xe5, 0x37, 0x44, 0x30, 0xff, 0xe5, 0x36, 0xfe,
+	0xe5, 0x35, 0xfd, 0xe5, 0x34, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x43, 0x12, 0x11, 0x23, 0xaf, 0x37,
+	0xae, 0x36, 0xad, 0x35, 0xac, 0x34, 0x12, 0x9, 0x43, 0xe5, 0x32, 0xb4, 0x6, 0x4, 0xff, 0x12,
+	0x16, 0xcf, 0x22, 0xe4, 0xfb, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x22, 0x7f, 0xa, 0x12,
+	0x1d, 0x37, 0xe4, 0xff, 0xfe, 0x12, 0x19, 0x6f, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6,
+	0xf, 0x7e, 00, 0x12, 0x19, 0x6f, 0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5,
+	0x1c, 0x24, 0x1, 0xff, 0xe4, 0x35, 0x1b, 0xfe, 0x12, 0x19, 0x6f, 0x8f, 0x1d, 0xe4, 0xff, 0x12,
+	0x1d, 0x37, 0xe5, 0x1c, 0x15, 0x1c, 0x70, 0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95,
+	0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11, 0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d,
+	0xf, 0xbf, 00, 0x1, 0xe, 0x80, 0xe6, 0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f,
+	00, 0x22, 0xef, 0x64, 0x6, 0xef, 0x64, 0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e,
+	0x4, 0x7d, 0x4, 0xfc, 0x22, 0xed, 0x70, 0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f,
+	0x42, 0x80, 0x24, 0xbd, 0x1, 0x4, 0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10,
+	0x6, 0x7f, 0x44, 0x7e, 0x4, 0x80, 0x12, 0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c,
+	0x80, 0x22, 0xbd, 0x11, 0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1,
+	0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6,
+	0x7c, 00, 0x22, 0x8f, 0x2c, 0x7f, 0x32, 0x12, 0x1f, 0x85, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20,
+	0x12, 0x9, 0x28, 0x78, 0x8, 0x12, 0x4, 0xe0, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc,
+	0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4, 0xcf, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12,
+	0x9, 0x28, 0xc0, 0x4, 0xc0, 0x5, 0xc0, 0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0x9, 0x7a, 0xe4,
+	0xfc, 0xfd, 0xfe, 0xd0, 0x3, 0xd0, 0x2, 0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb,
+	0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0xbd, 0x50,
+	0xa9, 0x7f, 00, 0x22, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
+	0x61, 0x6e, 0x64, 0xd, 0xa, 00, 0x69, 0x64, 0x3a, 0x20, 00, 00, 0x50, 00, 0x4d, 00,
+	0x50, 0x20, 00, 00, 00, 0xd, 0xa, 0x20, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x20, 0x40,
+	0x31, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x30, 00, 0x4f, 0x6b,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 00, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 00, 0xd, 0xa,
+	0x54, 0x65, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0xd, 0xa,
+	00, 0x8f, 0x38, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x59, 0x12, 0x12, 0xf9, 0x12, 0x1f, 0x53, 0x7a,
+	0xb6, 0x12, 0x13, 0x3, 0x75, 0x3d, 0xff, 0x75, 0x3e, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12,
+	0xaf, 0x38, 0x12, 0x19, 0x49, 0x75, 0x3d, 00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d,
+	0x11, 0xaf, 0x38, 0x12, 0x19, 0x49, 0x7a, 0x96, 0x12, 0x13, 0x3, 0xaf, 0x38, 0x12, 0x1f, 0x5c,
+	0x12, 0x1a, 0x64, 0x12, 0x12, 0xf9, 0x2, 0x1f, 0x65, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0x49,
+	0xaf, 0x38, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xce, 0x22, 0x8f, 0x3f, 0x8d,
+	0x40, 0x12, 0x1f, 0xa8, 0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xaf, 0x8f, 0x46, 0x7b, 0x1, 0xad,
+	0x45, 0x7f, 0x60, 0x12, 0x9, 0x3c, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44,
+	0x4, 0xfc, 0xef, 0x45, 0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x9, 0x59, 0x12, 0x9, 0x43, 0xaf,
+	0x45, 0x12, 0x1b, 0x13, 0x7b, 0x2, 0xad, 0x45, 0x7f, 0x60, 0x12, 0x9, 0x28, 0x8f, 0x44, 0x8e,
+	0x43, 0x8d, 0x42, 0x8c, 0x41, 0xe5, 0x42, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x43, 0xaf,
+	0x44, 0x22, 0xe4, 0xfe, 0xff, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xf5, 0x38, 0xfb, 0x7a, 00,
+	0x79, 0x39, 0x12, 0x14, 0x86, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x38, 0x1, 0xe5, 0x39,
+	0x65, 0x35, 0x60, 0x3, 0x75, 0x38, 0x1, 0xe5, 0x38, 0x70, 0x25, 0xf5, 0x37, 0x12, 0x1c, 0xfb,
+	0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x36, 0x12, 0x1b, 0x3c, 0xc3, 0x12,
+	0x4, 0xcf, 0x60, 0x3, 0x75, 0x38, 0x1, 0x5, 0x37, 0xe5, 0x37, 0xc3, 0x94, 0x1f, 0x40, 0xdd,
+	0x12, 0x1d, 0xf, 0xaf, 0x38, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17,
+	0xce, 0xe5, 0x36, 0x54, 0x3, 0xff, 0x70, 0x6, 0xf5, 0x37, 0xf5, 0x38, 0x80, 0x14, 0xbf, 0x1,
+	0x8, 0x75, 0x37, 0x20, 0x75, 0x38, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x37, 00, 0x75,
+	0x38, 0x40, 0xe5, 0x36, 0x30, 0xe4, 0x3, 0x43, 0x37, 0x1, 0xe5, 0x36, 0x30, 0xe7, 0x3, 0x43,
+	0x37, 0x40, 0xab, 0x38, 0xaa, 0x37, 0xe4, 0xfd, 0xaf, 0x35, 0x2, 0x17, 0xce, 0x8f, 0x27, 0x12,
+	0x1f, 0x53, 0x7b, 0xf0, 0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xce, 0x7d, 0x11, 0xaf,
+	0x27, 0x12, 0x13, 0xd, 0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54,
+	0x1f, 0xff, 0xc3, 0x94, 0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12,
+	0x1f, 0x5c, 0x75, 0x3d, 0x3, 0x12, 0x1a, 0x67, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x19, 0x49, 0xaf,
+	0x27, 0x2, 0x1f, 0x65, 0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c,
+	0x7f, 0x80, 0x7e, 0x1, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x43, 0x7b, 0x7, 0xe4, 0xfd, 0x7f,
+	0x40, 0x12, 0x9, 0x3c, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34,
+	0xc2, 0xfc, 0x12, 0x9, 0x43, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x16, 0x65, 0x5, 0x27, 0xe5, 0x27,
+	0xd3, 0x94, 0xf, 0x40, 0xc2, 0x22, 0x8b, 0x3a, 0x8a, 0x3b, 0x89, 0x3c, 0xe4, 0xf5, 0x8, 0xf5,
+	0x9, 0x12, 0x14, 0xba, 0xe5, 0x3d, 0x54, 0x3f, 0xf5, 0x41, 0x85, 0x3e, 0x42, 0xe5, 0x3b, 0x45,
+	0x3c, 0x45, 0x3a, 0x60, 0x10, 0xe5, 0x40, 0x54, 0x7, 0xab, 0x3a, 0xaa, 0x3b, 0xa9, 0x3c, 0x12,
+	0x3, 0x93, 0x12, 0x14, 0xba, 0xae, 0x41, 0xaf, 0x42, 0x22, 0x12, 0x1c, 0xfb, 0x8f, 0x40, 0x8e,
+	0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29,
+	0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 00,
+	0xb5, 0x15, 0x8, 0xea, 0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x80, 0x25, 0x1e, 0xf8,
+	0xa6, 0x17, 0xe5, 0x1e, 0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2, 0x6,
+	0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8b, 0x23, 0x8a, 0x24, 0x89, 0x25, 0xab, 0x26, 0xaa, 0x27, 0xa9,
+	0x28, 0x12, 0x3, 0x7a, 0xf5, 0x29, 0x70, 0x2, 0xff, 0x22, 0x74, 0x1, 0x25, 0x28, 0xf5, 0x28,
+	0xe4, 0x35, 0x27, 0xf5, 0x27, 0xab, 0x23, 0x5, 0x25, 0xe5, 0x25, 0xaa, 0x24, 0x70, 0x2, 0x5,
+	0x24, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12, 0x1c, 0x44, 0xef, 0x65, 0x29, 0x60, 0xcc, 0x7f,
+	0x1, 0x22, 0x8f, 0x3a, 0x8e, 0x39, 0x8d, 0x38, 0x8c, 0x37, 0x20, 0x8, 0x30, 0x7b, 0xc0, 0xad,
+	0xa, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0xaf, 0x3a, 0xae, 0x39, 0xad, 0x38, 0xac, 0x37, 0x12, 0x9,
+	0x43, 0xe4, 0x78, 0xa7, 0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x9, 0x28, 0xee, 0x30,
+	0xe0, 0xb, 0x78, 0xa7, 0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x8, 0x22, 0x12, 0x19,
+	0x23, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x9, 0x7a, 0xef, 0xf4, 0xff, 0xef, 0x55,
+	0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a, 0x24, 0x80, 0xfb,
+	0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40, 0x12, 0x10, 0x60,
+	0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xc4, 0x50, 0x35, 0x12,
+	0x1d, 0xed, 0xef, 0x64, 0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18, 0xd3, 0x94, 00, 0x40,
+	0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa, 0xae, 0x18, 0x5, 0x18,
+	0x74, 0x62, 0x2e, 0xf8, 0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4, 0x1e, 0x4, 0x78, 0x7f,
+	0x76, 0xd, 0xd3, 0x22, 0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x6, 0x60, 0x2d,
+	0xe5, 0x26, 0x54, 0x3, 0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x13, 0xfd, 0xe5, 0x26, 0x54,
+	0x3, 0x70, 0x1a, 0xaf, 0x25, 0x12, 0x1f, 0x5c, 0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49,
+	0x12, 0x1a, 0x4c, 0xaf, 0x25, 0x12, 0x19, 0x49, 0xaf, 0x25, 0x12, 0x1f, 0x65, 0x22, 0xaf, 0xb,
+	0x15, 0xb, 0xef, 0xd3, 0x94, 00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55,
+	0x12, 0x15, 0x42, 0x80, 0xe9, 0x30, 0x8, 0x9, 0x75, 0x3c, 0x1, 0x12, 0x16, 0x58, 0xc2, 0x8,
+	0x22, 0xe4, 0xf5, 0x3c, 0x12, 0x16, 0x58, 0x22, 0x75, 0x3d, 0x1, 0x7b, 0xc4, 0xad, 0xa, 0x7f,
+	0x20, 0x12, 0x17, 0x6c, 0x22, 0x8e, 0x28, 0x8f, 0x29, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x9, 0x3c, 0xae, 0x28, 0xaf, 0x29, 0xe4, 0xfc, 0xfd, 0x12, 0x9, 0x43, 0x7f, 0xa, 0x12, 0x1f,
+	0x85, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x28, 0xef, 0x54, 0x7, 0x60, 0xa, 0x12,
+	0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x4, 0x12, 0x1f, 0xc5, 0x22, 0x8f, 0x28, 0x8d, 0x29, 0xe5, 0x29,
+	0xf4, 0x60, 0x29, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x9, 0x3c, 0x7f, 00, 0x7e, 0x6,
+	0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x43, 0xad, 0x29, 0xaf, 0x28, 0x12, 0x7, 0x66, 0xe4, 0xfd,
+	0xaf, 0x28, 0x12, 00, 0x26, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xb7, 0x2, 0x15, 0x7e, 0x8f,
+	0x38, 0x75, 0x3c, 0x5, 0x75, 0x3d, 0x1, 0x7b, 0x19, 0xad, 0x38, 0x7f, 0x20, 0x12, 0x17, 0x6c,
+	0xe5, 0x38, 0xb4, 0x6, 0xe, 0x75, 0x3c, 0x2, 0x75, 0x3d, 0x1, 0x7b, 0x19, 0xfd, 0x7f, 0x20,
+	0x12, 0x17, 0x6c, 0x7b, 0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0x22, 0x12, 0x1f,
+	0x9a, 0x2, 0x9, 0x43, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40,
+	0x12, 0x9, 0x3c, 0x7f, 00, 0x12, 0x1f, 0x9a, 0x12, 0x9, 0x43, 0xe5, 0x22, 0xb4, 0x6, 0x5,
+	0x7d, 0x12, 0xff, 0x80, 0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0x8b, 0x5, 0x22, 0xe5, 0x22,
+	0xc3, 0x94, 0x7, 0x40, 0xd2, 0x2, 0x15, 0x7e, 0x8b, 0x2b, 0x8a, 0x2c, 0x89, 0x2d, 0xe4, 0xf5,
+	0x2e, 0xab, 0x2b, 0x5, 0x2d, 0xe5, 0x2d, 0xaa, 0x2c, 0x70, 0x2, 0x5, 0x2c, 0x14, 0xf9, 0x12,
+	0x3, 0x7a, 0xff, 0x12, 0x1b, 0xf9, 0xe5, 0x2e, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d, 0x12,
+	0x1f, 0xc8, 0x5, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x39, 0x8d, 0x3a,
+	0x8b, 0x3b, 0x12, 0x9, 0x28, 0x8f, 0x41, 0x8e, 0x40, 0x8d, 0x3f, 0x8c, 0x3e, 0x7b, 00, 0x7a,
+	00, 0x79, 0x3e, 0xad, 0x3d, 0xaf, 0x3c, 0x12, 0x9, 0xa9, 0xab, 0x3b, 0xad, 0x3a, 0xaf, 0x39,
+	0x12, 0x9, 0x3c, 0xaf, 0x41, 0xae, 0x40, 0xad, 0x3f, 0xac, 0x3e, 0x2, 0x9, 0x43, 00, 00,
+	0x10, 0x10, 00, 00, 00, 00, 00, 0xe, 00, 0x15, 00, 0x10, 00, 0x15, 00, 0x12,
+	00, 0x15, 00, 0x14, 00, 0x15, 00, 00, 0x10, 0xc, 00, 00, 00, 0x1, 00, 0xa,
+	00, 0x18, 00, 0xb, 00, 0x18, 00, 0xc, 00, 0x18, 00, 0xd, 00, 0x18, 0x8f, 0x3f,
+	0x8d, 0x40, 0x8a, 0x41, 0x8b, 0x42, 0x12, 0x1f, 0xa8, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f, 0xaf,
+	0x8f, 0x44, 0x7b, 0x1, 0xad, 0x43, 0x7f, 0x60, 0x12, 0x9, 0x3c, 0xab, 0x44, 0xad, 0x40, 0xaf,
+	0x42, 0xae, 0x41, 0x12, 0x1f, 0x5, 0x12, 0x9, 0x43, 0xaf, 0x43, 0x2, 0x1b, 0x13, 0x8f, 0x37,
+	0x7b, 00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0xce, 0x7f, 0x2, 0x12, 0x1d, 0x5e, 0xe4, 0xf5,
+	0x38, 0xe4, 0xfd, 0xaf, 0x37, 0x12, 0x13, 0xd, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x38, 0xe5, 0x38,
+	0xd3, 0x94, 0xc8, 0x50, 0x7, 0x7f, 0x1, 0x12, 0x1d, 0x5e, 0x80, 0xe5, 0x22, 0xc1, 0x5, 0xc1,
+	0x4, 0x1, 0x1e, 00, 0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2,
+	0xc1, 0x3, 0x1, 0xc, 0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1,
+	0x18, 00, 0x1, 0x4d, 00, 0x1, 0x51, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c,
+	0x27, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x3c, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28,
+	0xac, 0x27, 0x12, 0x9, 0x43, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x28, 0xef, 0x54,
+	0x3, 0x70, 0xf2, 0x22, 0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6,
+	0x4, 0xe, 0xbe, 0x6, 0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd,
+	0xed, 0x24, 0x4, 0xf8, 0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x7b, 0x17,
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0xff, 0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12,
+	0x9, 0x43, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0x9b, 0x7e, 0x22, 0x7d,
+	00, 0x7c, 00, 0x2, 0x9, 0x43, 0x8f, 0x32, 0x8d, 0x33, 0x8b, 0x34, 0x12, 0x1f, 0x2d, 0xaf,
+	0x33, 0x12, 0x1f, 0x2d, 0x7f, 0x5, 0x12, 0x1e, 0xfb, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x32,
+	0x12, 0x13, 0xb6, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x33, 0x2, 0x13, 0xb6, 0x8f, 0x32, 0xed,
+	0x70, 0x2, 0x80, 0x1, 0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x2, 0xf5, 0x37, 0xf5, 0x36, 0x75,
+	0x3d, 0xff, 0x75, 0x3c, 0xf, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x2, 0xad, 0x32, 0x7f, 0x20, 0x12,
+	0x10, 0x60, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 00, 0x3, 0xef, 0x60, 0xd,
+	0x7b, 00, 0x7a, 00, 0x79, 0x2c, 0x7d, 0x1, 0xaf, 0x2d, 0x12, 0x9, 0x81, 0x5, 0x2d, 0xe5,
+	0x2d, 0xc3, 0x94, 0x7, 0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b,
+	0x3c, 0x12, 0x13, 0xd, 0xe5, 0x3e, 0xf4, 0xfd, 0xe5, 0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42,
+	0x3c, 0xee, 0x42, 0x3b, 0xab, 0x3c, 0xaa, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x2, 0x17, 0xce, 0x8e,
+	0x48, 0x8f, 0x49, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x3, 0x12, 0x1a, 0x29, 0xe5, 0x48, 0xff,
+	0x12, 0x1a, 0x29, 0xaf, 0x49, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x4a, 0x7f, 0x1, 0x12,
+	0x1d, 0xa8, 0xaf, 0x4a, 0x22, 0x12, 0x1c, 0x44, 0x74, 0x30, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94,
+	0x39, 0x50, 0x5, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94,
+	0x46, 0x50, 0x5, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92,
+	0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x3, 0xd5, 0xc, 0x15, 0x75, 0xc, 0xa, 0xd2, 00, 0xd5,
+	0xd, 0x5, 0x75, 0xd, 0x64, 0xd2, 0x1, 0x30, 0x2, 0x5, 0xd5, 0xe, 0x2, 0xc2, 0x2, 0x32,
+	0x8b, 0x32, 0x8a, 0x33, 0x89, 0x34, 0xab, 0x32, 0xaa, 0x33, 0xa9, 0x34, 0x12, 0x3, 0x7a, 0x60,
+	0x13, 0x5, 0x34, 0xe5, 0x34, 0x70, 0x2, 0x5, 0x33, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12,
+	0x1d, 0x84, 0x80, 0xe2, 0x22, 0x78, 0x56, 0x12, 0x5, 0x6, 0xad, 0x7, 0x22, 0x78, 0x5a, 0x12,
+	0x5, 0x6, 0xab, 0x7, 0x22, 0x78, 0x52, 0x12, 0x5, 0x6, 0x78, 0x5, 0x2, 0x4, 0xf3, 0xa9,
+	0x1a, 0x7a, 00, 0x7b, 00, 0x75, 0x26, 0xff, 0x22, 0x8f, 0x29, 0xe4, 0xf5, 0x2a, 0xe5, 0x29,
+	0x54, 0x80, 0xff, 0x12, 0x1d, 0xba, 0xe5, 0x29, 0x25, 0xe0, 0xf5, 0x29, 0x12, 0x1f, 0x75, 0x12,
+	0x1f, 0x7d, 0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x75, 0x3d, 0x60, 0x75,
+	0x3e, 00, 0x7b, 00, 0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0x7b,
+	00, 0x7a, 0x2, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x8f, 0x35,
+	0x7d, 0x80, 0x7c, 00, 0x12, 0xf, 0x8d, 0xe4, 0xf5, 0x36, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x3c,
+	0x12, 0x15, 0x42, 0x5, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2, 0x16, 0x2e, 0x7b,
+	0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x28, 0xec, 0x54, 0xf, 0xfc, 0x7b, 0xe9, 0x7a, 0x50,
+	0x79, 0x38, 0x78, 0x7, 0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22,
+	0x8f, 0x32, 0xe5, 0x32, 0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x32, 0x75, 0xf0, 0xa, 0x84, 0x12,
+	0x1f, 0x23, 0x80, 0x2, 0x7f, 0x20, 0x12, 0x1d, 0x84, 0xe5, 0x32, 0x12, 0x1f, 0x23, 0x2, 0x1d,
+	0x84, 0xe4, 0xf5, 0x4e, 0x7f, 0x3, 0x12, 0x1e, 0xfb, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e,
+	0x80, 0x50, 0x5, 0xaf, 0x22, 0x12, 0x9, 0xf2, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40,
+	0xeb, 0x22, 0xe4, 0xf5, 0x29, 0xe5, 0x2a, 0x25, 0xe0, 0xf5, 0x2a, 0x12, 0x1f, 0x75, 0x12, 0x1d,
+	0xcc, 0xef, 0x42, 0x2a, 0x12, 0x1f, 0x7d, 0x5, 0x29, 0xe5, 0x29, 0xc3, 0x94, 0x8, 0x40, 0xe5,
+	0xaf, 0x2a, 0x22, 0x8f, 0x47, 0x7f, 0x5, 0x12, 0x1f, 0x85, 0xe4, 0xfb, 0xad, 0x47, 0x7f, 0x60,
+	0x12, 0x9, 0x28, 0xef, 0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0xbd, 0x50, 0xed, 0x7f, 0x2, 0x12,
+	0x1f, 0xc5, 0x22, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff, 0xe4, 0x34, 0x56,
+	0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3, 0xa8, 0x6, 0x8,
+	0x22, 0xad, 0x7, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36, 0x10, 0xf5, 0x3d,
+	0xf5, 0x3c, 0x75, 0x3b, 0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0x10, 0x60, 0x8f, 0x25,
+	0x12, 0x1f, 0xa1, 0xe4, 0xfd, 0x12, 0x9, 0x81, 0xaf, 0x25, 0x12, 0x1e, 0x80, 0x50, 0x5, 0xaf,
+	0x25, 0x12, 0x1f, 0x41, 0x7d, 0xff, 0xaf, 0x25, 0x2, 0x1b, 0x8b, 0x8f, 0x26, 0x8d, 0x27, 0xe5,
+	0x26, 0x64, 0x5, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 00, 0xaf, 0x26, 0x12, 0x1d, 0x96, 0xad,
+	0x27, 0xaf, 0x26, 0x12, 0x16, 0x9a, 0x22, 0xbf, 0x6, 0x3, 0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12,
+	0x13, 0xd, 0xef, 0x13, 0x13, 0x13, 0x54, 0x3, 0xfe, 0xef, 0x30, 0xe5, 0x3, 0x43, 0x6, 0x10,
+	0xaf, 0x6, 0x22, 0x8f, 0x2b, 0x12, 0x1e, 0x56, 0x7d, 0x1, 0xaf, 0x2b, 0x12, 0x1e, 0xaa, 0xaf,
+	0x2b, 0x12, 0x9, 0x7a, 0x12, 0x11, 0xf3, 0xe4, 0xfd, 0xaf, 0x2b, 0x2, 0x1e, 0xaa, 0xe4, 0xf5,
+	0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xc, 0xc5, 0x5, 0x22, 0xe5,
+	0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0xc2, 0x9, 0x22, 0x8f, 0x2f, 0xe5, 0x2f, 0xc4, 0x54, 0xf,
+	0xff, 0x12, 0x1e, 0x47, 0x12, 0x1d, 0x84, 0xe5, 0x2f, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x47, 0x2,
+	0x1d, 0x84, 0x8f, 0x28, 0x8e, 0x27, 0x8d, 0x26, 0x8c, 0x25, 0x78, 0x10, 0x12, 0x4, 0xe0, 0x12,
+	0x1d, 0xfc, 0xe5, 0x28, 0xff, 0xe5, 0x27, 0xfe, 0x2, 0x1d, 0xfc, 0xe4, 0xf5, 0x22, 0xaf, 0x22,
+	0x12, 0x1e, 0xf0, 0x74, 0xa0, 0x25, 0x22, 0xf8, 0xa6, 0x7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94,
+	0x7, 0x40, 0xeb, 0x22, 0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0xc,
+	0xef, 0x64, 0x80, 0x94, 0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12,
+	0x1b, 0xa7, 0x8f, 0x26, 0x7d, 0x5, 0xaf, 0x25, 0x12, 0x13, 0xd, 0xee, 0x30, 0xe2, 0x3, 0x43,
+	0x26, 0x20, 0xaf, 0x26, 0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc,
+	0x2, 0x75, 0xc8, 0x34, 0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0x8f, 0xef,
+	0x60, 0x5, 0x7f, 0x5, 0x12, 0x1f, 0xc5, 0x12, 0x1c, 0xd1, 0xef, 0x60, 0x5, 0x7f, 0x6, 0x12,
+	0x1f, 0xc5, 0x22, 0x8f, 0x37, 0x12, 0x1f, 0x5c, 0x75, 0x3d, 0x3, 0x12, 0x1a, 0x5c, 0x7d, 0xc,
+	0xaf, 0x37, 0x12, 0x19, 0x49, 0xaf, 0x37, 0x2, 0x1f, 0x65, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f,
+	0x5, 0x12, 0x1a, 0x29, 0x12, 0x1a, 0xf2, 0x8f, 0x28, 0x7f, 0x1, 0x12, 0x1d, 0xa8, 0xaf, 0x28,
+	0x22, 0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x80, 0x5, 0x22, 0xe5, 0x22, 0xc3,
+	0x94, 0x7, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc,
+	0x1, 0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x8, 0xfd, 0xe5, 0x9,
+	0xfb, 0x7f, 0x80, 0x12, 0x9, 0x28, 0x5, 0x9, 0xe5, 0x9, 0x70, 0x2, 0x5, 0x8, 0x22, 0xe4,
+	0xfb, 0x7d, 0x4, 0x7f, 0x80, 0x12, 0x9, 0x3c, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00,
+	0x2, 0x9, 0x43, 0x8f, 0x32, 0xaf, 0x32, 0x15, 0x32, 0xef, 0xd3, 0x94, 00, 0x40, 0x7, 0x7f,
+	0x20, 0x12, 0x1d, 0x84, 0x80, 0xef, 0x22, 0x8f, 0x51, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12,
+	0x9, 0x3c, 0xaf, 0x51, 0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0x9, 0x43, 0x53, 0x89, 0xf, 0x43, 0x89,
+	0x10, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x3,
+	0xae, 0x7, 0x1f, 0xee, 0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3, 0xfd, 0xc2, 0x3, 0x80, 0xf0,
+	0x22, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x3c, 0x7f, 0x1, 0x12, 0x1f, 0x9a, 0x12,
+	0x9, 0x43, 0x80, 0xfe, 0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12, 0x1f, 0x85, 0x20, 0x6, 0x5,
+	0x12, 0x1f, 0xbd, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1b, 0xc3, 0xad,
+	0x2a, 0xac, 0x29, 0xaf, 0x28, 0x2, 0x8, 0x5c, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 0x2, 0x80,
+	0x4, 0xe5, 0x51, 0x54, 0xfd, 0xff, 0x12, 0x1d, 0x37, 0x22, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44,
+	0x1, 0x80, 0x4, 0xe5, 0x51, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x37, 0x22, 0x7b, 0x35, 0xe4, 0xfd,
+	0x7f, 0xe0, 0x12, 0x9, 0x28, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf, 0xff, 0x22, 0x5, 0xf, 0xe5,
+	0xf, 0xc3, 0x94, 0x96, 0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1f, 0x8c, 0x22, 0x74, 0x80, 0x25,
+	0x1f, 0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x29, 0x8f, 0x2a,
+	0xe5, 0x29, 0xff, 0x12, 0x1b, 0xf9, 0xaf, 0x2a, 0x2, 0x1b, 0xf9, 0x5, 0x4d, 0xe5, 0x4d, 0xc3,
+	0x94, 0xa, 0x40, 0x5, 0xe4, 0xf5, 0x4d, 0xd2, 0x9, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 00,
+	0x7b, 00, 0x7a, 0x12, 0xe4, 0xfd, 0x2, 0x19, 0x49, 0x4c, 0x75, 0x74, 0x20, 0x32, 0x2e, 0x32,
+	0x39, 0x62, 0x5f, 0x61, 0x74, 0x68, 00, 00, 0xe4, 0xff, 0x12, 0x1d, 0xa8, 0x7f, 0x6, 0x12,
+	0x1a, 0x29, 0x7f, 0x1, 0x2, 0x1d, 0xa8, 0xef, 0xc3, 0x94, 0xa, 0xef, 0x50, 0x4, 0x24, 0x30,
+	0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x7, 0x75, 0x3c, 0x10, 0xe4, 0xf5, 0x3d, 0xfb, 0x7f,
+	0x20, 0x2, 0x17, 0x6c, 0x7d, 0x25, 0x12, 0x18, 0x84, 0x7b, 00, 0x7a, 00, 0x79, 0x25, 0x2,
+	0x17, 0x38, 0x45, 0x52, 0x41, 0x53, 0x45, 00, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 00,
+	0xef, 0x90, 0x1e, 0x95, 0x93, 0xd3, 0x94, 0x1, 0x50, 0x2, 0x80, 0x1, 0xc3, 0x22, 00, 0x1,
+	0x2, 0x3, 0x4, 0xff, 0x6, 00, 00, 00, 00, 00, 0xff, 0x1, 0x7d, 0x1, 0x12, 0x13,
+	0xd, 0xef, 0x30, 0xe2, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0xe,
+	0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x6c, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x10, 0xe4, 0xfd, 0x7f,
+	0x40, 0x2, 0x17, 0x6c, 0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0xe5,
+	0xaa, 0x54, 0x3, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x7f, 0x3, 0x7e, 00, 0x7d, 00,
+	0x7c, 00, 0x2, 0x18, 0x59, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80, 0xf6, 0x22,
+	0x12, 0x1e, 0x80, 0x50, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0xc2, 0x2, 0x8f, 0xe, 0xd2,
+	0x2, 0x20, 0x2, 0xfd, 0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f,
+	0x30, 0x12, 0x1d, 0x84, 0x7f, 0x78, 0x2, 0x1d, 0x84, 0x7f, 0xd, 0x12, 0x1d, 0x84, 0x7f, 0xa,
+	0x2, 0x1d, 0x84, 0x75, 0xf0, 0xa, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x35, 0x12,
+	0x17, 0xfe, 0xaf, 0x35, 0x2, 0x9, 0xf2, 0xd3, 0xe5, 0x26, 0x94, 00, 0xe5, 0x25, 0x94, 00,
+	0x22, 0xef, 0x64, 0x6, 0x60, 0x3, 0x12, 0x1c, 0xa3, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f,
+	0x2, 0x17, 0xce, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x2, 0x17, 0xce, 0x7b, 0x30, 0x7a, 0x2a,
+	0x7d, 0x1f, 0x2, 0x17, 0xce, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x2, 0x17, 0xce, 0x7d, 0x32, 0x12,
+	0x18, 0x84, 0xaf, 0x37, 0x22, 0xe5, 0x51, 0x44, 0x4, 0xff, 0x2, 0x1d, 0x37, 0xe5, 0x51, 0x54,
+	0xfb, 0xff, 0x2, 0x1d, 0x37, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00,
+	0x2, 0x16, 0x65, 0x7f, 0x5, 0x7e, 00, 0x2, 0x16, 0x65, 0x7e, 00, 0x7d, 00, 0x7c, 00,
+	0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x4e, 0x22, 0xef, 0x90, 0x1e, 0x95, 0x93, 0xff, 0x22, 0xef,
+	0x90, 0x1e, 0x8e, 0x93, 0xff, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0x6, 0x5, 0xa2, 0x2, 0xb3,
+	0x22, 0x12, 0x11, 0x2d, 0x22, 0xd2, 0x7, 0x22, 0x2, 0x1d, 0x84, 0x2, 0x15, 0x7e, 0x22, 0x22,
+};
diff --git a/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c
new file mode 100644
index 0000000000..1ea408ba42
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v3.c
@@ -0,0 +1,521 @@
+/*
+ * Microcode for VSC 7385, with
+ *	- 3 delay in RGMII port
+ *	- Latest phy settings
+ *	- Flush port entries when link goes down
+ *	  (to avoid ~30sec delay when we move between
+ *	  different ports of the switch)
+ */
+static unsigned char g5_Plus1_2_31_unmanaged_Atheros_v3 [] = {
+	0x2, 0xd, 0x57, 0x8f, 0x2e, 0x12, 0x1f, 0xb9, 0x12, 0xb, 0x45, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x1a, 0x22, 0x7e, 00,
+	0x2, 0xb, 0x78, 0x2, 0x15, 0xb6, 0x78, 0x5a, 0x12, 0x4, 0xee, 0xad, 0x7, 0x22, 0x78, 0x5e,
+	0x12, 0x4, 0xee, 0xab, 0x7, 0x22, 0x78, 0x56, 0x12, 0x4, 0xee, 0x78, 0x5, 0x2, 0x4, 0xdb,
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x23, 0x8d, 0x24, 0x8b, 0x25, 0xe5, 0x25, 0x7b, 0xff,
+	0x60, 0x6, 0x7a, 0x1e, 0x79, 0x27, 0x80, 0x4, 0x7a, 0x1e, 0x79, 0x26, 0x12, 0x1a, 0x47, 0x7b,
+	0xff, 0x7a, 0x1e, 0x79, 0x28, 0x12, 0x1a, 0x47, 0xe5, 0x23, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4,
+	0xf5, 0x23, 0x75, 0x26, 0x6, 0x80, 0x11, 0xe5, 0x25, 0x60, 0xa, 0x53, 0x23, 0xfe, 0xe5, 0x23,
+	0x4, 0xf5, 0x26, 0x80, 0x3, 0x85, 0x23, 0x26, 0xe5, 0x24, 0xb4, 0xff, 0x5, 0x75, 0x28, 0x7,
+	0x80, 0xf, 0xaf, 0x24, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+	0x28, 0x7b, 0xd, 0x12, 0x3, 0x13, 0x7b, 0xe, 0x12, 0x3, 0x13, 0x12, 0x3, 0x4e, 0x12, 0x1b,
+	0x96, 0x12, 0xa, 0xc9, 0xe5, 0x23, 0x90, 0x1f, 0xce, 0x93, 0xf5, 0x2f, 0xe5, 0x25, 0x60, 0x1e,
+	0xe5, 0x23, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94,
+	0x80, 0x50, 0x8, 0xe5, 0x23, 0xa3, 0x93, 0xf5, 0x30, 0x80, 0x3, 0x75, 0x30, 0x7, 0x7e, 00,
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x29, 0x12, 0x5, 0x16, 0x75, 0x27, 0x2,
+	0xe5, 0x27, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x27, 0x8, 0x80,
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x28, 0x70, 0x3, 0x2, 0x2,
+	0x4b, 0xe5, 0x27, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x2f, 0x12, 0x1e, 0xa2,
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x30, 0x12, 0x1e, 0xa2, 0x50, 0x7, 0xe5, 0x30, 0xc3, 0x94,
+	0x7, 0x40, 0x7, 0xe5, 0x25, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x2f, 0x64, 0x6, 0x70, 0x1b,
+	0xe5, 0x27, 0x70, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27, 0xb4,
+	0x1, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x25, 0x60, 0x67, 0xe5,
+	0x27, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x27, 0x70, 0xe,
+	0x7d, 0x1, 0xaf, 0x30, 0x12, 0x13, 0x79, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27,
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x30, 0x12, 0x13, 0x79, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2,
+	0x4b, 0x12, 0x3, 0x58, 0xe4, 0xf5, 0x2d, 0xf5, 0x2e, 0xaf, 0x2f, 0x12, 0x1e, 0xbe, 0x50, 0x7,
+	0xaf, 0x30, 0x12, 0x1e, 0xbe, 0x40, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa,
+	0x12, 0x1d, 0x8d, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x58, 0x5,
+	0x2e, 0xe4, 0xf5, 0x2d, 0x80, 0xd3, 0xe5, 0x27, 0x44, 0x90, 0xfd, 0xaf, 0x2f, 0x12, 0x14, 0x22,
+	0x7f, 0xa, 0x12, 0x1f, 0x1d, 0xad, 0x27, 0xaf, 0x2f, 0x12, 0x11, 0x2c, 0xe5, 0x25, 0x60, 0x7,
+	0xad, 0x27, 0xaf, 0x30, 0x12, 0x11, 0x2c, 0x7f, 0x5, 0x12, 0x1f, 0x1d, 0xe5, 0x25, 0x60, 0x41,
+	0xad, 0x30, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0xad, 0x80, 0x2,
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0xad, 0x2f, 0xaf, 0x30, 0x12, 0xf,
+	0xed, 0xe5, 0x27, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc,
+	0x12, 0x1b, 0xad, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x80,
+	0x1a, 0xad, 0x2f, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0xad, 0x80,
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0x15, 0x27, 0x2, 00, 0xf0,
+	0xe4, 0xf5, 0x2c, 0xe5, 0x25, 0x70, 0x7, 0xe5, 0x2c, 0xc3, 0x94, 0x1, 0x40, 0xe, 0xe5, 0x25,
+	0x70, 0x3, 0x2, 0x2, 0xe5, 0xe5, 0x2c, 0xc3, 0x94, 0x2, 0x50, 0x79, 0x12, 0x1f, 0x3b, 0xaf,
+	0x23, 0x12, 0x1a, 0xf3, 0xe4, 0xf5, 0x27, 0xe5, 0x27, 0x25, 0xe0, 0xff, 0x74, 0x29, 0x25, 0x2c,
+	0xf8, 0xe6, 0xfe, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2b,
+	0x64, 0x3, 0x60, 0x1f, 0xe5, 0x2b, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x1e, 0x79, 0x29, 0x12, 0x1a,
+	0x47, 0x80, 0x10, 0x7a, 0x1e, 0x79, 0x2a, 0x12, 0x1a, 0x47, 0xaf, 0x2b, 0xe4, 0xfc, 0xfd, 0xfe,
+	0x12, 0xf, 0x77, 0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x3, 0x40, 0xbb, 0xe5, 0x2c, 0x70, 0xb,
+	0xaf, 0x2f, 0x12, 0x1e, 0xa2, 0x50, 0x10, 0xaf, 0x2f, 0x80, 0x9, 0xaf, 0x30, 0x12, 0x1e, 0xa2,
+	0x50, 0x5, 0xaf, 0x30, 0x12, 0x1f, 0x4f, 0x5, 0x23, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x5,
+	0x5, 0x2c, 0x2, 0x2, 0x53, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b,
+	0xff, 0x7a, 0x1e, 0x79, 0x2b, 0x12, 0x1a, 0x47, 0x7b, 0xd, 0x12, 0x3, 0x26, 0x12, 0xa, 0xc9,
+	0x7b, 0xe, 0x12, 0x3, 0x26, 0x12, 0xa, 0xc9, 0x12, 0x3, 0x4e, 0x7f, 0x5f, 0x12, 0x1b, 0x98,
+	0x2, 0xa, 0xc9, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x7f, 00, 0x7e, 00, 0x7d, 00,
+	0x7c, 00, 0x12, 0xa, 0xc9, 0x22, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x7f, 0x5f, 0x7e,
+	00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x2f, 0x12, 0xf, 0xed, 0xe5, 0x27, 0x25, 0xe0, 0xfe,
+	0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf, 0x2f, 0x12, 0x13, 0x79, 0xee, 0x22, 0x7b, 0xf,
+	0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x22, 0xab, 0x27, 0xad, 0x30, 0xaf, 0x2f, 0x12, 0x19,
+	0x3d, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb,
+	0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82,
+	0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22, 0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0,
+	0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9, 0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed,
+	0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd, 0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38,
+	0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c, 0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4,
+	0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf, 0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c,
+	0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd, 0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75,
+	0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82,
+	0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99, 0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee,
+	0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc, 0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4,
+	0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22, 0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00,
+	0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd, 0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef,
+	0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7,
+	0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf, 0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18,
+	0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10,
+	0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec, 0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0,
+	0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75, 0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+	0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33, 0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8,
+	0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a, 0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda,
+	0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8, 0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce,
+	0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb, 0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9,
+	0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed,
+	0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3,
+	0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc,
+	0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6, 0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93,
+	0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93, 0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8,
+	0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e, 0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb,
+	0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3, 0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50,
+	0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9,
+	0xf0, 0x22, 0x8f, 0x36, 0x12, 0xc, 0x1b, 0xaf, 0x36, 0x12, 0x13, 0x1d, 0x7d, 0x3, 0xaf, 0x36,
+	0x12, 0x13, 0x79, 0xef, 0x54, 0xf, 0xf5, 0x37, 0x70, 0x7b, 0x12, 0x6, 0x67, 0x12, 0x1f, 0x6b,
+	0x7b, 0x92, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x7b, 0x3, 0x7a, 0x28, 0x12,
+	0x6, 0xc4, 0x7b, 0xfa, 0x7a, 0x87, 0x12, 0x6, 0x8f, 0xaf, 0x36, 0x12, 0x1f, 0x7d, 0x12, 0x6,
+	0x67, 0x12, 0x6, 0xac, 0x7b, 0x89, 0x7a, 0x6, 0x12, 0x6, 0xc4, 0x7b, 0x92, 0x7a, 0x8f, 0x7d,
+	0x10, 0x12, 0x6, 0xcc, 0x12, 0x6, 0xac, 0x7b, 0x35, 0x7a, 0xe, 0x7d, 0x11, 0xaf, 0x36, 0x12,
+	0x17, 0xdf, 0x7b, 0x86, 0x7a, 0x97, 0x12, 0x6, 0x8f, 0x7b, 0x80, 0x7a, 0xff, 0x7d, 0x17, 0xaf,
+	0x36, 0x12, 0x17, 0xdf, 0xe4, 0xfb, 0xfa, 0x7d, 0x17, 0x12, 0x6, 0xcc, 0x12, 0x1f, 0x74, 0x75,
+	0x3d, 0x80, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x80, 0x7d, 0x2, 0xaf, 0x36, 0x12, 0x19, 0xb0,
+	0xaf, 0x36, 0x12, 0x1f, 0x7d, 0xaf, 0x36, 0x12, 0x1f, 0x7d, 0x75, 0x3d, 00, 0x75, 0x3e, 0x40,
+	0x7b, 0x40, 0x7d, 0x12, 0x12, 0x6, 0xba, 0x12, 0x1f, 0x74, 0x12, 0x6, 0xd4, 0x12, 0x6, 0xd4,
+	0xaf, 0x36, 0x12, 0x1f, 0x7d, 0xe5, 0x37, 0xaf, 0x36, 0x70, 0x1a, 0x12, 0x1f, 0x74, 0x75, 0x3d,
+	0x60, 0x75, 0x3e, 00, 0x7a, 0x40, 0x12, 0x6, 0x80, 0x75, 0x3d, 0xe0, 0x75, 0x3e, 0xe, 0x7b,
+	0xe, 0x7a, 0xa0, 0x80, 0x4a, 0x12, 0x1f, 0x74, 0x75, 0x3d, 0xf, 0x75, 0x3e, 0xc0, 0x7b, 0x40,
+	0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x75, 0x3d, 0x60, 0x75, 0x3e, 00, 0x7b,
+	00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x75, 0x3d, 00, 0x75, 0x3e, 0x38,
+	0x7b, 0x30, 0x7d, 0x18, 0x12, 0x6, 0xba, 0x12, 0x1f, 0x62, 0x75, 0x3d, 0xe0, 0x75, 0x3e, 00,
+	0x7a, 0x20, 0x12, 0x6, 0x80, 0x75, 0x3d, 0xe0, 0x75, 0x3e, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d,
+	0x18, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x22, 0xaf, 0x36, 0x12, 0x1f, 0x74, 0x75, 0x3d, 0x2, 0x75,
+	0x3e, 00, 0x7b, 00, 0x7a, 0x2, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0xaf, 0x36, 0x22,
+	0x7b, 00, 0x7d, 0x14, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0xaf, 0x36, 0x12, 0x1f, 0x7d, 0x22, 0x7d,
+	0x10, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0xaf, 0x36, 0x12, 0x1f, 0x74, 0x75, 0x3d, 0x2, 0x75, 0x3e,
+	00, 0xe4, 0xfb, 0xfa, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0x22, 0x12, 0x1f, 0x6b, 0xe4,
+	0xfb, 0xfa, 0x7d, 0x12, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x22, 0x7a, 00, 0xaf, 0x36, 0x12, 0x19,
+	0xb0, 0xaf, 0x36, 0x22, 0x7d, 0x11, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x22, 0xaf, 0x36, 0x12, 0x17,
+	0xdf, 0xaf, 0x36, 0x22, 0x7b, 0x82, 0x7a, 0xf0, 0x7d, 0x3, 0xaf, 0x36, 0x12, 0x17, 0xdf, 0x22,
+	0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x64, 0x20, 0x60, 0x9, 0xe5, 0x23, 0x64, 0xd, 0x60, 0x3, 0x7f,
+	0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe, 0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79, 0x56, 0x12,
+	0x5, 0x16, 0x12, 0x1f, 0x7, 0x75, 0x24, 0xa, 0xe4, 0xf5, 0x26, 0xa8, 0x1a, 0xe6, 0x64, 0x30,
+	0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6, 0xff, 0x12, 0x1c, 0x8a, 0xbf, 0x58, 0x10, 0x75, 0x24, 0x10,
+	0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8, 0x1a, 0xe6,
+	0xf5, 0x23, 0x64, 0x20, 0x60, 0x6, 0xe5, 0x23, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x26, 0xd3, 0x94,
+	00, 0x40, 0x6a, 0xe4, 0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x31, 0xf5, 0x25, 0xe5, 0x25,
+	0xc3, 0x95, 0x26, 0x50, 0x3a, 0xaf, 0x24, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x34, 0xaa, 0x33, 0xa9,
+	0x32, 0xa8, 0x31, 0x12, 0x3, 0x8d, 0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0x74, 0x27,
+	0x25, 0x25, 0xf8, 0xe6, 0xff, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5, 0x34, 0xee,
+	0x3a, 0xf5, 0x33, 0xed, 0x39, 0xf5, 0x32, 0xec, 0x38, 0xf5, 0x31, 0x5, 0x25, 0x80, 0xbf, 0xe5,
+	0x19, 0xc3, 0x94, 0x4, 0x50, 0x17, 0xaf, 0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31, 0xab, 0x19,
+	0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25, 0xe0, 0x24, 0x56, 0xf8, 0x12, 0x5, 0xa, 0xe5, 0x23, 0x64,
+	0xd, 0x60, 0x3, 0x2, 0x7, 0x2, 0xff, 0x22, 0xaf, 0x23, 0x12, 0x19, 0xfc, 0x8f, 0x23, 0xe5,
+	0x23, 0xf4, 0x60, 0x1d, 0xe5, 0x26, 0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x26, 0x5, 0x26, 0x74,
+	0x27, 0x2f, 0xf8, 0xa6, 0x23, 0xe5, 0x23, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x24, 0x10, 0x80,
+	0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a, 0x2, 0x7, 0x2d, 0xa8, 0x1a, 0xe6, 0xf5, 0x22, 0x5, 0x1a,
+	0x12, 0x6, 0xe0, 0xef, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xaf, 0x22, 0x12, 0x1c, 0x8a, 0xef, 0x24,
+	0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60, 0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x3, 0x2,
+	0x8, 0xab, 0x24, 0xfd, 0x60, 0x28, 0x4, 0x60, 0x3, 0x2, 0x8, 0xe6, 0x12, 0x11, 0x91, 0x2,
+	0x8, 0xe9, 0x12, 0x1f, 0x31, 0x12, 00, 0x36, 0xc0, 0x7, 0x12, 00, 0x26, 0xc0, 0x5, 0x12,
+	00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0xa, 0xae, 0x12, 0x1c, 0x58, 0x80, 0x3e, 0xe5, 0x19,
+	0xc3, 0x94, 0x4, 0x50, 0x3, 0x2, 0x8, 0xe9, 0x12, 00, 0x36, 0xc0, 0x7, 0x12, 00, 0x26,
+	0xc0, 0x5, 0x12, 00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0xa, 0xc2, 0x78, 0x62, 0x12, 0x4,
+	0xee, 0x12, 0xa, 0xc9, 0x2, 0x8, 0xe9, 0x12, 0x1f, 0x31, 0x78, 0x56, 0x12, 0x4, 0xee, 0xc0,
+	0x7, 0x12, 00, 0x26, 0xd0, 0x7, 0x12, 0x13, 0x79, 0x12, 0x1e, 0x3b, 0x12, 0x1f, 0x3b, 0x80,
+	0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3, 0x40, 0x61, 0x78, 0x56, 0x12, 0x4, 0xee, 0xc0, 0x7, 0x12,
+	00, 0x26, 0xc0, 0x5, 0x12, 00, 0x2e, 0xaa, 0x6, 0x78, 0x62, 0x12, 0x4, 0xee, 0x8e, 0x3d,
+	0x8f, 0x3e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x19, 0xb0, 0x80, 0x3e, 0x78, 0x56, 0x12, 0x4, 0xee,
+	0xef, 0x24, 0xfe, 0x60, 0x17, 0x4, 0x70, 0x2b, 0x78, 0x5a, 0x12, 0x4, 0xee, 0xc0, 0x7, 0x78,
+	0x5e, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x5a, 0x12, 0x4,
+	0xee, 0xc0, 0x7, 0x78, 0x5e, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1, 0x12, 00,
+	0x46, 0x80, 0x6, 0x7f, 0x1, 0x22, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a, 0x7f, 0x1,
+	0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30, 0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed, 0x54, 0x3,
+	0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1, 0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x7,
+	0xef, 0x60, 0x4, 0x7d, 0x1, 0x80, 0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70, 0x3, 0xed,
+	0x60, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18,
+	0xc3, 0x7b, 0x8, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff,
+	0xad, 0x30, 0x7c, 00, 0x12, 0xa, 0xdf, 0x12, 0xa, 0xc9, 0x7b, 0xc, 0xad, 0x2a, 0x7f, 0x20,
+	0x12, 0xa, 0xc2, 0xe5, 0x34, 0xfe, 0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12, 0xa, 0xdf,
+	0x12, 0xa, 0xc9, 0xe5, 0x2b, 0x60, 0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xc7, 0x12, 0x9, 0xd8,
+	0x7f, 0xff, 0x7e, 00, 0x7d, 0x3, 0x7c, 00, 0x12, 0xa, 0xc9, 0x85, 0x2a, 0x3b, 0xe4, 0xf5,
+	0x3c, 0x7b, 0x12, 0x80, 0x1d, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xaf, 0x12, 0x9, 0xd8, 0x7f, 00,
+	0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0xa, 0xc9, 0x85, 0x2a, 0x3b, 0x75, 0x3c, 0x1, 0x7b,
+	0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12, 0x17, 0x7d, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb,
+	0xad, 0x2a, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x4, 0xfa,
+	0x12, 0xa, 0xc9, 0x74, 0x4, 0x25, 0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x5, 0x2f,
+	0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40, 0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0xa,
+	0xc2, 0x22, 0x8f, 0x2b, 0x8c, 0x2c, 0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0xa, 0xf5,
+	0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b,
+	0x12, 0x12, 0x5b, 0x8f, 0x31, 0x8e, 0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0x12, 0xa, 0xa4, 0xe5, 0x31,
+	0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe, 0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff,
+	0xec, 0x44, 0x20, 0xfc, 0x12, 0xa, 0xc9, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf,
+	0x2b, 0x12, 0x1e, 0xd9, 0x12, 0xa, 0xa4, 0x7f, 0x30, 0x7e, 00, 0x7d, 00, 0x7c, 0x20, 0x12,
+	0xa, 0xc9, 0x85, 0x2b, 0x3b, 0x75, 0x3c, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17,
+	0x7d, 0xaf, 0x2b, 0x12, 0x1f, 0x85, 0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x4, 0xdb, 0xec,
+	0x44, 0x8, 0xfc, 0xe5, 0x31, 0x4f, 0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d,
+	0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5, 0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0xa, 0xc2,
+	0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f, 0xac, 0x2e, 0x12, 0xa, 0xc9, 0xaf, 0x2b, 0x12, 0x1b, 0xb4,
+	0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x19, 0x64, 0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff,
+	0x12, 0x14, 0xb0, 0x22, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x22, 0xef, 0x2d,
+	0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf,
+	0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b, 0x8b, 0x4c, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f,
+	0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5, 0x4c, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22,
+	0xec, 0xfe, 0xed, 0xff, 0x22, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf,
+	0x90, 0xa, 0xe5, 0xb4, 0x8, 00, 0x50, 0x3, 0x93, 0xff, 0x22, 0x94, 0x8, 0x93, 0xfe, 0x22,
+	0xef, 0x90, 0xa, 0xe5, 0x93, 0xff, 0x22, 0x90, 0xa, 0xe5, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb,
+	0x1, 0xe, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22,
+	0xbb, 00, 0xb, 0xe9, 0xf8, 0xe6, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74,
+	0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f,
+	0xff, 0x12, 0xb, 0x7, 0x22, 0x90, 0xa, 0xe5, 0xef, 0x93, 0xff, 0xbb, 0x1, 0x7, 0x89, 0x82,
+	0x8a, 0x83, 0xe0, 0x80, 0x6, 0xbb, 00, 0x8, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22,
+	0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa,
+	0x74, 0x7, 0x5f, 0xff, 0x12, 0xb, 0x45, 0x22, 0xab, 0x7, 0xaa, 0x6, 0xe4, 0xf5, 0x29, 0xf5,
+	0x28, 0xf5, 0x27, 0xf5, 0x26, 0xeb, 0x4a, 0x70, 0x8, 0xf5, 0x29, 0xf5, 0x28, 0xf5, 0x27, 0x80,
+	0x53, 0xeb, 0x64, 0x1, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x1, 0x80, 0x44,
+	0xeb, 0x64, 0x2, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x2, 0x80, 0x35, 0xeb,
+	0x64, 0x3, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x3, 0x80, 0x26, 0xeb, 0x64,
+	0x4, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x4, 0x80, 0x17, 0xeb, 0x64, 0x5,
+	0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x5, 0x80, 0x8, 0xe4, 0xf5, 0x29, 0xf5,
+	0x28, 0x75, 0x27, 0x6, 0x75, 0x26, 0x80, 0x12, 0xc, 0x11, 0xaf, 0x29, 0xae, 0x28, 0xad, 0x27,
+	0xac, 0x26, 0x12, 0xa, 0xc9, 0x7f, 0x3, 0x7e, 00, 0x12, 0x16, 0xe0, 0x7f, 0x3, 0x7e, 00,
+	0x12, 0x16, 0xe0, 0x12, 0xc, 0x11, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0xa,
+	0xc9, 0x7b, 0x9, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x74,
+	0x12, 0x1b, 0x76, 0x12, 0xc, 0xaa, 0x12, 0x1f, 0x6b, 0x7a, 0xaf, 0x12, 0xc, 0x96, 0x12, 0x1b,
+	0x8b, 0x12, 0xc, 0x80, 0x7a, 0x8f, 0x12, 0xc, 0x96, 0x7a, 0xaf, 0x12, 0xc, 0xa0, 0xe4, 0xf5,
+	0x3d, 0xf5, 0x3e, 0xfb, 0xfa, 0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0x12, 0x1b, 0x8b, 0x7d,
+	0x12, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0x7a, 0x8f, 0x12, 0xc, 0xa0, 0x7a, 0xaf, 0x12, 0xc, 0xb4,
+	0x75, 0x3d, 0x1, 0x75, 0x3e, 0x80, 0x7b, 00, 0x7a, 0x1, 0x12, 0xc, 0x80, 0x7a, 0x8f, 0x12,
+	0xc, 0xb4, 0xaf, 0x38, 0x12, 0x1f, 0x74, 0x12, 0x1b, 0x81, 0x12, 0xc, 0xaa, 0x2, 0x1f, 0x7d,
+	0x7d, 0x11, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0xe4, 0xf5, 0x3d, 0xf5, 0x3e, 0xfb, 0xfa, 0x7d, 0x12,
+	0xaf, 0x38, 0x12, 0x19, 0xb0, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22,
+	0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19,
+	0xb0, 0xaf, 0x38, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22, 0x8f, 0x35,
+	0xe5, 0x35, 0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 0x12, 0x17, 0xdf, 0xaf,
+	0x35, 0x12, 0x18, 0xf, 0x12, 0xd, 0x4b, 0x7a, 0x2, 0x12, 0xd, 0x41, 0x7b, 0xb5, 0x7a, 0x52,
+	0x7d, 0x1f, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x7b, 0xf, 0x7a, 00, 0x7d, 0x2, 0xaf, 0x35, 0x12,
+	0x17, 0xdf, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x7b, 0xa4, 0x7a,
+	0x8f, 0xe4, 0xfd, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x12, 0xd, 0x4b, 0x7a, 00, 0x12, 0xd, 0x41,
+	0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x35, 0x2, 0x17, 0xdf, 0xaf, 0x35, 0x12, 0x5, 0x42, 0xaf,
+	0x35, 0x12, 0x1c, 0xe9, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x75,
+	0x3d, 00, 0x75, 0x3e, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 0x35, 0x12, 0x19, 0xb0,
+	0x22, 0x7b, 0x12, 0x7d, 0x8, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x22, 0x7b, 0x30, 0x7a, 0x2a, 0x7d,
+	0x1f, 0xaf, 0x35, 0x12, 0x17, 0xdf, 0x22, 0x78, 0xfe, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x53, 00,
+	0x75, 0x54, 00, 0x75, 0x81, 0xab, 0x2, 0xd, 0xa4, 0x2, 0xd, 0xe9, 0xe4, 0x93, 0xa3, 0xf8,
+	0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 0x8, 0xdf, 0xf4, 0x80, 0x29, 0xe4, 0x93,
+	0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0xf, 0x44, 0x20, 0xc8, 0x83,
+	0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0xb, 0x1, 0x2, 0x4, 0x8,
+	0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x6c, 0xe4, 0x7e, 0x1, 0x93, 0x60, 0xbc, 0xa3, 0xff, 0x54,
+	0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x1, 0xe, 0xcf, 0x54, 0xc0,
+	0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4, 0x93,
+	0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca,
+	0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x12, 0x1f, 0xec, 0x12, 0x19, 0x15, 0xd2,
+	0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d, 0x75,
+	0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 0x7f, 0xe0, 0x12, 0x10, 0xc4, 0x12, 0x1d,
+	0x7a, 0x12, 0x1c, 0xbb, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 0x1d, 0x8d, 0x12, 0xe, 0xf9, 0x12, 0x1f,
+	0xed, 0x12, 0x1a, 0xd2, 0xef, 0x70, 0x3, 0x30, 0x7, 0x3, 0x12, 0x1f, 0xd5, 0x12, 0x1b, 0x14,
+	0x12, 0x1d, 00, 0xef, 0x60, 0x3, 0x12, 0x1f, 0xd5, 0x12, 0x17, 0x15, 0x12, 0x1c, 0x71, 0x30,
+	0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2, 0x7f, 00, 0x7e,
+	00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0xa, 0xc9, 0x12, 0x18, 0xed, 0x30, 00, 0x8, 0xc2, 00,
+	0x12, 0x1e, 0x4a, 0x12, 0x1c, 0x24, 0x30, 0x1, 0xd6, 0xc2, 0x1, 0x12, 0x1e, 0xc, 0x12, 0x1c,
+	0xd2, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x8f, 0x23, 0x74, 0xa4, 0x2f, 0xf8, 0xe6, 0x24,
+	0xfe, 0x60, 0x2a, 0x14, 0x60, 0x5c, 0x24, 0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d, 0x4,
+	0xaf, 0x23, 0x12, 0x17, 0xdf, 0x7b, 00, 0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17, 0xdf,
+	0xaf, 0x23, 0x12, 0x1e, 0x59, 0x74, 0xa4, 0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9, 0x48,
+	0xaf, 0x23, 0x12, 0x1e, 0xbe, 0x50, 0x41, 0x12, 0x1f, 0xb9, 0x7d, 0x1, 0xaf, 0x23, 0x12, 0xb,
+	0x7, 0xaf, 0x23, 0x12, 0x1c, 0xa3, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0xd1, 0xad,
+	0x24, 0xaf, 0x23, 0x12, 0x15, 0x76, 0x74, 0xa4, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23, 0x2,
+	0x1f, 0xe8, 0x30, 0x9, 0x13, 0xaf, 0x23, 0x12, 0x1e, 0xbe, 0x40, 0xc, 0x74, 0xa4, 0x25, 0x23,
+	0xf8, 0x76, 0x2, 0xaf, 0x23, 0x12, 0x1a, 0x8f, 0x22, 0x12, 0x1f, 0xeb, 0xe4, 0x75, 0x26, 0xc0,
+	0xf5, 0x25, 0xf5, 0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf, 0x22,
+	0x12, 0xb, 0x62, 0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x2, 0x7f, 0x60, 0x12, 0xa, 0xc2, 0xe4, 0x25,
+	0x22, 0xff, 0xe4, 0x34, 0x4, 0xfe, 0xe4, 0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12, 0xa,
+	0xc9, 0x7f, 0x2, 0x12, 0x1d, 0x8d, 0x5, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9, 0x7f,
+	0x3, 0x12, 0x1f, 0x1d, 0x12, 0x1f, 0xab, 0x12, 0x1e, 0xfc, 0x7f, 0x4, 0x12, 0x1f, 0x1d, 0x75,
+	0x3b, 0x1, 0x75, 0x3c, 0x1, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x7d, 0x7f, 0x14,
+	0x12, 0x1d, 0x8d, 0x7b, 0x4, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0x7f, 0x5f, 0x12, 0x1f,
+	0xb2, 0x12, 0xa, 0xc9, 0x2, 0x14, 0xf4, 0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31, 0xe4,
+	0xf5, 0x3f, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x34, 0xaa, 0x33, 0xa9, 0x32, 0xa8, 0x31, 0xd3,
+	0x12, 0x4, 0xb7, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 0x34, 0xae, 0x33, 0xad,
+	0x32, 0xac, 0x31, 0x12, 0x4, 0x18, 0xaf, 0x3, 0x74, 0x35, 0x25, 0x3f, 0xf8, 0xa6, 0x7, 0xaf,
+	0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0x12, 0x4, 0x18,
+	0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31, 0x5, 0x3f, 0x80, 0xb6, 0xe5, 0x3f, 0x70, 0x5,
+	0x7f, 0x30, 0x2, 0x1d, 0xb3, 0x15, 0x3f, 0xe5, 0x3f, 0xf4, 0x60, 0x10, 0x74, 0x35, 0x25, 0x3f,
+	0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0xb3, 0x15, 0x3f, 0x80, 0xeb, 0x22, 0x8f, 0x31, 0x8d,
+	0x32, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x7f, 0x6, 0x12, 0x1b, 0x98, 0x12, 0xa, 0xc9,
+	0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0x75, 0x3c, 0x1, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x17, 0x7d, 0x7f, 0x2, 0x12, 0x1f, 0x1d, 0xaf, 0x32, 0x12, 0x1a, 0xb1, 0x7f, 0xa, 0x12, 0x1f,
+	0x9d, 0x12, 0x1e, 0xf1, 0x40, 0x5, 0x12, 0x1f, 0xda, 0x50, 0xf6, 0x12, 0x1f, 0xda, 0x40, 0x13,
+	0xad, 0x32, 0xaf, 0x31, 0x12, 0x13, 0xd2, 0xef, 0x70, 0x4, 0xf5, 0x33, 0x80, 0x8, 0x75, 0x33,
+	0x1, 0x80, 0x3, 0x75, 0x33, 0x2, 0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0xe4, 0xf5,
+	0x3c, 0xfd, 0x7f, 0x40, 0x12, 0x17, 0x7d, 0xaf, 0x33, 0x22, 0x8f, 0xa, 0xc3, 0xed, 0x94, 0x40,
+	0xec, 0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 0xef, 0x78, 0x2,
+	0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 0x3, 0xff, 0xe4,
+	0x3c, 0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 0xe0, 0x5, 0x75,
+	0xb, 0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x40, 0xe,
+	0xae, 0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xdb, 0x80, 0x8, 0x7f, 00,
+	0x7e, 00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x15, 0xf5, 0x7f, 0x20, 0x7e, 0x5, 0x7d, 00, 0x7c,
+	00, 0x2, 0x15, 0xf5, 0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39,
+	0xe5, 0x38, 0x55, 0x3c, 0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a,
+	0xf5, 0x36, 0x12, 0xa, 0xae, 0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d, 0xae,
+	0x3c, 0xad, 0x3b, 0xac, 0x3a, 0x12, 0x4, 0xaa, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d,
+	0xfd, 0xe8, 0x5c, 0xfc, 0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37,
+	0x4d, 0xf5, 0x37, 0xe5, 0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0xa,
+	0xc2, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac, 0x36, 0x2, 0xa, 0xc9, 0x8f, 0x31, 0x8d, 0x32,
+	0x7b, 0x19, 0xad, 0x31, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0x12, 0x1b, 0x96, 0x12, 0xa, 0xc9, 0xe5,
+	0x32, 0x44, 0x10, 0xfd, 0xaf, 0x31, 0x12, 0x12, 0x5b, 0xef, 0xf5, 0x36, 0xee, 0xf5, 0x35, 0xed,
+	0x44, 0x1, 0xf5, 0x34, 0xec, 0x44, 0x10, 0xf5, 0x33, 0x12, 0x11, 0x87, 0xe5, 0x36, 0x44, 0x30,
+	0xff, 0xe5, 0x35, 0xfe, 0xe5, 0x34, 0xfd, 0xe5, 0x33, 0x44, 0x20, 0xfc, 0x12, 0xa, 0xc9, 0x12,
+	0x11, 0x87, 0xaf, 0x36, 0xae, 0x35, 0xad, 0x34, 0xac, 0x33, 0x12, 0xa, 0xc9, 0xe5, 0x31, 0xb4,
+	0x6, 0x4, 0xff, 0x12, 0x14, 0xb0, 0x22, 0xe4, 0xfb, 0xad, 0x31, 0x7f, 0x20, 0x12, 0xa, 0xc2,
+	0x22, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x68, 0x12, 0x1a, 0x47, 0x12, 0x1f, 0x3b, 0x7b, 0xff, 0x7a,
+	0x1e, 0x79, 0x20, 0x12, 0x1a, 0x47, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xae, 0x12,
+	0x1c, 0x58, 0x12, 0x1f, 0x3b, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x22, 0x12, 0x1a, 0x47, 0xe4, 0xf5,
+	0x23, 0xaf, 0x23, 0x12, 0x1a, 0xf3, 0xaf, 0x23, 0x12, 0x1e, 0x94, 0x7f, 0x1, 0x12, 0x1d, 0x52,
+	0xaf, 0x23, 0x12, 0x1f, 0xc0, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 0xf, 0x77, 0x7f, 0x3, 0x12, 0x1d,
+	0x52, 0xaf, 0x23, 0x12, 0x1f, 0xc7, 0x12, 0x1a, 0xf3, 0x12, 0x1f, 0x3b, 0x5, 0x23, 0xe5, 0x23,
+	0xc3, 0x94, 0x7, 0x40, 0xcc, 0x22, 0x7f, 0xa, 0x12, 0x1d, 0x66, 0xe4, 0xff, 0xfe, 0x12, 0x19,
+	0xd6, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 0xf, 0x7e, 00, 0x12, 0x19, 0xd6, 0xef,
+	0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 0x1c, 0x24, 0x1, 0xff, 0xe4, 0x35, 0x1b,
+	0xfe, 0x12, 0x19, 0xd6, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 0x1d, 0x66, 0xe5, 0x1c, 0x15, 0x1c, 0x70,
+	0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11, 0x8f,
+	0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 0xf, 0xbf, 00, 0x1, 0xe, 0x80, 0xe6,
+	0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x22, 0xef, 0x64, 0x6, 0xef, 0x64,
+	0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 0x4, 0x7d, 0x4, 0xfc, 0x22, 0xed, 0x70,
+	0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 0x42, 0x80, 0x24, 0xbd, 0x1, 0x4, 0x7f,
+	0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 0x6, 0x7f, 0x44, 0x7e, 0x4, 0x80, 0x12,
+	0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 0x80, 0x22, 0xbd, 0x11, 0x9, 0x7f, 0x44,
+	0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 00,
+	0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 0x7c, 00, 0x22, 0x8f, 0x2c, 0x7f, 0x32,
+	0x12, 0x1f, 0x9d, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 0x12, 0xa, 0xae, 0x78, 0x8, 0x12, 0x4,
+	0xc8, 0xef, 0x54, 0x1f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4,
+	0xb7, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 0xa, 0xae, 0xc0, 0x4, 0xc0, 0x5, 0xc0,
+	0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0xb, 00, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 0x3, 0xd0, 0x2,
+	0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4, 0xb7,
+	0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0xda, 0x50, 0xa9, 0x7f, 00, 0x22, 0x8f, 0x38, 0x12,
+	0x1f, 0x74, 0x12, 0x1b, 0x76, 0x12, 0x13, 0x65, 0x12, 0x1f, 0x6b, 0x7a, 0xb6, 0x12, 0x13, 0x6f,
+	0x75, 0x3d, 0xff, 0x75, 0x3e, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x38, 0x12, 0x19,
+	0xb0, 0x75, 0x3d, 00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 0x11, 0xaf, 0x38, 0x12,
+	0x19, 0xb0, 0x7a, 0x96, 0x12, 0x13, 0x6f, 0xaf, 0x38, 0x12, 0x1f, 0x74, 0x12, 0x1b, 0x81, 0x12,
+	0x13, 0x65, 0x2, 0x1f, 0x7d, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0xb0, 0xaf, 0x38, 0x22, 0x7b,
+	0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xdf, 0x22, 0x8f, 0x3f, 0x8d, 0x40, 0x12, 0x1f, 0xc0,
+	0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xc7, 0x8f, 0x46, 0x7b, 0x1, 0xad, 0x45, 0x7f, 0x60, 0x12,
+	0xa, 0xc2, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 0x4, 0xfc, 0xef, 0x45,
+	0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0xa, 0xdf, 0x12, 0xa, 0xc9, 0xaf, 0x45, 0x12, 0x1b, 0x56,
+	0x7b, 0x2, 0xad, 0x45, 0x7f, 0x60, 0x12, 0xa, 0xae, 0x8f, 0x44, 0x8e, 0x43, 0x8d, 0x42, 0x8c,
+	0x41, 0xe5, 0x42, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x43, 0xaf, 0x44, 0x22, 0xe4, 0xfe,
+	0xff, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xf5, 0x37, 0xfb, 0x7a, 00, 0x79, 0x38, 0x12, 0x15,
+	0x36, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x37, 0x1, 0xe5, 0x38, 0x65, 0x34, 0x60, 0x3,
+	0x75, 0x37, 0x1, 0xe5, 0x37, 0x70, 0x25, 0xf5, 0x36, 0x12, 0x1d, 0x2a, 0xa8, 0x4, 0xa9, 0x5,
+	0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x9f, 0xc3, 0x12, 0x4, 0xb7, 0x60, 0x3,
+	0x75, 0x37, 0x1, 0x5, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 0x12, 0x1d, 0x3e, 0xaf,
+	0x37, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 0xdf, 0xe5, 0x35, 0x54,
+	0x3, 0xff, 0x70, 0x6, 0xf5, 0x36, 0xf5, 0x37, 0x80, 0x14, 0xbf, 0x1, 0x8, 0x75, 0x36, 0x20,
+	0x75, 0x37, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x36, 00, 0x75, 0x37, 0x40, 0xe5, 0x35,
+	0x30, 0xe4, 0x3, 0x43, 0x36, 0x1, 0xe5, 0x35, 0x30, 0xe7, 0x3, 0x43, 0x36, 0x40, 0xab, 0x37,
+	0xaa, 0x36, 0xe4, 0xfd, 0xaf, 0x34, 0x2, 0x17, 0xdf, 0x8f, 0x27, 0x12, 0x1f, 0x6b, 0x7b, 0xf0,
+	0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xdf, 0x7d, 0x11, 0xaf, 0x27, 0x12, 0x13, 0x79,
+	0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 0x1f, 0xff, 0xc3, 0x94,
+	0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 0x1f, 0x74, 0x75, 0x3d,
+	0x3, 0x12, 0x1b, 0x84, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x19, 0xb0, 0xaf, 0x27, 0x2, 0x1f, 0x7d,
+	0x8f, 0x37, 0x75, 0x3b, 0x5, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xad, 0x37, 0x7f, 0x20, 0x12, 0x17,
+	0x7d, 0xe5, 0x37, 0xb4, 0x6, 0x6, 0x75, 0x3b, 0x3, 0x12, 0x14, 0xe8, 0xe5, 0x37, 0xb4, 0x6,
+	0x6, 0x75, 0x3b, 0x2, 0x12, 0x14, 0xe8, 0x7b, 0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2,
+	0x7f, 0x33, 0x12, 0x1f, 0xb2, 0x2, 0xa, 0xc9, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xfd, 0x7f, 0x20,
+	0x12, 0x17, 0x7d, 0x22, 0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2,
+	0x7f, 0x80, 0x7e, 0x1, 0x7d, 00, 0x7c, 00, 0x12, 0xa, 0xc9, 0x7b, 0x7, 0xe4, 0xfd, 0x7f,
+	0x40, 0x12, 0xa, 0xc2, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34,
+	0xc2, 0xfc, 0x12, 0xa, 0xc9, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x16, 0xe0, 0x5, 0x27, 0xe5, 0x27,
+	0xd3, 0x94, 0xf, 0x40, 0xc2, 0x22, 0x8b, 0x39, 0x8a, 0x3a, 0x89, 0x3b, 0xe4, 0xf5, 0x8, 0xf5,
+	0x9, 0x12, 0x15, 0x6a, 0xe5, 0x3c, 0x54, 0x3f, 0xf5, 0x40, 0x85, 0x3d, 0x41, 0xe5, 0x3a, 0x45,
+	0x3b, 0x45, 0x39, 0x60, 0x10, 0xe5, 0x3f, 0x54, 0x7, 0xab, 0x39, 0xaa, 0x3a, 0xa9, 0x3b, 0x12,
+	0x3, 0x7b, 0x12, 0x15, 0x6a, 0xae, 0x40, 0xaf, 0x41, 0x22, 0x12, 0x1d, 0x2a, 0x8f, 0x3f, 0x8e,
+	0x3e, 0x8d, 0x3d, 0x8c, 0x3c, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x6, 0x60, 0x23,
+	0xe5, 0x26, 0x54, 0x3, 0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x14, 0x69, 0xe5, 0x26, 0x54,
+	0x3, 0x70, 0x10, 0xaf, 0x25, 0x12, 0x1f, 0x74, 0x12, 0x15, 0xa4, 0x12, 0x15, 0xa4, 0xaf, 0x25,
+	0x12, 0x1f, 0x7d, 0x22, 0x75, 0x3d, 0x60, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x20, 0x7d, 0x14,
+	0xaf, 0x25, 0x12, 0x19, 0xb0, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29,
+	0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 00,
+	0xb5, 0x15, 0x8, 0xea, 0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x84, 0x25, 0x1e, 0xf8,
+	0xa6, 0x17, 0xe5, 0x1e, 0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2, 0x6,
+	0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8f, 0x39, 0x8e, 0x38, 0x8d, 0x37, 0x8c, 0x36, 0x20, 0x8, 0x30,
+	0x7b, 0xc0, 0xad, 0xa, 0x7f, 0x20, 0x12, 0xa, 0xc2, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac,
+	0x36, 0x12, 0xa, 0xc9, 0xe4, 0x78, 0xab, 0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12, 0xa,
+	0xae, 0xee, 0x30, 0xe0, 0xb, 0x78, 0xab, 0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x8,
+	0x22, 0x12, 0x19, 0x8a, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0xb, 00, 0xef, 0xf4,
+	0xff, 0xef, 0x55, 0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a,
+	0x24, 0x80, 0xfb, 0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40,
+	0x12, 0x10, 0xc4, 0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xe6,
+	0x50, 0x35, 0x12, 0x1e, 0x2c, 0xef, 0x64, 0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18, 0xd3,
+	0x94, 00, 0x40, 0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa, 0xae,
+	0x18, 0x5, 0x18, 0x74, 0x66, 0x2e, 0xf8, 0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4, 0x1e,
+	0x4, 0x78, 0x83, 0x76, 0xd, 0xd3, 0x22, 0xc3, 0x22, 0xaf, 0xb, 0x15, 0xb, 0xef, 0xd3, 0x94,
+	00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55, 0x12, 0x15, 0xf5, 0x80, 0xe9,
+	0x30, 0x8, 0x9, 0x75, 0x3b, 0x1, 0x12, 0x16, 0xd3, 0xc2, 0x8, 0x22, 0xe4, 0xf5, 0x3b, 0x12,
+	0x16, 0xd3, 0x22, 0x75, 0x3c, 0x1, 0x7b, 0xc4, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x17, 0x7d, 0x22,
+	0x8e, 0x2a, 0x8f, 0x2b, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0xae, 0x2a, 0xaf,
+	0x2b, 0xe4, 0xfc, 0xfd, 0x12, 0xa, 0xc9, 0x7f, 0xa, 0x12, 0x1f, 0x9d, 0x7b, 0xb0, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0xa, 0xae, 0xef, 0x54, 0x7, 0x60, 0xa, 0x12, 0x1f, 0xda, 0x50, 0xed, 0x7f,
+	0x4, 0x12, 0x1f, 0xe2, 0x22, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f,
+	0x40, 0x12, 0xa, 0xc2, 0x7f, 00, 0x12, 0x1f, 0xb2, 0x12, 0xa, 0xc9, 0xe5, 0x22, 0xb4, 0x6,
+	0x5, 0x7d, 0x12, 0xff, 0x80, 0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0xd1, 0x5, 0x22, 0xe5,
+	0x22, 0xc3, 0x94, 0x7, 0x40, 0xd2, 0x2, 0x16, 0x31, 0x8b, 0x2a, 0x8a, 0x2b, 0x89, 0x2c, 0xe4,
+	0xf5, 0x2d, 0xab, 0x2a, 0x5, 0x2c, 0xe5, 0x2c, 0xaa, 0x2b, 0x70, 0x2, 0x5, 0x2b, 0x14, 0xf9,
+	0x12, 0x3, 0x62, 0xff, 0x12, 0x1c, 0x3f, 0xe5, 0x2d, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d,
+	0x12, 0x1f, 0xe5, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x38, 0x8d,
+	0x39, 0x8b, 0x3a, 0x12, 0xa, 0xae, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x7b, 00,
+	0x7a, 00, 0x79, 0x3d, 0xad, 0x3c, 0xaf, 0x3b, 0x12, 0xb, 0x2f, 0xab, 0x3a, 0xad, 0x39, 0xaf,
+	0x38, 0x12, 0xa, 0xc2, 0xaf, 0x40, 0xae, 0x3f, 0xad, 0x3e, 0xac, 0x3d, 0x2, 0xa, 0xc9, 00,
+	00, 0x14, 0x14, 00, 00, 00, 00, 00, 0x15, 00, 0x18, 00, 0x16, 00, 0x18, 00,
+	0x17, 00, 0x18, 00, 0x18, 00, 0x18, 00, 00, 0xc, 0x8, 00, 00, 00, 0x1, 00,
+	0x6, 00, 0x14, 00, 0x7, 00, 0x14, 00, 0x8, 00, 0x14, 00, 0x9, 00, 0x14, 0x8f,
+	0x3f, 0x8d, 0x40, 0x8a, 0x41, 0x8b, 0x42, 0x12, 0x1f, 0xc0, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f,
+	0xc7, 0x8f, 0x44, 0x7b, 0x1, 0xad, 0x43, 0x7f, 0x60, 0x12, 0xa, 0xc2, 0xab, 0x44, 0xad, 0x40,
+	0xaf, 0x42, 0xae, 0x41, 0x12, 0x1f, 0x27, 0x12, 0xa, 0xc9, 0xaf, 0x43, 0x2, 0x1b, 0x56, 0x8f,
+	0x36, 0x7b, 00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0xdf, 0x7f, 0x2, 0x12, 0x1d, 0x8d, 0xe4,
+	0xf5, 0x37, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x13, 0x79, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x37, 0xe5,
+	0x37, 0xd3, 0x94, 0xc8, 0x50, 0x7, 0x7f, 0x1, 0x12, 0x1d, 0x8d, 0x80, 0xe5, 0x22, 0x8f, 0x28,
+	0x8d, 0x29, 0xe5, 0x29, 0xf4, 0x60, 0x22, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0xa, 0xc2,
+	0x7f, 00, 0x7e, 0x6, 0x7d, 00, 0x7c, 00, 0x12, 0xa, 0xc9, 0xad, 0x29, 0xaf, 0x28, 0x12,
+	0x8, 0xec, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xd9, 0x2, 0x16, 0x31, 0xc1, 0x5, 0xc1, 0x4,
+	0x1, 0x1e, 00, 0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 0xc1,
+	0x3, 0x1, 0xc, 0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 0x18,
+	00, 0x1, 0x4d, 00, 0x1, 0x55, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 0x27,
+	0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xc2, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 0xac,
+	0x27, 0x12, 0xa, 0xc9, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0xa, 0xae, 0xef, 0x54, 0x3,
+	0x70, 0xf2, 0x22, 0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 0x4,
+	0xe, 0xbe, 0x6, 0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 0xed,
+	0x24, 0x4, 0xf8, 0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x12, 0x16, 0x6d,
+	0x50, 0x22, 0x75, 0x1a, 0x66, 0x12, 0x1f, 0x7, 0x12, 0x7, 0xe9, 0xef, 0x60, 0x13, 0x12, 0x1e,
+	0xe6, 0x50, 0x5, 0x12, 0x1e, 0x2c, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x1e, 0x79, 0x1c, 0x12, 0x1a,
+	0x47, 0xe4, 0xf5, 0x18, 0x22, 0x7b, 0x17, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2, 0x7f, 0xff,
+	0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0xa, 0xc9, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12,
+	0xa, 0xc2, 0x7f, 0x13, 0x7e, 0x23, 0x7d, 00, 0x7c, 00, 0x2, 0xa, 0xc9, 0x8f, 0x31, 0x8d,
+	0x32, 0x8b, 0x33, 0x12, 0x1f, 0x4f, 0xaf, 0x32, 0x12, 0x1f, 0x4f, 0x7f, 0x5, 0x12, 0x1f, 0x1d,
+	0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf, 0x31, 0x12, 0x14, 0x22, 0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf,
+	0x32, 0x2, 0x14, 0x22, 0x8f, 0x32, 0xed, 0x70, 0x2, 0x80, 0x1, 0xe4, 0x75, 0x39, 0x86, 0x75,
+	0x38, 0x2, 0xf5, 0x37, 0xf5, 0x36, 0x75, 0x3d, 0xff, 0x75, 0x3c, 0xf, 0xf5, 0x3b, 0xf5, 0x3a,
+	0x7b, 0x2, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x10, 0xc4, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf,
+	0x2d, 0x12, 00, 0x3, 0xef, 0x60, 0xd, 0x7b, 00, 0x7a, 00, 0x79, 0x2c, 0x7d, 0x1, 0xaf,
+	0x2d, 0x12, 0xb, 0x7, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x7, 0x40, 0xe2, 0xaf, 0x2c, 0x22,
+	0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b, 0x3c, 0x12, 0x13, 0x79, 0xe5, 0x3e, 0xf4, 0xfd, 0xe5,
+	0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42, 0x3c, 0xee, 0x42, 0x3b, 0xab, 0x3c, 0xaa, 0x3b, 0xad,
+	0x3a, 0xaf, 0x39, 0x2, 0x17, 0xdf, 0x8e, 0x48, 0x8f, 0x49, 0xe4, 0xff, 0x12, 0x1d, 0xd7, 0x7f,
+	0x3, 0x12, 0x1a, 0x6c, 0xe5, 0x48, 0xff, 0x12, 0x1a, 0x6c, 0xaf, 0x49, 0x12, 0x1a, 0x6c, 0x12,
+	0x1b, 0x35, 0x8f, 0x4a, 0x7f, 0x1, 0x12, 0x1d, 0xd7, 0xaf, 0x4a, 0x22, 0x12, 0x1c, 0x8a, 0x74,
+	0x30, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x39, 0x50, 0x5, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74,
+	0x41, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x46, 0x50, 0x5, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f,
+	0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x3, 0xd5, 0xc,
+	0x15, 0x75, 0xc, 0xa, 0xd2, 00, 0xd5, 0xd, 0x5, 0x75, 0xd, 0x64, 0xd2, 0x1, 0x30, 0x2,
+	0x5, 0xd5, 0xe, 0x2, 0xc2, 0x2, 0x32, 0x8b, 0x31, 0x8a, 0x32, 0x89, 0x33, 0xab, 0x31, 0xaa,
+	0x32, 0xa9, 0x33, 0x12, 0x3, 0x62, 0x60, 0x13, 0x5, 0x33, 0xe5, 0x33, 0x70, 0x2, 0x5, 0x32,
+	0x14, 0xf9, 0x12, 0x3, 0x62, 0xff, 0x12, 0x1d, 0xb3, 0x80, 0xe2, 0x22, 0x8f, 0x4f, 0xe4, 0xf5,
+	0x50, 0xe5, 0x4f, 0x54, 0x80, 0xff, 0x12, 0x1d, 0xe9, 0xe5, 0x4f, 0x25, 0xe0, 0xf5, 0x4f, 0x12,
+	0x1f, 0x8d, 0x12, 0x1f, 0x95, 0x5, 0x50, 0xe5, 0x50, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x8f,
+	0x25, 0x12, 0x1f, 0xb9, 0xe4, 0xfd, 0x12, 0xb, 0x7, 0xaf, 0x25, 0x12, 0x1e, 0xa2, 0x50, 0x5,
+	0xaf, 0x25, 0x12, 0x1f, 0x59, 0x7d, 0xff, 0xaf, 0x25, 0x12, 0x1b, 0xd1, 0xaf, 0x25, 0x2, 00,
+	0x1e, 0x8f, 0x34, 0x7d, 0x80, 0x7c, 00, 0x12, 0x10, 0x5a, 0xe4, 0xf5, 0x35, 0xe4, 0x25, 0x34,
+	0x12, 0x1b, 0x9f, 0x12, 0x15, 0xf5, 0x5, 0x35, 0xe5, 0x35, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2,
+	0x16, 0xa9, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xae, 0xec, 0x54, 0xf, 0xfc, 0x7b,
+	0xe9, 0x7a, 0x50, 0x79, 0x38, 0x78, 0x7, 0xc3, 0x12, 0x4, 0xb7, 0x60, 0x3, 0x7f, 0x1, 0x22,
+	0x7f, 00, 0x22, 0x8f, 0x31, 0xe5, 0x31, 0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x31, 0x75, 0xf0,
+	0xa, 0x84, 0x12, 0x1f, 0x45, 0x80, 0x2, 0x7f, 0x20, 0x12, 0x1d, 0xb3, 0xe5, 0x31, 0x12, 0x1f,
+	0x45, 0x2, 0x1d, 0xb3, 0xe4, 0xf5, 0x4e, 0x7f, 0x3, 0x12, 0x1f, 0x1d, 0xe4, 0xf5, 0x22, 0xaf,
+	0x22, 0x12, 0x1e, 0xa2, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xc, 0xbe, 0x5, 0x22, 0xe5, 0x22, 0xc3,
+	0x94, 0x7, 0x40, 0xeb, 0x22, 0xe4, 0xf5, 0x51, 0xe5, 0x52, 0x25, 0xe0, 0xf5, 0x52, 0x12, 0x1f,
+	0x8d, 0x12, 0x1d, 0xfb, 0xef, 0x42, 0x52, 0x12, 0x1f, 0x95, 0x5, 0x51, 0xe5, 0x51, 0xc3, 0x94,
+	0x8, 0x40, 0xe5, 0xaf, 0x52, 0x22, 0x8f, 0x47, 0x7f, 0x5, 0x12, 0x1f, 0x9d, 0xe4, 0xfb, 0xad,
+	0x47, 0x7f, 0x60, 0x12, 0xa, 0xae, 0xef, 0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0xda, 0x50, 0xed,
+	0x7f, 0x2, 0x12, 0x1f, 0xe2, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x2,
+	0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x75, 0x3d, 00, 0x75, 0x3e,
+	0xc, 0x7b, 0x8, 0x7a, 00, 0x22, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff,
+	0xe4, 0x34, 0x56, 0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3,
+	0xa8, 0x6, 0x8, 0x22, 0xad, 0x7, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36,
+	0x10, 0xf5, 0x3d, 0xf5, 0x3c, 0x75, 0x3b, 0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0x10,
+	0xc4, 0x8f, 0x26, 0x8d, 0x27, 0xe5, 0x26, 0x64, 0x5, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 00,
+	0xaf, 0x26, 0x12, 0x1d, 0xc5, 0xad, 0x27, 0xaf, 0x26, 0x12, 0x18, 0x3e, 0x22, 0xbf, 0x6, 0x3,
+	0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12, 0x13, 0x79, 0xef, 0x13, 0x13, 0x13, 0x54, 0x3, 0xfe, 0xef,
+	0x30, 0xe5, 0x3, 0x43, 0x6, 0x10, 0xaf, 0x6, 0x22, 0x8f, 0x2b, 0x12, 0x1e, 0x86, 0x7d, 0x1,
+	0xaf, 0x2b, 0x12, 0x1e, 0xcc, 0xaf, 0x2b, 0x12, 0xb, 00, 0x12, 0x12, 0xbc, 0xe4, 0xfd, 0xaf,
+	0x2b, 0x2, 0x1e, 0xcc, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0xa2, 0x50, 0x5, 0xaf, 0x22,
+	0x12, 0xe, 0x78, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0xc2, 0x9, 0x22, 0x8f,
+	0x2e, 0xe5, 0x2e, 0xc4, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x77, 0x12, 0x1d, 0xb3, 0xe5, 0x2e, 0x54,
+	0xf, 0xff, 0x12, 0x1e, 0x77, 0x2, 0x1d, 0xb3, 0x8f, 0x27, 0x8e, 0x26, 0x8d, 0x25, 0x8c, 0x24,
+	0x78, 0x10, 0x12, 0x4, 0xc8, 0x12, 0x1e, 0x3b, 0xe5, 0x27, 0xff, 0xe5, 0x26, 0xfe, 0x2, 0x1e,
+	0x3b, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1f, 0x12, 0x74, 0xa4, 0x25, 0x22, 0xf8, 0xa6, 0x7,
+	0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22, 0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74,
+	0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 0xef, 0x64, 0x80, 0x94, 0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0,
+	0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 0x1b, 0xed, 0x8f, 0x26, 0x7d, 0x5, 0xaf, 0x25, 0x12, 0x13,
+	0x79, 0xee, 0x30, 0xe2, 0x3, 0x43, 0x26, 0x20, 0xaf, 0x26, 0x22, 0x75, 0xcb, 0xff, 0x75, 0xca,
+	0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 0x2, 0x75, 0xc8, 0x34, 0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2,
+	0xac, 0x22, 0x12, 0x1a, 0xd2, 0xef, 0x60, 0x5, 0x7f, 0x5, 0x12, 0x1f, 0xe2, 0x12, 0x1d, 00,
+	0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 0x1f, 0xe2, 0x22, 0x8f, 0x36, 0x12, 0x1f, 0x74, 0x75, 0x3d,
+	0x3, 0x12, 0x1b, 0x79, 0x7d, 0xc, 0xaf, 0x36, 0x12, 0x19, 0xb0, 0xaf, 0x36, 0x2, 0x1f, 0x7d,
+	0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0xa2, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94,
+	0x7, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x1,
+	0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x8, 0xfd, 0xe5, 0x9, 0xfb,
+	0x7f, 0x80, 0x12, 0xa, 0xae, 0x5, 0x9, 0xe5, 0x9, 0x70, 0x2, 0x5, 0x8, 0x22, 0xe4, 0xfb,
+	0x7d, 0x4, 0x7f, 0x80, 0x12, 0xa, 0xc2, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2,
+	0xa, 0xc9, 0x8f, 0x24, 0xaf, 0x24, 0x15, 0x24, 0xef, 0xd3, 0x94, 00, 0x40, 0x7, 0x7f, 0x20,
+	0x12, 0x1d, 0xb3, 0x80, 0xef, 0x22, 0x8f, 0x55, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa,
+	0xc2, 0xaf, 0x55, 0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0xa, 0xc9, 0x53, 0x89, 0xf, 0x43, 0x89, 0x10,
+	0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x3, 0xae,
+	0x7, 0x1f, 0xee, 0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3, 0xfd, 0xc2, 0x3, 0x80, 0xf0, 0x22,
+	0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0xa, 0xc2, 0x7f, 0x1, 0x12, 0x1f, 0xb2, 0x12, 0xa,
+	0xc9, 0x80, 0xfe, 0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12, 0x1f, 0x9d, 0x20, 0x6, 0x5, 0x12,
+	0x1f, 0xda, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1c, 0x9, 0xad, 0x2a,
+	0xac, 0x29, 0xaf, 0x28, 0x2, 0x9, 0xe2, 0xef, 0x60, 0x6, 0xe5, 0x55, 0x44, 0x2, 0x80, 0x4,
+	0xe5, 0x55, 0x54, 0xfd, 0xff, 0x12, 0x1d, 0x66, 0x22, 0xef, 0x60, 0x6, 0xe5, 0x55, 0x44, 0x1,
+	0x80, 0x4, 0xe5, 0x55, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x66, 0x22, 0x7b, 0x35, 0xe4, 0xfd, 0x7f,
+	0xe0, 0x12, 0xa, 0xae, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf, 0xff, 0x22, 0x5, 0xf, 0xe5, 0xf,
+	0xc3, 0x94, 0x96, 0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1f, 0xa4, 0x22, 0x49, 0xd, 0xa, 00,
+	0x69, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0x74, 0x84, 0x25, 0x1f,
+	0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x28, 0x8f, 0x29, 0xe5,
+	0x28, 0xff, 0x12, 0x1c, 0x3f, 0xaf, 0x29, 0x2, 0x1c, 0x3f, 0x5, 0x4d, 0xe5, 0x4d, 0xc3, 0x94,
+	0xa, 0x40, 0x5, 0xe4, 0xf5, 0x4d, 0xd2, 0x9, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 00, 0x7b,
+	00, 0x7a, 0x12, 0xe4, 0xfd, 0x2, 0x19, 0xb0, 0x4c, 0x20, 0x32, 0x2e, 0x33, 0x31, 0x41, 0x74,
+	0x68, 0x33, 00, 00, 00, 00, 00, 0xef, 0xc3, 0x94, 0xa, 0xef, 0x50, 0x4, 0x24, 0x30,
+	0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x7, 0x75, 0x3b, 0x10, 0xe4, 0xf5, 0x3c, 0xfb, 0x7f,
+	0x20, 0x2, 0x17, 0x7d, 0x7d, 0x24, 0x12, 0x18, 0xc3, 0x7b, 00, 0x7a, 00, 0x79, 0x24, 0x2,
+	0x17, 0x49, 0xef, 0x90, 0x1e, 0xb7, 0x93, 0xd3, 0x94, 0x1, 0x50, 0x2, 0x80, 0x1, 0xc3, 0x22,
+	00, 0x1, 0x2, 0x3, 0x4, 0xff, 0x6, 00, 00, 00, 00, 00, 0xff, 0x1, 0x7d, 0x1,
+	0x12, 0x13, 0x79, 0xef, 0x30, 0xe2, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x8f, 0x3b, 0x8d, 0x3c,
+	0x7b, 0xe, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x7d, 0x8f, 0x3b, 0x8d, 0x3c, 0x7b, 0x10, 0xe4,
+	0xfd, 0x7f, 0x40, 0x2, 0x17, 0x7d, 0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3,
+	0x22, 0xe5, 0xaa, 0x54, 0x3, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x7f, 0x3, 0x7e, 00,
+	0x7d, 00, 0x7c, 00, 0x2, 0x18, 0x98, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80,
+	0xf6, 0x22, 0x12, 0x1e, 0xa2, 0x50, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0xc2, 0x2, 0x8f,
+	0xe, 0xd2, 0x2, 0x20, 0x2, 0xfd, 0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd,
+	0x22, 0x7f, 0x30, 0x12, 0x1d, 0xb3, 0x7f, 0x78, 0x2, 0x1d, 0xb3, 0x7f, 0xd, 0x12, 0x1d, 0xb3,
+	0x7f, 0xa, 0x2, 0x1d, 0xb3, 0x75, 0xf0, 0xa, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f,
+	0x34, 0x12, 0x18, 0xf, 0xaf, 0x34, 0x2, 0xc, 0xbe, 0xef, 0x64, 0x6, 0x60, 0x3, 0x12, 0x1c,
+	0xe9, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 0x2, 0x17, 0xdf, 0x7b, 0xb5, 0x7a, 0x52, 0x7d,
+	0x1f, 0x2, 0x17, 0xdf, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0x2, 0x17, 0xdf, 0xe4, 0xfb, 0xfa,
+	0x7d, 0x1f, 0x2, 0x17, 0xdf, 0x7d, 0x32, 0x12, 0x18, 0xc3, 0xaf, 0x37, 0x22, 0xe5, 0x55, 0x44,
+	0x4, 0xff, 0x2, 0x1d, 0x66, 0xe5, 0x55, 0x54, 0xfb, 0xff, 0x2, 0x1d, 0x66, 0xc2, 0x2, 0x8f,
+	0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 0x2, 0x16, 0xe0, 0x7f, 0x5, 0x7e, 00, 0x2,
+	0x16, 0xe0, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x4e, 0x22,
+	0xef, 0x90, 0x1e, 0xb7, 0x93, 0xff, 0x22, 0xef, 0x90, 0x1e, 0xb0, 0x93, 0xff, 0x22, 00, 0x1,
+	0x2, 0x3, 0x4, 0x6, 0x5, 0x75, 0x22, 0x1, 0x80, 0xfe, 0xa2, 0x2, 0xb3, 0x22, 0x12, 0x11,
+	0xf6, 0x22, 0xd2, 0x7, 0x22, 0x2, 0x1d, 0xb3, 0x2, 0x16, 0x31, 0x22, 0x22, 0x22,
+};
diff --git a/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c
new file mode 100644
index 0000000000..7608c6f13e
--- /dev/null
+++ b/board/ar7100/common/g5_Plus1_2_31_unmanaged_Atheros_v4.c
@@ -0,0 +1,509 @@
+/*
+ * Microcode for VSC 7395, with
+ *	- 3 delay in RGMII port
+ *	- Latest phy settings
+ *	- Flush port entries when link goes down
+ *	  (to avoid ~30sec delay when we move between
+ *	  different ports of the switch)
+ */
+static unsigned char g5_Plus1_2_31_unmanaged_Atheros_v4 [] = {
+	0x2, 0xc, 0x68, 0x8f, 0x2e, 0x12, 0x1e, 0xef, 0x12, 0x9, 0xc3, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x19, 0x5f, 0x7e, 00,
+	0x2, 0x9, 0xf6, 0x2, 0x14, 0x87, 0x78, 0x59, 0x12, 0x4, 0xee, 0xad, 0x7, 0x22, 0x78, 0x5d,
+	0x12, 0x4, 0xee, 0xab, 0x7, 0x22, 0x78, 0x55, 0x12, 0x4, 0xee, 0x78, 0x5, 0x2, 0x4, 0xdb,
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x23, 0x8d, 0x24, 0x8b, 0x25, 0xe5, 0x25, 0x7b, 0xff,
+	0x60, 0x6, 0x7a, 0x1d, 0x79, 0x5d, 0x80, 0x4, 0x7a, 0x1d, 0x79, 0x5c, 0x12, 0x19, 0x84, 0x7b,
+	0xff, 0x7a, 0x1d, 0x79, 0x5e, 0x12, 0x19, 0x84, 0xe5, 0x23, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4,
+	0xf5, 0x23, 0x75, 0x26, 0x6, 0x80, 0x11, 0xe5, 0x25, 0x60, 0xa, 0x53, 0x23, 0xfe, 0xe5, 0x23,
+	0x4, 0xf5, 0x26, 0x80, 0x3, 0x85, 0x23, 0x26, 0xe5, 0x24, 0xb4, 0xff, 0x5, 0x75, 0x28, 0x7,
+	0x80, 0xf, 0xaf, 0x24, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+	0x28, 0x7b, 0xd, 0x12, 0x3, 0x13, 0x7b, 0xe, 0x12, 0x3, 0x13, 0x12, 0x3, 0x4e, 0x12, 0x1a,
+	0xb3, 0x12, 0x9, 0x47, 0xe5, 0x23, 0x90, 0x1f, 0x4, 0x93, 0xf5, 0x2f, 0xe5, 0x25, 0x60, 0x1e,
+	0xe5, 0x23, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94,
+	0x80, 0x50, 0x8, 0xe5, 0x23, 0xa3, 0x93, 0xf5, 0x30, 0x80, 0x3, 0x75, 0x30, 0x7, 0x7e, 00,
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x29, 0x12, 0x5, 0x16, 0x75, 0x27, 0x2,
+	0xe5, 0x27, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x27, 0x8, 0x80,
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x28, 0x70, 0x3, 0x2, 0x2,
+	0x4b, 0xe5, 0x27, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x2f, 0x12, 0x1d, 0xd8,
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x30, 0x12, 0x1d, 0xd8, 0x50, 0x7, 0xe5, 0x30, 0xc3, 0x94,
+	0x7, 0x40, 0x7, 0xe5, 0x25, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x2f, 0x64, 0x6, 0x70, 0x1b,
+	0xe5, 0x27, 0x70, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27, 0xb4,
+	0x1, 0x9, 0x12, 0x3, 0x45, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x25, 0x60, 0x67, 0xe5,
+	0x27, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x27, 0x70, 0xe,
+	0x7d, 0x1, 0xaf, 0x30, 0x12, 0x12, 0x8a, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x27,
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x30, 0x12, 0x12, 0x8a, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2,
+	0x4b, 0x12, 0x3, 0x58, 0xe4, 0xf5, 0x2d, 0xf5, 0x2e, 0xaf, 0x2f, 0x12, 0x1d, 0xf4, 0x50, 0x7,
+	0xaf, 0x30, 0x12, 0x1d, 0xf4, 0x40, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa,
+	0x12, 0x1c, 0xc3, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x58, 0x5,
+	0x2e, 0xe4, 0xf5, 0x2d, 0x80, 0xd3, 0xe5, 0x27, 0x44, 0x90, 0xfd, 0xaf, 0x2f, 0x12, 0x13, 0x33,
+	0x7f, 0xa, 0x12, 0x1e, 0x53, 0xad, 0x27, 0xaf, 0x2f, 0x12, 0x10, 0x3d, 0xe5, 0x25, 0x60, 0x7,
+	0xad, 0x27, 0xaf, 0x30, 0x12, 0x10, 0x3d, 0x7f, 0x5, 0x12, 0x1e, 0x53, 0xe5, 0x25, 0x60, 0x41,
+	0xad, 0x30, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1a, 0xca, 0x80, 0x2,
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0xad, 0x2f, 0xaf, 0x30, 0x12, 0xe,
+	0xfe, 0xe5, 0x27, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc,
+	0x12, 0x1a, 0xca, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x80,
+	0x1a, 0xad, 0x2f, 0x12, 0x3, 0x36, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1a, 0xca, 0x80,
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x29, 0x4f, 0xf5, 0x29, 0x15, 0x27, 0x2, 00, 0xf0,
+	0xe4, 0xf5, 0x2c, 0xe5, 0x25, 0x70, 0x7, 0xe5, 0x2c, 0xc3, 0x94, 0x1, 0x40, 0xe, 0xe5, 0x25,
+	0x70, 0x3, 0x2, 0x2, 0xe5, 0xe5, 0x2c, 0xc3, 0x94, 0x2, 0x50, 0x79, 0x12, 0x1e, 0x71, 0xaf,
+	0x23, 0x12, 0x1a, 0x30, 0xe4, 0xf5, 0x27, 0xe5, 0x27, 0x25, 0xe0, 0xff, 0x74, 0x29, 0x25, 0x2c,
+	0xf8, 0xe6, 0xfe, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2b,
+	0x64, 0x3, 0x60, 0x1f, 0xe5, 0x2b, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x1d, 0x79, 0x5f, 0x12, 0x19,
+	0x84, 0x80, 0x10, 0x7a, 0x1d, 0x79, 0x60, 0x12, 0x19, 0x84, 0xaf, 0x2b, 0xe4, 0xfc, 0xfd, 0xfe,
+	0x12, 0xe, 0x88, 0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x3, 0x40, 0xbb, 0xe5, 0x2c, 0x70, 0xb,
+	0xaf, 0x2f, 0x12, 0x1d, 0xd8, 0x50, 0x10, 0xaf, 0x2f, 0x80, 0x9, 0xaf, 0x30, 0x12, 0x1d, 0xd8,
+	0x50, 0x5, 0xaf, 0x30, 0x12, 0x1e, 0x85, 0x5, 0x23, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x5,
+	0x5, 0x2c, 0x2, 0x2, 0x53, 0xe5, 0x23, 0xd3, 0x95, 0x26, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b,
+	0xff, 0x7a, 0x1d, 0x79, 0x61, 0x12, 0x19, 0x84, 0x7b, 0xd, 0x12, 0x3, 0x26, 0x12, 0x9, 0x47,
+	0x7b, 0xe, 0x12, 0x3, 0x26, 0x12, 0x9, 0x47, 0x12, 0x3, 0x4e, 0x7f, 0x5f, 0x12, 0x1a, 0xb5,
+	0x2, 0x9, 0x47, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x7f, 00, 0x7e, 00, 0x7d, 00,
+	0x7c, 00, 0x12, 0x9, 0x47, 0x22, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x7f, 0x5f, 0x7e,
+	00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x2f, 0x12, 0xe, 0xfe, 0xe5, 0x27, 0x25, 0xe0, 0xfe,
+	0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf, 0x2f, 0x12, 0x12, 0x8a, 0xee, 0x22, 0x7b, 0xf,
+	0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x22, 0xab, 0x27, 0xad, 0x30, 0xaf, 0x2f, 0x12, 0x18,
+	0x7a, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb,
+	0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83, 0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82,
+	0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22, 0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0,
+	0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9, 0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed,
+	0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd, 0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38,
+	0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c, 0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4,
+	0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf, 0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c,
+	0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd, 0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75,
+	0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82,
+	0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99, 0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee,
+	0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc, 0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4,
+	0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22, 0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00,
+	0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd, 0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef,
+	0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7,
+	0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf, 0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18,
+	0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10,
+	0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec, 0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0,
+	0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75, 0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+	0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33, 0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8,
+	0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a, 0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda,
+	0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8, 0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce,
+	0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb, 0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9,
+	0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22, 0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed,
+	0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff, 0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3,
+	0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc,
+	0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6, 0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93,
+	0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93, 0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8,
+	0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e, 0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb,
+	0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3, 0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50,
+	0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9,
+	0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x64, 0x20, 0x60, 0x9, 0xe5, 0x23, 0x64, 0xd, 0x60,
+	0x3, 0x7f, 0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe, 0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79,
+	0x55, 0x12, 0x5, 0x16, 0x12, 0x1e, 0x3d, 0x75, 0x24, 0xa, 0xe4, 0xf5, 0x26, 0xa8, 0x1a, 0xe6,
+	0x64, 0x30, 0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6, 0xff, 0x12, 0x1b, 0xc0, 0xbf, 0x58, 0x10, 0x75,
+	0x24, 0x10, 0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8,
+	0x1a, 0xe6, 0xf5, 0x23, 0x64, 0x20, 0x60, 0x6, 0xe5, 0x23, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x26,
+	0xd3, 0x94, 00, 0x40, 0x6a, 0xe4, 0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x31, 0xf5, 0x25,
+	0xe5, 0x25, 0xc3, 0x95, 0x26, 0x50, 0x3a, 0xaf, 0x24, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x34, 0xaa,
+	0x33, 0xa9, 0x32, 0xa8, 0x31, 0x12, 0x3, 0x8d, 0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7,
+	0x74, 0x27, 0x25, 0x25, 0xf8, 0xe6, 0xff, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5,
+	0x34, 0xee, 0x3a, 0xf5, 0x33, 0xed, 0x39, 0xf5, 0x32, 0xec, 0x38, 0xf5, 0x31, 0x5, 0x25, 0x80,
+	0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x17, 0xaf, 0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31,
+	0xab, 0x19, 0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25, 0xe0, 0x24, 0x55, 0xf8, 0x12, 0x5, 0xa, 0xe5,
+	0x23, 0x64, 0xd, 0x60, 0x3, 0x2, 0x5, 0x64, 0xff, 0x22, 0xaf, 0x23, 0x12, 0x19, 0x39, 0x8f,
+	0x23, 0xe5, 0x23, 0xf4, 0x60, 0x1d, 0xe5, 0x26, 0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x26, 0x5,
+	0x26, 0x74, 0x27, 0x2f, 0xf8, 0xa6, 0x23, 0xe5, 0x23, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x24,
+	0x10, 0x80, 0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a, 0x2, 0x5, 0x8f, 0xa8, 0x1a, 0xe6, 0xf5, 0x22,
+	0x5, 0x1a, 0x12, 0x5, 0x42, 0xef, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xaf, 0x22, 0x12, 0x1b, 0xc0,
+	0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60, 0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70,
+	0x3, 0x2, 0x7, 0xd, 0x24, 0xfd, 0x60, 0x28, 0x4, 0x60, 0x3, 0x2, 0x7, 0x48, 0x12, 0x10,
+	0xa2, 0x2, 0x7, 0x4b, 0x12, 0x1e, 0x67, 0x12, 00, 0x36, 0xc0, 0x7, 0x12, 00, 0x26, 0xc0,
+	0x5, 0x12, 00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x9, 0x2c, 0x12, 0x1b, 0x8e, 0x80, 0x3e,
+	0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x3, 0x2, 0x7, 0x4b, 0x12, 00, 0x36, 0xc0, 0x7, 0x12,
+	00, 0x26, 0xc0, 0x5, 0x12, 00, 0x2e, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x9, 0x40, 0x78, 0x61,
+	0x12, 0x4, 0xee, 0x12, 0x9, 0x47, 0x2, 0x7, 0x4b, 0x12, 0x1e, 0x67, 0x78, 0x55, 0x12, 0x4,
+	0xee, 0xc0, 0x7, 0x12, 00, 0x26, 0xd0, 0x7, 0x12, 0x12, 0x8a, 0x12, 0x1d, 0x71, 0x12, 0x1e,
+	0x71, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3, 0x40, 0x61, 0x78, 0x55, 0x12, 0x4, 0xee, 0xc0,
+	0x7, 0x12, 00, 0x26, 0xc0, 0x5, 0x12, 00, 0x2e, 0xaa, 0x6, 0x78, 0x61, 0x12, 0x4, 0xee,
+	0x8e, 0x3c, 0x8f, 0x3d, 0xd0, 0x5, 0xd0, 0x7, 0x12, 0x18, 0xed, 0x80, 0x3e, 0x78, 0x55, 0x12,
+	0x4, 0xee, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x4, 0x70, 0x2b, 0x78, 0x59, 0x12, 0x4, 0xee, 0xc0,
+	0x7, 0x78, 0x5d, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x59,
+	0x12, 0x4, 0xee, 0xc0, 0x7, 0x78, 0x5d, 0x12, 0x4, 0xee, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1,
+	0x12, 00, 0x46, 0x80, 0x6, 0x7f, 0x1, 0x22, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a,
+	0x7f, 0x1, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30, 0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed,
+	0x54, 0x3, 0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1, 0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20,
+	0xe4, 0x7, 0xef, 0x60, 0x4, 0x7d, 0x1, 0x80, 0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70,
+	0x3, 0xed, 0x60, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a,
+	0x12, 0x18, 00, 0x7b, 0x8, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x40, 0xe5, 0x31, 0xfe, 0xe5,
+	0x32, 0xff, 0xad, 0x30, 0x7c, 00, 0x12, 0x9, 0x5d, 0x12, 0x9, 0x47, 0x7b, 0xc, 0xad, 0x2a,
+	0x7f, 0x20, 0x12, 0x9, 0x40, 0xe5, 0x34, 0xfe, 0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12,
+	0x9, 0x5d, 0x12, 0x9, 0x47, 0xe5, 0x2b, 0x60, 0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0x5, 0x12,
+	0x8, 0x3a, 0x7f, 0xff, 0x7e, 00, 0x7d, 0x3, 0x7c, 00, 0x12, 0x9, 0x47, 0x85, 0x2a, 0x3b,
+	0xe4, 0xf5, 0x3c, 0x7b, 0x12, 0x80, 0x1d, 0x75, 0x2d, 0x16, 0x75, 0x2e, 0xed, 0x12, 0x8, 0x3a,
+	0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x47, 0x85, 0x2a, 0x3b, 0x75, 0x3c,
+	0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12, 0x16, 0xbb, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24,
+	0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12,
+	0x4, 0xfa, 0x12, 0x9, 0x47, 0x74, 0x4, 0x25, 0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d,
+	0x5, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40, 0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20,
+	0x12, 0x9, 0x40, 0x22, 0x8f, 0x2b, 0x8c, 0x2c, 0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70,
+	0xa, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5, 0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd,
+	0xaf, 0x2b, 0x12, 0x11, 0x6c, 0x8f, 0x31, 0x8e, 0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0xe4, 0xf5, 0x39,
+	0xf5, 0x38, 0xf5, 0x37, 0x75, 0x36, 0x80, 0xf5, 0x3d, 0xf5, 0x3c, 0xf5, 0x3b, 0x75, 0x3a, 0x80,
+	0x7b, 0xdf, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0xf, 0xd5, 0x12, 0x9, 0x22, 0xe5, 0x31, 0x54, 0xf8,
+	0xff, 0xe5, 0x30, 0xfe, 0xe5, 0x2f, 0xfd, 0xe5, 0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44,
+	0x20, 0xfc, 0x12, 0x9, 0x47, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12,
+	0x1e, 0xf, 0x12, 0x9, 0x22, 0x7f, 0x30, 0x7e, 00, 0x7d, 00, 0x7c, 0x20, 0x12, 0x9, 0x47,
+	0x85, 0x2b, 0x3b, 0x75, 0x3c, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x16, 0xbb, 0xaf,
+	0x2b, 0x12, 0x1e, 0xbb, 0xe4, 0xfc, 0xfd, 0xfe, 0x78, 0x13, 0x12, 0x4, 0xdb, 0xec, 0x44, 0x8,
+	0xfc, 0xe5, 0x31, 0x4f, 0xf5, 0x31, 0xe5, 0x30, 0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f,
+	0xe5, 0x2e, 0x4c, 0xf5, 0x2e, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x40, 0xaf, 0x31,
+	0xae, 0x30, 0xad, 0x2f, 0xac, 0x2e, 0x12, 0x9, 0x47, 0xaf, 0x2b, 0x12, 0x1a, 0xd1, 0xe5, 0x2d,
+	0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x18, 0xa1, 0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x13,
+	0xc1, 0x22, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x22, 0xef, 0x2d, 0xf5, 0xf9,
+	0x8b, 0xfa, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0xac, 0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22,
+	0xef, 0x2d, 0xf5, 0x4a, 0x8b, 0x4b, 0x22, 0x8c, 0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5,
+	0x4a, 0xf5, 0xf9, 0xe5, 0x4b, 0xf5, 0xfb, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe,
+	0xed, 0xff, 0x22, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x9,
+	0x63, 0xb4, 0x8, 00, 0x50, 0x3, 0x93, 0xff, 0x22, 0x94, 0x8, 0x93, 0xfe, 0x22, 0xef, 0x90,
+	0x9, 0x63, 0x93, 0xff, 0x22, 0x90, 0x9, 0x63, 0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x1, 0xe,
+	0x89, 0x82, 0x8a, 0x83, 0xe0, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22, 0xbb, 00,
+	0xb, 0xe9, 0xf8, 0xe6, 0x5e, 0xbd, 00, 0x2, 0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3,
+	0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12,
+	0x9, 0x85, 0x22, 0x90, 0x9, 0x63, 0xef, 0x93, 0xff, 0xbb, 0x1, 0x7, 0x89, 0x82, 0x8a, 0x83,
+	0xe0, 0x80, 0x6, 0xbb, 00, 0x8, 0xe9, 0xf8, 0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22, 0xc3, 0x22,
+	0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7,
+	0x5f, 0xff, 0x12, 0x9, 0xc3, 0x22, 0xab, 0x7, 0xaa, 0x6, 0xe4, 0xf5, 0x29, 0xf5, 0x28, 0xf5,
+	0x27, 0xf5, 0x26, 0xeb, 0x4a, 0x70, 0x8, 0xf5, 0x29, 0xf5, 0x28, 0xf5, 0x27, 0x80, 0x53, 0xeb,
+	0x64, 0x1, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x1, 0x80, 0x44, 0xeb, 0x64,
+	0x2, 0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x2, 0x80, 0x35, 0xeb, 0x64, 0x3,
+	0x4a, 0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x3, 0x80, 0x26, 0xeb, 0x64, 0x4, 0x4a,
+	0x70, 0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x4, 0x80, 0x17, 0xeb, 0x64, 0x5, 0x4a, 0x70,
+	0x9, 0xf5, 0x29, 0xf5, 0x28, 0x75, 0x27, 0x5, 0x80, 0x8, 0xe4, 0xf5, 0x29, 0xf5, 0x28, 0x75,
+	0x27, 0x6, 0x75, 0x26, 0x80, 0x12, 0xa, 0x8f, 0xaf, 0x29, 0xae, 0x28, 0xad, 0x27, 0xac, 0x26,
+	0x12, 0x9, 0x47, 0x7f, 0x3, 0x7e, 00, 0x12, 0x15, 0xe9, 0x7f, 0x3, 0x7e, 00, 0x12, 0x15,
+	0xe9, 0x12, 0xa, 0x8f, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x47, 0x7b,
+	0x9, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x22, 0x8f, 0x37, 0x12, 0x1e, 0xaa, 0x12, 0x17,
+	0x89, 0x12, 0xb, 0x28, 0x12, 0x1e, 0xa1, 0x7a, 0xaf, 0x12, 0xb, 0x14, 0x12, 0x17, 0x9e, 0x12,
+	0xa, 0xfe, 0x7a, 0x8f, 0x12, 0xb, 0x14, 0x7a, 0xaf, 0x12, 0xb, 0x1e, 0xe4, 0xf5, 0x3c, 0xf5,
+	0x3d, 0xfb, 0xfa, 0x7d, 0x11, 0xaf, 0x37, 0x12, 0x18, 0xed, 0x12, 0x17, 0x9e, 0x7d, 0x12, 0xaf,
+	0x37, 0x12, 0x18, 0xed, 0x7a, 0x8f, 0x12, 0xb, 0x1e, 0x7a, 0xaf, 0x12, 0xb, 0x32, 0x75, 0x3c,
+	0x1, 0x75, 0x3d, 0x80, 0x7b, 00, 0x7a, 0x1, 0x12, 0xa, 0xfe, 0x7a, 0x8f, 0x12, 0xb, 0x32,
+	0xaf, 0x37, 0x12, 0x1e, 0xaa, 0x12, 0x17, 0x94, 0x12, 0xb, 0x28, 0x2, 0x1e, 0xb3, 0x7d, 0x11,
+	0xaf, 0x37, 0x12, 0x18, 0xed, 0xe4, 0xf5, 0x3c, 0xf5, 0x3d, 0xfb, 0xfa, 0x7d, 0x12, 0xaf, 0x37,
+	0x12, 0x18, 0xed, 0x22, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x7b, 0x86,
+	0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x7d, 0x8, 0xaf, 0x37, 0x12, 0x18, 0xed, 0xaf,
+	0x37, 0x22, 0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x8f, 0x35, 0xe5, 0x35,
+	0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 0x12, 0x17, 0x1d, 0xaf, 0x35, 0x12,
+	0x17, 0x4d, 0x12, 0xb, 0xc9, 0x7a, 0x2, 0x12, 0xb, 0xbf, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f,
+	0xaf, 0x35, 0x12, 0x17, 0x1d, 0x7b, 0xf, 0x7a, 00, 0x7d, 0x2, 0xaf, 0x35, 0x12, 0x17, 0x1d,
+	0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x7b, 0xa4, 0x7a, 0x8f, 0xe4,
+	0xfd, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x12, 0xb, 0xc9, 0x7a, 00, 0x12, 0xb, 0xbf, 0xe4, 0xfb,
+	0xfa, 0x7d, 0x1f, 0xaf, 0x35, 0x2, 0x17, 0x1d, 0xaf, 0x35, 0x12, 0xb, 0xd5, 0xaf, 0x35, 0x12,
+	0x1c, 0x1f, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x75, 0x3c, 00,
+	0x75, 0x3d, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 0x35, 0x12, 0x18, 0xed, 0x22, 0x7b,
+	0x12, 0x7d, 0x8, 0xaf, 0x35, 0x12, 0x17, 0x1d, 0x22, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0xaf,
+	0x35, 0x12, 0x17, 0x1d, 0x22, 0x8f, 0x36, 0x12, 0xa, 0x99, 0xaf, 0x36, 0x12, 0x12, 0x2e, 0x75,
+	0x3c, 00, 0x75, 0x3d, 0xc0, 0x7b, 0x40, 0x7d, 0x12, 0x12, 0xc, 0x52, 0x12, 0x1e, 0xaa, 0x12,
+	0xc, 0x5c, 0x12, 0xc, 0x5c, 0xaf, 0x36, 0x12, 0x1e, 0xb3, 0xaf, 0x36, 0x12, 0x1e, 0xaa, 0x75,
+	0x3c, 0xf, 0x75, 0x3d, 0xc0, 0x7b, 0x40, 0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x36, 0x12, 0x18, 0xed,
+	0x75, 0x3c, 0x60, 0x75, 0x3d, 00, 0x7b, 00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x36, 0x12, 0x18,
+	0xed, 0x75, 0x3c, 00, 0x75, 0x3d, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0xc, 0x52, 0x12, 0x1e,
+	0x98, 0x75, 0x3c, 0xe0, 0x12, 0x17, 0x7f, 0xaf, 0x36, 0x12, 0x18, 0xed, 0xaf, 0x36, 0x12, 0x1e,
+	0xb3, 0x75, 0x3c, 0xe0, 0x75, 0x3d, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x36, 0x2,
+	0x18, 0xed, 0x7a, 00, 0xaf, 0x36, 0x12, 0x18, 0xed, 0xaf, 0x36, 0x22, 0x7b, 0x82, 0x7a, 0xf0,
+	0x7d, 0x3, 0xaf, 0x36, 0x12, 0x17, 0x1d, 0x22, 0x78, 0xfe, 0xe4, 0xf6, 0xd8, 0xfd, 0x75, 0x52,
+	00, 0x75, 0x53, 00, 0x75, 0x81, 0xaa, 0x2, 0xc, 0xb5, 0x2, 0xc, 0xfa, 0xe4, 0x93, 0xa3,
+	0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 0x8, 0xdf, 0xf4, 0x80, 0x29, 0xe4,
+	0x93, 0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0xf, 0x44, 0x20, 0xc8,
+	0x83, 0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0xb, 0x1, 0x2, 0x4,
+	0x8, 0x10, 0x20, 0x40, 0x80, 0x90, 0x17, 0xa9, 0xe4, 0x7e, 0x1, 0x93, 0x60, 0xbc, 0xa3, 0xff,
+	0x54, 0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x1, 0xe, 0xcf, 0x54,
+	0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3, 0xf8, 0xe4,
+	0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5, 0x82, 0xc8,
+	0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x12, 0x1f, 0x22, 0x12, 0x18, 0x52,
+	0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 0xf5, 0x37, 0xf5, 0x36, 0xf5, 0x3d,
+	0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 0x7f, 0xe0, 0x12, 0xf, 0xd5, 0x12,
+	0x1c, 0xb0, 0x12, 0x1b, 0xf1, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 0x1c, 0xc3, 0x12, 0xe, 0xa, 0x12,
+	0x1f, 0x23, 0x12, 0x1a, 0xf, 0xef, 0x70, 0x3, 0x30, 0x7, 0x3, 0x12, 0x1f, 0xb, 0x12, 0x1a,
+	0x51, 0x12, 0x1c, 0x36, 0xef, 0x60, 0x3, 0x12, 0x1f, 0xb, 0x12, 0x16, 0x53, 0x12, 0x1b, 0xa7,
+	0x30, 0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f, 00,
+	0x7e, 00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x47, 0x12, 0x18, 0x2a, 0x30, 00, 0x8, 0xc2,
+	00, 0x12, 0x1d, 0x80, 0x12, 0x1b, 0x41, 0x30, 0x1, 0xd6, 0xc2, 0x1, 0x12, 0x1d, 0x42, 0x12,
+	0x1c, 0x8, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x8f, 0x23, 0x74, 0xa3, 0x2f, 0xf8, 0xe6,
+	0x24, 0xfe, 0x60, 0x2a, 0x14, 0x60, 0x5c, 0x24, 0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d,
+	0x4, 0xaf, 0x23, 0x12, 0x17, 0x1d, 0x7b, 00, 0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17,
+	0x1d, 0xaf, 0x23, 0x12, 0x1d, 0x8f, 0x74, 0xa3, 0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9,
+	0x48, 0xaf, 0x23, 0x12, 0x1d, 0xf4, 0x50, 0x41, 0x12, 0x1e, 0xef, 0x7d, 0x1, 0xaf, 0x23, 0x12,
+	0x9, 0x85, 0xaf, 0x23, 0x12, 0x1b, 0xd9, 0x8f, 0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1a, 0xee,
+	0xad, 0x24, 0xaf, 0x23, 0x12, 0x15, 0x7a, 0x74, 0xa3, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23,
+	0x2, 0x1f, 0x1e, 0x30, 0x9, 0x13, 0xaf, 0x23, 0x12, 0x1d, 0xf4, 0x40, 0xc, 0x74, 0xa3, 0x25,
+	0x23, 0xf8, 0x76, 0x2, 0xaf, 0x23, 0x12, 0x19, 0xcc, 0x22, 0x12, 0x1f, 0x21, 0xe4, 0x75, 0x26,
+	0xc0, 0xf5, 0x25, 0xf5, 0x24, 0xf5, 0x23, 0xf5, 0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf,
+	0x22, 0x12, 0x9, 0xe0, 0x40, 0x21, 0xe4, 0xfb, 0x7d, 0x2, 0x7f, 0x60, 0x12, 0x9, 0x40, 0xe4,
+	0x25, 0x22, 0xff, 0xe4, 0x34, 0x4, 0xfe, 0xe4, 0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12,
+	0x9, 0x47, 0x7f, 0x2, 0x12, 0x1c, 0xc3, 0x5, 0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9,
+	0x7f, 0x3, 0x12, 0x1e, 0x53, 0x12, 0x1e, 0xe1, 0x12, 0x1e, 0x32, 0x7f, 0x4, 0x12, 0x1e, 0x53,
+	0x75, 0x3b, 0x1, 0x75, 0x3c, 0x1, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x16, 0xbb, 0x7f,
+	0x14, 0x12, 0x1c, 0xc3, 0x7b, 0x4, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0x7f, 0x5f, 0x12,
+	0x1e, 0xe8, 0x12, 0x9, 0x47, 0x2, 0x14, 0x5, 0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31,
+	0xe4, 0xf5, 0x3f, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x34, 0xaa, 0x33, 0xa9, 0x32, 0xa8, 0x31,
+	0xd3, 0x12, 0x4, 0xb7, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 0x34, 0xae, 0x33,
+	0xad, 0x32, 0xac, 0x31, 0x12, 0x4, 0x18, 0xaf, 0x3, 0x74, 0x35, 0x25, 0x3f, 0xf8, 0xa6, 0x7,
+	0xaf, 0x34, 0xae, 0x33, 0xad, 0x32, 0xac, 0x31, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0x12, 0x4,
+	0x18, 0x8f, 0x34, 0x8e, 0x33, 0x8d, 0x32, 0x8c, 0x31, 0x5, 0x3f, 0x80, 0xb6, 0xe5, 0x3f, 0x70,
+	0x5, 0x7f, 0x30, 0x2, 0x1c, 0xe9, 0x15, 0x3f, 0xe5, 0x3f, 0xf4, 0x60, 0x10, 0x74, 0x35, 0x25,
+	0x3f, 0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1c, 0xe9, 0x15, 0x3f, 0x80, 0xeb, 0x22, 0x8f, 0x31,
+	0x8d, 0x32, 0x7b, 0x24, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x7f, 0x6, 0x12, 0x1a, 0xb5, 0x12, 0x9,
+	0x47, 0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0x75, 0x3c, 0x1, 0xe4, 0xfd, 0x7f, 0x40,
+	0x12, 0x16, 0xbb, 0x7f, 0x2, 0x12, 0x1e, 0x53, 0xaf, 0x32, 0x12, 0x19, 0xee, 0x7f, 0xa, 0x12,
+	0x1e, 0xd3, 0x12, 0x1e, 0x27, 0x40, 0x5, 0x12, 0x1f, 0x10, 0x50, 0xf6, 0x12, 0x1f, 0x10, 0x40,
+	0x13, 0xad, 0x32, 0xaf, 0x31, 0x12, 0x12, 0xe3, 0xef, 0x70, 0x4, 0xf5, 0x33, 0x80, 0x8, 0x75,
+	0x33, 0x1, 0x80, 0x3, 0x75, 0x33, 0x2, 0xe5, 0x31, 0x24, 0x80, 0xfb, 0x75, 0x3b, 0x1b, 0xe4,
+	0xf5, 0x3c, 0xfd, 0x7f, 0x40, 0x12, 0x16, 0xbb, 0xaf, 0x33, 0x22, 0x8f, 0xa, 0xc3, 0xed, 0x94,
+	0x40, 0xec, 0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 0xef, 0x78,
+	0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 0x3, 0xff,
+	0xe4, 0x3c, 0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 0xe0, 0x5,
+	0x75, 0xb, 0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x40,
+	0xe, 0xae, 0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xdb, 0x80, 0x8, 0x7f,
+	00, 0x7e, 00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x14, 0xc6, 0x7f, 0x20, 0x7e, 0x5, 0x7d, 00,
+	0x7c, 00, 0x2, 0x14, 0xc6, 0x8f, 0x33, 0x8d, 0x34, 0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5,
+	0x39, 0xe5, 0x38, 0x55, 0x3c, 0xf5, 0x38, 0xe5, 0x37, 0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55,
+	0x3a, 0xf5, 0x36, 0x12, 0x9, 0x2c, 0xa8, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d,
+	0xae, 0x3c, 0xad, 0x3b, 0xac, 0x3a, 0x12, 0x4, 0xaa, 0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9,
+	0x5d, 0xfd, 0xe8, 0x5c, 0xfc, 0xe5, 0x39, 0x4f, 0xf5, 0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5,
+	0x37, 0x4d, 0xf5, 0x37, 0xe5, 0x36, 0x4c, 0xf5, 0x36, 0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12,
+	0x9, 0x40, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac, 0x36, 0x2, 0x9, 0x47, 0x8f, 0x31, 0x8d,
+	0x32, 0x7b, 0x19, 0xad, 0x31, 0x7f, 0x20, 0x12, 0x9, 0x40, 0x12, 0x1a, 0xb3, 0x12, 0x9, 0x47,
+	0xe5, 0x32, 0x44, 0x10, 0xfd, 0xaf, 0x31, 0x12, 0x11, 0x6c, 0xef, 0xf5, 0x36, 0xee, 0xf5, 0x35,
+	0xed, 0x44, 0x1, 0xf5, 0x34, 0xec, 0x44, 0x10, 0xf5, 0x33, 0x12, 0x10, 0x98, 0xe5, 0x36, 0x44,
+	0x30, 0xff, 0xe5, 0x35, 0xfe, 0xe5, 0x34, 0xfd, 0xe5, 0x33, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x47,
+	0x12, 0x10, 0x98, 0xaf, 0x36, 0xae, 0x35, 0xad, 0x34, 0xac, 0x33, 0x12, 0x9, 0x47, 0xe5, 0x31,
+	0xb4, 0x6, 0x4, 0xff, 0x12, 0x13, 0xc1, 0x22, 0xe4, 0xfb, 0xad, 0x31, 0x7f, 0x20, 0x12, 0x9,
+	0x40, 0x22, 0x7b, 0xff, 0x7a, 0x1d, 0x79, 0x9e, 0x12, 0x19, 0x84, 0x12, 0x1e, 0x71, 0x7b, 0xff,
+	0x7a, 0x1d, 0x79, 0x56, 0x12, 0x19, 0x84, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x2c,
+	0x12, 0x1b, 0x8e, 0x12, 0x1e, 0x71, 0x7b, 0xff, 0x7a, 0x1d, 0x79, 0x58, 0x12, 0x19, 0x84, 0xe4,
+	0xf5, 0x23, 0xaf, 0x23, 0x12, 0x1a, 0x30, 0xaf, 0x23, 0x12, 0x1d, 0xca, 0x7f, 0x1, 0x12, 0x1c,
+	0x88, 0xaf, 0x23, 0x12, 0x1e, 0xf6, 0xe4, 0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x88, 0x7f, 0x3, 0x12,
+	0x1c, 0x88, 0xaf, 0x23, 0x12, 0x1e, 0xfd, 0x12, 0x1a, 0x30, 0x12, 0x1e, 0x71, 0x5, 0x23, 0xe5,
+	0x23, 0xc3, 0x94, 0x7, 0x40, 0xcc, 0x22, 0x7f, 0xa, 0x12, 0x1c, 0x9c, 0xe4, 0xff, 0xfe, 0x12,
+	0x19, 0x13, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 0xf, 0x7e, 00, 0x12, 0x19, 0x13,
+	0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 0x1c, 0x24, 0x1, 0xff, 0xe4, 0x35,
+	0x1b, 0xfe, 0x12, 0x19, 0x13, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 0x1c, 0x9c, 0xe5, 0x1c, 0x15, 0x1c,
+	0x70, 0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 0x1c, 0xee, 0x95, 0x1b, 0x50, 0x11,
+	0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 0xf, 0xbf, 00, 0x1, 0xe, 0x80,
+	0xe6, 0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x22, 0xef, 0x64, 0x6, 0xef,
+	0x64, 0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 0x4, 0x7d, 0x4, 0xfc, 0x22, 0xed,
+	0x70, 0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 0x42, 0x80, 0x24, 0xbd, 0x1, 0x4,
+	0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 0x6, 0x7f, 0x44, 0x7e, 0x4, 0x80,
+	0x12, 0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 0x80, 0x22, 0xbd, 0x11, 0x9, 0x7f,
+	0x44, 0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d,
+	00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 0x7c, 00, 0x22, 0x8f, 0x2c, 0x7f,
+	0x32, 0x12, 0x1e, 0xd3, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 0x12, 0x9, 0x2c, 0x78, 0x8, 0x12,
+	0x4, 0xc8, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12,
+	0x4, 0xb7, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 0x9, 0x2c, 0xc0, 0x4, 0xc0, 0x5,
+	0xc0, 0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0x9, 0x7e, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0, 0x3, 0xd0,
+	0x2, 0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3, 0x12, 0x4,
+	0xb7, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0x10, 0x50, 0xa9, 0x7f, 00, 0x22, 0x8f, 0x37,
+	0x12, 0x1e, 0xaa, 0x12, 0x17, 0x89, 0x12, 0x12, 0x76, 0x12, 0x1e, 0xa1, 0x7a, 0xb6, 0x12, 0x12,
+	0x80, 0x75, 0x3c, 0xff, 0x75, 0x3d, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x37, 0x12,
+	0x18, 0xed, 0x75, 0x3c, 00, 0x75, 0x3d, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 0x11, 0xaf, 0x37,
+	0x12, 0x18, 0xed, 0x7a, 0x96, 0x12, 0x12, 0x80, 0xaf, 0x37, 0x12, 0x1e, 0xaa, 0x12, 0x17, 0x94,
+	0x12, 0x12, 0x76, 0x2, 0x1e, 0xb3, 0x7d, 0x8, 0xaf, 0x37, 0x12, 0x18, 0xed, 0xaf, 0x37, 0x22,
+	0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x37, 0x12, 0x17, 0x1d, 0x22, 0x8f, 0x3e, 0x8d, 0x3f, 0x12, 0x1e,
+	0xf6, 0x8f, 0x44, 0xaf, 0x3e, 0x12, 0x1e, 0xfd, 0x8f, 0x45, 0x7b, 0x1, 0xad, 0x44, 0x7f, 0x60,
+	0x12, 0x9, 0x40, 0xe5, 0x45, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 0x4, 0xfc, 0xef,
+	0x45, 0x3f, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x9, 0x5d, 0x12, 0x9, 0x47, 0xaf, 0x44, 0x12, 0x1a,
+	0x93, 0x7b, 0x2, 0xad, 0x44, 0x7f, 0x60, 0x12, 0x9, 0x2c, 0x8f, 0x43, 0x8e, 0x42, 0x8d, 0x41,
+	0x8c, 0x40, 0xe5, 0x41, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x42, 0xaf, 0x43, 0x22, 0xe4,
+	0xfe, 0xff, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xf5, 0x37, 0xfb, 0x7a, 00, 0x79, 0x38, 0x12,
+	0x14, 0x47, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x37, 0x1, 0xe5, 0x38, 0x65, 0x34, 0x60,
+	0x3, 0x75, 0x37, 0x1, 0xe5, 0x37, 0x70, 0x25, 0xf5, 0x36, 0x12, 0x1c, 0x60, 0xa8, 0x4, 0xa9,
+	0x5, 0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x35, 0x12, 0x1a, 0xbc, 0xc3, 0x12, 0x4, 0xb7, 0x60,
+	0x3, 0x75, 0x37, 0x1, 0x5, 0x36, 0xe5, 0x36, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 0x12, 0x1c, 0x74,
+	0xaf, 0x37, 0x22, 0x8f, 0x34, 0x8d, 0x35, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 0x1d, 0xe5, 0x35,
+	0x54, 0x3, 0xff, 0x70, 0x6, 0xf5, 0x36, 0xf5, 0x37, 0x80, 0x14, 0xbf, 0x1, 0x8, 0x75, 0x36,
+	0x20, 0x75, 0x37, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x36, 00, 0x75, 0x37, 0x40, 0xe5,
+	0x35, 0x30, 0xe4, 0x3, 0x43, 0x36, 0x1, 0xe5, 0x35, 0x30, 0xe7, 0x3, 0x43, 0x36, 0x40, 0xab,
+	0x37, 0xaa, 0x36, 0xe4, 0xfd, 0xaf, 0x34, 0x2, 0x17, 0x1d, 0x8f, 0x27, 0x12, 0x1e, 0xa1, 0x7b,
+	0xf0, 0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0x1d, 0x7d, 0x11, 0xaf, 0x27, 0x12, 0x12,
+	0x8a, 0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 0x1f, 0xff, 0xc3,
+	0x94, 0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 0x1e, 0xaa, 0x75,
+	0x3c, 0x3, 0x12, 0x17, 0x97, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x18, 0xed, 0xaf, 0x27, 0x2, 0x1e,
+	0xb3, 0x8f, 0x37, 0x75, 0x3b, 0x5, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xad, 0x37, 0x7f, 0x20, 0x12,
+	0x16, 0xbb, 0xe5, 0x37, 0xb4, 0x6, 0x6, 0x75, 0x3b, 0x3, 0x12, 0x13, 0xf9, 0xe5, 0x37, 0xb4,
+	0x6, 0x6, 0x75, 0x3b, 0x2, 0x12, 0x13, 0xf9, 0x7b, 0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9,
+	0x40, 0x7f, 0x33, 0x12, 0x1e, 0xe8, 0x2, 0x9, 0x47, 0x75, 0x3c, 0x1, 0x7b, 0x19, 0xfd, 0x7f,
+	0x20, 0x12, 0x16, 0xbb, 0x22, 0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9,
+	0x40, 0x7f, 0x80, 0x7e, 0x1, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x47, 0x7b, 0x7, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0x9, 0x40, 0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4,
+	0x34, 0xc2, 0xfc, 0x12, 0x9, 0x47, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x15, 0xe9, 0x5, 0x27, 0xe5,
+	0x27, 0xd3, 0x94, 0xf, 0x40, 0xc2, 0x22, 0x8b, 0x39, 0x8a, 0x3a, 0x89, 0x3b, 0xe4, 0xf5, 0x8,
+	0xf5, 0x9, 0x12, 0x14, 0x7b, 0xe5, 0x3c, 0x54, 0x3f, 0xf5, 0x40, 0x85, 0x3d, 0x41, 0xe5, 0x3a,
+	0x45, 0x3b, 0x45, 0x39, 0x60, 0x10, 0xe5, 0x3f, 0x54, 0x7, 0xab, 0x39, 0xaa, 0x3a, 0xa9, 0x3b,
+	0x12, 0x3, 0x7b, 0x12, 0x14, 0x7b, 0xae, 0x40, 0xaf, 0x41, 0x22, 0x12, 0x1c, 0x60, 0x8f, 0x3f,
+	0x8e, 0x3e, 0x8d, 0x3d, 0x8c, 0x3c, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98,
+	0x29, 0xaf, 0x99, 0xc2, 0x98, 0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a,
+	00, 0xb5, 0x15, 0x8, 0xea, 0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x83, 0x25, 0x1e,
+	0xf8, 0xa6, 0x17, 0xe5, 0x1e, 0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2,
+	0x6, 0xd0, 0xd0, 0xd0, 0xe0, 0x32, 0x8f, 0x39, 0x8e, 0x38, 0x8d, 0x37, 0x8c, 0x36, 0x20, 0x8,
+	0x30, 0x7b, 0xc0, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x9, 0x40, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37,
+	0xac, 0x36, 0x12, 0x9, 0x47, 0xe4, 0x78, 0xaa, 0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12,
+	0x9, 0x2c, 0xee, 0x30, 0xe0, 0xb, 0x78, 0xaa, 0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2,
+	0x8, 0x22, 0x12, 0x18, 0xc7, 0x8f, 0x2b, 0xe4, 0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x9, 0x7e, 0xef,
+	0xf4, 0xff, 0xef, 0x55, 0x2b, 0xff, 0xe4, 0x8f, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5,
+	0x2a, 0x24, 0x80, 0xfb, 0xe4, 0x75, 0x3d, 0x5f, 0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f,
+	0x40, 0x12, 0xf, 0xd5, 0x5, 0x2a, 0xe5, 0x2a, 0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e,
+	0x1c, 0x50, 0x35, 0x12, 0x1d, 0x62, 0xef, 0x64, 0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18,
+	0xd3, 0x94, 00, 0x40, 0x23, 0x15, 0x18, 0x80, 0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa,
+	0xae, 0x18, 0x5, 0x18, 0x74, 0x65, 0x2e, 0xf8, 0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4,
+	0x1e, 0x4, 0x78, 0x82, 0x76, 0xd, 0xd3, 0x22, 0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25,
+	0x64, 0x6, 0x60, 0x2d, 0xe5, 0x26, 0x54, 0x3, 0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x13,
+	0x7a, 0xe5, 0x26, 0x54, 0x3, 0x70, 0x1a, 0xaf, 0x25, 0x12, 0x1e, 0xaa, 0x12, 0x17, 0x7c, 0xaf,
+	0x25, 0x12, 0x18, 0xed, 0x12, 0x17, 0x7c, 0xaf, 0x25, 0x12, 0x18, 0xed, 0xaf, 0x25, 0x12, 0x1e,
+	0xb3, 0x22, 0xaf, 0xb, 0x15, 0xb, 0xef, 0xd3, 0x94, 00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55,
+	0x7d, 0x55, 0x7c, 0x55, 0x12, 0x14, 0xc6, 0x80, 0xe9, 0x30, 0x8, 0x9, 0x75, 0x3b, 0x1, 0x12,
+	0x15, 0xdc, 0xc2, 0x8, 0x22, 0xe4, 0xf5, 0x3b, 0x12, 0x15, 0xdc, 0x22, 0x75, 0x3c, 0x1, 0x7b,
+	0xc4, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x16, 0xbb, 0x22, 0x8e, 0x2a, 0x8f, 0x2b, 0x7b, 0xb0, 0xe4,
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0xae, 0x2a, 0xaf, 0x2b, 0xe4, 0xfc, 0xfd, 0x12, 0x9, 0x47,
+	0x7f, 0xa, 0x12, 0x1e, 0xd3, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x2c, 0xef, 0x54,
+	0x7, 0x60, 0xa, 0x12, 0x1f, 0x10, 0x50, 0xed, 0x7f, 0x4, 0x12, 0x1f, 0x18, 0x22, 0x8f, 0x28,
+	0x8d, 0x29, 0xe5, 0x29, 0xf4, 0x60, 0x29, 0x7b, 0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x9, 0x40,
+	0x7f, 00, 0x7e, 0x6, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x47, 0xad, 0x29, 0xaf, 0x28, 0x12,
+	0x7, 0x4e, 0xe4, 0xfd, 0xaf, 0x28, 0x12, 0x1b, 0x5c, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xf,
+	0x2, 0x15, 0x2, 0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x9, 0x40, 0x7f, 00, 0x12, 0x1e, 0xe8, 0x12, 0x9, 0x47, 0xe5, 0x22, 0xb4, 0x6, 0x5, 0x7d,
+	0x12, 0xff, 0x80, 0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1a, 0xee, 0x5, 0x22, 0xe5, 0x22, 0xc3,
+	0x94, 0x7, 0x40, 0xd2, 0x2, 0x15, 0x2, 0x8b, 0x2a, 0x8a, 0x2b, 0x89, 0x2c, 0xe4, 0xf5, 0x2d,
+	0xab, 0x2a, 0x5, 0x2c, 0xe5, 0x2c, 0xaa, 0x2b, 0x70, 0x2, 0x5, 0x2b, 0x14, 0xf9, 0x12, 0x3,
+	0x62, 0xff, 0x12, 0x1b, 0x75, 0xe5, 0x2d, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d, 0x12, 0x1f,
+	0x1b, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x38, 0x8d, 0x39, 0x8b,
+	0x3a, 0x12, 0x9, 0x2c, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c, 0x3d, 0x7b, 00, 0x7a, 00,
+	0x79, 0x3d, 0xad, 0x3c, 0xaf, 0x3b, 0x12, 0x9, 0xad, 0xab, 0x3a, 0xad, 0x39, 0xaf, 0x38, 0x12,
+	0x9, 0x40, 0xaf, 0x40, 0xae, 0x3f, 0xad, 0x3e, 0xac, 0x3d, 0x2, 0x9, 0x47, 00, 00, 0x10,
+	0x10, 0x80, 00, 00, 00, 00, 0xe, 00, 0x15, 00, 0x10, 00, 0x15, 00, 0x12, 00,
+	0x15, 00, 0x14, 00, 0x15, 00, 00, 0x10, 0xc, 0x80, 00, 00, 0x1, 00, 0xa, 00,
+	0x18, 00, 0xb, 00, 0x18, 00, 0xc, 00, 0x18, 00, 0xd, 00, 0x18, 0x8f, 0x3e, 0x8d,
+	0x3f, 0x8a, 0x40, 0x8b, 0x41, 0x12, 0x1e, 0xf6, 0x8f, 0x42, 0xaf, 0x3e, 0x12, 0x1e, 0xfd, 0x8f,
+	0x43, 0x7b, 0x1, 0xad, 0x42, 0x7f, 0x60, 0x12, 0x9, 0x40, 0xab, 0x43, 0xad, 0x3f, 0xaf, 0x41,
+	0xae, 0x40, 0x12, 0x1e, 0x5d, 0x12, 0x9, 0x47, 0xaf, 0x42, 0x2, 0x1a, 0x93, 0x8f, 0x36, 0x7b,
+	00, 0x7a, 0x80, 0xe4, 0xfd, 0x12, 0x17, 0x1d, 0x7f, 0x2, 0x12, 0x1c, 0xc3, 0xe4, 0xf5, 0x37,
+	0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x12, 0x8a, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x37, 0xe5, 0x37, 0xd3,
+	0x94, 0xc8, 0x50, 0x7, 0x7f, 0x1, 0x12, 0x1c, 0xc3, 0x80, 0xe5, 0x22, 0x75, 0x3c, 0x60, 0x75,
+	0x3d, 00, 0x7b, 00, 0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3c, 0x2, 0x75, 0x3d, 00, 0x7b,
+	00, 0x7a, 0x2, 0x22, 0x75, 0x3c, 0x2, 0x75, 0x3d, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x75, 0x3c,
+	00, 0x75, 0x3d, 0xc, 0x7b, 0x8, 0x7a, 00, 0x22, 0xc1, 0x5, 0xc1, 0x4, 0x1, 0x1e, 00,
+	0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 0xc1, 0x3, 0x1, 0xc,
+	0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 0x18, 00, 0x1, 0x4c,
+	00, 0x1, 0x54, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 0x27, 0x7b, 0xd0, 0xe4,
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x40, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 0xac, 0x27, 0x12, 0x9,
+	0x47, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x2c, 0xef, 0x54, 0x3, 0x70, 0xf2, 0x22,
+	0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 0x4, 0xe, 0xbe, 0x6,
+	0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 0xed, 0x24, 0x4, 0xf8,
+	0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x12, 0x15, 0x3e, 0x50, 0x22, 0x75,
+	0x1a, 0x65, 0x12, 0x1e, 0x3d, 0x12, 0x6, 0x4b, 0xef, 0x60, 0x13, 0x12, 0x1e, 0x1c, 0x50, 0x5,
+	0x12, 0x1d, 0x62, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x1d, 0x79, 0x52, 0x12, 0x19, 0x84, 0xe4, 0xf5,
+	0x18, 0x22, 0x7b, 0x17, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f, 0xff, 0x7e, 0xff, 0x7d,
+	0xff, 0x7c, 0xff, 0x12, 0x9, 0x47, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f,
+	0x14, 0x7e, 0x23, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x47, 0x8f, 0x31, 0x8d, 0x32, 0x8b, 0x33,
+	0x12, 0x1e, 0x85, 0xaf, 0x32, 0x12, 0x1e, 0x85, 0x7f, 0x5, 0x12, 0x1e, 0x53, 0xe5, 0x33, 0x44,
+	0x10, 0xfd, 0xaf, 0x31, 0x12, 0x13, 0x33, 0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf, 0x32, 0x2, 0x13,
+	0x33, 0x8f, 0x32, 0xed, 0x70, 0x2, 0x80, 0x1, 0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x2, 0xf5,
+	0x37, 0xf5, 0x36, 0x75, 0x3d, 0xff, 0x75, 0x3c, 0xf, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x2, 0xad,
+	0x32, 0x7f, 0x20, 0x12, 0xf, 0xd5, 0x22, 0xe4, 0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 00,
+	0x3, 0xef, 0x60, 0xd, 0x7b, 00, 0x7a, 00, 0x79, 0x2c, 0x7d, 0x1, 0xaf, 0x2d, 0x12, 0x9,
+	0x85, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x7, 0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x38, 0x8d,
+	0x39, 0x8a, 0x3a, 0x8b, 0x3b, 0x12, 0x12, 0x8a, 0xe5, 0x3d, 0xf4, 0xfd, 0xe5, 0x3c, 0xf4, 0x5e,
+	0xfe, 0xef, 0x5d, 0x42, 0x3b, 0xee, 0x42, 0x3a, 0xab, 0x3b, 0xaa, 0x3a, 0xad, 0x39, 0xaf, 0x38,
+	0x2, 0x17, 0x1d, 0x8e, 0x47, 0x8f, 0x48, 0xe4, 0xff, 0x12, 0x1d, 0xd, 0x7f, 0x3, 0x12, 0x19,
+	0xa9, 0xe5, 0x47, 0xff, 0x12, 0x19, 0xa9, 0xaf, 0x48, 0x12, 0x19, 0xa9, 0x12, 0x1a, 0x72, 0x8f,
+	0x49, 0x7f, 0x1, 0x12, 0x1d, 0xd, 0xaf, 0x49, 0x22, 0x12, 0x1b, 0xc0, 0x74, 0x30, 0xd3, 0x9f,
+	0x50, 0xa, 0xef, 0x94, 0x39, 0x50, 0x5, 0xef, 0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f,
+	0x50, 0xa, 0xef, 0x94, 0x46, 0x50, 0x5, 0xef, 0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2,
+	0x8e, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xd2, 0x8e, 0xd2, 0x3, 0xd5, 0xc, 0x15, 0x75, 0xc,
+	0xa, 0xd2, 00, 0xd5, 0xd, 0x5, 0x75, 0xd, 0x64, 0xd2, 0x1, 0x30, 0x2, 0x5, 0xd5, 0xe,
+	0x2, 0xc2, 0x2, 0x32, 0x8b, 0x31, 0x8a, 0x32, 0x89, 0x33, 0xab, 0x31, 0xaa, 0x32, 0xa9, 0x33,
+	0x12, 0x3, 0x62, 0x60, 0x13, 0x5, 0x33, 0xe5, 0x33, 0x70, 0x2, 0x5, 0x32, 0x14, 0xf9, 0x12,
+	0x3, 0x62, 0xff, 0x12, 0x1c, 0xe9, 0x80, 0xe2, 0x22, 0x8f, 0x4e, 0xe4, 0xf5, 0x4f, 0xe5, 0x4e,
+	0x54, 0x80, 0xff, 0x12, 0x1d, 0x1f, 0xe5, 0x4e, 0x25, 0xe0, 0xf5, 0x4e, 0x12, 0x1e, 0xc3, 0x12,
+	0x1e, 0xcb, 0x5, 0x4f, 0xe5, 0x4f, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x8f, 0x25, 0x12, 0x1e,
+	0xef, 0xe4, 0xfd, 0x12, 0x9, 0x85, 0xaf, 0x25, 0x12, 0x1d, 0xd8, 0x50, 0x5, 0xaf, 0x25, 0x12,
+	0x1e, 0x8f, 0x7d, 0xff, 0xaf, 0x25, 0x12, 0x1a, 0xee, 0xaf, 0x25, 0x2, 00, 0x1e, 0x8f, 0x34,
+	0x7d, 0x80, 0x7c, 00, 0x12, 0xf, 0x6b, 0xe4, 0xf5, 0x35, 0xe4, 0x25, 0x34, 0x12, 0x1a, 0xbc,
+	0x12, 0x14, 0xc6, 0x5, 0x35, 0xe5, 0x35, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2, 0x15, 0xb2, 0x7b,
+	0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x2c, 0xec, 0x54, 0xf, 0xfc, 0x7b, 0xe9, 0x7a, 0x50,
+	0x79, 0x39, 0x78, 0x7, 0xc3, 0x12, 0x4, 0xb7, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22,
+	0x8f, 0x31, 0xe5, 0x31, 0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x31, 0x75, 0xf0, 0xa, 0x84, 0x12,
+	0x1e, 0x7b, 0x80, 0x2, 0x7f, 0x20, 0x12, 0x1c, 0xe9, 0xe5, 0x31, 0x12, 0x1e, 0x7b, 0x2, 0x1c,
+	0xe9, 0xe4, 0xf5, 0x4d, 0x7f, 0x3, 0x12, 0x1e, 0x53, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1d,
+	0xd8, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xb, 0x3c, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40,
+	0xeb, 0x22, 0xe4, 0xf5, 0x50, 0xe5, 0x51, 0x25, 0xe0, 0xf5, 0x51, 0x12, 0x1e, 0xc3, 0x12, 0x1d,
+	0x31, 0xef, 0x42, 0x51, 0x12, 0x1e, 0xcb, 0x5, 0x50, 0xe5, 0x50, 0xc3, 0x94, 0x8, 0x40, 0xe5,
+	0xaf, 0x51, 0x22, 0x8f, 0x46, 0x7f, 0x5, 0x12, 0x1e, 0xd3, 0xe4, 0xfb, 0xad, 0x46, 0x7f, 0x60,
+	0x12, 0x9, 0x2c, 0xef, 0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0x10, 0x50, 0xed, 0x7f, 0x2, 0x12,
+	0x1f, 0x18, 0x22, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff, 0xe4, 0x34, 0x56,
+	0xfe, 0xe4, 0x34, 0x34, 0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3, 0xa8, 0x6, 0x8,
+	0x22, 0xad, 0x7, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36, 0x10, 0xf5, 0x3d,
+	0xf5, 0x3c, 0x75, 0x3b, 0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0xf, 0xd5, 0x8f, 0x26,
+	0x8d, 0x27, 0xe5, 0x26, 0x64, 0x5, 0x60, 0x11, 0xe5, 0x27, 0xfd, 0x7c, 00, 0xaf, 0x26, 0x12,
+	0x1c, 0xfb, 0xad, 0x27, 0xaf, 0x26, 0x12, 0x16, 0x1e, 0x22, 0xbf, 0x6, 0x3, 0x7f, 0x12, 0x22,
+	0x7d, 0x1c, 0x12, 0x12, 0x8a, 0xef, 0x13, 0x13, 0x13, 0x54, 0x3, 0xfe, 0xef, 0x30, 0xe5, 0x3,
+	0x43, 0x6, 0x10, 0xaf, 0x6, 0x22, 0x8f, 0x2b, 0x12, 0x1d, 0xbc, 0x7d, 0x1, 0xaf, 0x2b, 0x12,
+	0x1e, 0x2, 0xaf, 0x2b, 0x12, 0x9, 0x7e, 0x12, 0x11, 0xcd, 0xe4, 0xfd, 0xaf, 0x2b, 0x2, 0x1e,
+	0x2, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1d, 0xd8, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xd, 0x89,
+	0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0xc2, 0x9, 0x22, 0xae, 0x5, 0xad, 0x7,
+	0x75, 0x3b, 0x6, 0xee, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x3c, 0x7b, 0x19,
+	0x7f, 0x20, 0x2, 0x16, 0xbb, 0x8f, 0x2e, 0xe5, 0x2e, 0xc4, 0x54, 0xf, 0xff, 0x12, 0x1d, 0xad,
+	0x12, 0x1c, 0xe9, 0xe5, 0x2e, 0x54, 0xf, 0xff, 0x12, 0x1d, 0xad, 0x2, 0x1c, 0xe9, 0x8f, 0x27,
+	0x8e, 0x26, 0x8d, 0x25, 0x8c, 0x24, 0x78, 0x10, 0x12, 0x4, 0xc8, 0x12, 0x1d, 0x71, 0xe5, 0x27,
+	0xff, 0xe5, 0x26, 0xfe, 0x2, 0x1d, 0x71, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x48, 0x74,
+	0xa3, 0x25, 0x22, 0xf8, 0xa6, 0x7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22,
+	0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 0xef, 0x64, 0x80, 0x94,
+	0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 0x1b, 0xa, 0x8f, 0x26,
+	0x7d, 0x5, 0xaf, 0x25, 0x12, 0x12, 0x8a, 0xee, 0x30, 0xe2, 0x3, 0x43, 0x26, 0x20, 0xaf, 0x26,
+	0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 0x2, 0x75, 0xc8, 0x34,
+	0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0xf, 0xef, 0x60, 0x5, 0x7f, 0x5,
+	0x12, 0x1f, 0x18, 0x12, 0x1c, 0x36, 0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 0x1f, 0x18, 0x22, 0x8f,
+	0x36, 0x12, 0x1e, 0xaa, 0x75, 0x3c, 0x3, 0x12, 0x17, 0x8c, 0x7d, 0xc, 0xaf, 0x36, 0x12, 0x18,
+	0xed, 0xaf, 0x36, 0x2, 0x1e, 0xb3, 0xe4, 0xf5, 0x23, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1d, 0xd8,
+	0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xf2, 0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5,
+	0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x1, 0x75, 0xf9, 0xe0, 0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe,
+	0xe5, 0x8, 0xfd, 0xe5, 0x9, 0xfb, 0x7f, 0x80, 0x12, 0x9, 0x2c, 0x5, 0x9, 0xe5, 0x9, 0x70,
+	0x2, 0x5, 0x8, 0x22, 0xe4, 0xfb, 0x7d, 0x4, 0x7f, 0x80, 0x12, 0x9, 0x40, 0x7f, 00, 0x7e,
+	00, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x47, 0x8f, 0x24, 0xaf, 0x24, 0x15, 0x24, 0xef, 0xd3,
+	0x94, 00, 0x40, 0x7, 0x7f, 0x20, 0x12, 0x1c, 0xe9, 0x80, 0xef, 0x22, 0x8f, 0x54, 0x7b, 0x35,
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0xaf, 0x54, 0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0x9, 0x47,
+	0x53, 0x89, 0xf, 0x43, 0x89, 0x10, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab,
+	0xd2, 0x8e, 0x22, 0xc2, 0x3, 0xae, 0x7, 0x1f, 0xee, 0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3,
+	0xfd, 0xc2, 0x3, 0x80, 0xf0, 0x22, 0x7b, 0x14, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x40, 0x7f,
+	0x1, 0x12, 0x1e, 0xe8, 0x12, 0x9, 0x47, 0x80, 0xfe, 0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12,
+	0x1e, 0xd3, 0x20, 0x6, 0x5, 0x12, 0x1f, 0x10, 0x50, 0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d,
+	0x2a, 0x12, 0x1b, 0x26, 0xad, 0x2a, 0xac, 0x29, 0xaf, 0x28, 0x2, 0x8, 0x44, 0xef, 0x60, 0x6,
+	0xe5, 0x54, 0x44, 0x2, 0x80, 0x4, 0xe5, 0x54, 0x54, 0xfd, 0xff, 0x12, 0x1c, 0x9c, 0x22, 0xef,
+	0x60, 0x6, 0xe5, 0x54, 0x44, 0x1, 0x80, 0x4, 0xe5, 0x54, 0x54, 0xfe, 0xff, 0x12, 0x1c, 0x9c,
+	0x22, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x2c, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf,
+	0xff, 0x22, 0x5, 0xf, 0xe5, 0xf, 0xc3, 0x94, 0x96, 0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1e,
+	0xda, 0x22, 0x49, 0xd, 0xa, 00, 0x69, 00, 00, 00, 00, 00, 00, 00, 00, 00,
+	00, 00, 0x74, 0x83, 0x25, 0x1f, 0xf8, 0xe6, 0xff, 0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f,
+	0x22, 0x8e, 0x28, 0x8f, 0x29, 0xe5, 0x28, 0xff, 0x12, 0x1b, 0x75, 0xaf, 0x29, 0x2, 0x1b, 0x75,
+	0x5, 0x4c, 0xe5, 0x4c, 0xc3, 0x94, 0xa, 0x40, 0x5, 0xe4, 0xf5, 0x4c, 0xd2, 0x9, 0x22, 0x75,
+	0x3c, 0x12, 0x75, 0x3d, 00, 0x7b, 00, 0x7a, 0x12, 0xe4, 0xfd, 0x2, 0x18, 0xed, 0x4c, 0x20,
+	0x32, 0x2e, 0x33, 0x31, 0x41, 0x74, 0x68, 0x34, 00, 00, 00, 00, 00, 0xef, 0xc3, 0x94,
+	0xa, 0xef, 0x50, 0x4, 0x24, 0x30, 0xff, 0x22, 0x24, 0x57, 0xff, 0x22, 0xad, 0x7, 0x75, 0x3b,
+	0x10, 0xe4, 0xf5, 0x3c, 0xfb, 0x7f, 0x20, 0x2, 0x16, 0xbb, 0x7d, 0x24, 0x12, 0x18, 00, 0x7b,
+	00, 0x7a, 00, 0x79, 0x24, 0x2, 0x16, 0x87, 0xef, 0x90, 0x1d, 0xed, 0x93, 0xd3, 0x94, 0x1,
+	0x50, 0x2, 0x80, 0x1, 0xc3, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0xff, 0x6, 00, 00, 00,
+	00, 00, 0xff, 0x1, 0x7d, 0x1, 0x12, 0x12, 0x8a, 0xef, 0x30, 0xe2, 0x3, 0xd3, 0x80, 0x1,
+	0xc3, 0x22, 0x8f, 0x3b, 0x8d, 0x3c, 0x7b, 0xe, 0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x16, 0xbb, 0x8f,
+	0x3b, 0x8d, 0x3c, 0x7b, 0x10, 0xe4, 0xfd, 0x7f, 0x40, 0x2, 0x16, 0xbb, 0xe5, 0x1e, 0x65, 0x1f,
+	0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0xe5, 0xaa, 0x54, 0x3, 0x60, 0x3, 0xd3, 0x80, 0x1,
+	0xc3, 0x22, 0x7f, 0x3, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x17, 0xd5, 0xa8, 0x1a, 0xe6,
+	0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80, 0xf6, 0x22, 0x12, 0x1d, 0xd8, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0x7f, 00, 0x22, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x20, 0x2, 0xfd, 0x22, 0xeb, 0x75, 0xf0,
+	0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f, 0x30, 0x12, 0x1c, 0xe9, 0x7f, 0x78, 0x2, 0x1c,
+	0xe9, 0x7f, 0xd, 0x12, 0x1c, 0xe9, 0x7f, 0xa, 0x2, 0x1c, 0xe9, 0x75, 0xf0, 0xa, 0x84, 0xe5,
+	0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x34, 0x12, 0x17, 0x4d, 0xaf, 0x34, 0x2, 0xb, 0x3c, 0xef,
+	0x64, 0x6, 0x60, 0x3, 0x12, 0x1c, 0x1f, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 0x2, 0x17,
+	0x1d, 0x7b, 0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x2, 0x17, 0x1d, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f,
+	0x2, 0x17, 0x1d, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x2, 0x17, 0x1d, 0x7d, 0x32, 0x12, 0x18, 00,
+	0xaf, 0x37, 0x22, 0xe5, 0x54, 0x44, 0x4, 0xff, 0x2, 0x1c, 0x9c, 0xe5, 0x54, 0x54, 0xfb, 0xff,
+	0x2, 0x1c, 0x9c, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 0x2, 0x15,
+	0xe9, 0x7f, 0x5, 0x7e, 00, 0x2, 0x15, 0xe9, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0x7b,
+	00, 0x7a, 00, 0x79, 0x4d, 0x22, 0xef, 0x90, 0x1d, 0xed, 0x93, 0xff, 0x22, 0xef, 0x90, 0x1d,
+	0xe6, 0x93, 0xff, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0x6, 0x5, 0x75, 0x22, 0x1, 0x80, 0xfe,
+	0xa2, 0x2, 0xb3, 0x22, 0x12, 0x11, 0x7, 0x22, 0xd2, 0x7, 0x22, 0x2, 0x1c, 0xe9, 0x2, 0x15,
+	0x2, 0x22, 0x22, 0x22,
+};
diff --git a/board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c b/board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c
new file mode 100644
index 0000000000..15f4d2dc22
--- /dev/null
+++ b/board/ar7100/common/g5e_Plus1_2_29a_unmanaged_Atheros_v3.c
@@ -0,0 +1,513 @@
+static unsigned char lutonu [] = {
+	0x2, 0xb, 0x3a, 0x8f, 0x2e, 0x12, 0x1f, 0xbd, 0x12, 0x9, 0xdb, 0x50, 0x3, 0x7f, 0x1, 0x22,
+	0xe5, 0x2e, 0xb4, 0x6, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x2, 0x19, 0xd7, 0x75, 0x22,
+	0x1, 0x80, 0xfe, 0x2, 0x14, 0xe2, 0xae, 0x5, 0xad, 0x7, 0x75, 0x3c, 0x6, 0xee, 0x70, 0x4,
+	0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x8f, 0x3d, 0x7b, 0x19, 0x7f, 0x20, 0x2, 0x17, 0x88, 0x22,
+	00, 0x1, 0xc1, 00, 00, 00, 0x8f, 0x24, 0x8d, 0x25, 0x8b, 0x26, 0xe5, 0x26, 0x7b, 0xff,
+	0x60, 0x6, 0x7a, 0x12, 0x79, 0x90, 0x80, 0x4, 0x7a, 0x12, 0x79, 0x8f, 0x12, 0x19, 0xfc, 0x7b,
+	0xff, 0x7a, 0x12, 0x79, 0x91, 0x12, 0x19, 0xfc, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0x8, 0xe4,
+	0xf5, 0x24, 0x75, 0x27, 0x6, 0x80, 0x11, 0xe5, 0x26, 0x60, 0xa, 0x53, 0x24, 0xfe, 0xe5, 0x24,
+	0x4, 0xf5, 0x27, 0x80, 0x3, 0x85, 0x24, 0x27, 0xe5, 0x25, 0xb4, 0xff, 0x5, 0x75, 0x29, 0x7,
+	0x80, 0xf, 0xaf, 0x25, 0x74, 0x1, 0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf5,
+	0x29, 0x7b, 0xd, 0x12, 0x3, 0x2b, 0x7b, 0xe, 0x12, 0x3, 0x2b, 0x12, 0x3, 0x66, 0x12, 0x1b,
+	0x4f, 0x12, 0x9, 0x5f, 0xe5, 0x24, 0x90, 0x1f, 0xd2, 0x93, 0xf5, 0x30, 0xe5, 0x26, 0x60, 0x1e,
+	0xe5, 0x24, 0x24, 0x1, 0xff, 0xe4, 0x33, 0xfe, 0xc3, 0xef, 0x94, 0x7, 0xee, 0x64, 0x80, 0x94,
+	0x80, 0x50, 0x8, 0xe5, 0x24, 0xa3, 0x93, 0xf5, 0x31, 0x80, 0x3, 0x75, 0x31, 0x7, 0x7e, 00,
+	0x7f, 0x2, 0x7d, 0xff, 0x7b, 00, 0x7a, 00, 0x79, 0x2a, 0x12, 0x5, 0x2e, 0x75, 0x28, 0x2,
+	0xe5, 0x28, 0xf4, 0x70, 0x3, 0x2, 0x2, 0x50, 0x74, 0x1, 0x7e, 00, 0xa8, 0x28, 0x8, 0x80,
+	0x5, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef, 0x55, 0x29, 0x70, 0x3, 0x2, 0x2,
+	0x4b, 0xe5, 0x28, 0xd3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x1, 0xec, 0xaf, 0x30, 0x12, 0x1e, 0x9c,
+	0x40, 0x3, 0x2, 0x2, 0x4b, 0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x50, 0x7, 0xe5, 0x31, 0xc3, 0x94,
+	0x7, 0x40, 0x7, 0xe5, 0x26, 0x60, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x30, 0x64, 0x6, 0x70, 0x1b,
+	0xe5, 0x28, 0x70, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28, 0xb4,
+	0x1, 0x9, 0x12, 0x3, 0x5d, 0x20, 0xe6, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x26, 0x60, 0x67, 0xe5,
+	0x28, 0xc3, 0x94, 0x2, 0x50, 0x6f, 0xe5, 0x31, 0x64, 0x6, 0x70, 0x25, 0xe5, 0x28, 0x70, 0xe,
+	0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0x29, 0xee, 0x20, 0xe4, 0x3, 0x2, 0x2, 0x4b, 0xe5, 0x28,
+	0xb4, 0x1, 0xe, 0x7d, 0x1, 0xaf, 0x31, 0x12, 0x13, 0x29, 0xee, 0x20, 0xe6, 0x3, 0x2, 0x2,
+	0x4b, 0x12, 0x3, 0x70, 0xe4, 0xf5, 0x2e, 0xf5, 0x2f, 0xaf, 0x30, 0x12, 0x1e, 0xb8, 0x50, 0x7,
+	0xaf, 0x31, 0x12, 0x1e, 0xb8, 0x40, 0x2e, 0xe5, 0x2f, 0xc3, 0x94, 0x3, 0x50, 0x27, 0x7f, 0xa,
+	0x12, 0x1d, 0x7a, 0x5, 0x2e, 0xe5, 0x2e, 0xc3, 0x94, 0xfa, 0x40, 0xdd, 0x12, 0x3, 0x70, 0x5,
+	0x2f, 0xe4, 0xf5, 0x2e, 0x80, 0xd3, 0xe5, 0x28, 0x44, 0x90, 0xfd, 0xaf, 0x30, 0x12, 0x13, 0xd2,
+	0x7f, 0xa, 0x12, 0x1f, 0x17, 0xad, 0x28, 0xaf, 0x30, 0x12, 0x10, 0xe4, 0xe5, 0x26, 0x60, 0x7,
+	0xad, 0x28, 0xaf, 0x31, 0x12, 0x10, 0xe4, 0x7f, 0x5, 0x12, 0x1f, 0x17, 0xe5, 0x26, 0x60, 0x41,
+	0xad, 0x31, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x66, 0x80, 0x2,
+	0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0xad, 0x30, 0xaf, 0x31, 0x12, 0xf,
+	0x3c, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc,
+	0x12, 0x1b, 0x66, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2b, 0x4f, 0xf5, 0x2b, 0x80,
+	0x1a, 0xad, 0x30, 0x12, 0x3, 0x4e, 0x80, 0x2, 0xc3, 0x33, 0xd8, 0xfc, 0x12, 0x1b, 0x66, 0x80,
+	0x2, 0xc3, 0x33, 0xd8, 0xfc, 0xf4, 0x55, 0x2a, 0x4f, 0xf5, 0x2a, 0x15, 0x28, 0x2, 00, 0xf0,
+	0xe4, 0xf5, 0x2d, 0xe5, 0x26, 0x70, 0x7, 0xe5, 0x2d, 0xc3, 0x94, 0x1, 0x40, 0x11, 0xe5, 0x26,
+	0x70, 0x3, 0x2, 0x2, 0xfd, 0xe5, 0x2d, 0xc3, 0x94, 0x2, 0x40, 0x3, 0x2, 0x2, 0xfd, 0x12,
+	0x1f, 0x35, 0x7f, 0x4, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1a, 0xcc, 0x7f, 0x4, 0x12, 0x1d,
+	0x3f, 0xe4, 0xf5, 0x28, 0xe5, 0x28, 0x25, 0xe0, 0xff, 0x74, 0x2a, 0x25, 0x2d, 0xf8, 0xe6, 0xfe,
+	0xa8, 0x7, 0x8, 0x80, 0x2, 0xc3, 0x13, 0xd8, 0xfc, 0x54, 0x3, 0xf5, 0x2c, 0xb4, 0x3, 0x7,
+	0x7f, 0x8, 0x12, 0x1d, 0x3f, 0x80, 0x24, 0xe5, 0x2c, 0x7b, 0xff, 0x70, 0x9, 0x7a, 0x12, 0x79,
+	0xaa, 0x12, 0x19, 0xfc, 0x80, 0x15, 0x7a, 0x12, 0x79, 0xb3, 0x12, 0x19, 0xfc, 0xaf, 0x2c, 0xe4,
+	0xfc, 0xfd, 0xfe, 0x12, 0xe, 0x57, 0x7f, 0x20, 0x12, 0x1f, 0xe4, 0x5, 0x28, 0xe5, 0x28, 0xc3,
+	0x94, 0x3, 0x40, 0xb0, 0xe5, 0x2d, 0x70, 0xb, 0xaf, 0x30, 0x12, 0x1e, 0x9c, 0x50, 0x10, 0xaf,
+	0x30, 0x80, 0x9, 0xaf, 0x31, 0x12, 0x1e, 0x9c, 0x50, 0x5, 0xaf, 0x31, 0x12, 0x1f, 0x49, 0x5,
+	0x24, 0xe5, 0x24, 0xd3, 0x95, 0x27, 0x50, 0x5, 0x5, 0x2d, 0x2, 0x2, 0x53, 0xe5, 0x24, 0xd3,
+	0x95, 0x27, 0x50, 0x3, 0x2, 00, 0xb4, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0xba, 0x12, 0x19, 0xfc,
+	0x7b, 0xd, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x5f, 0x7b, 0xe, 0x12, 0x3, 0x3e, 0x12, 0x9, 0x5f,
+	0x12, 0x3, 0x66, 0x7f, 0x5f, 0x12, 0x1b, 0x51, 0x2, 0x9, 0x5f, 0xe4, 0xfd, 0x7f, 0x40, 0x12,
+	0x9, 0x58, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x5f, 0x22, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 0x5f, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xaf, 0x30,
+	0x12, 0xf, 0x3c, 0xe5, 0x28, 0x25, 0xe0, 0xfe, 0xef, 0xa8, 0x6, 0x8, 0x22, 0x7d, 0x1, 0xaf,
+	0x30, 0x12, 0x13, 0x29, 0xee, 0x22, 0x7b, 0xf, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0x22,
+	0xab, 0x28, 0xad, 0x31, 0xaf, 0x30, 0x12, 0x18, 0xf2, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a,
+	0x83, 0xe0, 0x22, 0x50, 0x2, 0xe7, 0x22, 0xbb, 0xfe, 0x2, 0xe3, 0x22, 0x89, 0x82, 0x8a, 0x83,
+	0xe4, 0x93, 0x22, 0xbb, 0x1, 0x6, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0x22, 0x50, 0x2, 0xf7, 0x22,
+	0xbb, 0xfe, 0x1, 0xf3, 0x22, 0xe8, 0x8f, 0xf0, 0xa4, 0xcc, 0x8b, 0xf0, 0xa4, 0x2c, 0xfc, 0xe9,
+	0x8e, 0xf0, 0xa4, 0x2c, 0xfc, 0x8a, 0xf0, 0xed, 0xa4, 0x2c, 0xfc, 0xea, 0x8e, 0xf0, 0xa4, 0xcd,
+	0xa8, 0xf0, 0x8b, 0xf0, 0xa4, 0x2d, 0xcc, 0x38, 0x25, 0xf0, 0xfd, 0xe9, 0x8f, 0xf0, 0xa4, 0x2c,
+	0xcd, 0x35, 0xf0, 0xfc, 0xeb, 0x8e, 0xf0, 0xa4, 0xfe, 0xa9, 0xf0, 0xeb, 0x8f, 0xf0, 0xa4, 0xcf,
+	0xc5, 0xf0, 0x2e, 0xcd, 0x39, 0xfe, 0xe4, 0x3c, 0xfc, 0xea, 0xa4, 0x2d, 0xce, 0x35, 0xf0, 0xfd,
+	0xe4, 0x3c, 0xfc, 0x22, 0x75, 0xf0, 0x8, 0x75, 0x82, 00, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe,
+	0xcd, 0x33, 0xcd, 0xcc, 0x33, 0xcc, 0xc5, 0x82, 0x33, 0xc5, 0x82, 0x9b, 0xed, 0x9a, 0xec, 0x99,
+	0xe5, 0x82, 0x98, 0x40, 0xc, 0xf5, 0x82, 0xee, 0x9b, 0xfe, 0xed, 0x9a, 0xfd, 0xec, 0x99, 0xfc,
+	0xf, 0xd5, 0xf0, 0xd6, 0xe4, 0xce, 0xfb, 0xe4, 0xcd, 0xfa, 0xe4, 0xcc, 0xf9, 0xa8, 0x82, 0x22,
+	0xb8, 00, 0xc1, 0xb9, 00, 0x59, 0xba, 00, 0x2d, 0xec, 0x8b, 0xf0, 0x84, 0xcf, 0xce, 0xcd,
+	0xfc, 0xe5, 0xf0, 0xcb, 0xf9, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+	0xec, 0x33, 0xfc, 0xeb, 0x33, 0xfb, 0x10, 0xd7, 0x3, 0x99, 0x40, 0x4, 0xeb, 0x99, 0xfb, 0xf,
+	0xd8, 0xe5, 0xe4, 0xf9, 0xfa, 0x22, 0x78, 0x18, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33,
+	0xfd, 0xec, 0x33, 0xfc, 0xc9, 0x33, 0xc9, 0x10, 0xd7, 0x5, 0x9b, 0xe9, 0x9a, 0x40, 0x7, 0xec,
+	0x9b, 0xfc, 0xe9, 0x9a, 0xf9, 0xf, 0xd8, 0xe0, 0xe4, 0xc9, 0xfa, 0xe4, 0xcc, 0xfb, 0x22, 0x75,
+	0xf0, 0x10, 0xef, 0x2f, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd, 0xcc, 0x33, 0xcc, 0xc8, 0x33,
+	0xc8, 0x10, 0xd7, 0x7, 0x9b, 0xec, 0x9a, 0xe8, 0x99, 0x40, 0xa, 0xed, 0x9b, 0xfd, 0xec, 0x9a,
+	0xfc, 0xe8, 0x99, 0xf8, 0xf, 0xd5, 0xf0, 0xda, 0xe4, 0xcd, 0xfb, 0xe4, 0xcc, 0xfa, 0xe4, 0xc8,
+	0xf9, 0x22, 0xcf, 0xf4, 0xcf, 0xce, 0xf4, 0xce, 0xcd, 0xf4, 0xcd, 0xcc, 0xf4, 0xcc, 0x22, 0xeb,
+	0x9f, 0xf5, 0xf0, 0xea, 0x9e, 0x42, 0xf0, 0xe9, 0x9d, 0x42, 0xf0, 0xe8, 0x9c, 0x45, 0xf0, 0x22,
+	0xe8, 0x60, 0xf, 0xec, 0xc3, 0x13, 0xfc, 0xed, 0x13, 0xfd, 0xee, 0x13, 0xfe, 0xef, 0x13, 0xff,
+	0xd8, 0xf1, 0x22, 0xe8, 0x60, 0xf, 0xef, 0xc3, 0x33, 0xff, 0xee, 0x33, 0xfe, 0xed, 0x33, 0xfd,
+	0xec, 0x33, 0xfc, 0xd8, 0xf1, 0x22, 0xe6, 0xfc, 0x8, 0xe6, 0xfd, 0x8, 0xe6, 0xfe, 0x8, 0xe6,
+	0xff, 0x22, 0xe4, 0x93, 0xfc, 0x74, 0x1, 0x93, 0xfd, 0x74, 0x2, 0x93, 0xfe, 0x74, 0x3, 0x93,
+	0xff, 0x22, 0xec, 0xf6, 0x8, 0xed, 0xf6, 0x8, 0xee, 0xf6, 0x8, 0xef, 0xf6, 0x22, 0xef, 0x4e,
+	0x60, 0x12, 0xef, 0x60, 0x1, 0xe, 0xed, 0xbb, 0x1, 0xb, 0x89, 0x82, 0x8a, 0x83, 0xf0, 0xa3,
+	0xdf, 0xfc, 0xde, 0xfa, 0x22, 0x89, 0xf0, 0x50, 0x7, 0xf7, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22,
+	0xbb, 0xfe, 0xfc, 0xf3, 0x9, 0xdf, 0xfc, 0xa9, 0xf0, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64,
+	0x20, 0x60, 0x9, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x7f, 0x1, 0x22, 0xe4, 0xf5, 0x19, 0xfe,
+	0x7f, 0x10, 0x7d, 0xff, 0xfb, 0x7a, 00, 0x79, 0x52, 0x12, 0x5, 0x2e, 0x12, 0x1f, 0x1, 0x75,
+	0x25, 0xa, 0xe4, 0xf5, 0x27, 0xa8, 0x1a, 0xe6, 0x64, 0x30, 0x70, 0x1b, 0xe8, 0x4, 0xf8, 0xe6,
+	0xff, 0x12, 0x1c, 0x60, 0xbf, 0x58, 0x10, 0x75, 0x25, 0x10, 0x5, 0x1a, 0x5, 0x1a, 0xa8, 0x1a,
+	0xe6, 0xb4, 0x20, 0x3, 0x7f, 0x1, 0x22, 0xa8, 0x1a, 0xe6, 0xf5, 0x24, 0x64, 0x20, 0x60, 0x6,
+	0xe5, 0x24, 0x64, 0xd, 0x70, 0x7c, 0xe5, 0x27, 0xd3, 0x94, 00, 0x40, 0x6a, 0xe4, 0xf5, 0x35,
+	0xf5, 0x34, 0xf5, 0x33, 0xf5, 0x32, 0xf5, 0x26, 0xe5, 0x26, 0xc3, 0x95, 0x27, 0x50, 0x3a, 0xaf,
+	0x25, 0xe4, 0xfc, 0xfd, 0xfe, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0x12, 0x3, 0xa5,
+	0xc0, 0x4, 0xa9, 0x5, 0xaa, 0x6, 0xab, 0x7, 0x74, 0x28, 0x25, 0x26, 0xf8, 0xe6, 0xff, 0xe4,
+	0xfc, 0xfd, 0xfe, 0xd0, 00, 0xeb, 0x2f, 0xf5, 0x35, 0xee, 0x3a, 0xf5, 0x34, 0xed, 0x39, 0xf5,
+	0x33, 0xec, 0x38, 0xf5, 0x32, 0x5, 0x26, 0x80, 0xbf, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x17,
+	0xaf, 0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xab, 0x19, 0x5, 0x19, 0xeb, 0x25, 0xe0, 0x25,
+	0xe0, 0x24, 0x52, 0xf8, 0x12, 0x5, 0x22, 0xe5, 0x24, 0x64, 0xd, 0x60, 0x3, 0x2, 0x5, 0x7c,
+	0xff, 0x22, 0xaf, 0x24, 0x12, 0x19, 0xb1, 0x8f, 0x24, 0xe5, 0x24, 0xf4, 0x60, 0x1d, 0xe5, 0x27,
+	0xc3, 0x94, 0xa, 0x50, 0x19, 0xaf, 0x27, 0x5, 0x27, 0x74, 0x28, 0x2f, 0xf8, 0xa6, 0x24, 0xe5,
+	0x24, 0xd3, 0x94, 0x9, 0x40, 0x8, 0x75, 0x25, 0x10, 0x80, 0x3, 0x7f, 0x1, 0x22, 0x5, 0x1a,
+	0x2, 0x5, 0xa7, 0xa8, 0x1a, 0xe6, 0xf5, 0x23, 0x5, 0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x3,
+	0x7f, 0x1, 0x22, 0xaf, 0x23, 0x12, 0x1c, 0x60, 0xef, 0x24, 0xb7, 0x60, 0x64, 0x24, 0xfa, 0x60,
+	0x7a, 0x24, 0xfd, 0x60, 0x17, 0x24, 0xfe, 0x70, 0x3, 0x2, 0x7, 0x25, 0x24, 0xfd, 0x60, 0x28,
+	0x4, 0x60, 0x3, 0x2, 0x7, 0x60, 0x12, 0xe, 0xcd, 0x2, 0x7, 0x63, 0x12, 0x1f, 0x2b, 0x12,
+	0x1a, 0x31, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xc0, 0x5, 0x12, 0x1a, 0x29, 0xd0, 0x5, 0xd0, 0x7,
+	0x12, 0x9, 0x44, 0x12, 0x1c, 0x2e, 0x80, 0x3e, 0xe5, 0x19, 0xc3, 0x94, 0x4, 0x50, 0x3, 0x2,
+	0x7, 0x63, 0x12, 0x1a, 0x31, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xc0, 0x5, 0x12, 0x1a, 0x29, 0xd0,
+	0x5, 0xd0, 0x7, 0x12, 0x9, 0x58, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x12, 0x9, 0x5f, 0x2, 0x7,
+	0x63, 0x12, 0x1f, 0x2b, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xd0, 0x7,
+	0x12, 0x13, 0x29, 0x12, 0x1e, 0x18, 0x12, 0x1f, 0x35, 0x80, 0x68, 0xe5, 0x19, 0xc3, 0x94, 0x3,
+	0x40, 0x61, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x21, 0xc0, 0x5, 0x12, 0x1a,
+	0x29, 0xaa, 0x6, 0x78, 0x5e, 0x12, 0x5, 0x6, 0x8e, 0x3d, 0x8f, 0x3e, 0xd0, 0x5, 0xd0, 0x7,
+	0x12, 0x19, 0x65, 0x80, 0x3e, 0x78, 0x52, 0x12, 0x5, 0x6, 0xef, 0x24, 0xfe, 0x60, 0x17, 0x4,
+	0x70, 0x2b, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12, 0x5, 0x6, 0xad, 0x7,
+	0xd0, 0x7, 0xe4, 0xfb, 0x80, 0x12, 0x78, 0x56, 0x12, 0x5, 0x6, 0xc0, 0x7, 0x78, 0x5a, 0x12,
+	0x5, 0x6, 0xad, 0x7, 0xd0, 0x7, 0x7b, 0x1, 0x12, 00, 0x46, 0x80, 0x6, 0x7f, 0x1, 0x22,
+	0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x2a, 0x7f, 0x1, 0xed, 0x54, 0x30, 0xfe, 0xbe, 0x30,
+	0x4, 0x7e, 0x1, 0x80, 0x2, 0x7e, 00, 0xed, 0x54, 0x3, 0xfc, 0xbc, 0x2, 0x4, 0x7c, 0x1,
+	0x80, 0x2, 0x7c, 00, 0x8c, 0x2c, 0xed, 0x20, 0xe4, 0x7, 0xef, 0x60, 0x4, 0x7d, 0x1, 0x80,
+	0x2, 0x7d, 00, 0xef, 0x60, 0x3, 0xee, 0x70, 0x3, 0xed, 0x60, 0x4, 0x7f, 0x1, 0x80, 0x2,
+	0x7f, 00, 0x8f, 0x2b, 0x7d, 0x30, 0xaf, 0x2a, 0x12, 0x18, 0xa0, 0x7b, 0x8, 0xad, 0x2a, 0x7f,
+	0x20, 0x12, 0x9, 0x58, 0xe5, 0x31, 0xfe, 0xe5, 0x32, 0xff, 0xad, 0x30, 0x7c, 00, 0x12, 0x9,
+	0x75, 0x12, 0x9, 0x5f, 0x7b, 0xc, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x58, 0xe5, 0x34, 0xfe,
+	0xe5, 0x35, 0xff, 0xad, 0x33, 0x7c, 00, 0x12, 0x9, 0x75, 0x12, 0x9, 0x5f, 0xe5, 0x2b, 0x60,
+	0x1e, 0x75, 0x2d, 0x17, 0x75, 0x2e, 0xd2, 0x12, 0x8, 0x52, 0x7f, 0xff, 0x7e, 00, 0x7d, 0x3,
+	0x7c, 00, 0x12, 0x9, 0x5f, 0x85, 0x2a, 0x3c, 0xe4, 0xf5, 0x3d, 0x7b, 0x12, 0x80, 0x1d, 0x75,
+	0x2d, 0x17, 0x75, 0x2e, 0xba, 0x12, 0x8, 0x52, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00,
+	0x12, 0x9, 0x5f, 0x85, 0x2a, 0x3c, 0x75, 0x3d, 0x1, 0x7b, 0x12, 0xe4, 0xfd, 0x7f, 0xa0, 0x12,
+	0x17, 0x88, 0xe4, 0xf5, 0x2f, 0xe5, 0x2f, 0x24, 0xde, 0xfb, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9,
+	0x58, 0x85, 0x2e, 0x82, 0x85, 0x2d, 0x83, 0x12, 0x5, 0x12, 0x12, 0x9, 0x5f, 0x74, 0x4, 0x25,
+	0x2e, 0xf5, 0x2e, 0xe4, 0x35, 0x2d, 0xf5, 0x2d, 0x5, 0x2f, 0xe5, 0x2f, 0xc3, 0x94, 0x6, 0x40,
+	0xd4, 0x22, 0x7b, 0x4, 0xad, 0x2a, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x22, 0x8f, 0x2b, 0x8c, 0x2c,
+	0x8d, 0x2d, 0xe5, 0x2d, 0xf4, 0x45, 0x2c, 0x70, 0xa, 0xf5, 0x31, 0xf5, 0x30, 0xf5, 0x2f, 0xf5,
+	0x2e, 0x80, 0x12, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x11, 0xae, 0x8f, 0x31, 0x8e,
+	0x30, 0x8d, 0x2f, 0x8c, 0x2e, 0xe4, 0xf5, 0x39, 0xf5, 0x38, 0xf5, 0x37, 0x75, 0x36, 0x80, 0xf5,
+	0x3d, 0xf5, 0x3c, 0xf5, 0x3b, 0x75, 0x3a, 0x80, 0x7b, 0xdf, 0xad, 0x2b, 0x7f, 0x20, 0x12, 0x10,
+	0x7c, 0x12, 0x9, 0x3a, 0xe5, 0x31, 0x54, 0xf8, 0xff, 0xe5, 0x30, 0xfe, 0xe5, 0x2f, 0xfd, 0xe5,
+	0x2e, 0xfc, 0xef, 0x44, 0x31, 0xff, 0xec, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x5f, 0xe5, 0x2d, 0xf4,
+	0x45, 0x2c, 0x70, 0x23, 0xfd, 0xaf, 0x2b, 0x12, 0x1e, 0xd3, 0x12, 0x9, 0x3a, 0x7f, 0x30, 0x7e,
+	00, 0x7d, 00, 0x7c, 0x20, 0x12, 0x9, 0x5f, 0x85, 0x2b, 0x3c, 0x75, 0x3d, 0x1, 0x7b, 0x12,
+	0xe4, 0xfd, 0x7f, 0xa0, 0x2, 0x17, 0x88, 0xaf, 0x2b, 0x12, 0x1f, 0x89, 0xe4, 0xfc, 0xfd, 0xfe,
+	0x78, 0x13, 0x12, 0x4, 0xf3, 0xec, 0x44, 0x8, 0xfc, 0xe5, 0x31, 0x4f, 0xf5, 0x31, 0xe5, 0x30,
+	0x4e, 0xf5, 0x30, 0xe5, 0x2f, 0x4d, 0xf5, 0x2f, 0xe5, 0x2e, 0x4c, 0xf5, 0x2e, 0xe4, 0xfb, 0xad,
+	0x2b, 0x7f, 0x20, 0x12, 0x9, 0x58, 0xaf, 0x31, 0xae, 0x30, 0xad, 0x2f, 0xac, 0x2e, 0x12, 0x9,
+	0x5f, 0xaf, 0x2b, 0x12, 0x1b, 0x6d, 0xe5, 0x2d, 0x54, 0x13, 0xfd, 0xaf, 0x2b, 0x12, 0x19, 0x19,
+	0xe5, 0x2b, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x16, 0xeb, 0x22, 0xe4, 0xfb, 0xad, 0x2b, 0x7f, 0x20,
+	0x12, 0x9, 0x58, 0x22, 0xef, 0x2d, 0xf5, 0xf9, 0x8b, 0xfa, 0x30, 0xf8, 0xfd, 0xd2, 0xf8, 0xac,
+	0xff, 0xad, 0xfe, 0xae, 0xfd, 0xaf, 0xfc, 0x22, 0xef, 0x2d, 0xf5, 0x4b, 0x8b, 0x4c, 0x22, 0x8c,
+	0xff, 0x8d, 0xfe, 0x8e, 0xfd, 0x8f, 0xfc, 0xe5, 0x4b, 0xf5, 0xf9, 0xe5, 0x4c, 0xf5, 0xfb, 0x30,
+	0xf8, 0xfd, 0xd2, 0xf8, 0x22, 0x22, 0xec, 0xfe, 0xed, 0xff, 0x22, 0x1, 0x2, 0x4, 0x8, 0x10,
+	0x20, 0x40, 0x80, 0xe4, 0xfe, 0xcf, 0x90, 0x9, 0x7b, 0xb4, 0x8, 00, 0x50, 0x3, 0x93, 0xff,
+	0x22, 0x94, 0x8, 0x93, 0xfe, 0x22, 0xef, 0x90, 0x9, 0x7b, 0x93, 0xff, 0x22, 0x90, 0x9, 0x7b,
+	0xef, 0x93, 0xff, 0xf4, 0xfe, 0xbb, 0x1, 0xe, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x5e, 0xbd, 00,
+	0x2, 0x80, 0x1, 0x4f, 0xf0, 0x22, 0xbb, 00, 0xb, 0xe9, 0xf8, 0xe6, 0x5e, 0xbd, 00, 0x2,
+	0x80, 0x1, 0x4f, 0xf6, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54, 0x3, 0x29, 0xf9,
+	0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 0x9d, 0x22, 0x90, 0x9, 0x7b, 0xef, 0x93,
+	0xff, 0xbb, 0x1, 0x7, 0x89, 0x82, 0x8a, 0x83, 0xe0, 0x80, 0x6, 0xbb, 00, 0x8, 0xe9, 0xf8,
+	0xe6, 0x5f, 0x60, 0x2, 0xd3, 0x22, 0xc3, 0x22, 0x74, 0x1f, 0xc3, 0x9f, 0x13, 0x13, 0x13, 0x54,
+	0x3, 0x29, 0xf9, 0xe4, 0x3a, 0xfa, 0x74, 0x7, 0x5f, 0xff, 0x12, 0x9, 0xdb, 0x22, 0x8f, 0x36,
+	0xe5, 0x36, 0x64, 0x6, 0x70, 0x54, 0x7b, 0x22, 0x7a, 0x1a, 0x7d, 0x17, 0x12, 0x17, 0xea, 0xaf,
+	0x36, 0x12, 0x18, 0x1a, 0x12, 0xa, 0x9b, 0x7a, 0x2, 0x12, 0xa, 0x91, 0x7b, 0xb5, 0x7a, 0x52,
+	0x7d, 0x1f, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x7b, 0xf, 0x7a, 00, 0x7d, 0x2, 0xaf, 0x36, 0x12,
+	0x17, 0xea, 0x7b, 0x2a, 0x7a, 0x47, 0x7d, 0x1, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x7b, 0xa4, 0x7a,
+	0x8f, 0xe4, 0xfd, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x12, 0xa, 0x9b, 0x7a, 00, 0x12, 0xa, 0x91,
+	0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0xaf, 0x36, 0x2, 0x17, 0xea, 0xaf, 0x36, 0x12, 0xd, 0xe0, 0xaf,
+	0x36, 0x12, 0x1c, 0xbf, 0x7b, 0x64, 0x7a, 00, 0x7d, 0x1b, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x75,
+	0x3d, 00, 0x75, 0x3e, 0xf, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x1e, 0xaf, 0x36, 0x12, 0x19, 0x65,
+	0x22, 0x7b, 0x12, 0x7d, 0x8, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x22, 0x7b, 0x30, 0x7a, 0x2a, 0x7d,
+	0x1f, 0xaf, 0x36, 0x12, 0x17, 0xea, 0x22, 0x8f, 0x38, 0x12, 0x1f, 0x78, 0x12, 0x1a, 0x75, 0x12,
+	0xb, 0x26, 0x12, 0x1f, 0x6f, 0x7a, 0xaf, 0x12, 0xb, 0x8, 0x75, 0x3d, 00, 0x75, 0x3e, 0xc,
+	0x7d, 0x11, 0x12, 0xb, 0x1c, 0x7a, 0x8f, 0x12, 0xb, 0x8, 0x7a, 0xaf, 0x12, 0xb, 0x12, 0x75,
+	0x3d, 00, 0x75, 0x3e, 0xc, 0x7d, 0x12, 0x12, 0xb, 0x1c, 0x7a, 0x8f, 0x12, 0xb, 0x12, 0x7a,
+	0xaf, 0x12, 0xb, 0x30, 0x75, 0x3d, 0x1, 0x75, 0x3e, 0x80, 0x7b, 00, 0x7a, 0x1, 0x7d, 0x11,
+	0xaf, 0x38, 0x12, 0x19, 0x65, 0x7a, 0x8f, 0x12, 0xb, 0x30, 0xaf, 0x38, 0x12, 0x1f, 0x78, 0x12,
+	0x1a, 0x80, 0x12, 0xb, 0x26, 0x2, 0x1f, 0x81, 0x7b, 0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17,
+	0xea, 0x22, 0x7b, 0x86, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xea, 0x22, 0x7b, 0x8, 0x7a, 00,
+	0xaf, 0x38, 0x12, 0x19, 0x65, 0x22, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0x65, 0xaf, 0x38, 0x22,
+	0x7b, 0x82, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xea, 0x22, 0x78, 0xfe, 0xe4, 0xf6, 0xd8, 0xfd,
+	0x75, 0x4f, 00, 0x75, 0x50, 00, 0x75, 0x81, 0xa7, 0x2, 0xb, 0x87, 0x2, 0xb, 0xcc, 0xe4,
+	0x93, 0xa3, 0xf8, 0xe4, 0x93, 0xa3, 0x40, 0x3, 0xf6, 0x80, 0x1, 0xf2, 0x8, 0xdf, 0xf4, 0x80,
+	0x29, 0xe4, 0x93, 0xa3, 0xf8, 0x54, 0x7, 0x24, 0xc, 0xc8, 0xc3, 0x33, 0xc4, 0x54, 0xf, 0x44,
+	0x20, 0xc8, 0x83, 0x40, 0x4, 0xf4, 0x56, 0x80, 0x1, 0x46, 0xf6, 0xdf, 0xe4, 0x80, 0xb, 0x1,
+	0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x90, 0x18, 0x49, 0xe4, 0x7e, 0x1, 0x93, 0x60, 0xbc,
+	0xa3, 0xff, 0x54, 0x3f, 0x30, 0xe5, 0x9, 0x54, 0x1f, 0xfe, 0xe4, 0x93, 0xa3, 0x60, 0x1, 0xe,
+	0xcf, 0x54, 0xc0, 0x25, 0xe0, 0x60, 0xa8, 0x40, 0xb8, 0xe4, 0x93, 0xa3, 0xfa, 0xe4, 0x93, 0xa3,
+	0xf8, 0xe4, 0x93, 0xa3, 0xc8, 0xc5, 0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xf0, 0xa3, 0xc8, 0xc5,
+	0x82, 0xc8, 0xca, 0xc5, 0x83, 0xca, 0xdf, 0xe9, 0xde, 0xe7, 0x80, 0xbe, 0x12, 0x1f, 0xea, 0x12,
+	0x18, 0xca, 0xd2, 0xa1, 0xc2, 0x91, 0xe4, 0xf5, 0x39, 0x75, 0x38, 0x1, 0xf5, 0x37, 0xf5, 0x36,
+	0xf5, 0x3d, 0x75, 0x3c, 0x1f, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x10, 0xfd, 0x7f, 0xe0, 0x12, 0x10,
+	0x7c, 0x12, 0x1d, 0x67, 0x12, 0x1c, 0x91, 0xd2, 0xaf, 0x7f, 0x14, 0x12, 0x1d, 0x7a, 0x12, 0xd,
+	0x62, 0x12, 0x1f, 0xeb, 0x12, 0x1a, 0xab, 0xef, 0x70, 0x3, 0x30, 0x7, 0x3, 0x12, 00, 0x1e,
+	0x12, 0x1a, 0xed, 0x12, 0x1c, 0xed, 0xef, 0x60, 0x3, 0x12, 00, 0x1e, 0x12, 0x17, 0x20, 0x12,
+	0x1c, 0x47, 0x30, 0x7, 0x16, 0xc2, 0x7, 0x7b, 0x16, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58,
+	0x7f, 00, 0x7e, 00, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x5f, 0x12, 0xc, 0x5b, 0x30, 00,
+	0x8, 0xc2, 00, 0x12, 0x1e, 0x27, 0x12, 0x1b, 0xfa, 0x30, 0x1, 0xd6, 0xc2, 0x1, 0x12, 0x1d,
+	0xf9, 0x12, 0x1c, 0xa8, 0xa2, 0x81, 0xb3, 0x92, 0x91, 0x80, 0xc7, 0x12, 0x15, 0xd6, 0x40, 0x3,
+	0x2, 0xc, 0xe0, 0x75, 0x1a, 0x62, 0x12, 0x1f, 0x1, 0x12, 0x1a, 0x3b, 0x75, 0x27, 0x1e, 0x75,
+	0x28, 0x8e, 0x12, 0x15, 0x21, 0xef, 0x70, 0x4, 0xf5, 0x22, 0x80, 0x4a, 0x12, 0x1a, 0x3b, 0x75,
+	0x27, 0x1e, 0x75, 0x28, 0x94, 0x12, 0x15, 0x21, 0xef, 0x70, 0x36, 0x74, 0x7, 0x25, 0x1a, 0xf5,
+	0x1a, 0x12, 0x5, 0x5a, 0xef, 0x60, 0x2, 0x80, 0x6, 0xe5, 0x19, 0x64, 0x2, 0x60, 0x5, 0x75,
+	0x22, 0x1, 0x80, 0x18, 0x78, 0x52, 0x12, 0x5, 0x6, 0xc0, 0x6, 0xc0, 0x7, 0x12, 0x1a, 0x21,
+	0xac, 0x6, 0xd0, 0x7, 0xd0, 0x6, 0x12, 0x10, 0x13, 0x12, 0x1d, 0x8d, 0xe4, 0xf5, 0x22, 0x80,
+	0x5, 0x12, 0x6, 0x63, 0x8f, 0x22, 0xe5, 0x22, 0x60, 0x13, 0x12, 0x1e, 0xe0, 0x50, 0x5, 0x12,
+	0x1e, 0x9, 0x80, 0xf6, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x70, 0x12, 0x19, 0xfc, 0xe4, 0xf5, 0x18,
+	0x22, 0x8f, 0x23, 0x74, 0xa0, 0x2f, 0xf8, 0xe6, 0x24, 0xfe, 0x60, 0x2a, 0x14, 0x60, 0x5c, 0x24,
+	0x2, 0x70, 0x6e, 0x7b, 0xe1, 0x7a, 0x5, 0x7d, 0x4, 0xaf, 0x23, 0x12, 0x17, 0xea, 0x7b, 00,
+	0x7a, 0x6, 0x7d, 0x9, 0xaf, 0x23, 0x12, 0x17, 0xea, 0xaf, 0x23, 0x12, 0x1e, 0x36, 0x74, 0xa0,
+	0x25, 0x23, 0xf8, 0x76, 0x2, 0x22, 0x30, 0x9, 0x48, 0xaf, 0x23, 0x12, 0x1e, 0xb8, 0x50, 0x41,
+	0x12, 0x1f, 0xbd, 0x7d, 0x1, 0xaf, 0x23, 0x12, 0x9, 0x9d, 0xaf, 0x23, 0x12, 0x1c, 0x79, 0x8f,
+	0x24, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x1b, 0xa7, 0xad, 0x24, 0xaf, 0x23, 0x12, 0x16, 0x12, 0x74,
+	0xa0, 0x25, 0x23, 0xf8, 0x76, 0x3, 0xaf, 0x23, 0x2, 0x1f, 0xe7, 0x30, 0x9, 0x13, 0xaf, 0x23,
+	0x12, 0x1e, 0xb8, 0x40, 0xc, 0x74, 0xa0, 0x25, 0x23, 0xf8, 0x76, 0x2, 0xaf, 0x23, 0x12, 0x1b,
+	0x8a, 0x22, 0x12, 00, 0x3f, 0xe4, 0x75, 0x26, 0xc0, 0xf5, 0x25, 0xf5, 0x24, 0xf5, 0x23, 0xf5,
+	0x22, 0x7b, 00, 0x7a, 00, 0x79, 0x23, 0xaf, 0x22, 0x12, 0x9, 0xf8, 0x40, 0x21, 0xe4, 0xfb,
+	0x7d, 0x2, 0x7f, 0x60, 0x12, 0x9, 0x58, 0xe4, 0x25, 0x22, 0xff, 0xe4, 0x34, 0x4, 0xfe, 0xe4,
+	0x34, 0x1, 0xfd, 0xe4, 0x34, 0x1, 0xfc, 0x12, 0x9, 0x5f, 0x7f, 0x2, 0x12, 0x1d, 0x7a, 0x5,
+	0x22, 0xe5, 0x22, 0xd3, 0x94, 0xf, 0x40, 0xc9, 0x7f, 0x3, 0x12, 0x1f, 0x17, 0x12, 0x1f, 0xaf,
+	0x12, 0x1e, 0xf6, 0x7f, 0x4, 0x12, 0x1f, 0x17, 0x75, 0x3c, 0x1, 0x75, 0x3d, 0x1, 0x7b, 0x14,
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x17, 0x88, 0x7f, 0x14, 0x12, 0x1d, 0x7a, 0x7b, 0x4, 0xe4, 0xfd,
+	0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 0x5f, 0x12, 0x1f, 0xb6, 0x12, 0x9, 0x5f, 0x2, 0x14, 0x60,
+	0x8f, 0x37, 0x12, 0xa, 0xa7, 0xaf, 0x37, 0x12, 0x12, 0xcd, 0x75, 0x3d, 00, 0x75, 0x3e, 0x40,
+	0x7b, 0x40, 0x7d, 0x12, 0x12, 0xe, 0x4d, 0x12, 0x1f, 0x78, 0x75, 0x3d, 0xf, 0x75, 0x3e, 0xc0,
+	0x7b, 0x40, 0x7a, 0x2, 0x7d, 0x16, 0xaf, 0x37, 0x12, 0x19, 0x65, 0x75, 0x3d, 0x60, 0x75, 0x3e,
+	00, 0x7b, 00, 0x7a, 0x40, 0x7d, 0x14, 0xaf, 0x37, 0x12, 0x19, 0x65, 0x75, 0x3d, 00, 0x75,
+	0x3e, 0x38, 0x7b, 0x30, 0x7d, 0x18, 0x12, 0xe, 0x4d, 0x12, 0x1f, 0x66, 0x75, 0x3d, 0xe0, 0x12,
+	0x1a, 0x6b, 0xaf, 0x37, 0x12, 0x19, 0x65, 0xaf, 0x37, 0x12, 0x1f, 0x81, 0x75, 0x3d, 0xe0, 0x75,
+	0x3e, 0xe, 0x7b, 0x2, 0x7a, 0x80, 0x7d, 0x18, 0xaf, 0x37, 0x2, 0x19, 0x65, 0x7a, 00, 0xaf,
+	0x37, 0x12, 0x19, 0x65, 0xaf, 0x37, 0x22, 0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0xe4,
+	0xf5, 0x40, 0xe4, 0xff, 0xfe, 0xfd, 0xfc, 0xab, 0x35, 0xaa, 0x34, 0xa9, 0x33, 0xa8, 0x32, 0xd3,
+	0x12, 0x4, 0xcf, 0x40, 0x37, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0xaf, 0x35, 0xae, 0x34, 0xad,
+	0x33, 0xac, 0x32, 0x12, 0x4, 0x30, 0xaf, 0x3, 0x74, 0x36, 0x25, 0x40, 0xf8, 0xa6, 0x7, 0xaf,
+	0x35, 0xae, 0x34, 0xad, 0x33, 0xac, 0x32, 0xe4, 0x7b, 0xa, 0xfa, 0xf9, 0xf8, 0x12, 0x4, 0x30,
+	0x8f, 0x35, 0x8e, 0x34, 0x8d, 0x33, 0x8c, 0x32, 0x5, 0x40, 0x80, 0xb6, 0xe5, 0x40, 0x70, 0x5,
+	0x7f, 0x30, 0x2, 0x1d, 0xa0, 0x15, 0x40, 0xe5, 0x40, 0xf4, 0x60, 0x10, 0x74, 0x36, 0x25, 0x40,
+	0xf8, 0xe6, 0x24, 0x30, 0xff, 0x12, 0x1d, 0xa0, 0x15, 0x40, 0x80, 0xeb, 0x22, 0x7b, 0xff, 0x7a,
+	0x1e, 0x79, 0x45, 0x12, 0x19, 0xfc, 0x12, 0x1f, 0x35, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x82, 0x12,
+	0x19, 0xfc, 0x7b, 0x18, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x44, 0x12, 0x1c, 0x2e, 0x12, 0x1f,
+	0x35, 0x7b, 0xff, 0x7a, 0x12, 0x79, 0x87, 0x12, 0x19, 0xfc, 0xe4, 0xf5, 0x24, 0xaf, 0x24, 0x12,
+	0x1a, 0xcc, 0x7f, 0x3, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1e, 0x80, 0x7f, 0x2, 0x12, 0x1d,
+	0x3f, 0x7f, 0x1, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1f, 0xc4, 0xe4, 0xfc, 0xfd, 0xfe, 0x12,
+	0xe, 0x57, 0x7f, 0x3, 0x12, 0x1d, 0x3f, 0xaf, 0x24, 0x12, 0x1f, 0xcb, 0x12, 0x1a, 0xcc, 0x12,
+	0x1f, 0x35, 0x5, 0x24, 0xe5, 0x24, 0xc3, 0x94, 0x7, 0x40, 0xc2, 0x22, 0x8f, 0x32, 0x8d, 0x33,
+	0x7b, 0x24, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x7f, 0x6, 0x12, 0x1b, 0x51, 0x12, 0x9, 0x5f, 0xe5,
+	0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0x75, 0x3d, 0x1, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x17,
+	0x88, 0x7f, 0x2, 0x12, 0x1f, 0x17, 0xaf, 0x33, 0x12, 0x1a, 0x8a, 0x7f, 0xa, 0x12, 0x1f, 0xa1,
+	0x12, 0x1e, 0xeb, 0x40, 0x5, 0x12, 0x1f, 0xd9, 0x50, 0xf6, 0x12, 0x1f, 0xd9, 0x40, 0x13, 0xad,
+	0x33, 0xaf, 0x32, 0x12, 0x13, 0x82, 0xef, 0x70, 0x4, 0xf5, 0x34, 0x80, 0x8, 0x75, 0x34, 0x1,
+	0x80, 0x3, 0x75, 0x34, 0x2, 0xe5, 0x32, 0x24, 0x80, 0xfb, 0x75, 0x3c, 0x1b, 0xe4, 0xf5, 0x3d,
+	0xfd, 0x7f, 0x40, 0x12, 0x17, 0x88, 0xaf, 0x34, 0x22, 0x8f, 0xa, 0xc3, 0xed, 0x94, 0x40, 0xec,
+	0x94, 00, 0x50, 0x16, 0xc3, 0x74, 0x40, 0x9d, 0xff, 0xe4, 0x9c, 0xfe, 0xef, 0x78, 0x2, 0xce,
+	0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0xf5, 0xb, 0x80, 0x1c, 0xed, 0x24, 0x3, 0xff, 0xe4, 0x3c,
+	0xfe, 0xef, 0x78, 0x2, 0xce, 0xc3, 0x13, 0xce, 0x13, 0xd8, 0xf9, 0x30, 0xe0, 0x5, 0x75, 0xb,
+	0x1, 0x80, 0x3, 0xe4, 0xf5, 0xb, 0xc3, 0xed, 0x94, 0x40, 0xec, 0x94, 00, 0x40, 0xe, 0xae,
+	0x4, 0xaf, 0x5, 0xe4, 0xfc, 0xfd, 0x78, 0x10, 0x12, 0x4, 0xf3, 0x80, 0x8, 0x7f, 00, 0x7e,
+	00, 0x7d, 0x40, 0x7c, 00, 0x12, 0x15, 0x5e, 0x7f, 0x20, 0x7e, 0x5, 0x7d, 00, 0x7c, 00,
+	0x2, 0x15, 0x5e, 0x8e, 0x23, 0x8f, 0x24, 0x8c, 0x25, 0x8d, 0x26, 0x7f, 0xa, 0x12, 0x1d, 0x53,
+	0x12, 0x1f, 0x53, 0x40, 0x52, 0x12, 0x1e, 0x54, 0xe4, 0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x2, 0x12,
+	0x1a, 0x45, 0xe5, 0x23, 0xff, 0x12, 0x1a, 0x45, 0xaf, 0x24, 0x12, 0x1a, 0x45, 0xe4, 0xf5, 0x27,
+	0x12, 0x1f, 0x53, 0x40, 0x24, 0x12, 0x1e, 0xe0, 0x50, 0xfb, 0x12, 0x1e, 0x9, 0x12, 0x1a, 0x45,
+	0x5, 0x24, 0xe5, 0x24, 0x70, 0x2, 0x5, 0x23, 0xe5, 0x26, 0x15, 0x26, 0x70, 0x2, 0x15, 0x25,
+	0x5, 0x27, 0xe5, 0x27, 0xc3, 0x94, 0x20, 0x40, 0xd7, 0x7f, 0x1, 0x12, 0x1d, 0xc4, 0x12, 0x1c,
+	0xd6, 0xef, 0x30, 0xe0, 0xab, 0x80, 0xf7, 0xe4, 0xff, 0x2, 0x1d, 0x53, 0x8f, 0x33, 0x8d, 0x34,
+	0x8b, 0x35, 0xe5, 0x39, 0x55, 0x3d, 0xf5, 0x39, 0xe5, 0x38, 0x55, 0x3c, 0xf5, 0x38, 0xe5, 0x37,
+	0x55, 0x3b, 0xf5, 0x37, 0xe5, 0x36, 0x55, 0x3a, 0xf5, 0x36, 0x12, 0x9, 0x44, 0xa8, 0x4, 0xa9,
+	0x5, 0xaa, 0x6, 0xab, 0x7, 0xaf, 0x3d, 0xae, 0x3c, 0xad, 0x3b, 0xac, 0x3a, 0x12, 0x4, 0xc2,
+	0xeb, 0x5f, 0xff, 0xea, 0x5e, 0xfe, 0xe9, 0x5d, 0xfd, 0xe8, 0x5c, 0xfc, 0xe5, 0x39, 0x4f, 0xf5,
+	0x39, 0xe5, 0x38, 0x4e, 0xf5, 0x38, 0xe5, 0x37, 0x4d, 0xf5, 0x37, 0xe5, 0x36, 0x4c, 0xf5, 0x36,
+	0xab, 0x35, 0xad, 0x34, 0xaf, 0x33, 0x12, 0x9, 0x58, 0xaf, 0x39, 0xae, 0x38, 0xad, 0x37, 0xac,
+	0x36, 0x2, 0x9, 0x5f, 0x8f, 0x32, 0x8d, 0x33, 0x7b, 0x19, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x9,
+	0x58, 0x12, 0x1b, 0x4f, 0x12, 0x9, 0x5f, 0xe5, 0x33, 0x44, 0x10, 0xfd, 0xaf, 0x32, 0x12, 0x11,
+	0xae, 0xef, 0xf5, 0x37, 0xee, 0xf5, 0x36, 0xed, 0x44, 0x1, 0xf5, 0x35, 0xec, 0x44, 0x10, 0xf5,
+	0x34, 0x12, 0x11, 0x3f, 0xe5, 0x37, 0x44, 0x30, 0xff, 0xe5, 0x36, 0xfe, 0xe5, 0x35, 0xfd, 0xe5,
+	0x34, 0x44, 0x20, 0xfc, 0x12, 0x9, 0x5f, 0x12, 0x11, 0x3f, 0xaf, 0x37, 0xae, 0x36, 0xad, 0x35,
+	0xac, 0x34, 0x12, 0x9, 0x5f, 0xe5, 0x32, 0xb4, 0x6, 0x4, 0xff, 0x12, 0x16, 0xeb, 0x22, 0xe4,
+	0xfb, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x22, 0x7f, 0xa, 0x12, 0x1d, 0x53, 0xe4, 0xff,
+	0xfe, 0x12, 0x19, 0x8b, 0xef, 0x7f, 00, 0xfe, 0xc0, 0x7, 0xc0, 0x6, 0xf, 0x7e, 00, 0x12,
+	0x19, 0x8b, 0xef, 0xfd, 0xd0, 0xe0, 0xf5, 0x1b, 0xd0, 0xe0, 0x4d, 0xf5, 0x1c, 0x24, 0x1, 0xff,
+	0xe4, 0x35, 0x1b, 0xfe, 0x12, 0x19, 0x8b, 0x8f, 0x1d, 0xe4, 0xff, 0x12, 0x1d, 0x53, 0xe5, 0x1c,
+	0x15, 0x1c, 0x70, 0x2, 0x15, 0x1b, 0xe4, 0xff, 0xfe, 0xc3, 0xef, 0x95, 0x1c, 0xee, 0x95, 0x1b,
+	0x50, 0x11, 0x8f, 0x82, 0x8e, 0x83, 0xe4, 0x93, 0x25, 0x1d, 0xf5, 0x1d, 0xf, 0xbf, 00, 0x1,
+	0xe, 0x80, 0xe6, 0xe5, 0x1d, 0x70, 0x4, 0x7f, 0x1, 0x80, 0x2, 0x7f, 00, 0x22, 0xef, 0x64,
+	0x6, 0xef, 0x64, 0x6, 0x70, 0x24, 0xbd, 0x10, 0x8, 0x7f, 0x43, 0x7e, 0x4, 0x7d, 0x4, 0xfc,
+	0x22, 0xed, 0x70, 0x4, 0x7f, 0x43, 0x80, 0x20, 0xbd, 0x11, 0x4, 0x7f, 0x42, 0x80, 0x24, 0xbd,
+	0x1, 0x4, 0x7f, 0x42, 0x80, 0x29, 0x7f, 0x81, 0x80, 0x2e, 0xbd, 0x10, 0x6, 0x7f, 0x44, 0x7e,
+	0x4, 0x80, 0x12, 0xed, 0x70, 0x8, 0x7f, 0x44, 0x7e, 0x4, 0xfd, 0x7c, 0x80, 0x22, 0xbd, 0x11,
+	0x9, 0x7f, 0x44, 0x7e, 0x24, 0x7d, 0x4, 0x7c, 00, 0x22, 0xbd, 0x1, 0x9, 0x7f, 0x44, 0x7e,
+	0x24, 0x7d, 00, 0x7c, 0x80, 0x22, 0x7f, 0x84, 0x7e, 0x1, 0x7d, 0x6, 0x7c, 00, 0x22, 0x8f,
+	0x2c, 0x7f, 0x32, 0x12, 0x1f, 0xa1, 0x7b, 0xd8, 0xad, 0x2c, 0x7f, 0x20, 0x12, 0x9, 0x44, 0x78,
+	0x8, 0x12, 0x4, 0xe0, 0xef, 0x54, 0x3f, 0xff, 0xe4, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8,
+	0xc3, 0x12, 0x4, 0xcf, 0x70, 0x32, 0x7b, 0xc, 0xfd, 0x7f, 0xa0, 0x12, 0x9, 0x44, 0xc0, 0x4,
+	0xc0, 0x5, 0xc0, 0x6, 0xc0, 0x7, 0xaf, 0x2c, 0x12, 0x9, 0x96, 0xe4, 0xfc, 0xfd, 0xfe, 0xd0,
+	0x3, 0xd0, 0x2, 0xd0, 0x1, 0xd0, 00, 0xeb, 0x5f, 0xff, 0xe4, 0xfb, 0xfa, 0xf9, 0xf8, 0xc3,
+	0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x12, 0x1f, 0xd9, 0x50, 0xa9, 0x7f, 00, 0x22,
+	0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0xd,
+	0xa, 00, 0x69, 0x64, 0x3a, 0x20, 00, 00, 0x50, 00, 0x4d, 00, 0x50, 0x20, 00, 00,
+	00, 0xd, 0xa, 0x20, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x20, 0x40, 0x31, 0x30, 0x20, 0x40,
+	0x31, 0x30, 0x30, 0x20, 0x40, 0x31, 0x30, 0x30, 0x30, 00, 0x4f, 0x6b, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 00, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 00, 0xd, 0xa, 0x54, 0x65, 0x73, 0x74,
+	0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0xd, 0xa, 00, 0x8f, 0x38, 0x12,
+	0x1f, 0x78, 0x12, 0x1a, 0x75, 0x12, 0x13, 0x15, 0x12, 0x1f, 0x6f, 0x7a, 0xb6, 0x12, 0x13, 0x1f,
+	0x75, 0x3d, 0xff, 0x75, 0x3e, 0x7, 0x7b, 0x3, 0x7a, 00, 0x7d, 0x12, 0xaf, 0x38, 0x12, 0x19,
+	0x65, 0x75, 0x3d, 00, 0x75, 0x3e, 0xff, 0x7b, 0xa2, 0x7a, 00, 0x7d, 0x11, 0xaf, 0x38, 0x12,
+	0x19, 0x65, 0x7a, 0x96, 0x12, 0x13, 0x1f, 0xaf, 0x38, 0x12, 0x1f, 0x78, 0x12, 0x1a, 0x80, 0x12,
+	0x13, 0x15, 0x2, 0x1f, 0x81, 0x7d, 0x8, 0xaf, 0x38, 0x12, 0x19, 0x65, 0xaf, 0x38, 0x22, 0x7b,
+	0x8a, 0x7d, 0x10, 0xaf, 0x38, 0x12, 0x17, 0xea, 0x22, 0x8f, 0x3f, 0x8d, 0x40, 0x12, 0x1f, 0xc4,
+	0x8f, 0x45, 0xaf, 0x3f, 0x12, 0x1f, 0xcb, 0x8f, 0x46, 0x7b, 0x1, 0xad, 0x45, 0x7f, 0x60, 0x12,
+	0x9, 0x58, 0xe5, 0x46, 0x75, 0xf0, 0x20, 0xa4, 0xff, 0xe5, 0xf0, 0x44, 0x4, 0xfc, 0xef, 0x45,
+	0x40, 0xfd, 0xe4, 0xff, 0xfe, 0x12, 0x9, 0x75, 0x12, 0x9, 0x5f, 0xaf, 0x45, 0x12, 0x1b, 0x2f,
+	0x7b, 0x2, 0xad, 0x45, 0x7f, 0x60, 0x12, 0x9, 0x44, 0x8f, 0x44, 0x8e, 0x43, 0x8d, 0x42, 0x8c,
+	0x41, 0xe5, 0x42, 0x54, 0x1, 0xfd, 0xed, 0x70, 0x5, 0xae, 0x43, 0xaf, 0x44, 0x22, 0xe4, 0xfe,
+	0xff, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xf5, 0x38, 0xfb, 0x7a, 00, 0x79, 0x39, 0x12, 0x14,
+	0xa2, 0xef, 0x64, 0x80, 0x4e, 0x60, 0x3, 0x75, 0x38, 0x1, 0xe5, 0x39, 0x65, 0x35, 0x60, 0x3,
+	0x75, 0x38, 0x1, 0xe5, 0x38, 0x70, 0x25, 0xf5, 0x37, 0x12, 0x1d, 0x17, 0xa8, 0x4, 0xa9, 0x5,
+	0xaa, 0x6, 0xab, 0x7, 0xe4, 0x25, 0x36, 0x12, 0x1b, 0x58, 0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3,
+	0x75, 0x38, 0x1, 0x5, 0x37, 0xe5, 0x37, 0xc3, 0x94, 0x1f, 0x40, 0xdd, 0x12, 0x1d, 0x2b, 0xaf,
+	0x38, 0x22, 0x8f, 0x35, 0x8d, 0x36, 0xe4, 0xfb, 0xfa, 0xfd, 0x12, 0x17, 0xea, 0xe5, 0x36, 0x54,
+	0x3, 0xff, 0x70, 0x6, 0xf5, 0x37, 0xf5, 0x38, 0x80, 0x14, 0xbf, 0x1, 0x8, 0x75, 0x37, 0x20,
+	0x75, 0x38, 00, 0x80, 0x9, 0xbf, 0x2, 0x6, 0x75, 0x37, 00, 0x75, 0x38, 0x40, 0xe5, 0x36,
+	0x30, 0xe4, 0x3, 0x43, 0x37, 0x1, 0xe5, 0x36, 0x30, 0xe7, 0x3, 0x43, 0x37, 0x40, 0xab, 0x38,
+	0xaa, 0x37, 0xe4, 0xfd, 0xaf, 0x35, 0x2, 0x17, 0xea, 0x8f, 0x27, 0x12, 0x1f, 0x6f, 0x7b, 0xf0,
+	0x7a, 0xaf, 0x7d, 0x10, 0xaf, 0x27, 0x12, 0x17, 0xea, 0x7d, 0x11, 0xaf, 0x27, 0x12, 0x13, 0x29,
+	0xee, 0xc4, 0xf8, 0x54, 0xf0, 0xc8, 0xef, 0xc4, 0x54, 0xf, 0x48, 0x54, 0x1f, 0xff, 0xc3, 0x94,
+	0x10, 0x40, 0x6, 0xef, 0xd3, 0x94, 0x14, 0x40, 0x12, 0xaf, 0x27, 0x12, 0x1f, 0x78, 0x75, 0x3d,
+	0x3, 0x12, 0x1a, 0x83, 0x7d, 0xc, 0xaf, 0x27, 0x12, 0x19, 0x65, 0xaf, 0x27, 0x2, 0x1f, 0x81,
+	0x75, 0x27, 0x1, 0x7b, 0x6, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f, 0x80, 0x7e, 0x1,
+	0x7d, 00, 0x7c, 00, 0x12, 0x9, 0x5f, 0x7b, 0x7, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58,
+	0xe4, 0x25, 0x27, 0xff, 0xe4, 0x33, 0xfe, 0xe4, 0x33, 0xfd, 0xe4, 0x34, 0xc2, 0xfc, 0x12, 0x9,
+	0x5f, 0x7f, 0x1, 0x7e, 0x26, 0x12, 0x16, 0x81, 0x5, 0x27, 0xe5, 0x27, 0xd3, 0x94, 0xf, 0x40,
+	0xc2, 0x22, 0x8b, 0x3a, 0x8a, 0x3b, 0x89, 0x3c, 0xe4, 0xf5, 0x8, 0xf5, 0x9, 0x12, 0x14, 0xd6,
+	0xe5, 0x3d, 0x54, 0x3f, 0xf5, 0x41, 0x85, 0x3e, 0x42, 0xe5, 0x3b, 0x45, 0x3c, 0x45, 0x3a, 0x60,
+	0x10, 0xe5, 0x40, 0x54, 0x7, 0xab, 0x3a, 0xaa, 0x3b, 0xa9, 0x3c, 0x12, 0x3, 0x93, 0x12, 0x14,
+	0xd6, 0xae, 0x41, 0xaf, 0x42, 0x22, 0x12, 0x1d, 0x17, 0x8f, 0x40, 0x8e, 0x3f, 0x8d, 0x3e, 0x8c,
+	0x3d, 0x22, 0xc0, 0xe0, 0xc0, 0xd0, 0x75, 0xd0, 0x10, 0x30, 0x98, 0x29, 0xaf, 0x99, 0xc2, 0x98,
+	0xe5, 0x1e, 0x24, 0x1, 0xfd, 0xe4, 0x33, 0xfc, 0xe5, 0x1f, 0x7a, 00, 0xb5, 0x15, 0x8, 0xea,
+	0xb5, 0x14, 0x4, 0xd2, 0x5, 0x80, 0xe, 0x74, 0x80, 0x25, 0x1e, 0xf8, 0xa6, 0x17, 0xe5, 0x1e,
+	0x4, 0x54, 0x1f, 0xf5, 0x1e, 0x30, 0x99, 0x4, 0xc2, 0x99, 0xd2, 0x6, 0xd0, 0xd0, 0xd0, 0xe0,
+	0x32, 0x8b, 0x23, 0x8a, 0x24, 0x89, 0x25, 0xab, 0x26, 0xaa, 0x27, 0xa9, 0x28, 0x12, 0x3, 0x7a,
+	0xf5, 0x29, 0x70, 0x2, 0xff, 0x22, 0x74, 0x1, 0x25, 0x28, 0xf5, 0x28, 0xe4, 0x35, 0x27, 0xf5,
+	0x27, 0xab, 0x23, 0x5, 0x25, 0xe5, 0x25, 0xaa, 0x24, 0x70, 0x2, 0x5, 0x24, 0x14, 0xf9, 0x12,
+	0x3, 0x7a, 0xff, 0x12, 0x1c, 0x60, 0xef, 0x65, 0x29, 0x60, 0xcc, 0x7f, 0x1, 0x22, 0x8f, 0x3a,
+	0x8e, 0x39, 0x8d, 0x38, 0x8c, 0x37, 0x20, 0x8, 0x30, 0x7b, 0xc0, 0xad, 0xa, 0x7f, 0x20, 0x12,
+	0x9, 0x58, 0xaf, 0x3a, 0xae, 0x39, 0xad, 0x38, 0xac, 0x37, 0x12, 0x9, 0x5f, 0xe4, 0x78, 0xa7,
+	0xf6, 0x7b, 0xc8, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x9, 0x44, 0xee, 0x30, 0xe0, 0xb, 0x78, 0xa7,
+	0x6, 0xe6, 0xd3, 0x94, 0x64, 0x40, 0xea, 0xd2, 0x8, 0x22, 0x12, 0x19, 0x3f, 0x8f, 0x2b, 0xe4,
+	0xf5, 0x2a, 0xaf, 0x2a, 0x12, 0x9, 0x96, 0xef, 0xf4, 0xff, 0xef, 0x55, 0x2b, 0xff, 0xe4, 0x8f,
+	0x39, 0xf5, 0x38, 0xf5, 0x37, 0xf5, 0x36, 0xe5, 0x2a, 0x24, 0x80, 0xfb, 0xe4, 0x75, 0x3d, 0x5f,
+	0xf5, 0x3c, 0xf5, 0x3b, 0xf5, 0x3a, 0xfd, 0x7f, 0x40, 0x12, 0x10, 0x7c, 0x5, 0x2a, 0xe5, 0x2a,
+	0xc3, 0x94, 0x7, 0x40, 0xcd, 0x22, 0x12, 0x1e, 0xe0, 0x50, 0x35, 0x12, 0x1e, 0x9, 0xef, 0x64,
+	0xa, 0x60, 0x2d, 0xbf, 0x8, 0xb, 0xe5, 0x18, 0xd3, 0x94, 00, 0x40, 0x23, 0x15, 0x18, 0x80,
+	0x1f, 0xe5, 0x18, 0xc3, 0x94, 0x1e, 0x50, 0xa, 0xae, 0x18, 0x5, 0x18, 0x74, 0x62, 0x2e, 0xf8,
+	0xa6, 0x7, 0xbf, 0xd, 0xb, 0xe5, 0x18, 0xb4, 0x1e, 0x4, 0x78, 0x7f, 0x76, 0xd, 0xd3, 0x22,
+	0xc3, 0x22, 0x8f, 0x25, 0x8d, 0x26, 0xe5, 0x25, 0x64, 0x6, 0x60, 0x2d, 0xe5, 0x26, 0x54, 0x3,
+	0xff, 0xbf, 0x2, 0x5, 0xaf, 0x25, 0x12, 0x14, 0x19, 0xe5, 0x26, 0x54, 0x3, 0x70, 0x1a, 0xaf,
+	0x25, 0x12, 0x1f, 0x78, 0x12, 0x1a, 0x68, 0xaf, 0x25, 0x12, 0x19, 0x65, 0x12, 0x1a, 0x68, 0xaf,
+	0x25, 0x12, 0x19, 0x65, 0xaf, 0x25, 0x12, 0x1f, 0x81, 0x22, 0xaf, 0xb, 0x15, 0xb, 0xef, 0xd3,
+	0x94, 00, 0x40, 0xd, 0x7f, 0x55, 0x7e, 0x55, 0x7d, 0x55, 0x7c, 0x55, 0x12, 0x15, 0x5e, 0x80,
+	0xe9, 0x30, 0x8, 0x9, 0x75, 0x3c, 0x1, 0x12, 0x16, 0x74, 0xc2, 0x8, 0x22, 0xe4, 0xf5, 0x3c,
+	0x12, 0x16, 0x74, 0x22, 0x75, 0x3d, 0x1, 0x7b, 0xc4, 0xad, 0xa, 0x7f, 0x20, 0x12, 0x17, 0x88,
+	0x22, 0x8e, 0x28, 0x8f, 0x29, 0x7b, 0xb0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0xae, 0x28,
+	0xaf, 0x29, 0xe4, 0xfc, 0xfd, 0x12, 0x9, 0x5f, 0x7f, 0xa, 0x12, 0x1f, 0xa1, 0x7b, 0xb0, 0xe4,
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x44, 0xef, 0x54, 0x7, 0x60, 0xa, 0x12, 0x1f, 0xd9, 0x50, 0xed,
+	0x7f, 0x4, 0x12, 0x1f, 0xe1, 0x22, 0x8f, 0x28, 0x8d, 0x29, 0xe5, 0x29, 0xf4, 0x60, 0x29, 0x7b,
+	0x10, 0xad, 0x28, 0x7f, 0x20, 0x12, 0x9, 0x58, 0x7f, 00, 0x7e, 0x6, 0x7d, 00, 0x7c, 00,
+	0x12, 0x9, 0x5f, 0xad, 0x29, 0xaf, 0x28, 0x12, 0x7, 0x66, 0xe4, 0xfd, 0xaf, 0x28, 0x12, 00,
+	0x26, 0x7d, 0x1, 0xaf, 0x28, 0x12, 0x1e, 0xd3, 0x2, 0x15, 0x9a, 0x8f, 0x38, 0x75, 0x3c, 0x5,
+	0x75, 0x3d, 0x1, 0x7b, 0x19, 0xad, 0x38, 0x7f, 0x20, 0x12, 0x17, 0x88, 0xe5, 0x38, 0xb4, 0x6,
+	0xe, 0x75, 0x3c, 0x2, 0x75, 0x3d, 0x1, 0x7b, 0x19, 0xfd, 0x7f, 0x20, 0x12, 0x17, 0x88, 0x7b,
+	0x5, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0x7f, 0x22, 0x12, 0x1f, 0xb6, 0x2, 0x9, 0x5f,
+	0xe4, 0xf5, 0x22, 0xe5, 0x22, 0x24, 0x80, 0xfb, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0x7f,
+	00, 0x12, 0x1f, 0xb6, 0x12, 0x9, 0x5f, 0xe5, 0x22, 0xb4, 0x6, 0x5, 0x7d, 0x12, 0xff, 0x80,
+	0x4, 0x7d, 0xff, 0xaf, 0x22, 0x12, 0x1b, 0xa7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40,
+	0xd2, 0x2, 0x15, 0x9a, 0x8b, 0x2b, 0x8a, 0x2c, 0x89, 0x2d, 0xe4, 0xf5, 0x2e, 0xab, 0x2b, 0x5,
+	0x2d, 0xe5, 0x2d, 0xaa, 0x2c, 0x70, 0x2, 0x5, 0x2c, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12,
+	0x1c, 0x15, 0xe5, 0x2e, 0xc3, 0x94, 0x5, 0x50, 0x5, 0x7f, 0x2d, 0x12, 0x1f, 0xe4, 0x5, 0x2e,
+	0xe5, 0x2e, 0xc3, 0x94, 0x6, 0x40, 0xd6, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8b, 0x3b, 0x12, 0x9,
+	0x44, 0x8f, 0x41, 0x8e, 0x40, 0x8d, 0x3f, 0x8c, 0x3e, 0x7b, 00, 0x7a, 00, 0x79, 0x3e, 0xad,
+	0x3d, 0xaf, 0x3c, 0x12, 0x9, 0xc5, 0xab, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x12, 0x9, 0x58, 0xaf,
+	0x41, 0xae, 0x40, 0xad, 0x3f, 0xac, 0x3e, 0x2, 0x9, 0x5f, 00, 00, 0x10, 0x10, 0x80, 00,
+	00, 00, 00, 0xe, 00, 0x15, 00, 0x10, 00, 0x15, 00, 0x12, 00, 0x15, 00, 0x14,
+	00, 0x15, 00, 00, 0x10, 0xc, 0x80, 00, 00, 0x1, 00, 0xa, 00, 0x18, 00, 0xb,
+	00, 0x18, 00, 0xc, 00, 0x18, 00, 0xd, 00, 0x18, 0x8f, 0x3f, 0x8d, 0x40, 0x8a, 0x41,
+	0x8b, 0x42, 0x12, 0x1f, 0xc4, 0x8f, 0x43, 0xaf, 0x3f, 0x12, 0x1f, 0xcb, 0x8f, 0x44, 0x7b, 0x1,
+	0xad, 0x43, 0x7f, 0x60, 0x12, 0x9, 0x58, 0xab, 0x44, 0xad, 0x40, 0xaf, 0x42, 0xae, 0x41, 0x12,
+	0x1f, 0x21, 0x12, 0x9, 0x5f, 0xaf, 0x43, 0x2, 0x1b, 0x2f, 0x8f, 0x37, 0x7b, 00, 0x7a, 0x80,
+	0xe4, 0xfd, 0x12, 0x17, 0xea, 0x7f, 0x2, 0x12, 0x1d, 0x7a, 0xe4, 0xf5, 0x38, 0xe4, 0xfd, 0xaf,
+	0x37, 0x12, 0x13, 0x29, 0xee, 0x30, 0xe7, 0x10, 0x5, 0x38, 0xe5, 0x38, 0xd3, 0x94, 0xc8, 0x50,
+	0x7, 0x7f, 0x1, 0x12, 0x1d, 0x7a, 0x80, 0xe5, 0x22, 0xc1, 0x5, 0xc1, 0x4, 0x1, 0x1e, 00,
+	0x1, 0x1f, 00, 0xc1, 00, 0xc1, 0x1, 0x1, 0xe, 00, 0xc1, 0x2, 0xc1, 0x3, 0x1, 0xc,
+	0xa, 0x1, 0xd, 0x64, 0xc1, 0x7, 0x1, 0xf, 00, 0xc1, 0x8, 0x1, 0x18, 00, 0x1, 0x4d,
+	00, 0x1, 0x51, 00, 00, 0x8f, 0x2a, 0x8e, 0x29, 0x8d, 0x28, 0x8c, 0x27, 0x7b, 0xd0, 0xe4,
+	0xfd, 0x7f, 0x40, 0x12, 0x9, 0x58, 0xaf, 0x2a, 0xae, 0x29, 0xad, 0x28, 0xac, 0x27, 0x12, 0x9,
+	0x5f, 0x7b, 0xd0, 0xe4, 0xfd, 0x7f, 0x40, 0x12, 0x9, 0x44, 0xef, 0x54, 0x3, 0x70, 0xf2, 0x22,
+	0xe4, 0xfe, 0xee, 0x90, 00, 0x40, 0x93, 0xfc, 0xed, 0x2e, 0xf8, 0xa6, 0x4, 0xe, 0xbe, 0x6,
+	0xf1, 0xed, 0x24, 0x5, 0xf8, 0xe6, 0x2f, 0xf6, 0xc3, 0x9f, 0x50, 0xd, 0xed, 0x24, 0x4, 0xf8,
+	0x6, 0xe6, 0x70, 0x5, 0xed, 0x24, 0x3, 0xf8, 0x6, 0x22, 0x7b, 0x17, 0xe4, 0xfd, 0x7f, 0xe0,
+	0x12, 0x9, 0x58, 0x7f, 0xff, 0x7e, 0xff, 0x7d, 0xff, 0x7c, 0xff, 0x12, 0x9, 0x5f, 0x7b, 0x16,
+	0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0x7f, 0x9a, 0x7e, 0x22, 0x7d, 00, 0x7c, 00, 0x2,
+	0x9, 0x5f, 0x8f, 0x32, 0x8d, 0x33, 0x8b, 0x34, 0x12, 0x1f, 0x49, 0xaf, 0x33, 0x12, 0x1f, 0x49,
+	0x7f, 0x5, 0x12, 0x1f, 0x17, 0xe5, 0x34, 0x44, 0x10, 0xfd, 0xaf, 0x32, 0x12, 0x13, 0xd2, 0xe5,
+	0x34, 0x44, 0x10, 0xfd, 0xaf, 0x33, 0x2, 0x13, 0xd2, 0x8f, 0x32, 0xed, 0x70, 0x2, 0x80, 0x1,
+	0xe4, 0x75, 0x39, 0x86, 0x75, 0x38, 0x2, 0xf5, 0x37, 0xf5, 0x36, 0x75, 0x3d, 0xff, 0x75, 0x3c,
+	0xf, 0xf5, 0x3b, 0xf5, 0x3a, 0x7b, 0x2, 0xad, 0x32, 0x7f, 0x20, 0x12, 0x10, 0x7c, 0x22, 0xe4,
+	0xf5, 0x2c, 0xf5, 0x2d, 0xaf, 0x2d, 0x12, 00, 0x3, 0xef, 0x60, 0xd, 0x7b, 00, 0x7a, 00,
+	0x79, 0x2c, 0x7d, 0x1, 0xaf, 0x2d, 0x12, 0x9, 0x9d, 0x5, 0x2d, 0xe5, 0x2d, 0xc3, 0x94, 0x7,
+	0x40, 0xe2, 0xaf, 0x2c, 0x22, 0x8f, 0x39, 0x8d, 0x3a, 0x8a, 0x3b, 0x8b, 0x3c, 0x12, 0x13, 0x29,
+	0xe5, 0x3e, 0xf4, 0xfd, 0xe5, 0x3d, 0xf4, 0x5e, 0xfe, 0xef, 0x5d, 0x42, 0x3c, 0xee, 0x42, 0x3b,
+	0xab, 0x3c, 0xaa, 0x3b, 0xad, 0x3a, 0xaf, 0x39, 0x2, 0x17, 0xea, 0x8e, 0x48, 0x8f, 0x49, 0xe4,
+	0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x3, 0x12, 0x1a, 0x45, 0xe5, 0x48, 0xff, 0x12, 0x1a, 0x45, 0xaf,
+	0x49, 0x12, 0x1a, 0x45, 0x12, 0x1b, 0xe, 0x8f, 0x4a, 0x7f, 0x1, 0x12, 0x1d, 0xc4, 0xaf, 0x4a,
+	0x22, 0x12, 0x1c, 0x60, 0x74, 0x30, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x39, 0x50, 0x5, 0xef,
+	0x24, 0xd0, 0xff, 0x22, 0x74, 0x41, 0xd3, 0x9f, 0x50, 0xa, 0xef, 0x94, 0x46, 0x50, 0x5, 0xef,
+	0x24, 0xc9, 0xff, 0x22, 0x7f, 0xff, 0x22, 0xc2, 0x8e, 0x75, 0x8b, 0x92, 0x75, 0x8d, 0xe6, 0xd2,
+	0x8e, 0xd2, 0x3, 0xd5, 0xc, 0x15, 0x75, 0xc, 0xa, 0xd2, 00, 0xd5, 0xd, 0x5, 0x75, 0xd,
+	0x64, 0xd2, 0x1, 0x30, 0x2, 0x5, 0xd5, 0xe, 0x2, 0xc2, 0x2, 0x32, 0x8b, 0x32, 0x8a, 0x33,
+	0x89, 0x34, 0xab, 0x32, 0xaa, 0x33, 0xa9, 0x34, 0x12, 0x3, 0x7a, 0x60, 0x13, 0x5, 0x34, 0xe5,
+	0x34, 0x70, 0x2, 0x5, 0x33, 0x14, 0xf9, 0x12, 0x3, 0x7a, 0xff, 0x12, 0x1d, 0xa0, 0x80, 0xe2,
+	0x22, 0x78, 0x56, 0x12, 0x5, 0x6, 0xad, 0x7, 0x22, 0x78, 0x5a, 0x12, 0x5, 0x6, 0xab, 0x7,
+	0x22, 0x78, 0x52, 0x12, 0x5, 0x6, 0x78, 0x5, 0x2, 0x4, 0xf3, 0xa9, 0x1a, 0x7a, 00, 0x7b,
+	00, 0x75, 0x26, 0xff, 0x22, 0x8f, 0x29, 0xe4, 0xf5, 0x2a, 0xe5, 0x29, 0x54, 0x80, 0xff, 0x12,
+	0x1d, 0xd6, 0xe5, 0x29, 0x25, 0xe0, 0xf5, 0x29, 0x12, 0x1f, 0x91, 0x12, 0x1f, 0x99, 0x5, 0x2a,
+	0xe5, 0x2a, 0xc3, 0x94, 0x8, 0x40, 0xe3, 0x22, 0x75, 0x3d, 0x60, 0x75, 0x3e, 00, 0x7b, 00,
+	0x7a, 0x20, 0x7d, 0x14, 0x22, 0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x2, 0x22,
+	0x75, 0x3d, 0x2, 0x75, 0x3e, 00, 0xe4, 0xfb, 0xfa, 0x22, 0x8f, 0x35, 0x7d, 0x80, 0x7c, 00,
+	0x12, 0xf, 0xa9, 0xe4, 0xf5, 0x36, 0xe4, 0x25, 0x35, 0x12, 0x1b, 0x58, 0x12, 0x15, 0x5e, 0x5,
+	0x36, 0xe5, 0x36, 0xc3, 0x94, 0x20, 0x40, 0xee, 0x2, 0x16, 0x4a, 0x7b, 0x18, 0xe4, 0xfd, 0x7f,
+	0xe0, 0x12, 0x9, 0x44, 0xec, 0x54, 0xf, 0xfc, 0x7b, 0xe9, 0x7a, 0x50, 0x79, 0x39, 0x78, 0x7,
+	0xc3, 0x12, 0x4, 0xcf, 0x60, 0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0x8f, 0x32, 0xe5, 0x32,
+	0xd3, 0x94, 0x9, 0x40, 0xb, 0xe5, 0x32, 0x75, 0xf0, 0xa, 0x84, 0x12, 0x1f, 0x3f, 0x80, 0x2,
+	0x7f, 0x20, 0x12, 0x1d, 0xa0, 0xe5, 0x32, 0x12, 0x1f, 0x3f, 0x2, 0x1d, 0xa0, 0xe4, 0xf5, 0x4e,
+	0x7f, 0x3, 0x12, 0x1f, 0x17, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x9c, 0x50, 0x5, 0xaf,
+	0x22, 0x12, 0xa, 0xe, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22, 0xe4, 0xf5,
+	0x29, 0xe5, 0x2a, 0x25, 0xe0, 0xf5, 0x2a, 0x12, 0x1f, 0x91, 0x12, 0x1d, 0xe8, 0xef, 0x42, 0x2a,
+	0x12, 0x1f, 0x99, 0x5, 0x29, 0xe5, 0x29, 0xc3, 0x94, 0x8, 0x40, 0xe5, 0xaf, 0x2a, 0x22, 0x8f,
+	0x47, 0x7f, 0x5, 0x12, 0x1f, 0xa1, 0xe4, 0xfb, 0xad, 0x47, 0x7f, 0x60, 0x12, 0x9, 0x44, 0xef,
+	0x54, 0xb, 0x60, 0xa, 0x12, 0x1f, 0xd9, 0x50, 0xed, 0x7f, 0x2, 0x12, 0x1f, 0xe1, 0x22, 0x7f,
+	00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0xff, 0xe4, 0x34, 0x56, 0xfe, 0xe4, 0x34, 0x34,
+	0xfd, 0xe4, 0x34, 0x12, 0xfc, 0x22, 0xff, 0x74, 0x3, 0xa8, 0x6, 0x8, 0x22, 0xad, 0x7, 0xe4,
+	0xf5, 0x39, 0xf5, 0x38, 0x75, 0x37, 0x1, 0x75, 0x36, 0x10, 0xf5, 0x3d, 0xf5, 0x3c, 0x75, 0x3b,
+	0x1, 0x75, 0x3a, 0x18, 0xfb, 0x7f, 0x20, 0x2, 0x10, 0x7c, 0x8f, 0x25, 0x12, 0x1f, 0xbd, 0xe4,
+	0xfd, 0x12, 0x9, 0x9d, 0xaf, 0x25, 0x12, 0x1e, 0x9c, 0x50, 0x5, 0xaf, 0x25, 0x12, 0x1f, 0x5d,
+	0x7d, 0xff, 0xaf, 0x25, 0x2, 0x1b, 0xa7, 0x8f, 0x26, 0x8d, 0x27, 0xe5, 0x26, 0x64, 0x5, 0x60,
+	0x11, 0xe5, 0x27, 0xfd, 0x7c, 00, 0xaf, 0x26, 0x12, 0x1d, 0xb2, 0xad, 0x27, 0xaf, 0x26, 0x12,
+	0x16, 0xb6, 0x22, 0xbf, 0x6, 0x3, 0x7f, 0x12, 0x22, 0x7d, 0x1c, 0x12, 0x13, 0x29, 0xef, 0x13,
+	0x13, 0x13, 0x54, 0x3, 0xfe, 0xef, 0x30, 0xe5, 0x3, 0x43, 0x6, 0x10, 0xaf, 0x6, 0x22, 0x8f,
+	0x2b, 0x12, 0x1e, 0x72, 0x7d, 0x1, 0xaf, 0x2b, 0x12, 0x1e, 0xc6, 0xaf, 0x2b, 0x12, 0x9, 0x96,
+	0x12, 0x12, 0xf, 0xe4, 0xfd, 0xaf, 0x2b, 0x2, 0x1e, 0xc6, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12,
+	0x1e, 0x9c, 0x50, 0x5, 0xaf, 0x22, 0x12, 0xc, 0xe1, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7,
+	0x40, 0xeb, 0xc2, 0x9, 0x22, 0x8f, 0x2f, 0xe5, 0x2f, 0xc4, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x63,
+	0x12, 0x1d, 0xa0, 0xe5, 0x2f, 0x54, 0xf, 0xff, 0x12, 0x1e, 0x63, 0x2, 0x1d, 0xa0, 0x8f, 0x28,
+	0x8e, 0x27, 0x8d, 0x26, 0x8c, 0x25, 0x78, 0x10, 0x12, 0x4, 0xe0, 0x12, 0x1e, 0x18, 0xe5, 0x28,
+	0xff, 0xe5, 0x27, 0xfe, 0x2, 0x1e, 0x18, 0xe4, 0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1f, 0xc, 0x74,
+	0xa0, 0x25, 0x22, 0xf8, 0xa6, 0x7, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xeb, 0x22,
+	0xd3, 0xef, 0x64, 0x80, 0xf8, 0x74, 0x61, 0x64, 0x80, 0x98, 0x50, 0xc, 0xef, 0x64, 0x80, 0x94,
+	0xfa, 0x50, 0x5, 0xef, 0x24, 0xe0, 0xff, 0x22, 0x22, 0x8f, 0x25, 0x12, 0x1b, 0xc3, 0x8f, 0x26,
+	0x7d, 0x5, 0xaf, 0x25, 0x12, 0x13, 0x29, 0xee, 0x30, 0xe2, 0x3, 0x43, 0x26, 0x20, 0xaf, 0x26,
+	0x22, 0x75, 0xcb, 0xff, 0x75, 0xca, 0x2, 0x75, 0xcd, 0xff, 0x75, 0xcc, 0x2, 0x75, 0xc8, 0x34,
+	0x75, 0x98, 0x52, 0xd2, 0xbc, 0xd2, 0xac, 0x22, 0x12, 0x1a, 0xab, 0xef, 0x60, 0x5, 0x7f, 0x5,
+	0x12, 0x1f, 0xe1, 0x12, 0x1c, 0xed, 0xef, 0x60, 0x5, 0x7f, 0x6, 0x12, 0x1f, 0xe1, 0x22, 0x8f,
+	0x37, 0x12, 0x1f, 0x78, 0x75, 0x3d, 0x3, 0x12, 0x1a, 0x78, 0x7d, 0xc, 0xaf, 0x37, 0x12, 0x19,
+	0x65, 0xaf, 0x37, 0x2, 0x1f, 0x81, 0xe4, 0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x5, 0x12, 0x1a, 0x45,
+	0x12, 0x1b, 0xe, 0x8f, 0x28, 0x7f, 0x1, 0x12, 0x1d, 0xc4, 0xaf, 0x28, 0x22, 0xe4, 0xf5, 0x23,
+	0xf5, 0x22, 0xaf, 0x22, 0x12, 0x1e, 0x9c, 0x5, 0x22, 0xe5, 0x22, 0xc3, 0x94, 0x7, 0x40, 0xf2,
+	0xaf, 0x23, 0x22, 0xe4, 0xf5, 0xff, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x1, 0x75, 0xf9, 0xe0,
+	0x75, 0xfb, 0x14, 0xd2, 0xf8, 0x80, 0xfe, 0xe5, 0x8, 0xfd, 0xe5, 0x9, 0xfb, 0x7f, 0x80, 0x12,
+	0x9, 0x44, 0x5, 0x9, 0xe5, 0x9, 0x70, 0x2, 0x5, 0x8, 0x22, 0xe4, 0xfb, 0x7d, 0x4, 0x7f,
+	0x80, 0x12, 0x9, 0x58, 0x7f, 00, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x9, 0x5f, 0x8f,
+	0x32, 0xaf, 0x32, 0x15, 0x32, 0xef, 0xd3, 0x94, 00, 0x40, 0x7, 0x7f, 0x20, 0x12, 0x1d, 0xa0,
+	0x80, 0xef, 0x22, 0x8f, 0x51, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0xaf, 0x51,
+	0xe4, 0xfc, 0xfd, 0xfe, 0x2, 0x9, 0x5f, 0x53, 0x89, 0xf, 0x43, 0x89, 0x10, 0x75, 0x8b, 0x92,
+	0x75, 0x8d, 0xe6, 0xc2, 0xbb, 0xd2, 0xab, 0xd2, 0x8e, 0x22, 0xc2, 0x3, 0xae, 0x7, 0x1f, 0xee,
+	0xd3, 0x94, 00, 0x40, 0x7, 0x30, 0x3, 0xfd, 0xc2, 0x3, 0x80, 0xf0, 0x22, 0x7b, 0x14, 0xe4,
+	0xfd, 0x7f, 0xe0, 0x12, 0x9, 0x58, 0x7f, 0x1, 0x12, 0x1f, 0xb6, 0x12, 0x9, 0x5f, 0x80, 0xfe,
+	0xc2, 0x6, 0x8f, 0x99, 0x7f, 0x2, 0x12, 0x1f, 0xa1, 0x20, 0x6, 0x5, 0x12, 0x1f, 0xd9, 0x50,
+	0xf8, 0x22, 0x8f, 0x28, 0x8c, 0x29, 0x8d, 0x2a, 0x12, 0x1b, 0xdf, 0xad, 0x2a, 0xac, 0x29, 0xaf,
+	0x28, 0x2, 0x8, 0x5c, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 0x2, 0x80, 0x4, 0xe5, 0x51, 0x54,
+	0xfd, 0xff, 0x12, 0x1d, 0x53, 0x22, 0xef, 0x60, 0x6, 0xe5, 0x51, 0x44, 0x1, 0x80, 0x4, 0xe5,
+	0x51, 0x54, 0xfe, 0xff, 0x12, 0x1d, 0x53, 0x22, 0x7b, 0x35, 0xe4, 0xfd, 0x7f, 0xe0, 0x12, 0x9,
+	0x44, 0xef, 0x54, 0x10, 0xc4, 0x54, 0xf, 0xff, 0x22, 0x5, 0xf, 0xe5, 0xf, 0xc3, 0x94, 0x96,
+	0x40, 0x6, 0xe4, 0xf5, 0xf, 0x12, 0x1f, 0xa8, 0x22, 0x74, 0x80, 0x25, 0x1f, 0xf8, 0xe6, 0xff,
+	0xe5, 0x1f, 0x4, 0x54, 0x1f, 0xf5, 0x1f, 0x22, 0x8e, 0x29, 0x8f, 0x2a, 0xe5, 0x29, 0xff, 0x12,
+	0x1c, 0x15, 0xaf, 0x2a, 0x2, 0x1c, 0x15, 0x5, 0x4d, 0xe5, 0x4d, 0xc3, 0x94, 0xa, 0x40, 0x5,
+	0xe4, 0xf5, 0x4d, 0xd2, 0x9, 0x22, 0x75, 0x3d, 0x12, 0x75, 0x3e, 00, 0x7b, 00, 0x7a, 0x12,
+	0xe4, 0xfd, 0x2, 0x19, 0x65, 0x4c, 0x75, 0x74, 0x6f, 0x6e, 0x20, 0x32, 0x2e, 0x32, 0x39, 0x61,
+	0x5f, 0x61, 0x74, 0x68, 0xe4, 0xff, 0x12, 0x1d, 0xc4, 0x7f, 0x6, 0x12, 0x1a, 0x45, 0x7f, 0x1,
+	0x2, 0x1d, 0xc4, 0xef, 0xc3, 0x94, 0xa, 0xef, 0x50, 0x4, 0x24, 0x30, 0xff, 0x22, 0x24, 0x57,
+	0xff, 0x22, 0xad, 0x7, 0x75, 0x3c, 0x10, 0xe4, 0xf5, 0x3d, 0xfb, 0x7f, 0x20, 0x2, 0x17, 0x88,
+	0x7d, 0x25, 0x12, 0x18, 0xa0, 0x7b, 00, 0x7a, 00, 0x79, 0x25, 0x2, 0x17, 0x54, 0x45, 0x52,
+	0x41, 0x53, 0x45, 00, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 00, 0xef, 0x90, 0x1e, 0xb1,
+	0x93, 0xd3, 0x94, 0x1, 0x50, 0x2, 0x80, 0x1, 0xc3, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0xff,
+	0x6, 00, 00, 00, 00, 00, 0xff, 0x1, 0x7d, 0x1, 0x12, 0x13, 0x29, 0xef, 0x30, 0xe2,
+	0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0xe, 0xe4, 0xfd, 0x7f, 0xa0,
+	0x2, 0x17, 0x88, 0x8f, 0x3c, 0x8d, 0x3d, 0x7b, 0x10, 0xe4, 0xfd, 0x7f, 0x40, 0x2, 0x17, 0x88,
+	0xe5, 0x1e, 0x65, 0x1f, 0x60, 0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0xe5, 0xaa, 0x54, 0x3, 0x60,
+	0x3, 0xd3, 0x80, 0x1, 0xc3, 0x22, 0x7f, 0x3, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x2, 0x18,
+	0x75, 0xa8, 0x1a, 0xe6, 0xb4, 0x20, 0x4, 0x5, 0x1a, 0x80, 0xf6, 0x22, 0x12, 0x1e, 0x9c, 0x50,
+	0x3, 0x7f, 0x1, 0x22, 0x7f, 00, 0x22, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x20, 0x2, 0xfd,
+	0x22, 0xeb, 0x75, 0xf0, 0x20, 0xa4, 0x4d, 0xac, 0xf0, 0xfd, 0x22, 0x7f, 0x30, 0x12, 0x1d, 0xa0,
+	0x7f, 0x78, 0x2, 0x1d, 0xa0, 0x7f, 0xd, 0x12, 0x1d, 0xa0, 0x7f, 0xa, 0x2, 0x1d, 0xa0, 0x75,
+	0xf0, 0xa, 0x84, 0xe5, 0xf0, 0x24, 0x30, 0xff, 0x22, 0x8f, 0x35, 0x12, 0x18, 0x1a, 0xaf, 0x35,
+	0x2, 0xa, 0xe, 0xd3, 0xe5, 0x26, 0x94, 00, 0xe5, 0x25, 0x94, 00, 0x22, 0xef, 0x64, 0x6,
+	0x60, 0x3, 0x12, 0x1c, 0xbf, 0x22, 0x7b, 0x1, 0x7a, 00, 0x7d, 0x1f, 0x2, 0x17, 0xea, 0x7b,
+	0xb5, 0x7a, 0x52, 0x7d, 0x1f, 0x2, 0x17, 0xea, 0x7b, 0x30, 0x7a, 0x2a, 0x7d, 0x1f, 0x2, 0x17,
+	0xea, 0xe4, 0xfb, 0xfa, 0x7d, 0x1f, 0x2, 0x17, 0xea, 0x7d, 0x32, 0x12, 0x18, 0xa0, 0xaf, 0x37,
+	0x22, 0xe5, 0x51, 0x44, 0x4, 0xff, 0x2, 0x1d, 0x53, 0xe5, 0x51, 0x54, 0xfb, 0xff, 0x2, 0x1d,
+	0x53, 0xc2, 0x2, 0x8f, 0xe, 0xd2, 0x2, 0x22, 0x7f, 0x3, 0x7e, 00, 0x2, 0x16, 0x81, 0x7f,
+	0x5, 0x7e, 00, 0x2, 0x16, 0x81, 0x7e, 00, 0x7d, 00, 0x7c, 00, 0x22, 0x7b, 00, 0x7a,
+	00, 0x79, 0x4e, 0x22, 0xef, 0x90, 0x1e, 0xb1, 0x93, 0xff, 0x22, 0xef, 0x90, 0x1e, 0xaa, 0x93,
+	0xff, 0x22, 00, 0x1, 0x2, 0x3, 0x4, 0x6, 0x5, 0xa2, 0x2, 0xb3, 0x22, 0x12, 0x11, 0x49,
+	0x22, 0xd2, 0x7, 0x22, 0x2, 0x1d, 0xa0, 0x2, 0x15, 0x9a, 0x22, 0x22,
+};
diff --git a/board/ar7100/common/generic_i2c.c b/board/ar7100/common/generic_i2c.c
new file mode 100644
index 0000000000..7d59c31370
--- /dev/null
+++ b/board/ar7100/common/generic_i2c.c
@@ -0,0 +1,460 @@
+
+/* generic_i2c.c */
+
+#ifdef __BDI
+#include "bdi.h"
+#define protect()
+#define unprotect()
+#define generic_check_interruption() (1)
+#else
+#ifdef __ECOS
+#include <cyg/hal/ar7100_soc.h>
+#include "ag7100_ecos.h"
+#define printk             DEBUG_PRINTF
+#define udelay             A_UDELAY
+#define protect()
+#define unprotect()
+#define generic_check_interruption() (1)
+#else
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <common.h>
+#include "ar7100_soc.h"
+#define printk printf
+
+#define protect()
+#define unprotect()
+
+#define generic_check_interruption() (1)
+
+#endif
+#endif
+
+#include "generic_i2c.h"
+
+#define GENERIC_I2C_IO_EXP            0x40
+
+#undef USE_TEST_CODE
+
+#ifndef COMPRESSED_UBOOT
+#define USE_TEST_CODE
+#endif
+
+/* ************************************************************** */
+
+static int generic_gpio_errcnt = 0;
+
+static void inline
+generic_gpio_errclr(void)
+{
+  generic_gpio_errcnt = 0;
+}
+
+static void inline
+generic_gpio_check_rc(unsigned int rc)
+{
+  if (rc) generic_gpio_errcnt++;
+}
+
+static int inline
+generic_gpio_errget(void)
+{
+  return generic_gpio_errcnt;
+}
+
+/* ************************************************************** */
+
+#define GENERIC_I2C_SCL  (1<<0)
+#define GENERIC_I2C_SDA  (1<<1)
+#define GENERIC_I2C_PAUSE 2
+
+static void inline
+generic_i2c_chigh_dhigh(void)
+{
+  generic_gpio_check_rc(ar7100_gpio_float_high_test ( GENERIC_I2C_SCL | GENERIC_I2C_SDA ));
+  udelay( GENERIC_I2C_PAUSE);
+}
+
+static void inline
+generic_i2c_chigh_dlow(void)
+{
+  generic_gpio_check_rc(ar7100_gpio_float_high_test ( GENERIC_I2C_SCL ));
+  ar7100_gpio_drive_low( GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_clow_dlow(void)
+{
+  ar7100_gpio_drive_low( GENERIC_I2C_SCL |  GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_clow_dhigh(void)
+{
+  ar7100_gpio_drive_low( GENERIC_I2C_SCL );
+  generic_gpio_check_rc(ar7100_gpio_float_high_test( GENERIC_I2C_SDA ));
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_clow_dfloat(void)
+{
+  ar7100_gpio_drive_low( GENERIC_I2C_SCL );
+  ar7100_reg_rmw_clear(AR7100_GPIO_OE, GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static void inline
+generic_i2c_chigh_dfloat(void)
+{
+  ar7100_gpio_drive_high( GENERIC_I2C_SCL );
+  ar7100_reg_rmw_clear( AR7100_GPIO_OE, GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE );
+}
+
+static int
+generic_i2c_chigh_dread(void)
+{
+  int d;
+
+  ar7100_gpio_float_high_test( GENERIC_I2C_SCL );
+  ar7100_reg_rmw_clear( AR7100_GPIO_OE, GENERIC_I2C_SDA );
+  udelay( GENERIC_I2C_PAUSE/2 );
+
+  d = (ar7100_reg_rd( AR7100_GPIO_IN ) & GENERIC_I2C_SDA) ? 1 : 0;
+  udelay ( GENERIC_I2C_PAUSE/2);
+
+  return d;
+}
+
+static void inline
+generic_i2c_start(void)
+{
+  generic_i2c_chigh_dhigh();
+  generic_i2c_chigh_dlow();
+  generic_i2c_clow_dlow();
+}
+
+static void inline
+generic_i2c_stop(void)
+{
+  generic_i2c_clow_dlow();
+  generic_i2c_chigh_dlow();
+  generic_i2c_chigh_dhigh();
+}
+
+static int
+generic_i2c_raw_write_8(unsigned char v)
+{
+  int ack;
+  int ii=7;
+  do {
+    if ((1<<ii) & v) {
+      generic_i2c_clow_dhigh();
+      generic_i2c_chigh_dhigh();
+    } else {
+      generic_i2c_clow_dlow();
+      generic_i2c_chigh_dlow();
+    }
+  } while (ii--);
+
+  generic_i2c_clow_dfloat();
+  ack=generic_i2c_chigh_dread();
+  generic_i2c_clow_dfloat();
+
+  return ack;
+}
+
+static void
+generic_i2c_raw_read_8(char lastByte, unsigned char *v)
+{
+  int d;
+  int ii=7;
+  int jj=0;
+  do {
+    generic_i2c_clow_dfloat();
+    d=generic_i2c_chigh_dread();
+    if (d) jj |= 1<<ii;
+  } while (ii--);
+
+  if (lastByte) {
+    generic_i2c_clow_dfloat();
+    generic_i2c_chigh_dfloat();
+  } else {
+    generic_i2c_clow_dlow();
+    generic_i2c_chigh_dlow();
+  }
+  *v = jj & 0xff;
+}
+
+static int
+generic_i2c_raw_write_bytes_to_addr(int addr, unsigned char *buffer, int count)
+{
+  volatile int ack;
+  int ii;
+  generic_gpio_errclr();
+  generic_i2c_start();
+  ack = generic_i2c_raw_write_8(addr&0xfe);
+  if (ack)
+    return 1;
+
+  for (ii=0; ii<count; ii++) {
+    ack = generic_i2c_raw_write_8(buffer[ii]);
+  }
+  generic_i2c_stop();
+  return generic_gpio_errget();
+}
+
+static int
+generic_i2c_raw_read_bytes_from_addr(int addr, unsigned char *buffer, int count)
+{
+  int ack;
+  int ii;
+  generic_gpio_errclr();
+  generic_i2c_start();
+  ack = generic_i2c_raw_write_8((addr&0xff)|0x01);
+  for (ii=0; ii<count; ii++) generic_i2c_raw_read_8( ii==(count-1), &buffer[ii]);
+  generic_i2c_stop();
+  return generic_gpio_errget();
+}
+
+#ifdef USE_TEST_CODE
+
+void generic_i2c_test_write_bits(void)
+{
+  printk("Writing bit stream of AA00\n");
+  generic_gpio_errclr();
+  do {
+    generic_i2c_start();
+    generic_i2c_raw_write_8(0xAA);
+    generic_i2c_raw_write_8(0x00);
+    generic_i2c_stop();
+    udelay(1000);
+  } while generic_check_interruption();
+}
+
+void
+generic_i2c_test_addr_strapping(void)
+{
+  int jj;
+
+  int end   = 0x7e;
+  int addr  = 0x20;
+
+  jj=0;
+  printk("Looping through addresses %02x .. %02x\n", addr, end);
+  while (addr<end) {
+    volatile int ack;
+    generic_i2c_start();
+    ack = generic_i2c_raw_write_8(addr&0xfe);
+    generic_i2c_stop();
+    if (0==ack) {
+      jj++;
+      printk(" Found addr:  %02x\n", addr);
+    }
+    addr+=2;
+  };
+
+  if (0==jj)
+    printk(" Failed test, no i2c found\n");
+}
+
+#endif
+
+/* ************************************************************** */
+
+static unsigned short generic_i2c_shadow_of_gpio = 0;
+
+int
+generic_i2c_write_gpio(unsigned short d)
+{
+  int errcnt;
+
+  unsigned char b[2];
+  b[0] = d;
+  b[1] = d>>8;
+
+  protect();
+
+  errcnt = generic_i2c_raw_write_bytes_to_addr(GENERIC_I2C_IO_EXP, b, sizeof(b));
+
+  if (errcnt == 0)
+    generic_i2c_shadow_of_gpio = d;
+  else
+    printk("%s failed: %d %04x\n",  __FUNCTION__, errcnt, d );
+
+  unprotect();
+
+  return errcnt;
+}
+
+int
+generic_i2c_read_gpio(unsigned short *d)
+{
+  int errcnt;
+  unsigned char b[2];
+
+  protect();
+
+  errcnt = generic_i2c_raw_read_bytes_from_addr(GENERIC_I2C_IO_EXP, b, sizeof(b));
+  if (errcnt == 0) {
+    *d = b[1]<<8 | b[0];
+    generic_i2c_shadow_of_gpio = *d;
+  }
+  else
+    printk("%s failed: %d %04x\n",  __FUNCTION__, errcnt, *d );
+
+  unprotect();
+
+  return errcnt;
+}
+
+int
+generic_i2c_init_gpio(void)
+{
+  ar7100_gpio_enable_i2c_on_gpio_0_1();
+  generic_i2c_write_gpio(GENERIC_I2C_INIT_OUT_HIGH);
+  return 0;
+}
+
+#ifdef USE_TEST_CODE
+
+static void
+generic_i2c_val_bit_desc (unsigned int chg, unsigned short val, char *bit_descriptions[])
+{
+  int ii;
+  int jj;
+  char *p2;
+
+  for (ii=0;ii<16; ii++) {
+    jj = 1<<(15-ii);
+    if ( chg & jj ) {
+      p2 = bit_descriptions[ii];
+      if (p2 && p2[0])
+	if (val & jj )
+	  printk(" %s-H\n", p2);
+	else
+	  printk(" %s-L\n", p2);
+    }
+  }
+}
+
+static char *gpio_desc[16] = {
+  "tp28",      /* 15 */
+  "tp27",      /* 14 */
+  "tp26",      /* 13 */
+  "tp25",      /* 12 */
+  "tp24",      /* 11 */
+  "led2",      /* 10 */
+  "led1",      /*  9 */
+  "jump_sw",   /*  8 */
+  "7?",        /*  7 */
+  "sw_reset",  /*  6 */
+  "slic_int1", /*  5 */
+  "slic_int0", /*  4 */
+  "slic_cs1",  /*  3 */
+  "slic_cs0",  /*  2 */
+  "stereo",    /*  1 */
+  "vsc",       /*  0 */
+};
+
+void
+generic_i2c_test_read_write_gpio(void)
+{
+  unsigned short d;
+  unsigned short e;
+  unsigned short f;
+
+  printk("Looping on gpio alternately turning on LED1,TP24 and LED2,TP25 \n");
+  printk("Pressing either push button will generate an output\n");
+
+  generic_i2c_init_gpio();
+  do {
+    d= GENERIC_I2C_JUMP_LED1 | GENERIC_I2C_TP28 | GENERIC_I2C_INIT_INPUT;
+    generic_i2c_write_gpio(d);
+    generic_i2c_read_gpio (&e);
+    f = d^e;
+    if ( f & (GENERIC_I2C_INIT_OUT_HIGH|GENERIC_I2C_INIT_OUT_LOW ))
+      printk("err: wrote: %04x  expected: %04x  dif: %04x \n", d, e, f);
+
+    generic_i2c_val_bit_desc (f, e, gpio_desc);
+    udelay(100000);
+
+    d= GENERIC_I2C_JUMP_LED2 | GENERIC_I2C_TP27;
+    generic_i2c_write_gpio(d);
+    generic_i2c_read_gpio (&e);
+    f = d^e;
+    if (f)
+      printk("err: wrote: %04x  expected: %04x  chg: %04x \n", d, e, f);
+
+    generic_i2c_val_bit_desc (f, e, gpio_desc);
+    udelay(200000);
+
+  } while generic_check_interruption();
+}
+
+void
+generic_i2c_test_toggle(unsigned short t)
+{
+  unsigned short d=0;
+
+  printk("Toggling i2c GPIO pins %08x\n", t);
+  generic_i2c_read_gpio(&d);
+  do {
+    generic_i2c_write_gpio(d | t);
+    udelay(1000);
+    generic_i2c_write_gpio(d & ~t);
+    udelay(1000);
+  } while generic_check_interruption();
+}
+
+#endif
+
+int
+generic_i2c_assert_cs(int cs)
+{
+  unsigned short d = generic_i2c_shadow_of_gpio;
+
+  /* We are active low, so turn on all of the bits */
+  d  |= GENERIC_I2C_VSC73XX_CS|GENERIC_I2C_STEREO_CS|GENERIC_I2C_SLIC_CS0;
+
+  /* Depending on CS, turn a single bit off */
+  switch (cs) {
+  case GENERIC_I2C_VSC73XX_CS:
+  case GENERIC_I2C_STEREO_CS:
+  case GENERIC_I2C_SLIC_CS0:
+    d &= ~cs;
+    return generic_i2c_write_gpio(d);
+
+  default:
+    printk("%s fail: %d\n", __FUNCTION__, cs);
+    return -1;
+  }
+}
+
+void
+generic_i2c_deassert_cs(void) {
+  unsigned short d = generic_i2c_shadow_of_gpio;
+
+  /* We are active low, so turn on all of the bits */
+  d  |= GENERIC_I2C_VSC73XX_CS|GENERIC_I2C_STEREO_CS|GENERIC_I2C_SLIC_CS0;
+  generic_i2c_write_gpio(d);
+}
+
+#ifdef USE_TEST_CODE
+
+void
+generic_i2c_test_cs_toggle(int cs)
+{
+  printk("Looping on CS %d \n", cs);
+
+  do {
+    generic_i2c_assert_cs(cs);
+    generic_i2c_deassert_cs();
+    udelay(1000);
+  } while generic_check_interruption();
+}
+
+#endif
diff --git a/board/ar7100/common/generic_i2c.h b/board/ar7100/common/generic_i2c.h
new file mode 100644
index 0000000000..e0349f01ae
--- /dev/null
+++ b/board/ar7100/common/generic_i2c.h
@@ -0,0 +1,84 @@
+/* generic_i2c.h
+ *
+ * History:
+ * Jan  4, 2007 wclewis initial
+ * Jan 11, 2007 wclewis ready for checkin
+ * Jan 14, 2007 wclewis common version for BDI/ECOS/Linux
+ * May 15, 2007 wclewis changed CS1 to TEST
+ */
+
+#ifndef _GENERIC_I2C_H
+#define _GENERIC_I2C_H
+
+/* OUT, ACTIVE LOW, INITIAL STATE HIGH */
+#define GENERIC_I2C_VSC73XX_CS    (1<<0)
+#define GENERIC_I2C_STEREO_CS     (1<<1)
+#define GENERIC_I2C_SLIC_CS0      (1<<2)
+#define GENERIC_I2C_SLIC_TEST     (1<<3)
+
+#define GENERIC_I2C_INIT_OUT_HIGH (GENERIC_I2C_VSC73XX_CS | GENERIC_I2C_STEREO_CS | GENERIC_I2C_SLIC_CS0 | GENERIC_I2C_TP28)
+
+/* OUT, ACTIVE HIGH, INITIAL STATE LOW */
+#define GENERIC_I2C_JUMP_LED1     (1<<9)
+#define GENERIC_I2C_JUMP_LED2     (1<<10)
+#define GENERIC_I2C_TP25          (1<<12)
+#define GENERIC_I2C_TP26          (1<<13)
+
+#define GENERIC_I2C_INIT_OUT_LOW  (GENERIC_I2C_JUMP_LED1 | GENERIC_I2C_JUMP_LED2 | GENERIC_I2C_SLIC_TEST | GENERIC_I2C_TP25 | GENERIC_I2C_TP26)
+
+/* IN */
+#define GENERIC_I2C_SLIC_INT0     (1<<4)
+#define GENERIC_I2C_SLIC_INT1     (1<<5)
+#define GENERIC_i2C_SW_RESET      (1<<6)
+#define GENERIC_I2C_JUMP_SW       (1<<8)
+#define GENERIC_I2C_TP24          (1<<11)
+#define GENERIC_I2C_TP27          (1<<14)
+#define GENERIC_I2C_TP28          (1<<15)
+
+#define GENERIC_I2C_INIT_INPUT (~(GENERIC_I2C_INIT_OUT_HIGH|GENERIC_I2C_INIT_OUT_LOW))
+
+#define GENERIC_I2C_INPUT_LOW (GENERIC_I2C_SLIC_INT0 | GENERIC_I2C_SLIC_INT1 | GENERIC_i2C_SW_RESET | GENERIC_I2C_JUMP_SW)
+
+int
+generic_i2c_init_gpio(void);
+
+int
+generic_i2c_write_gpio(unsigned short d);
+
+int
+generic_i2c_read_gpio(unsigned short *d);
+
+int
+generic_i2c_assert_cs(int cs);
+
+void
+generic_i2c_deassert_cs(void);
+
+#ifdef USE_TEST_CODE
+
+void
+generic_i2c_test_scl(void);
+
+void
+generic_i2c_test_sda(void);
+
+void
+generic_i2c_test_write_bits(void);
+
+void
+generic_i2c_test_toggle(unsigned short t);
+
+void
+generic_i2c_test_addr_strapping(void);
+
+void
+generic_i2c_check_input(void);
+
+void
+generic_i2c_test_read_write_gpio(void);
+
+void
+generic_i2c_test_vs7385_toggle(void);
+
+#endif
+#endif
diff --git a/board/ar7100/common/generic_spi.c b/board/ar7100/common/generic_spi.c
new file mode 100644
index 0000000000..8ff8b4664a
--- /dev/null
+++ b/board/ar7100/common/generic_spi.c
@@ -0,0 +1,355 @@
+
+
+/* generic_spi.c */
+
+#ifdef __BDI
+#include "bdi.h"
+
+#define protect()
+#define unprotect()
+
+#else
+#ifdef __ECOS
+#include <cyg/hal/ar7100_soc.h>
+#include "ag7100_ecos.h"
+#define printk          DEBUG_PRINTF
+
+#define protect()
+#define unprotect()
+
+#else
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <common.h>
+#include "ar7100_soc.h"
+#define printk printf
+
+void ar7100_flash_spi_down(void);
+void ar7100_flash_spi_up(void);
+
+#define protect()
+#define unprotect()
+
+#endif
+#endif
+
+#include "generic_spi.h"
+//#include "generic_i2c.h"
+
+/* ************************************************************** */
+#ifdef CONFIG_AR9100
+
+extern int ap83_board_version;
+
+#define AR9100_SPI_GPIO_OE       0x18040000 /* GPIO Output Enable */
+#define AR9100_SPI_GPIO_OUT      0x18040008 /* GPIO Output Value Register */
+#define AR9100_SPI_GPIO_FUNC     0x18040028
+#define AR9100_SPI_CLK_HIGH      (1<<23)
+#define AR9100_SPI_CLK_LOW       ~(1<<23)
+#define AR9100_SPI_DO_HI         (1<<0)
+#define AR9100_SPI_CS_DISABLE_0  (1<<12)
+#define AR9100_SPI_CS_DISABLE_1  (1<<13)
+#define AR9100_SPI_CLK
+#define AR9100_SPI_GPIO_IN       0x18040004
+
+#else
+
+#define GENERIC_SPI_FS           0x1f000000 /* Function select */
+#define GENERIC_SPI_CLOCK        0x1f000004 /* Alias-disable + clock */
+
+#define GENERIC_SPI_WRITE        0x1f000008 /* SPI_IO_CTRL
+					    * spi_do    = 1<<0  (reflects pin)
+					    * spi_clk   = 1<<8  (reflects pin)
+					    * cs0/gpio  = 1<<16 (active low)
+					    * cs1/gpio  = 1<<17 (active low)
+					    * cs2gpio   = 1<<18 (active low)
+					    */
+
+#define GENERIC_SPI_RD_SHIFT_REG 0x1f00000c /* spi_di is clocked into register pos 0 every clock */
+
+#define GENERIC_SPI_CS_DISABLE_0 (1<<16)
+#define GENERIC_SPI_CS_DISABLE_1 (1<<17)
+#define GENERIC_SPI_CS_DISABLE_2 (1<<18)
+
+#define GENERIC_SPI_CS_DIS       (GENERIC_SPI_CS_DISABLE_0|GENERIC_SPI_CS_DISABLE_1|GENERIC_SPI_CS_DISABLE_2)
+
+#define GENERIC_SPI_D0_HIGH      (1<<0)
+#define GENERIC_SPI_CLK_HIGH     (1<<8)
+#endif
+#ifdef CONFIG_AR9100
+int
+generic_spi_access_enable(int cs)
+{
+  u32 val;
+
+  protect();
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE)|0x02);
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,val);
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OUT) & ~(0x0A));
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT,val);
+
+  return 0;
+}
+int
+generic_spi_access_done(void)
+{
+  u32 val;
+
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE)|0x02);
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,val);
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OUT)|0x02);
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT,val);
+
+  unprotect();
+
+  return 0;
+}
+int
+generic_spi_init(int cs)
+{
+        return 0;
+}
+/* Data needs to be stable on rising edge of clock */
+
+#define IN_DATA_GPIO		3
+#define OUT_DATA_GPIO		16
+#define CLK_GPIO		17
+
+void
+generic_spi_raw_output_u8_050(unsigned char val)
+{
+	int i, rd_val, wr_val;
+
+	for (i = 7; i >= 0; i--) {
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+
+		rd_val &= ~(1 << CLK_GPIO); /* lower clock */
+
+		wr_val = (((val >> i) & 1) << OUT_DATA_GPIO);
+		wr_val |= (rd_val & ~(1 << OUT_DATA_GPIO));
+
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, wr_val);
+
+		wr_val |= (1 << CLK_GPIO); /* high clock */
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, wr_val);
+	}
+}
+unsigned int
+generic_spi_raw_input_u32_050(void)
+{
+	int i, rd_val;
+	unsigned int ret_val = 0;
+
+	/* Configure GPIO as input for data */
+	rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) & ~(1 << IN_DATA_GPIO));
+	ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+
+	/* Configure GPIO as output for clock */
+	rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) | (1 << CLK_GPIO));
+	ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+
+	for (i = 31; i >= 0; i--) {
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+		rd_val &= ~(1 << CLK_GPIO); /* lower clock */
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, rd_val);
+
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+		rd_val |= (1 << CLK_GPIO); /* high clock */
+		ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, rd_val);
+
+		rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_IN);
+
+		ret_val |= ((rd_val & (1 << IN_DATA_GPIO)) >> IN_DATA_GPIO) << i;
+	}
+
+	rd_val = ar7100_reg_rd(AR9100_SPI_GPIO_OUT);
+	rd_val &= ~(1 << CLK_GPIO); /* lower clock */
+	ar7100_reg_wr_nf(AR9100_SPI_GPIO_OUT, rd_val);
+
+	return ret_val;
+}
+
+void
+gpio_clk_setup(void)
+{
+        unsigned rd_val;
+
+        rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) | (1 << OUT_DATA_GPIO));
+        ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+
+        /* Configure GPIO as output for clock */
+        rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) | (1 << CLK_GPIO));
+        ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE, rd_val);
+}
+
+void
+generic_spi_raw_output_u8_040(unsigned char val)
+{
+  int ii,rd_val, wr_val;
+
+  /* Only change GPIO 0, 1 or 2 in mask */
+  unsigned int cs0to2mask = (0xbf000000);
+
+  rd_val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) & ~(0x08));
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,rd_val);
+
+  /* Shift out SPI values keeping GPIO bits the same */
+  for (ii = 7; ii>=0 ; ii--) {
+    u32  jj = (val >> ii) & 1;
+    /* First assert data, make sure clock is low */
+
+    if(jj)
+    wr_val = (cs0to2mask | (1 << 22));
+    else
+    wr_val = cs0to2mask;
+    /* Falling edge of the spi clk*/
+    rd_val=ar7100_reg_rd(wr_val);
+    /* Leave data there, rising edge of clock causes data to be output */
+    rd_val=ar7100_reg_rd((wr_val | AR9100_SPI_CLK_HIGH));
+  }
+}
+unsigned int
+generic_spi_raw_input_u32_040(void)
+{
+  int ii;
+  u32 val;
+  u32 rd_val = 0x0;
+  unsigned int cs0to2mask = 0xbf000000;
+
+  val = (ar7100_reg_rd(AR9100_SPI_GPIO_OE) & ~(0x08));
+  ar7100_reg_wr_nf(AR9100_SPI_GPIO_OE,val);
+  val=ar7100_reg_rd(cs0to2mask);
+
+  /* Only change GPIO 0, 1 or 2 in mask */
+  /* For each rising edge the data in is sampled and clocked into serial shift register */
+  for (ii = 31; ii>=0 ; ii--) {
+
+    val=ar7100_reg_rd((cs0to2mask | AR9100_SPI_CLK_HIGH));
+    val = ar7100_reg_rd(AR9100_SPI_GPIO_IN);
+    rd_val = rd_val | (((val >> 3) & 0x1)<< ii);
+    val=ar7100_reg_rd(cs0to2mask);
+  }
+
+    val=ar7100_reg_rd(cs0to2mask);
+
+  /* Shift register contains value read */
+  return rd_val;
+}
+
+void
+generic_spi_raw_output_u8(unsigned char val)
+{
+	if (ap83_board_version >= 50) {
+		generic_spi_raw_output_u8_050(val);
+	} else {
+		generic_spi_raw_output_u8_040(val);
+	}
+}
+
+unsigned int
+generic_spi_raw_input_u32(void)
+{
+	if (ap83_board_version >= 50) {
+		return generic_spi_raw_input_u32_050();
+	} else {
+		return generic_spi_raw_input_u32_040();
+	}
+}
+
+#else
+int
+generic_spi_access_enable(int cs)
+{
+
+  protect();
+
+  ar7100_reg_wr(GENERIC_SPI_CLOCK, 0x43);
+
+  /* Enable access to SPI bits through memory
+   * mapped registers.
+   */
+  ar7100_reg_wr_nf(GENERIC_SPI_FS, 1);
+  ar7100_reg_wr_nf(GENERIC_SPI_WRITE, GENERIC_SPI_CS_DIS);
+
+  {
+    unsigned int cs0to2mask;
+    cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & GENERIC_SPI_CS_DIS;
+    ar7100_reg_wr  (GENERIC_SPI_WRITE, cs0to2mask | GENERIC_SPI_CLK_HIGH );
+  }
+
+  generic_i2c_assert_cs(cs);
+
+  return 0;
+}
+
+int
+generic_spi_access_done(void)
+{
+  generic_i2c_deassert_cs();
+  ar7100_reg_wr_nf(GENERIC_SPI_FS, 0);
+
+  unprotect();
+
+  return 0;
+}
+
+int
+generic_spi_init(int cs)
+{
+  /* For now just initialize the i2c, this will be different for bdi/ecos/linux */
+
+  return generic_i2c_init_gpio();
+}
+
+/* Data needs to be stable on rising edge of clock */
+
+void
+generic_spi_raw_output_u8(unsigned char val)
+{
+  int ii;
+
+  unsigned int cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & ~(GENERIC_SPI_D0_HIGH|GENERIC_SPI_CLK_HIGH);
+
+  /* Shift out SPI values keeping GPIO bits the same */
+  for (ii = 7; ii>=0 ; ii--) {
+    unsigned char  jj = (val >> ii) & 1;
+
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | jj );
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | jj | GENERIC_SPI_CLK_HIGH );
+  }
+}
+
+unsigned int
+generic_spi_raw_input_u32(void)
+{
+  int ii;
+
+  unsigned int cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & ~(GENERIC_SPI_D0_HIGH|GENERIC_SPI_CLK_HIGH);
+
+  /* For each rising edge the data in is sampled and clocked into serial shift register */
+  for (ii = 31; ii>=0 ; ii--) {
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask                            );
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | GENERIC_SPI_CLK_HIGH     );
+  }
+
+  /* Shift register contains value read */
+  return ar7100_reg_rd(GENERIC_SPI_RD_SHIFT_REG);
+}
+
+unsigned int
+generic_spi_raw_input_u8(void)
+{
+  int ii;
+
+  unsigned int cs0to2mask = ar7100_reg_rd(GENERIC_SPI_WRITE) & ~(GENERIC_SPI_D0_HIGH|GENERIC_SPI_CLK_HIGH);
+
+  /* For each rising edge the data in is sampled and clocked into serial shift register */
+  for (ii = 7; ii>=0 ; ii--) {
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask                            );
+    ar7100_reg_wr(GENERIC_SPI_WRITE, cs0to2mask | GENERIC_SPI_CLK_HIGH     );
+  }
+
+  /* Shift register contains value read */
+  return ar7100_reg_rd(GENERIC_SPI_RD_SHIFT_REG);
+}
+#endif
diff --git a/board/ar7100/common/generic_spi.h b/board/ar7100/common/generic_spi.h
new file mode 100644
index 0000000000..69e268b865
--- /dev/null
+++ b/board/ar7100/common/generic_spi.h
@@ -0,0 +1,48 @@
+/*****************************************************************************/
+/*! file generic_spi.h
+** /brief Generic SPI interface support
+**
+** This interface file contains the definitions for the SPI interface functions.
+** It requires the i2c support.
+**
+**  Copyright (c) 2007-2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+
+
+/* generic_spi.h */
+
+#ifndef _GENERIC_SPI_H
+#define _GENERIC_SPI_H
+
+#ifndef CEXTERN
+#define  CEXTERN static inline
+#endif
+
+#include "generic_i2c.h"
+
+#define GENERIC_SPI_VSC73XX_CS    GENERIC_I2C_VSC73XX_CS
+#define GENERIC_SPI_STEREO_CS     GENERIC_I2C_STEREO_CS
+#define GENERIC_SPI_SLIC_CS0      GENERIC_I2C_SLIC_CS0
+#define GENERIC_SPI_SLIC_CS1      GENERIC_I2C_SLIC_CS1
+
+int
+generic_spi_init(int cs);
+
+int
+generic_spi_access_enable(int cs);
+
+int
+generic_spi_access_done(void);
+
+void
+generic_spi_raw_output_u8(unsigned char val);
+
+unsigned int
+generic_spi_raw_input_u32(void);
+
+unsigned int
+generic_spi_raw_input_u8(void);
+
+#endif
diff --git a/board/ar7100/common/ipPhy.c b/board/ar7100/common/ipPhy.c
new file mode 100644
index 0000000000..a64d365f28
--- /dev/null
+++ b/board/ar7100/common/ipPhy.c
@@ -0,0 +1,843 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the ICPLUS ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "ipPhy.h"
+
+#define mdelay(_x)  udelay((_x) * 1000)
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#ifdef DEBUG
+#define DRV_DEBUG 1
+#endif
+#define DRV_DEBUG 1
+
+#if DRV_DEBUG
+#define DRV_DEBUG_PHYERROR  0x00000001
+#define DRV_DEBUG_PHYCHANGE 0x00000002
+#define DRV_DEBUG_PHYSETUP  0x00000004
+
+int ipPhyDebug = DRV_DEBUG_PHYERROR;
+
+#define DRV_LOG(FLG, X0, X1, X2, X3, X4, X5, X6)    \
+{                                                   \
+    if (ipPhyDebug & (FLG)) {                       \
+        logMsg(X0, X1, X2, X3, X4, X5, X6);         \
+    }                                               \
+}
+
+#define DRV_MSG(x,a,b,c,d,e,f)                      \
+    logMsg(x,a,b,c,d,e,f)
+
+#define DRV_PRINT(FLG, X)                           \
+{                                                   \
+    if (ipPhyDebug & (FLG)) {                       \
+        printf X;                                   \
+    }                                               \
+}
+
+#else /* !DRV_DEBUG */
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+#endif
+
+#define IP_LAN_PORT_VLAN          1
+#define IP_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_DEFAULT 0
+
+#define BOOL    uint32_t
+#define TRUE    1
+#define FALSE   0
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} ipPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+ipPhyInfo_t ipPhyInfo[] = {
+    /*
+     * On AP30/AR5312, all PHYs are associated with MAC0.
+     * AP30/AR5312's MAC1 isn't used for anything.
+     * CONFIG_VENETDEV==1 (router) configuration:
+     *    Ports 0,1,2, and 3 are "LAN ports"
+     *    Port 4 is a WAN port
+     *    Port 5 connects to MAC0 in the AR5312
+     * CONFIG_VENETDEV==0 (bridge) configuration:
+     *    Ports 0,1,2,3,4 are "LAN ports"
+     *    Port 5 connects to the MAC0 in the AR5312
+     */
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY0_ADDR,
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY1_ADDR,
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY2_ADDR,
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY3_ADDR,
+     IP_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_DEFAULT,
+     0,
+     IP_PHY4_ADDR,
+     IP_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_DEFAULT,
+     0,
+     0x00,
+     IP_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+#define IP_GLOBALREGBASE    0
+
+#define IP_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define IP_ID_MIN 0
+#define IP_ID_MAX (IP_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define IP_IS_ENET_PORT(phyUnit) (ipPhyInfo[phyUnit].isEnetPort)
+#define IP_IS_PHY_ALIVE(phyUnit) (ipPhyInfo[phyUnit].isPhyAlive)
+#define IP_ETHUNIT(phyUnit) (ipPhyInfo[phyUnit].ethUnit)
+#define IP_PHYBASE(phyUnit) (ipPhyInfo[phyUnit].phyBase)
+#define IP_PHYADDR(phyUnit) (ipPhyInfo[phyUnit].phyAddr)
+#define IP_VLAN_TABLE_SETTING(phyUnit) (ipPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define IP_IS_ETHUNIT(phyUnit, ethUnit) \
+            (IP_IS_ENET_PORT(phyUnit) &&        \
+            IP_ETHUNIT(phyUnit) == (ethUnit))
+
+/* Forward references */
+BOOL       ip_phyIsLinkAlive(int phyUnit);
+static void ip_VLANInit(int ethUnit);
+static void ip_verifyReady(int ethUnit);
+#ifdef DEBUG
+void       ip_phyShow(int phyUnit);
+void       ip_phySet(int phyUnit, uint32_t regnum, uint32_t value);
+void       ip_globalSet(uint32_t phyAddr, uint32_t regnum, uint32_t value);
+#endif
+
+uint16_t
+phyRegRead(uint32_t phybase, uint16_t phyaddr, uint16_t reg)
+{
+    uint16_t val;
+
+    phy_reg_read(phybase, phyaddr, reg, &val);
+    return val;
+}
+
+void
+phyRegWrite(uint32_t phybase, uint16_t phyaddr, uint16_t reg, uint32_t val)
+{
+    phy_reg_write(phybase, phyaddr, reg, val);
+}
+
+
+/******************************************************************************
+*
+* ip_phyIsLinkAlive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+ip_phyIsLinkAlive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = IP_PHYBASE(phyUnit);
+    phyAddr = IP_PHYADDR(phyUnit);
+
+    phyHwStatus = phyRegRead(phyBase, phyAddr, IP_PHY_STATUS);
+
+    if (phyHwStatus & IP_STATUS_LINK_PASS) {
+        return TRUE;
+    } else {
+        return FALSE;
+    }
+}
+
+/******************************************************************************
+*
+* ip_VLANInit - initialize "port-based VLANs" for the specified enet unit.
+*/
+static void
+ip_VLANInit(int ethUnit)
+{
+    int     phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyReg;
+
+    phyBase = IP_GLOBALREGBASE;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (IP_ETHUNIT(phyUnit) != ethUnit) {
+            continue;
+        }
+        phyRegWrite(phyBase, IP_GLOBAL_PHY29_ADDR,
+                    IP_GLOBAL_PHY29_24_REG + ((phyUnit == 5) ? (phyUnit + 1) : phyUnit),
+                                    IP_VLAN_TABLE_SETTING(phyUnit));
+
+        /* Send all packets to all ports */
+        phyReg = phyRegRead(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_1_REG);
+        phyReg = phyReg | ((1 << phyUnit) << IP_VLAN1_OUTPUT_PORT_MASK_S);
+        phyRegWrite(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_1_REG, phyReg);
+    }
+    phyReg = phyRegRead(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_9_REG);
+    phyReg = phyReg | TAG_VLAN_ENABLE;
+    phyReg = phyReg & ~VID_INDX_SEL_M;
+    phyRegWrite(phyBase, IP_GLOBAL_PHY30_ADDR, IP_GLOBAL_PHY30_9_REG, phyReg);
+
+}
+
+
+static void
+ip_verifyReady(int ethUnit)
+{
+    int     phyUnit;
+    uint32_t  phyBase = 0;
+    uint32_t  phyAddr;
+    uint16_t  phyID1;
+    uint16_t  phyID2;
+
+    /*
+     * The first read to the Phy port registers always fails and
+     * returns 0.   So get things started with a bogus read.
+     */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        phyID1 = phyRegRead(phyBase, phyAddr, IP_PHY_ID1); /* returns 0 */
+        break;
+    }
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        /*******************/
+        /* Verify phy port */
+        /*******************/
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        phyID1 = phyRegRead(phyBase, phyAddr, IP_PHY_ID1);
+        if (phyID1 != IP_PHY_ID1_EXPECTATION) {
+            DRV_PRINT(DRV_DEBUG_PHYERROR,
+                      ("Invalid PHY ID1 for enet%d port%d.  Expected 0x%04x, read 0x%04x\n",
+                       ethUnit,
+                       phyUnit,
+                       IP_PHY_ID1_EXPECTATION,
+                       phyID1));
+            return;
+        }
+
+        phyID2 = phyRegRead(phyBase, phyAddr, IP_PHY_ID2);
+        if ((phyID2 & IP_OUI_LSB_MASK) != IP_OUI_LSB_EXPECTATION) {
+            DRV_PRINT(DRV_DEBUG_PHYERROR,
+                      ("Invalid PHY ID2 for enet%d port %d.  Expected 0x%04x, read 0x%04x\n",
+                       ethUnit,
+                       phyUnit,
+                       IP_OUI_LSB_EXPECTATION,
+                       phyID2));
+            return;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                  ("Found PHY enet%d port%d: model 0x%x revision 0x%x\n",
+                   ethUnit,
+                   phyUnit,
+                   (phyID2 & IP_MODEL_NUM_MASK) >> IP_MODEL_NUM_SHIFT,
+                   (phyID2 & IP_REV_NUM_MASK) >> IP_REV_NUM_SHIFT));
+
+    }
+}
+
+
+/******************************************************************************
+*
+* ip_phySetup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+ip_phySetup(int ethUnit)
+{
+    int     phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int     liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL    foundPhy = FALSE;
+    uint32_t  phyAddr;
+
+    /* Reset PHYs*/
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        phyRegWrite(phyBase, phyAddr, IP_PHY_CONTROL,
+                    IP_CTRL_SOFTWARE_RESET);
+    }
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    mdelay(300);
+    /* Verify that the switch is what we think it is, and that it's ready */
+    ip_verifyReady(ethUnit);
+
+    /* See if there's any configuration data for this enet */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (IP_ETHUNIT(phyUnit) != ethUnit) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        foundPhy = TRUE;
+        break;
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+#ifdef COBRA_TODO
+    /* Initialize global switch settings */
+
+    /* Initialize the aging time */
+
+    /* Set the learning properties */
+#endif
+
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        phyRegWrite(phyBase, phyAddr, IP_AUTONEG_ADVERT,
+                                        IP_ADVERTISE_ALL);
+        phyRegWrite(phyBase, phyAddr, IP_PHY_CONTROL,
+                    IP_CTRL_AUTONEGOTIATION_ENABLE | IP_CTRL_START_AUTONEGOTIATION);
+    }
+
+    /*
+     * Wait up to .75 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=5;
+    for (phyUnit=0; (phyUnit < IP_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        for (;;) {
+            phyBase = IP_PHYBASE(phyUnit);
+            phyAddr = IP_PHYADDR(phyUnit);
+
+            phyHwStatus = phyRegRead(phyBase, phyAddr, IP_PHY_STATUS);
+
+            if (IP_AUTONEG_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            mdelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (ip_phyIsLinkAlive(phyUnit)) {
+            liveLinks++;
+            IP_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            IP_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Status=%4.4x\n",
+            ethUnit,
+            phyRegRead(IP_PHYBASE(phyUnit),
+                       IP_PHYADDR(phyUnit),
+                       IP_PHY_STATUS)));
+    }
+
+    ip_VLANInit(ethUnit);
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* ip_phyIsDuplexFull - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1  --> FULL
+*    0 --> HALF
+*/
+int
+ip_phyIsFullDuplex(int ethUnit)
+{
+    int     phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (ip_phyIsLinkAlive(phyUnit)) {
+
+            phyBase = IP_PHYBASE(phyUnit);
+            phyAddr = IP_PHYADDR(phyUnit);
+
+            phyHwStatus = phyRegRead(phyBase, phyAddr, IP_LINK_PARTNER_ABILITY);
+            printf("ipPhy.c: phyHwStatus 0x%x\n",phyHwStatus);
+            if ((phyHwStatus & IP_LINK_100BASETX_FULL_DUPLEX) ||
+                (phyHwStatus & IP_LINK_10BASETX_FULL_DUPLEX)) {
+                return TRUE;
+            }
+        }
+        return -1;
+    }
+
+    return FALSE;
+
+}
+
+
+/******************************************************************************
+*
+* ip_phyIsSpeed100 - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*    TRUE --> 100Mbit
+*    FALSE --> 10Mbit
+*/
+
+BOOL
+ip_phySpeed(int ethUnit)
+{
+    int     phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (ip_phyIsLinkAlive(phyUnit)) {
+
+            phyBase = IP_PHYBASE(phyUnit);
+            phyAddr = IP_PHYADDR(phyUnit);
+
+            phyHwStatus = phyRegRead(phyBase, phyAddr, IP_LINK_PARTNER_ABILITY);
+
+            if (phyHwStatus & IP_LINK_100BASETX) {
+                return _100BASET;
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* ip_phyCheckStatusChange -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+void
+ip_phyIsUp(int ethUnit)
+{
+
+    int           phyUnit;
+    uint16_t        phyHwStatus;
+    ipPhyInfo_t   *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t        phyBase;
+    uint32_t        phyAddr;
+
+    for (phyUnit=0; phyUnit < IP_PHY_MAX; phyUnit++) {
+        if (!IP_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = IP_PHYBASE(phyUnit);
+        phyAddr = IP_PHYADDR(phyUnit);
+
+        lastStatus = &ipPhyInfo[phyUnit];
+        phyHwStatus = phyRegRead(phyBase, phyAddr, IP_PHY_STATUS);
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            /* See if we've lost link */
+            if (phyHwStatus & IP_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+#ifdef COBRA_TODO
+                mv_flushATUDB(phyUnit);
+#endif
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for AutoNegotiation complete */
+            if (IP_AUTONEG_DONE(phyHwStatus)) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if 0
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+#ifdef DEBUG
+
+/* Define the registers of interest for a phyShow command */
+typedef struct ipRegisterTableEntry_s {
+    uint32_t regNum;
+    char  *regIdString;
+} ipRegisterTableEntry_t;
+
+ipRegisterTableEntry_t ipPhyRegisterTable[] = {
+    {IP_PHY_CONTROL,                 "PHY Control                     "},
+    {IP_PHY_STATUS,                  "PHY Status                      "},
+    {IP_PHY_ID1,                     "PHY Identifier 1                "},
+    {IP_PHY_ID2,                     "PHY Identifier 2                "},
+    {IP_AUTONEG_ADVERT,              "Auto-Negotiation Advertisement  "},
+    {IP_LINK_PARTNER_ABILITY,        "Link Partner Ability            "},
+    {IP_AUTONEG_EXPANSION,           "Auto-Negotiation Expansion      "},
+};
+int ipPhyNumRegs = sizeof(ipPhyRegisterTable) / sizeof(ipPhyRegisterTable[0]);
+
+
+ipRegisterTableEntry_t ipPhy29GlobalRegisterTable[] = {
+    {IP_GLOBAL_PHY29_18_REG,        "29_18_REG   "},
+    {IP_GLOBAL_PHY29_19_REG,        "29_19_REG   "},
+    {IP_GLOBAL_PHY29_20_REG,        "29_20_REG   "},
+    {IP_GLOBAL_PHY29_21_REG,        "29_21_REG   "},
+    {IP_GLOBAL_PHY29_22_REG,        "29_22_REG   "},
+    {IP_GLOBAL_PHY29_23_REG,        "29_23_REG   "},
+    {IP_GLOBAL_PHY29_24_REG,        "29_24_REG   "},
+    {IP_GLOBAL_PHY29_25_REG,        "29_25_REG   "},
+    {IP_GLOBAL_PHY29_26_REG,        "29_26_REG   "},
+    {IP_GLOBAL_PHY29_27_REG,        "29_27_REG   "},
+    {IP_GLOBAL_PHY29_28_REG,        "29_28_REG   "},
+    {IP_GLOBAL_PHY29_29_REG,        "29_29_REG   "},
+    {IP_GLOBAL_PHY29_30_REG,        "29_30_REG   "},
+    {IP_GLOBAL_PHY29_31_REG,        "29_31_REG   "},
+};
+int ipPhy29GlobalNumRegs =
+    sizeof(ipPhy29GlobalRegisterTable) / sizeof(ipPhy29GlobalRegisterTable[0]);
+
+
+ipRegisterTableEntry_t ipPhy30GlobalRegisterTable[] = {
+    {IP_GLOBAL_PHY30_0_REG,   "30_0_REG    "},
+    {IP_GLOBAL_PHY30_1_REG,   "30_1_REG    "},
+    {IP_GLOBAL_PHY30_2_REG,   "30_2_REG    "},
+    {IP_GLOBAL_PHY30_3_REG,   "30_3_REG    "},
+    {IP_GLOBAL_PHY30_4_REG,   "30_4_REG    "},
+    {IP_GLOBAL_PHY30_5_REG,   "30_5_REG    "},
+    {IP_GLOBAL_PHY30_6_REG,   "30_6_REG    "},
+    {IP_GLOBAL_PHY30_7_REG,   "30_7_REG    "},
+    {IP_GLOBAL_PHY30_8_REG,   "30_8_REG    "},
+    {IP_GLOBAL_PHY30_9_REG,   "30_9_REG    "},
+    {IP_GLOBAL_PHY30_10_REG,  "30_10_REG   "},
+    {IP_GLOBAL_PHY30_11_REG,  "30_11_REG   "},
+    {IP_GLOBAL_PHY30_12_REG,  "30_12_REG   "},
+    {IP_GLOBAL_PHY30_13_REG,  "30_13_REG   "},
+    {IP_GLOBAL_PHY30_16_REG,  "30_16_REG   "},
+    {IP_GLOBAL_PHY30_17_REG,  "30_17_REG   "},
+    {IP_GLOBAL_PHY30_18_REG,  "30_18_REG   "},
+    {IP_GLOBAL_PHY30_20_REG,  "30_20_REG   "},
+    {IP_GLOBAL_PHY30_21_REG,  "30_21_REG   "},
+    {IP_GLOBAL_PHY30_22_REG,  "30_22_REG   "},
+    {IP_GLOBAL_PHY30_23_REG,  "30_23_REG   "},
+    {IP_GLOBAL_PHY30_24_REG,  "30_24_REG   "},
+    {IP_GLOBAL_PHY30_25_REG,  "30_25_REG   "},
+    {IP_GLOBAL_PHY30_26_REG,  "30_26_REG   "},
+    {IP_GLOBAL_PHY30_27_REG,  "30_27_REG   "},
+    {IP_GLOBAL_PHY30_28_REG,  "30_28_REG   "},
+    {IP_GLOBAL_PHY30_29_REG,  "30_29_REG   "},
+    {IP_GLOBAL_PHY30_30_REG,  "30_30_REG   "},
+    {IP_GLOBAL_PHY30_31_REG,  "30_31_REG   "},
+};
+int ipPhy30GlobalNumRegs =
+    sizeof(ipPhy30GlobalRegisterTable) / sizeof(ipPhy30GlobalRegisterTable[0]);
+
+ipRegisterTableEntry_t ipPhy31GlobalRegisterTable[] = {
+    {IP_GLOBAL_PHY31_0_REG,   "31_0_REG    "},
+    {IP_GLOBAL_PHY31_1_REG,   "31_1_REG    "},
+    {IP_GLOBAL_PHY31_2_REG,   "31_2_REG    "},
+    {IP_GLOBAL_PHY31_3_REG,   "31_3_REG    "},
+    {IP_GLOBAL_PHY31_4_REG,   "31_4_REG    "},
+    {IP_GLOBAL_PHY31_5_REG,   "31_5_REG    "},
+    {IP_GLOBAL_PHY31_6_REG,   "31_6_REG    "},
+};
+
+int ipPhy31GlobalNumRegs =
+    sizeof(ipPhy31GlobalRegisterTable) / sizeof(ipPhy31GlobalRegisterTable[0]);
+
+
+/*****************************************************************************
+*
+* ip_phyShow - Dump the state of a PHY.
+* There are two sets of registers for each phy port:
+*  "phy registers" and
+*  "switch port registers"
+* We dump 'em all, plus the switch global registers.
+*/
+void
+ip_phyShow(int phyUnit)
+{
+    int     i;
+    uint16_t  value;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+
+    phyBase        = IP_PHYBASE(phyUnit);
+    phyAddr        = IP_PHYADDR(phyUnit);
+
+    printf("PHY state for PHY%d (enet%d, phyBase 0x%8x, phyAddr 0x%x)\n",
+           phyUnit,
+           IP_ETHUNIT(phyUnit),
+           IP_PHYBASE(phyUnit),
+           IP_PHYADDR(phyUnit));
+
+    printf("PHY Registers:\n");
+    for (i=0; i < ipPhyNumRegs; i++) {
+
+        value = phyRegRead(phyBase, phyAddr, ipPhyRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhyRegisterTable[i].regNum,
+               ipPhyRegisterTable[i].regNum,
+               ipPhyRegisterTable[i].regIdString,
+               value);
+    }
+
+    phyBase = IP_GLOBALREGBASE;
+
+    printf("Switch Global Registers:\n");
+    printf("Phy29 Registers:\n");
+    for (i=0; i < ipPhy29GlobalNumRegs; i++) {
+
+        value = phyRegRead(phyBase, IP_GLOBAL_PHY29_ADDR,
+                           ipPhy29GlobalRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhy29GlobalRegisterTable[i].regNum,
+               ipPhy29GlobalRegisterTable[i].regNum,
+               ipPhy29GlobalRegisterTable[i].regIdString,
+               value);
+    }
+
+    printf("Phy30 Registers:\n");
+    for (i=0; i < ipPhy30GlobalNumRegs; i++) {
+
+        value = phyRegRead(phyBase, IP_GLOBAL_PHY30_ADDR,
+                           ipPhy30GlobalRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhy30GlobalRegisterTable[i].regNum,
+               ipPhy30GlobalRegisterTable[i].regNum,
+               ipPhy30GlobalRegisterTable[i].regIdString,
+               value);
+    }
+    printf("Phy31 Registers:\n");
+    for (i=0; i < ipPhy31GlobalNumRegs; i++) {
+
+        value = phyRegRead(phyBase, IP_GLOBAL_PHY31_ADDR,
+                           ipPhy31GlobalRegisterTable[i].regNum);
+
+        printf("Reg %02d (0x%02x) %s = 0x%08x\n",
+               ipPhy31GlobalRegisterTable[i].regNum,
+               ipPhy31GlobalRegisterTable[i].regNum,
+               ipPhy31GlobalRegisterTable[i].regIdString,
+               value);
+    }
+}
+
+/*****************************************************************************
+*
+* ip_phySet - Modify the value of a PHY register (debug only).
+*/
+void
+ip_phySet(int phyUnit, uint32_t regnum, uint32_t value)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+
+
+    phyBase = IP_PHYBASE(phyUnit);
+    phyAddr = IP_PHYADDR(phyUnit);
+
+    phyRegWrite(phyBase, phyAddr, regnum, value);
+}
+
+/*****************************************************************************
+*
+* ip_globalSet - Modify the value of a global register
+* (debug only).
+*/
+void
+ip_globalSet(uint32_t phyAddr, uint32_t regnum, uint32_t value)
+{
+    uint32_t  phyBase;
+
+    phyBase = IP_GLOBALREGBASE;
+
+    phyRegWrite(phyBase, phyAddr, regnum, value);
+}
+
+
+#endif
diff --git a/board/ar7100/common/ipPhy.h b/board/ar7100/common/ipPhy.h
new file mode 100644
index 0000000000..1b5f16dbf7
--- /dev/null
+++ b/board/ar7100/common/ipPhy.h
@@ -0,0 +1,172 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2003 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * icPhy.h - definitions for the ethernet PHY.
+ * This code supports a simple 1-port ethernet phy, ICPLUS,
+ * All definitions in this file are operating system independent!
+ */
+
+#ifndef IPPHY_H
+#define IPPHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define IP_PHY_CONTROL                 0
+#define IP_PHY_STATUS                  1
+#define IP_PHY_ID1                     2
+#define IP_PHY_ID2                     3
+#define IP_AUTONEG_ADVERT              4
+#define IP_LINK_PARTNER_ABILITY        5
+#define IP_AUTONEG_EXPANSION           6
+
+
+/* IP_PHY_CONTROL fields */
+#define IP_CTRL_SOFTWARE_RESET                    0x8000
+#define IP_CTRL_SPEED_100                         0x2000
+#define IP_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define IP_CTRL_START_AUTONEGOTIATION             0x0200
+#define IP_CTRL_SPEED_FULL_DUPLEX                 0x0100
+
+/* Phy status fields */
+#define IP_STATUS_AUTO_NEG_DONE                   0x0020
+#define IP_STATUS_LINK_PASS                       0x0004
+
+#define IP_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (IP_STATUS_AUTO_NEG_DONE)) ==                    \
+        (IP_STATUS_AUTO_NEG_DONE))
+
+/* ICPLUS_PHY_ID1 fields */
+#define IP_PHY_ID1_EXPECTATION                    0x0243 /* OUI >> 6 */
+
+/* ICPLUS_PHY_ID2 fields */
+#define IP_OUI_LSB_MASK                           0xfc00
+#define IP_OUI_LSB_EXPECTATION                    0x0c00
+#define IP_OUI_LSB_SHIFT                              10
+#define IP_MODEL_NUM_MASK                         0x03f0
+#define IP_MODEL_NUM_SHIFT                             4
+#define IP_REV_NUM_MASK                           0x000f
+#define IP_REV_NUM_SHIFT                               0
+
+/* Link Partner ability */
+#define IP_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define IP_LINK_100BASETX                   0x0080
+#define IP_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define IP_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define IP_ADVERTISE_100FULL                0x0100
+#define IP_ADVERTISE_100HALF                0x0080
+#define IP_ADVERTISE_10FULL                 0x0040
+#define IP_ADVERTISE_10HALF                 0x0020
+
+#define IP_ADVERTISE_ALL (IP_ADVERTISE_10HALF | IP_ADVERTISE_10FULL | \
+                       IP_ADVERTISE_100HALF | IP_ADVERTISE_100FULL)
+
+
+#define IP_VLAN_TAG_VALID                   0x81
+#define IP_VLAN_TAG_SIZE                    4
+#define IP_VLAN_TAG_OFFSET                  12   /* After DA & SA */
+#define IP_SPECIAL_TAG_VALID                0x81
+
+/****************************/
+/* Global Control Registers */
+/****************************/
+/* IP Global register doesn't have names based on functionality
+ * hence has to live with this names  for now */
+#define IP_GLOBAL_PHY29_18_REG  18
+#define IP_GLOBAL_PHY29_19_REG  19
+#define IP_GLOBAL_PHY29_20_REG  20
+#define IP_GLOBAL_PHY29_21_REG  21
+#define IP_GLOBAL_PHY29_22_REG  22
+#define IP_GLOBAL_PHY29_23_REG  23
+#define IP_GLOBAL_PHY29_24_REG  24
+#define IP_GLOBAL_PHY29_25_REG  25
+#define IP_GLOBAL_PHY29_26_REG  26
+#define IP_GLOBAL_PHY29_27_REG  27
+#define IP_GLOBAL_PHY29_28_REG  28
+#define IP_GLOBAL_PHY29_29_REG  29
+#define IP_GLOBAL_PHY29_30_REG  30
+#define IP_GLOBAL_PHY29_31_REG  31
+
+
+#define IP_GLOBAL_PHY30_0_REG   0
+#define IP_GLOBAL_PHY30_1_REG   1
+#define IP_GLOBAL_PHY30_2_REG   2
+#define IP_GLOBAL_PHY30_3_REG   3
+#define IP_GLOBAL_PHY30_4_REG   4
+#define IP_GLOBAL_PHY30_5_REG   5
+#define IP_GLOBAL_PHY30_6_REG   6
+#define IP_GLOBAL_PHY30_7_REG   7
+#define IP_GLOBAL_PHY30_8_REG   8
+#define IP_GLOBAL_PHY30_9_REG   9
+#define IP_GLOBAL_PHY30_10_REG  10
+#define IP_GLOBAL_PHY30_11_REG  11
+#define IP_GLOBAL_PHY30_12_REG  12
+#define IP_GLOBAL_PHY30_13_REG  13
+#define IP_GLOBAL_PHY30_16_REG  16
+#define IP_GLOBAL_PHY30_17_REG  17
+#define IP_GLOBAL_PHY30_18_REG  18
+#define IP_GLOBAL_PHY30_20_REG  20
+#define IP_GLOBAL_PHY30_21_REG  21
+#define IP_GLOBAL_PHY30_22_REG  22
+#define IP_GLOBAL_PHY30_23_REG  23
+#define IP_GLOBAL_PHY30_24_REG  24
+#define IP_GLOBAL_PHY30_25_REG  25
+#define IP_GLOBAL_PHY30_26_REG  26
+#define IP_GLOBAL_PHY30_27_REG  27
+#define IP_GLOBAL_PHY30_28_REG  28
+#define IP_GLOBAL_PHY30_29_REG  29
+#define IP_GLOBAL_PHY30_30_REG  30
+#define IP_GLOBAL_PHY30_31_REG  31
+
+#define IP_GLOBAL_PHY31_0_REG   0
+#define IP_GLOBAL_PHY31_1_REG   1
+#define IP_GLOBAL_PHY31_2_REG   2
+#define IP_GLOBAL_PHY31_3_REG   3
+#define IP_GLOBAL_PHY31_4_REG   4
+#define IP_GLOBAL_PHY31_5_REG   5
+#define IP_GLOBAL_PHY31_6_REG   6
+
+#define IP_GLOBAL_PHY29_31_REG  31
+
+
+#define IP_VLAN0_OUTPUT_PORT_MASK_S     0
+#define IP_VLAN1_OUTPUT_PORT_MASK_S     8
+#define IP_VLAN2_OUTPUT_PORT_MASK_S     0
+#define IP_VLAN3_OUTPUT_PORT_MASK_S     8
+
+/* Masks and shifts for 29.23 register */
+#define IP_PORTX_ADD_TAG_S               11
+#define IP_PORTX_REMOVE_TAG_S            6
+#define IP_PORT5_ADD_TAG_S               1
+#define IP_PORT5_REMOVE_TAG_S            0
+
+/*
+ * 30.9   Definitions
+ */
+#define TAG_VLAN_ENABLE         0x0080
+#define VID_INDX_SEL_M          0x0070
+#define VID_INDX_SEL_S          4
+
+
+/* PHY Addresses */
+#define IP_PHY0_ADDR    0
+#define IP_PHY1_ADDR    1
+#define IP_PHY2_ADDR    2
+#define IP_PHY3_ADDR    3
+#define IP_PHY4_ADDR    4
+
+#define IP_GLOBAL_PHY29_ADDR    29
+#define IP_GLOBAL_PHY30_ADDR    30
+#define IP_GLOBAL_PHY31_ADDR    31
+
+
+#endif
diff --git a/board/ar7100/common/lowlevel_init.S b/board/ar7100/common/lowlevel_init.S
new file mode 100644
index 0000000000..c7fdeec9dd
--- /dev/null
+++ b/board/ar7100/common/lowlevel_init.S
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2009, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    /*
+     * WAR for the bug#55574: Set the CKE (bit 7 in DDR_CONFIG2 register)
+     * to low initially
+     */
+
+    li  a1, KSEG1ADDR(AR7100_DDR_CONFIG2);
+    lw  t8, 0(a1);
+    li  t0, 0xffffff7f;
+    and t8, t8, t0;
+    sw  t8, 0(a1);
+
+    /* End of WAR for 55574 */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+	pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+
+    MEMDELAY(900, t2)
+
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting the mode register
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
+ /* end of file */
diff --git a/board/ar7100/common/lowlevel_init_ar9100.S b/board/ar7100/common/lowlevel_init_ar9100.S
new file mode 100644
index 0000000000..eaff1f9a8d
--- /dev/null
+++ b/board/ar7100/common/lowlevel_init_ar9100.S
@@ -0,0 +1,150 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+
+/*
+#define PLL_CONFIG_CPU_DIV_VAL  (0x3 << 16)
+#define PLL_CONFIG_AHB_DIV_VAL  (0x0 << 20)
+#define PLL_CONFIG_DDR_DIV_VAL  (0x3 << 18)
+#define PLL_CONFIG_PLL_FB_VAL   (0x1d << 3)
+#define PLL_CONFIG_PLL_LOOP_BW_VAL  (0x0 << 12)
+*/
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+#if 0
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+    pll_set(PLL_CONFIG_PLL_RESET_MASK, (1 << PLL_CONFIG_PLL_RESET_SHIFT))
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+#if 0
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK, PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK, PLL_CONFIG_DDR_DIV_VAL)
+#else
+    pll_set(PLL_CONFIG_PLL_FB_MASK|PLL_CONFIG_AHB_DIV_MASK|PLL_CONFIG_DDR_DIV_MASK, PLL_CONFIG_PLL_FB_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL)
+#endif
+
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop
+
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+initialize_pll:
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+/* Should we do this before doing clock control reset above? */
+wait_for_pll_update2:
+    pll_get(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update2
+    nop
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+#else
+    pll_set(PLL_CONFIG_PLL_RESET_MASK, (1 << PLL_CONFIG_PLL_RESET_SHIFT))
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_clr(PLL_CONFIG_AHB_DIV_MASK)
+    pll_clr(PLL_CONFIG_DDR_DIV_MASK)
+    pll_clr(PLL_CONFIG_PLL_FB_MASK)
+    pll_set(PLL_CONFIG_PLL_FB_MASK|PLL_CONFIG_AHB_DIV_MASK|PLL_CONFIG_DDR_DIV_MASK, PLL_CONFIG_PLL_FB_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL)
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop
+
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+    li t9, 0xffff;
+wait_loop2:
+    addi t9, -1;
+    bgtz t9, wait_loop2;
+    nop
+
+    set_val(AR7100_DDR_RD_DATA_THIS_CYCLE, 0xffffffff, CFG_DDR_RD_DATA_THIS_CYCLE_VAL);
+#endif
+
+    jr ra
+    nop
+
+ /* end of file */
diff --git a/board/ar7100/common/phy.h b/board/ar7100/common/phy.h
new file mode 100644
index 0000000000..e885f4ef1c
--- /dev/null
+++ b/board/ar7100/common/phy.h
@@ -0,0 +1,28 @@
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+/*
+ * This file defines the interface between MAC and various phy switches.
+ */
+#define ag7100_unit2name(_unit) _unit ?  "eth1" : "eth0"
+extern int  ag7100_miiphy_read(char *devname, unsigned char phaddr,
+		unsigned char reg, unsigned short *data);
+extern int  ag7100_miiphy_write(char *devname, unsigned char phaddr,
+		unsigned char reg, unsigned short data);
+
+#ifdef CFG_ATHRS16_PHY
+inline unsigned short s16_phy_reg_read(unsigned int base, unsigned char addr, unsigned char reg)
+{   unsigned short data;
+    ag7100_miiphy_read(ag7100_unit2name(base), addr, reg, &data);
+    return data;
+}
+#define phy_reg_read(base, addr, reg) s16_phy_reg_read(base, addr, reg)
+#else
+#define phy_reg_read(base, addr, reg, datap)                    \
+    ag7100_miiphy_read(ag7100_unit2name(base), addr, reg, datap);
+#endif
+#define phy_reg_write(base, addr, reg, data)                   \
+        ag7100_miiphy_write(ag7100_unit2name(base), addr, reg, data);
+
+#endif
diff --git a/board/ar7100/common/vsc73xx.c b/board/ar7100/common/vsc73xx.c
new file mode 100644
index 0000000000..720f29bfdc
--- /dev/null
+++ b/board/ar7100/common/vsc73xx.c
@@ -0,0 +1,1208 @@
+/* vsc73xx.c
+ * May 24, 2007 Tag before BSP resturcture
+ */
+
+#ifdef __BDI
+#include "bdi.h"
+#else
+#ifdef __ECOS
+#if defined(CYGNUM_USE_ENET_VERBOSE)
+#   undef  VERBOSE
+#   define VERBOSE CYGNUM_USE_ENET_VERBOSE
+#else
+#   define VERBOSE 0
+#endif
+#define printk             DEBUG_PRINTF
+#define udelay             A_UDELAY
+#else
+//#include <linux/kernel.h>
+//#include <asm/delay.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <common.h>
+#include "ar7100_soc.h"
+#define printk printf
+#endif
+#endif
+
+#ifndef VERBOSE
+#define  VERBOSE           0
+#endif
+
+#include "generic_spi.h"
+#include "vsc73xx.h"
+
+#define MODULE_NAME "VSC73XX"
+#ifdef CONFIG_AR9100
+extern int ap83_board_version;
+#endif
+
+/* ************************************************************** */
+
+#define VSC73XX_SYSTEM            0x7
+#define VSC73XX_ICPU_CTRL         0x10
+#define VSC73XX_ICPU_ADDR         0x11
+#define VSC73XX_ICPU_SRAM         0x12
+#define VSC73XX_ICPU_MAILBOX_VAL  0x15
+#define VSC73XX_ICPU_MAILBOX_SET  0x16
+#define VSC73XX_ICPU_MAILBOX_CLR  0x17
+#define VSC73XX_ICPU_CHIPID       0x18
+#define VSC73XX_ICPU_SIPAD        0x01
+#define VSC73XX_ICPU_GPIO         0x34
+
+#define VSC73XX_ICPU_CLOCK_DELAY  0x05
+
+#define VSC73XX_MAC               0x1
+#define VSC73XX_MAC_CFG           0x0
+#define VSC73XX_ADVPORTM          0x19
+#define VSC73XX_RXOCT             0x50
+#define VSC73XX_TXOCT             0x51
+#define VSC73XX_C_RX0             0x52
+#define VSC73XX_C_RX1             0x53
+#define VSC73XX_C_RX2             0x54
+#define VSC73XX_C_TX0             0x55
+#define VSC73XX_C_TX1             0x56
+#define VSC73XX_C_TX2             0x57
+#define VSC73XX_C_CFG             0x58
+
+#define VSC73XX_MII               0x3
+#define VSC73XX_MII_STAT          0x0
+#define VSC73XX_MII_CMD           0x1
+#define VSC73XX_MII_DATA          0x2
+
+static void inline
+vsc73xx_force_reset(void)
+{
+  ar7100_reg_rmw_set(AR7100_RESET, AR7100_RESET_GE1_PHY);
+  udelay(10);
+  ar7100_reg_rmw_clear(AR7100_RESET, AR7100_RESET_GE1_PHY);
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_reset_line(void)
+{
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping 10 uSec nRESET, 100Usec RESET\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  do {
+    vsc73xx_force_reset();
+    udelay(100);
+  } while (1);
+}
+
+#endif
+
+static int
+vsc73xx_check_block_sublock_ok(int block, int sublock)
+{
+  switch (block) {
+  case 1:
+    switch (sublock) {
+    case 0: case 1: case 2: case 3: case 4: case 6:
+      return (0==0);
+    }
+    break;
+  case 2: case 7:
+    switch (sublock) {
+    case 0:
+      return (0==0);
+    }
+    break;
+  case 3: case 4: case 5:
+    switch (sublock) {
+    case 0: case 1:
+      return (0==0);
+    }
+    break;
+  }
+  return 0;
+}
+
+int
+vsc73xx_rd(int block, int subblock, int reg, unsigned int  *value)
+{
+  int rc;
+
+  rc=vsc73xx_check_block_sublock_ok(block, subblock);
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": non-supported block/subblock %d %d\n", block, subblock);
+#endif
+    return -1;
+  }
+
+  rc=generic_spi_access_enable(GENERIC_SPI_VSC73XX_CS);
+#ifdef CONFIG_AR9100
+  if (ap83_board_version >= 50) {
+    gpio_clk_setup();
+  }
+#endif
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to CS %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }
+
+  /* Send address */
+  generic_spi_raw_output_u8((block<<5) | (0/*READ*/<<4) | (subblock<<0));
+  generic_spi_raw_output_u8(reg);
+
+  /* Pad based on SiPAD register ( default 2) */
+  generic_spi_raw_output_u8(0);
+  generic_spi_raw_output_u8(0);
+
+  /* Clock 32b data into serial shift register */
+  *value = generic_spi_raw_input_u32();
+
+  rc=generic_spi_access_done();
+
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to deassert CS %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }
+
+  return 0;
+}
+
+int
+vsc73xx_wr(int block, int subblock, int reg, unsigned int  value)
+{
+  int rc;
+
+  rc=vsc73xx_check_block_sublock_ok(block, subblock);
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": non-supported block/subblock %d %d\n", block, subblock);
+#endif
+    return -1;
+  }
+
+  rc=generic_spi_access_enable(GENERIC_SPI_VSC73XX_CS);
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to CS %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }
+
+  /* Address */
+  generic_spi_raw_output_u8((block<<5) | (1/*WRITE*/<<4) | (subblock<<0) );
+  generic_spi_raw_output_u8(reg);
+
+  /* Data */
+  generic_spi_raw_output_u8((value>>24) & 0xff);
+  generic_spi_raw_output_u8((value>>16) & 0xff);
+  generic_spi_raw_output_u8((value>>8 ) & 0xff);
+  generic_spi_raw_output_u8((value>>0 ) & 0xff);
+
+  rc=generic_spi_access_done();
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unable to deassert CS  %08x \n", GENERIC_SPI_VSC73XX_CS);
+#endif
+    return -1;
+  }
+
+  return 0;
+}
+
+static int
+vsc73xx_get_and_verify_chipid(void)
+{
+  int curVal;
+  int chip;
+  int ii=256;
+
+  do {
+    vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CHIPID, &curVal);
+    chip = (curVal >> 12)  & 0x0ffff;
+  } while ((chip != 0x7385) && (chip != 0x7395) && (chip != 0x7396) && --ii);
+
+#ifdef VSC73XX_DEBUG
+  printk(MODULE_NAME": curval = 0x%08x\n", curVal);
+#endif
+
+  if (0==ii) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": unknown chip: %08x\n", chip);
+#endif
+    return -1;
+  }
+
+#ifdef CONFIG_AR9100
+
+  /*
+   * Per Martin Olsen [martino@vitesse.com],
+   * VSC7385YV chips with 0x0 in bits 31:28 of "Block 7 Subblock 0
+   * Address 0x18" is the first revision and that have a problem
+   * with the reset. This can be the reason why this doesn't work.
+   */
+  if (!((curVal >> 28) & 0xf)) {
+#ifndef COMPRESSED_UBOOT
+    printk("\n==================================================\n"
+           "WARNING:\n"
+           "Using revision 0 of chip 0x%x. It might not work!\n"
+           "==================================================\n", chip);
+#endif
+  }
+#endif
+
+  return chip;
+}
+
+static int
+vsc73xx_reset_and_verify_chipid(void)
+{
+#ifdef CONFIG_AR9100
+  if (ap83_board_version < 50) {
+    vsc73xx_force_reset();
+  }
+#else
+  vsc73xx_force_reset();
+#endif
+  return vsc73xx_get_and_verify_chipid();
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_reset_and_verify_chipid(void)
+{
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on reset & verify chipid\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  do {
+    vsc73xx_reset_and_verify_chipid();
+  } while (1);
+}
+
+#endif
+
+static inline int
+vsc73xx_mailbox_get(unsigned int *d)
+{
+  return vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_MAILBOX_VAL, d);
+}
+
+static inline int
+vsc73xx_mailbox_clr(unsigned int value)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_MAILBOX_CLR, value);
+}
+
+static inline int
+vsc73xx_mailbox_set(unsigned int value)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_MAILBOX_SET, value);
+}
+
+static inline int
+vsc73xx_gpio_config_output(int value)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, ( value & VSC73XX_GPIO_MASK ) << 4);
+}
+
+static inline int
+vsc73xx_gpio_output(int value)
+{
+  unsigned int d;
+  int rc;
+
+  value &=VSC73XX_GPIO_MASK;
+
+  /* 1 = high 0=low  */
+  rc=vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, &d);
+  if (rc<0)
+    return rc;
+
+  d &=VSC73XX_GPIO_MASK;
+  d |=value;
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, d);
+}
+
+static inline int
+vsc73xx_gpio_input(unsigned int *d)
+{
+  int rc;
+  unsigned int e;
+  rc=vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_GPIO, &e);
+  if (rc<0)
+    return rc;
+
+  *d = e & VSC73XX_GPIO_MASK;
+  return rc;
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_gpio(void)
+{
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on / off vsc73xx GPIO\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  vsc73xx_gpio_config_output(VSC73XX_GPIO_2);
+  do {
+    vsc73xx_gpio_output(VSC73XX_GPIO_2);
+    udelay(50);
+    vsc73xx_gpio_output(0);
+    udelay(50);
+  } while (1);
+}
+
+#endif
+
+static int
+vsc73xx_get_sVersion_resetNeeded(int *sVersion, int *resetNeeded)
+{
+  unsigned int d;
+  int rc;
+
+  rc=vsc73xx_mailbox_get(&d);
+  if (rc<0)
+    return rc;
+  *sVersion    = d & 0xffff;
+  *resetNeeded = (d & 0xffff0000) == 0xffff0000;
+  return 0;
+}
+
+static inline int
+vsc73xx_restart_firmware(void)
+{
+  int rc;
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<7) |          /* SOFT_RST_HOLD = 1 */
+		  (1<<3) |          /* BOOT_EN       = 1 */
+		  (1<<2) |          /* EXT_ACC_EN    = 1 */
+		  (0<<0)            /* SOFT_RST      = 0 */
+		  );
+  if (rc<0)
+    return rc;
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0,VSC73XX_ICPU_ADDR,
+		  0x0000
+		  );
+  if (rc<0)
+    return rc;
+
+  udelay(100);
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<8) |          /* CLK_DIV  = 1 */
+		  (1<<3) |          /* BOOT_EN  = 1 */
+		  (1<<1) |          /* CLK_EN   = 1 */
+		  (1<<0)            /* SOFT_RST = 1 */
+		  );
+  return rc;
+}
+
+static int
+vsc73xx_load_firmware_raw(unsigned char *lutonuAddr, int lutonuSize)
+{
+  int            ii;
+  unsigned char  *dp;
+  unsigned int   curVal;
+  int            diffs;
+  int            rc;
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<7) |          /* SOFT_RST_HOLD = 1 */
+		  (1<<3) |          /* BOOT_EN       = 1 */
+		  (1<<2) |          /* EXT_ACC_EN    = 1 */
+		  (0<<0)            /* SOFT_RST      = 0 */
+		  );
+  if (rc<0)
+    return rc;
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0,VSC73XX_ICPU_ADDR,
+		  0x0000
+		  );
+  if (rc<0)
+    return rc;
+
+  dp = lutonuAddr;
+  for (ii=0; ii<lutonuSize; ii++) {
+    rc = vsc73xx_wr(
+		    VSC73XX_SYSTEM, 0, VSC73XX_ICPU_SRAM,
+		    *dp++
+		    );
+    if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": could not load microcode %d\n",rc);
+#endif
+      return rc;
+    }
+  }
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_ADDR,
+		  0x0000
+		  );
+  if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": could not reset microcode %d\n",rc);
+#endif
+    return rc;
+  }
+
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": microcode Loaded, verifying...\n");
+#endif
+
+  dp = lutonuAddr;
+  diffs=0;
+  for (ii=0; ii<lutonuSize; ii++) {
+    rc = vsc73xx_rd(
+		    VSC73XX_SYSTEM, 0,VSC73XX_ICPU_SRAM,
+		    &curVal
+		    );
+    if (rc<0) {
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": could not read microcode %d\n",rc);
+#endif
+      return rc;
+    }
+
+    if (curVal > 0xff) {
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": bad val read: %04x : %02x  %02x  \n", ii, *dp, curVal);
+#endif
+      return -1;
+    }
+
+    if ((curVal & 0xff) != *dp) {
+      diffs++;
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": verify error: %04x : %02x  %02x  \n", ii, *dp, curVal);
+#endif
+
+      if (diffs > 4)
+	break;
+    }
+    dp++;
+  }
+
+  if (diffs) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": failed to verify\n");
+#endif
+    return -1;
+  }
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": verify OK\n");
+#endif
+
+  rc = vsc73xx_wr(
+		  VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CTRL,
+		  (1<<8) |          /* CLK_DIV  = 1 */
+		  (1<<3) |          /* BOOT_EN  = 1 */
+		  (1<<1) |          /* CLK_EN   = 1 */
+		  (1<<0)            /* SOFT_RST = 1 */
+		  );
+  return rc;
+}
+
+#define VSC73XX_SFTW_VERSION            0x229
+#ifdef CONFIG_AR9100
+#	include "g5_Plus1_2_31_unmanaged_Atheros_v3.c"
+#	include "g5_Plus1_2_31_unmanaged_Atheros_v4.c"
+#else
+#	include "g5_Plus1_2_29b_unmanaged_Atheros_v5.c"
+#	include "g5e_Plus1_2_29a_unmanaged_Atheros_v3.c"
+#	include "g5_Plus1_2_29a_unmanaged_Atheros_v5.c"
+#endif
+static int
+vsc73xx_load_firmware(void)
+{
+  int sVersion;
+  int resetNeeded;
+  int rc;
+
+#ifdef CONFIG_AR9100
+ ar7100_reg_rmw_set(AR9100_FLASH_CONFIG,0x3fffff);
+#endif
+  rc = vsc73xx_reset_and_verify_chipid();
+  if (rc < 0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": could not identify chip, err %d\n", rc);
+#endif
+    return rc;
+  }
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": found chip id: %04x\n", rc);
+#endif
+
+#if defined(__BDI) && defined(VSC73XX_LOAD_FROM_RAM)
+  rc = vsc73xx_load_firmware_raw(get_scratch_uncached(8192), 8192);
+#else
+  switch (rc) {
+  case 0x00007385:
+#ifdef CONFIG_AR9100
+    rc = vsc73xx_load_firmware_raw(g5_Plus1_2_31_unmanaged_Atheros_v3,
+				   sizeof(g5_Plus1_2_31_unmanaged_Atheros_v3));
+#else
+    rc = vsc73xx_load_firmware_raw(g5_Plus1_2_29b_unmanaged_Atheros_v5,
+                                   sizeof(g5_Plus1_2_29b_unmanaged_Atheros_v5));
+#endif
+    break;
+
+  case 0x00007395:
+    /* source from vitesse uses symbol lutonu, later versions use the name of the file.  */
+#ifdef CONFIG_AR9100
+    rc = vsc73xx_load_firmware_raw(g5_Plus1_2_31_unmanaged_Atheros_v4,
+				   sizeof(g5_Plus1_2_31_unmanaged_Atheros_v4));
+#else
+    rc = vsc73xx_load_firmware_raw(lutonu,       /* g5e_Plus1_2_29a_unmanaged_Atheros_v3 */
+				   sizeof(lutonu /* g5e_Plus1_2_29a_unmanaged_Atheros_v3 */));
+#endif
+    break;
+
+  default:
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": microcode not availale for chip id: %08x\n", rc);
+#endif
+    rc = -1;
+  }
+#endif
+
+  if (rc<0)
+    return rc;
+
+  vsc73xx_get_sVersion_resetNeeded(&sVersion, &resetNeeded);
+  if (resetNeeded) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": failed to start\n");
+#endif
+    return -1;
+  }
+  if (sVersion < VSC73XX_SFTW_VERSION) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": incorrect software version %04x\n", sVersion);
+#endif
+#ifdef CONFIG_AR9100
+    if (ap83_board_version < 50) {
+      return -1;
+    }
+#else
+    return -1;
+#endif
+  }
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": software version %08x started OK\n",sVersion);
+#endif
+
+#ifdef CONFIG_AR9100
+ ar7100_reg_rmw_set(AR9100_FLASH_CONFIG,0xf2288);
+#endif
+
+  return 0;
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_load_and_reset_firmware(void)
+{
+  int rc;
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on load firmware / reset firmware\n");
+#endif
+  generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  do {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": return from load firmware: %d\n", vsc73xx_load_firmware());
+#endif
+    udelay(10000);
+  } while (1);
+}
+
+#endif
+
+#ifndef COMPRESSED_UBOOT
+static void
+vsc73xx_print_val_bit_desc (unsigned int val, char *fieldName, char *bit_descriptions[])
+{
+  int ii;
+  char *p2;
+
+  printk(MODULE_NAME":   %s=%04x\n", fieldName, val);
+  for (ii=0;ii<32; ii++) {
+    p2 = val & 1<<(31-ii) ? bit_descriptions[ii*2] : bit_descriptions[ii*2+1];
+    if (p2 && p2[0]) {
+      printk(MODULE_NAME":     %s\n", p2);
+    }
+  }
+}
+#endif
+
+/* Port 0..4, 6 */
+static inline int
+vsc73xx_get_mac_cfg(int port, unsigned int *d)
+{
+  return vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_MAC_CFG, d);
+}
+
+#ifndef COMPRESSED_UBOOT
+static char *mac_cfg_desc[32*2] = {
+  "wexc_dis","", /* 31 */
+  "","", /* 30 */
+  "port_rst","", /* 29 */
+  "tx_en","", /* 28 */
+  "seed_load","", /* 27 */
+  "","", /* 26 */
+  "","", /* 25 */
+  "","", /* 24 */
+  "","", /* 23 */
+  "","", /* 22 */
+  "","", /* 21 */
+  "","", /* 20 */
+  "","", /* 19 */
+  "en-fdx","", /* 18 */
+  "gige","", /* 17 */
+  "rx_en","", /* 16 */
+  "vlan_dblawr","", /* 15 */
+  "vlan_awr","", /* 14 */
+  "100-base-T","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "mac_rx_rst","", /*  5 */
+  "mac_tx_rst","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+static inline void
+vsc73xx_print_mac_cfg_val(unsigned int val)
+{
+  vsc73xx_print_val_bit_desc (val, "mac_cfg        (01P00)", mac_cfg_desc);
+  printk(MODULE_NAME":   clk_sel: %02x\n", (val>>0)&0x3);
+  printk(MODULE_NAME":   tx_ipg:  %02x\n", (val>>6)&0x1f);
+}
+#endif
+
+static inline int
+vsc73xx_set_mac_cfg(int port, unsigned int value)
+{
+  return vsc73xx_wr(VSC73XX_MAC, port, VSC73XX_MAC_CFG, value);
+}
+
+static inline int
+vsc73xx_get_clock_delay_reg(unsigned int *val)
+{
+  return vsc73xx_rd(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+static inline int
+vsc73xx_set_clock_delay_reg(unsigned int val)
+{
+  return vsc73xx_wr(VSC73XX_SYSTEM, 0, VSC73XX_ICPU_CLOCK_DELAY, val);
+}
+
+#ifndef COMPRESSED_UBOOT
+static inline int
+vsc73xx_get_advportm(int port, unsigned int *val)
+{
+  return vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_ADVPORTM, val);
+}
+
+static char *advportm_desc[32*2] = {
+  "","", /* 31 */
+  "","", /* 30 */
+  "","", /* 29 */
+  "","", /* 28 */
+  "","", /* 27 */
+  "","", /* 26 */
+  "","", /* 25 */
+  "","", /* 24 */
+  "","", /* 23 */
+  "","", /* 22 */
+  "","", /* 21 */
+  "","", /* 20 */
+  "","", /* 19 */
+  "","", /* 18 */
+  "","", /* 17 */
+  "","", /* 16 */
+  "","", /* 15 */
+  "","", /* 14 */
+  "","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "ifg_ppm","",       /*  7 */
+  "exc_col","",       /*  6 */
+  "ext_port","",      /*  5 */
+  "inv_gtx","",       /*  4 */
+  "ena_gtx","",       /*  3 */
+  "ddr_mode","",      /*  2 */
+  "io_loopback","",   /*  1 */
+  "host_loopback","", /*  0 */
+};
+
+static inline void
+vsc73xx_print_advportm_val(unsigned int val)
+{
+  vsc73xx_print_val_bit_desc (val, "advportm      (01P19)", advportm_desc);
+}
+#endif
+
+static inline int
+vsc73xx_set_advportm(int port, unsigned int val)
+{
+  return vsc73xx_wr(VSC73XX_MAC, port, VSC73XX_ADVPORTM, val);
+}
+
+/* HERE */
+
+static inline unsigned int
+vsc73xx_get_c_rx0(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_RX0, &d);
+  return d;
+}
+
+static inline unsigned int
+vsc73xx_get_c_rx1(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_RX1, &d);
+  return d;
+}
+
+static inline unsigned int
+vsc73xx_get_c_rx2(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_RX2, &d);
+  return d;
+}
+
+static inline unsigned int
+vsc73xx_get_c_tx0(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_TX0, &d);
+  return d;
+}
+
+static inline unsigned int
+vsc73xx_get_c_tx1(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_TX1, &d);
+  return d;
+}
+
+static inline unsigned int
+vsc73xx_get_c_tx2(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_TX2, &d);
+  return d;
+}
+
+static inline unsigned int
+vsc73xx_get_c_cfg(int port)
+{
+  unsigned int d;
+  vsc73xx_rd(VSC73XX_MAC, port, VSC73XX_C_CFG, &d);
+  return d;
+}
+
+static inline void
+vsc73xx_set_c_cfg(int port, unsigned int value)
+{
+  vsc73xx_wr(VSC73XX_MAC, port, VSC73XX_C_CFG, value);
+}
+
+#ifndef COMPRESSED_UBOOT
+void
+vsc73xx_print_counts(int port)
+{
+  printk(MODULE_NAME":counters port %d\n", port);
+  printk(MODULE_NAME":   cfg: %8x\n", vsc73xx_get_c_cfg(port));
+  printk(MODULE_NAME":   rx0: %9d\n", vsc73xx_get_c_rx0(port));
+  printk(MODULE_NAME":   rx0: %9d\n", vsc73xx_get_c_rx1(port));
+  printk(MODULE_NAME":   rx0: %9d\n", vsc73xx_get_c_tx2(port));
+  printk(MODULE_NAME":   tx0: %9d\n", vsc73xx_get_c_tx0(port));
+  printk(MODULE_NAME":   tx0: %9d\n", vsc73xx_get_c_tx1(port));
+  printk(MODULE_NAME":   tx0: %9d\n", vsc73xx_get_c_tx2(port));
+}
+
+static inline void
+vsc73xx_print_link_status_from_value(int port, int up, int fdx, int speed, unsigned int cfg)
+{
+  printk(MODULE_NAME": STATUS Port: %d  up: %d  fdx: %d  speed: %d  mac cfg: %08x\n", port, up, fdx, speed, cfg);
+  vsc73xx_print_mac_cfg_val(cfg);
+}
+#endif
+
+#if 0
+
+/* WARNING: Do not use this if the switch application is running on the 8051. This
+ *          function may be used if the switch application is on the host and the
+ *          8051 is in reset.
+ */
+unsigned short
+vsc73xx_rw_phy(int writeFlg, int unit, int phy_addr, int reg, uint16_t value)
+{
+  /* unit 0   = mac0 and should not happen here
+   * unit 1   = mac1, PHY we connect to using MAC 1
+   * unit 2-6 = ports on switch */
+
+  unsigned int  request;
+  unsigned int  resp;
+  int sublockA;
+  int sublockB;
+
+  /* This needs to be checked since we are at a new level of 8051 code */
+  sublockA = unit==1 ? 6:0; /* unit==1 is PHY tied to MAC using RGMII */
+  sublockB = unit==1 ? 1:0; /* unit>=1 is PHY on switch                */
+                            /* With the new 8051 code this has to be figured
+			     * out again ( that is sublock values )
+			     */
+
+  request = (writeFlg ? 0 : 1)<<26 | (phy_addr<<21) | (reg<<16) | value;
+
+  vsc73xx_wr(VSC73XX_MII, sublockA, VSC73XX_MII_CMD, request, 0);
+  udelay(10);
+  do {
+    vsc73xx_rd(VSC73XX_MII, sublockB, VSC73XX_MII_STAT, &resp, 0);
+    udelay(10);
+  } while ( resp & 0xf );
+
+  if (writeFlg)
+    return 0;
+
+  udelay(1);
+
+  vsc73xx_rd(VSC73XX_MII, sublockB, VSC73XX_MII_DATA, &resp, 0);
+
+  if (resp & 1<<16) {
+    return 0xffff;
+  }
+
+  return resp & 0xffff;
+}
+
+#endif
+
+static int
+vsc73xx_setup_raw(void)
+{
+  int          rc;
+  int          sVersion=0;
+  int          resetNeeded=0;
+
+  unsigned int t_cfg;
+  unsigned int t_clock_delay;
+  unsigned int t_advportm;
+
+  rc = generic_spi_init(GENERIC_SPI_VSC73XX_CS);
+  if (rc < 0) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME": could not initialize spi interface, err %d\n", rc);
+#endif
+    return rc;
+  }
+
+  vsc73xx_get_sVersion_resetNeeded(&sVersion, &resetNeeded);
+ if ( (resetNeeded) || (sVersion < VSC73XX_SFTW_VERSION) ) {
+    rc = vsc73xx_load_firmware();
+    if (rc < 0)
+      return rc;
+  }
+
+  /* The VSC73XX does not work very well unless we setup 2 nsec delay */
+  vsc73xx_set_clock_delay_reg(VSC73XX_CLOCK_DELAY);
+  vsc73xx_get_clock_delay_reg(&t_clock_delay);
+
+  if ((t_clock_delay & VSC73XX_CLOCK_DELAY_MASK) != VSC73XX_CLOCK_DELAY) {
+#ifndef COMPRESSED_UBOOT
+    printk(MODULE_NAME":   unable to set clock_delay %08x %08x\n",
+		   VSC73XX_CLOCK_DELAY,
+		   VSC73XX_CLOCK_DELAY_MASK &  t_clock_delay);
+#endif
+    return -1;
+  }
+#ifndef COMPRESSED_UBOOT
+  else {
+    printk(MODULE_NAME":  clock_delay_reg %08x\n", t_clock_delay);
+  }
+#endif
+
+  /* We must tell the VSC73XX that it has an external interface */
+  vsc73xx_set_advportm(VSC73XX_PORT_MAC,
+		       VSC73XX_ADVPORTM_HYDRA);
+
+#ifndef COMPRESSED_UBOOT
+  vsc73xx_get_advportm(VSC73XX_PORT_MAC, &t_advportm);
+
+  if ((VSC73XX_ADVPORTM_HYDRA_MASK & t_advportm) != VSC73XX_ADVPORTM_HYDRA) {
+    printk(MODULE_NAME":   unable to set advanportm for MAC port (6) %08x %08x\n",
+		   VSC73XX_ADVPORTM_HYDRA,
+		   VSC73XX_ADVPORTM_HYDRA_MASK & t_advportm);
+  }
+  else
+    vsc73xx_print_advportm_val(t_advportm);
+#endif
+
+  /* We must tell the VSC73XX that it can send/recieve data */
+#ifdef CONFIG_AR9100
+  vsc73xx_set_mac_cfg(VSC73XX_PORT_MAC, VSC73XX_MAC_CFG_PORT_RST |
+		VSC73XX_MAC_CFG_MAC_RX_RST | VSC73XX_MAC_CFG_MAC_TX_RST);
+  vsc73xx_set_mac_cfg(VSC73XX_PORT_MAC, VSC73XX_MAC_CFG_AR9100);
+#else
+  vsc73xx_set_mac_cfg(VSC73XX_PORT_MAC,
+		      VSC73XX_MAC_CFG_HYDRA );
+#endif
+  vsc73xx_get_mac_cfg(VSC73XX_PORT_MAC, &t_cfg);
+
+#ifndef COMPRESSED_UBOOT
+#ifndef CONFIG_AR9100
+  if ((VSC73XX_MAC_CFG_HYDRA_MASK & t_cfg) != VSC73XX_MAC_CFG_HYDRA) {
+    printk(MODULE_NAME":   unable to set mac_cfg for port 6 %08x %08x\n",
+		   VSC73XX_MAC_CFG_HYDRA,
+		   VSC73XX_MAC_CFG_HYDRA_MASK & t_cfg);
+  }
+  else
+#endif
+    vsc73xx_print_mac_cfg_val(t_cfg);
+#endif
+
+  return rc;
+}
+
+static unsigned int mac_cfg_port[7] = { 0, 0, 0, 0, 0, 0, 0 };
+
+static unsigned int
+vsc73xx_get_link_status_raw(int port, int *up, int *fdx, ag7100_phy_speed_t *speed, unsigned int *cfg)
+{
+  int rc;
+
+  int t_up;
+  int t_fdx;
+  ag7100_phy_speed_t t_speed;
+
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  rc = vsc73xx_get_mac_cfg(port, &t_cfg);
+  if (rc<0)
+    return ~0;
+
+  /* FIXME WCL
+   * Occasionally the VSC73XX will return 0xffffffff for cfg status with no apparent error.
+   */
+  if (t_cfg == 0xffffffff)
+    return ~0;
+
+  t_chg = mac_cfg_port[port] ^ t_cfg;
+  mac_cfg_port[port] = t_cfg;
+
+  t_up  = (t_cfg & ( VSC73XX_MAC_CFG_TX_EN | VSC73XX_MAC_CFG_RX_EN )) == ( VSC73XX_MAC_CFG_TX_EN | VSC73XX_MAC_CFG_RX_EN );
+  t_fdx = (t_cfg & VSC73XX_MAC_CFG_FDX ) != 0;
+
+  if ( t_cfg & VSC73XX_MAC_CFG_GIGA_MODE )
+    t_speed = AG7100_PHY_SPEED_1000T;
+  else
+    if ( t_cfg & VSC73XX_MAC_CFG_100_BASE_T )
+      t_speed = AG7100_PHY_SPEED_100TX;
+    else
+      t_speed = AG7100_PHY_SPEED_10T;
+
+  if(t_speed  == AG7100_PHY_SPEED_1000T)
+	if (speed) *speed = 1000;
+  else if (t_speed  == AG7100_PHY_SPEED_100TX)
+	if (speed) *speed = 100;
+  else if (t_speed  == AG7100_PHY_SPEED_10T)
+        if (speed) *speed = 100;
+  if (up)    *up    = t_up;
+  if (fdx)   *fdx   = t_fdx;
+  if (cfg)   *cfg   = t_cfg;
+
+  return t_chg;
+}
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_link_status(void)
+{
+  int          port;
+  int          ii;
+
+  unsigned int t_up;
+  unsigned int t_fdx;
+  ag7100_phy_speed_t t_speed;
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  int          rc;
+
+#ifndef COMPRESSED_UBOOT
+  printk(MODULE_NAME": looping on load firmware / reset firmware\n" );
+#endif
+  vsc73xx_setup_raw();
+  do {
+    t_chg = vsc73xx_get_link_status_raw(port, &t_up, &t_fdx, &t_speed, &t_cfg);
+#ifndef COMPRESSED_UBOOT
+    if (t_chg == ~0) {
+      printk(MODULE_NAME": bad read from switch\n");
+    }
+    else {
+      if (t_chg)
+        vsc73xx_print_link_status_from_value(port, t_up, t_fdx, t_speed, t_cfg);
+    }
+#endif
+  } while (1);
+}
+
+#endif
+
+int
+vsc73xx_setup(int unit)
+{
+  return vsc73xx_setup_raw();
+}
+
+int
+vsc73xx_get_link_status(int unit, int *up, int *fdx, ag7100_phy_speed_t *speed, unsigned int *cfg)
+{
+  int          port;
+
+  unsigned int t_up;
+  unsigned int t_fdx;
+  ag7100_phy_speed_t t_speed;
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  /* The VSC73XX uses a fixed numbering scheme to get to ports - rather than using PHY Address.
+   *
+   * unit 0   == mac 0
+   * unit 1   == mac 1
+   * unit 2-6 == ports 0-4
+   */
+
+  switch (unit) {
+    case 1: port=VSC73XX_PORT_MAC; break;
+    case 2: port=VSC73XX_PORT_0; break;
+    case 3: port=VSC73XX_PORT_1; break;
+    case 4: port=VSC73XX_PORT_2; break;
+    case 5: port=VSC73XX_PORT_3; break;
+    case 6: port=VSC73XX_PORT_4; break;
+    default:
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": bad unit number %d\n", unit);
+#endif
+      return -1;
+  }
+
+  t_chg = vsc73xx_get_link_status_raw(port, &t_up, &t_fdx, &t_speed, &t_cfg);
+  if (t_chg == ~0)
+    return -2;
+
+  if(t_fdx)
+     if(fdx) *fdx = 44;
+  else
+     if(fdx) *fdx = 22;
+
+  if (up)    *up    = t_up;
+  if (speed) *speed = t_speed;
+  if (cfg)   *cfg   = t_cfg;
+
+#ifdef VSC73XX_DEBUG
+  printk("\t==== vsc(%d) up:%d fdx:%d speed:%d cfg=0x%08x\n", unit, t_up, t_fdx, t_speed, t_cfg);
+#endif
+  return 0;
+}
+
+#ifndef COMPRESSED_UBOOT
+#ifdef VSC73XX_DEBUG
+void
+vsc73xx_flush_mac_table_all(void)
+{
+	/* This flushes the mac table of all the ports */
+	vsc73xx_wr(2, 0, 0xB0, 0x4);
+}
+
+void
+vsc73xx_get_link_status_dbg(void)
+{
+#ifndef COMPRESSED_UBOOT
+	printk("\n");
+#endif
+	vsc73xx_get_link_status(1, 0, 0, 0, 0);
+	vsc73xx_get_link_status(2, 0, 0, 0, 0);
+	vsc73xx_get_link_status(3, 0, 0, 0, 0);
+	vsc73xx_get_link_status(4, 0, 0, 0, 0);
+	vsc73xx_get_link_status(5, 0, 0, 0, 0);
+	vsc73xx_get_link_status(6, 0, 0, 0, 0);
+}
+#endif /* VSC73XX_DEBUG */
+
+int
+vsc73xx_phy_print_link_status(int unit)
+{
+  int          port;
+
+  unsigned int t_up;
+  unsigned int t_fdx;
+  ag7100_phy_speed_t t_speed;
+  unsigned int t_cfg;
+  unsigned int t_chg;
+
+  /* The VSC73XX uses a fixed numbering scheme to get to ports - rather than using PHY Address.
+   *
+   * unit 0   == mac 0
+   * unit 1   == mac 1
+   * unit 2-6 == ports 0-4
+   */
+
+  switch (unit) {
+    case 1: port=VSC73XX_PORT_MAC; break;
+    case 2: port=VSC73XX_PORT_0; break;
+    case 3: port=VSC73XX_PORT_1; break;
+    case 4: port=VSC73XX_PORT_2; break;
+    case 5: port=VSC73XX_PORT_3; break;
+    case 6: port=VSC73XX_PORT_4; break;
+    default:
+#ifndef COMPRESSED_UBOOT
+      printk(MODULE_NAME": bad unit number %d\n", unit);
+#endif
+      return -1;
+  }
+
+  t_chg = vsc73xx_get_link_status_raw(port, &t_up, &t_fdx, &t_speed, &t_cfg);
+  if (t_chg == ~0)
+    return -2;
+
+#ifndef COMPRESSED_UBOOT
+  vsc73xx_print_link_status_from_value(port, t_up, t_fdx, t_speed, t_cfg);
+#endif
+  return 0;
+}
+#endif
diff --git a/board/ar7100/common/vsc73xx.h b/board/ar7100/common/vsc73xx.h
new file mode 100644
index 0000000000..38e2ba1ce9
--- /dev/null
+++ b/board/ar7100/common/vsc73xx.h
@@ -0,0 +1,168 @@
+/* vsc73xx.h
+ *
+ * History:
+ * Jan  4, 2007 wclewis initial
+ * Jan 12, 2007 wclewis ready for checkin
+ * May 24, 2007 Tag before BSP resturcture
+ */
+
+#ifndef _VSC73XX_H
+#define _VSC73XX_H
+
+//#include "ag7100.h"
+
+typedef enum {
+    AG7100_PHY_SPEED_10T,
+    AG7100_PHY_SPEED_100TX,
+    AG7100_PHY_SPEED_1000T,
+}ag7100_phy_speed_t;
+
+
+int
+vsc73xx_rd(int block, int subblock, int reg, unsigned int  *value);
+
+int
+vsc73xx_wr(int block, int subblock, int reg, unsigned int  value);
+
+/* Extern for heathrow.c and other vitesse provided stuff  */
+#define vtss_io_si_rd vsc73xx_rd_vsc7395
+#define vtss_io_si_wr vsc73xx_wr_vsc7395
+
+#define VSC73XX_GPIO_0          0x01
+#define VSC73XX_GPIO_1          0x02
+#define VSC73XX_GPIO_2          0x04
+#define VSC73XX_GPIO_3          0x08
+
+#define VSC73XX_GPIO_MASK       (VSC73XX_GPIO_0 | VSC73XX_GPIO_1 | VSC73XX_GPIO_2 | VSC73XX_GPIO_3 )
+
+#define VSC73XX_MAC_CFG_WEXC_DIS	(1<<31)
+#define VSC73XX_MAC_CFG_PORT_RST        (1<<29)
+#define VSC73XX_MAC_CFG_TX_EN	(1<<28)
+#define VSC73XX_MAC_CFG_FDX	        (1<<18)
+#define VSC73XX_MAC_CFG_GIGA_MODE       (1<<17)
+#define VSC73XX_MAC_CFG_RX_EN           (1<<16)
+#define VSC73XX_MAC_CFG_100_BASE_T      (1<<13)
+#define VSC73XX_MAC_CFG_TX_IPG(y)       ((y&0x1f)<<6)
+#define VSC73XX_MAC_CFG_MAC_RX_RST      (1<<5)
+#define VSC73XX_MAC_CFG_MAC_TX_RST      (11<4)
+#define VSC73XX_MAC_CFG_CLK_SEL(y)      ((y&0x3)<<0)
+
+#define VSC73XX_MAC_CFG_HYDRA_MASK ( \
+VSC73XX_MAC_CFG_WEXC_DIS   | \
+VSC73XX_MAC_CFG_PORT_RST   | \
+VSC73XX_MAC_CFG_TX_EN      | \
+VSC73XX_MAC_CFG_FDX        | \
+VSC73XX_MAC_CFG_GIGA_MODE  | \
+VSC73XX_MAC_CFG_RX_EN      | \
+VSC73XX_MAC_CFG_100_BASE_T | \
+VSC73XX_MAC_CFG_TX_IPG(31) | \
+VSC73XX_MAC_CFG_MAC_RX_RST | \
+VSC73XX_MAC_CFG_MAC_TX_RST | \
+VSC73XX_MAC_CFG_CLK_SEL(3)   \
+)
+
+#define VSC73XX_MAC_CFG_HYDRA ( \
+VSC73XX_MAC_CFG_TX_EN      | \
+VSC73XX_MAC_CFG_FDX        | \
+VSC73XX_MAC_CFG_GIGA_MODE  | \
+VSC73XX_MAC_CFG_RX_EN      | \
+VSC73XX_MAC_CFG_TX_IPG(6)  | \
+VSC73XX_MAC_CFG_CLK_SEL(3)   \
+)
+
+#define VSC73XX_MAC_CFG_AR9100 ( \
+VSC73XX_MAC_CFG_TX_EN      | \
+VSC73XX_MAC_CFG_FDX        | \
+VSC73XX_MAC_CFG_GIGA_MODE  | \
+VSC73XX_MAC_CFG_RX_EN      | \
+VSC73XX_MAC_CFG_TX_IPG(6)  | \
+4                            \
+)
+
+#define VSC73XX_MAC_CFG_CLK_RGMI_125MHZ 1
+#define VSC73XX_MAC_CFG_CLK_RGMI_25MHZ  2
+#define VSC73XX_MAC_CFG_CLK_RGMI_2_5MHZ 3
+
+#define VSC73XX_CLOCK_DELAY       (3<<4|3)
+#define VSC73XX_CLOCK_DELAY_MASK  (3<<4|3)
+
+#define VSC73XX_ADVPORTM_IFG_PPM       (1<<7)
+#define VSC73XX_ADVPORTM_EXC_COL_CONT  (1<<6)
+#define VSC73XX_ADVPORTM_EXT_PORT      (1<<5)
+#define VSC73XX_ADVPORTM_INV_GTX       (1<<4)
+#define VSC73XX_ADVPORTM_ENA_GTX       (1<<3)
+#define VSC73XX_ADVPORTM_DDR_MODE      (1<<2)
+#define VSC73XX_ADVPORTM_IO_LOOPBACK   (1<<1)
+#define VSC73XX_ADVPORTM_HOST_LOOPBACK (1<<0)
+
+#define VSC73XX_ADVPORTM_HYDRA_MASK ( \
+VSC73XX_ADVPORTM_IFG_PPM       | \
+VSC73XX_ADVPORTM_EXC_COL_CONT  | \
+VSC73XX_ADVPORTM_EXT_PORT      | \
+VSC73XX_ADVPORTM_INV_GTX       | \
+VSC73XX_ADVPORTM_ENA_GTX       | \
+VSC73XX_ADVPORTM_DDR_MODE      | \
+VSC73XX_ADVPORTM_IO_LOOPBACK   | \
+VSC73XX_ADVPORTM_HOST_LOOPBACK   \
+)
+
+#define VSC73XX_ADVPORTM_HYDRA ( \
+VSC73XX_ADVPORTM_EXT_PORT      | \
+VSC73XX_ADVPORTM_ENA_GTX       | \
+VSC73XX_ADVPORTM_DDR_MODE        \
+)
+
+/* Port 0..4, 6 */
+
+void
+vsc73xx_print_counts(int port);
+
+#define VSC73XX_PORT_0      0
+#define VSC73XX_PORT_1      1
+#define VSC73XX_PORT_2      2
+#define VSC73XX_PORT_3      3
+#define VSC73XX_PORT_4      4
+
+#define VSC73XX_PORT_MAC    6
+
+/* ********************************** INTERFACE TO AG7100 ********************* */
+
+int
+vsc73xx_setup(int unit);
+
+int
+vsc73xx_get_link_status(int unit, int *up, int *fdx, ag7100_phy_speed_t *speed, unsigned int *cfg);
+
+int
+vsc73xx_phy_print_link_status(int unit);
+
+/* This command may be used to read/write to the PHY in the case where the
+ * switch code is running on the host. The 8051 processor is not running.
+ *
+ * If 8051 processor on the switch is running the 'unmanaged' application than
+ * it is unwise to use the vsc73xx_rw_phy() command since the switch 8051 code
+ * is also using that interface.
+ */
+unsigned short
+vsc73xx_rw_phy(int writeFlg, int unit, int phy_addr, int reg, uint16_t value);
+
+#ifdef USE_TEST_CODE
+
+void
+vsc73xx_test_reset_line(void);
+
+void
+vsc73xx_test_reset_and_verify_chipid(void);
+
+void
+vsc73xx_test_gpio(void);
+
+void
+vsc73xx_test_load_and_reset_firmware(void);
+
+void
+vsc73xx_test_link_status(void);
+
+#endif
+
+#endif
diff --git a/board/ar7100/common/vsc8601_phy.c b/board/ar7100/common/vsc8601_phy.c
new file mode 100644
index 0000000000..39edfbcb18
--- /dev/null
+++ b/board/ar7100/common/vsc8601_phy.c
@@ -0,0 +1,1226 @@
+/* vsc8601.h
+ *
+ * History:
+ * Jan 14, 2007 wclewis ready common BDI/ECOS/Linux
+ *
+ *
+ * 1) Routine uses MII interface to query the specified device.
+ *
+ * 2) If the device is a VSC8201 or VSC8601 routine initializes
+ *    device using Vitesse specific routines.
+ *
+ * 3) If device is a IEEE complient device the device is
+ *    initialized in a generic fashion.
+ *
+ * 4) During query the PHY address is captured and used to
+ *    initialize the phy table. This has been tested for
+ *    the VSC8201, VSC8601 and ICPLUS.
+ */
+
+#ifdef __BDI
+#include "bdi.h"
+#else
+#ifdef __ECOS
+#if defined(CYGNUM_USE_ENET_VERBOSE)
+#   undef  VERBOSE
+#   define VERBOSE CYGNUM_USE_ENET_VERBOSE
+#else
+#   define VERBOSE 0
+#endif
+#define generic_printk             DEBUG_PRINTF
+#define generic_udelay             A_UDELAY
+#else
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include "vsc8601_phy.h"
+#define generic_printk             printf
+#define generic_udelay             udelay
+#endif
+#endif
+
+#ifndef VERBOSE
+#define  VERBOSE           1
+#endif
+
+#include "vsc8601_phy.h"
+
+typedef struct {
+  uint16_t     is_enet_port;
+  uint16_t     mac_unit;
+  uint16_t     phy_addr;
+  uint32_t     id;
+  uint16_t     status;
+}vsc8601_phy_t;
+
+static uint16_t nmbr_phys = 0;
+static vsc8601_phy_t phy_info[] = {
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  },
+  {
+    is_enet_port: 0,
+    mac_unit    : 0,
+    phy_addr    : 0
+  }
+};
+
+static uint16_t
+ag7100_mii_read(uint32_t phybase, uint16_t phyaddr, uint16_t reg)
+{
+    uint16_t val;
+
+    phy_reg_read(phybase, phyaddr, reg, &val);
+    return val;
+}
+
+static void
+ag7100_mii_write(uint32_t phybase, uint16_t phyaddr, uint16_t reg, uint32_t val)
+{
+    phy_reg_write(phybase, phyaddr, reg, val);
+}
+
+#if 0
+static vsc8601_phy_t *
+vsc8601_phy_find(int unit)
+{
+  int i;
+  vsc8601_phy_t *phy;
+
+  for(i = 0; i < sizeof(phy_info)/sizeof(phy_info[0]); i++) {
+    phy = &phy_info[i];
+    if (phy->is_enet_port && (phy->mac_unit == unit))
+      return phy;
+  }
+  generic_printk(" ERROR: Did not find unit %d\n", unit);
+  return NULL;
+}
+#endif
+
+/* Base read/write routines built on ag7100_mii_ macros */
+
+static inline void
+vsc8601_phy_mii_write_main(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+  ag7100_mii_write(unit, phy_addr, 31,  0);
+  ag7100_mii_write(unit, phy_addr, reg, data);
+}
+
+static inline void
+vsc8601_phy_mii_write_ex(int unit, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+  ag7100_mii_write(unit, phy_addr, 31,  1);
+  ag7100_mii_write(unit, phy_addr, reg, data);
+}
+
+static inline uint16_t
+vsc8601_phy_mii_read_main(int unit, uint32_t phy_addr, uint8_t reg)
+{
+  ag7100_mii_write(unit, phy_addr, 31,  0);
+  return ag7100_mii_read(unit, phy_addr, reg);
+}
+
+static inline uint16_t
+vsc8601_phy_mii_read_ex(int unit, uint32_t phy_addr, uint8_t reg)
+{
+  uint16_t val;
+  ag7100_mii_write(unit, phy_addr, 31,  1);
+  val = ag7100_mii_read(unit, phy_addr, reg);
+  ag7100_mii_write(unit, phy_addr, 31,  0);
+  return val;
+}
+
+/* Super simple routine to make it easier to print bits */
+
+static void
+vsc8601_phy_print_val_bit_desc (uint16_t val, char *fieldName, char *bit_descriptions[])
+{
+  int ii;
+  char *p2;
+
+  generic_printk(" %s=%04x ", fieldName, val);
+  for (ii=0;ii<16; ii++) {
+    p2 = val & 1<<(15-ii) ? bit_descriptions[ii*2] : bit_descriptions[ii*2+1];
+    if (p2 && p2[0])
+        generic_printk("    %s\n", p2);
+  }
+}
+
+/* ****************************************************************************
+ *
+ * For each register of interest:
+ * 1) register read
+ * 2) register print if there are alot of fields or bits
+ * 3) register write if there may be a need to write
+ * 4) masked write if there is a write and there are bits.
+ *
+ * **************************************************************************** */
+
+/* mode control */
+
+CEXTERN uint16_t
+vsc8601_phy_mii_read_mode_ctrl(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 0);
+}
+
+static char *mode_ctrl_desc[16*2] = {
+  "sreset","", /* 15 */
+  "loopback", "", /* 14 */
+  "f100","", /* 13 */
+  "auto-eg","", /* 12 */
+  "pwr-dwn","", /* 11 */
+  "isolate","", /* 10 */
+  "restar-auto-neg","", /*  9 */
+  "full-duplex","half-duplex", /*  8 */
+  "ctest","", /*  7 */
+  "f1000","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_mode_ctrl(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "mode_ctr        (00 )", mode_ctrl_desc);
+}
+
+CEXTERN void
+vsc8601_phy_mii_write_mode_ctrl(int unit, uint32_t phy_addr, uint16_t reg )
+{
+  vsc8601_phy_mii_write_main(unit, phy_addr, 0, reg);
+}
+
+CEXTERN void
+vsc8601_phy_mii_rmw_ctrl(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_mii_read_mode_ctrl(unit, phy_addr);
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_mii_write_mode_ctrl(unit, phy_addr, reg);
+}
+
+/* mode status */
+
+CEXTERN uint16_t
+vsc8601_phy_mii_read_mode_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 1);
+}
+
+static char *mode_status_desc[16*2] = {
+  "","", /* 15 */
+  "","", /* 14 */
+  "","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "auto-neg-cmplt","", /*  5 */
+  "rem-fault","", /*  4 */
+  "auto-neg-cap","", /*  3 */
+  "link-up","", /*  2 */
+  "jabber","", /*  1 */
+  "ex-cap","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_mode_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "mode_status     (01 )", mode_status_desc);
+}
+
+/* phy identification */
+
+CEXTERN uint16_t
+vsc8601_phy_mii_read_id1(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 2);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_mii_read_id2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 3);
+}
+
+/* gige control R/W */
+
+CEXTERN uint16_t
+vsc8601_phy_mii_read_gige_ctrl(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 9);
+}
+
+static char *gige_ctrl_desc[16*2] = {
+  "distortion-test","", /* 15 */
+  "jitter-test","", /* 14 */
+  "waveform-test","", /* 13 */
+  "man-cfg","", /* 12 */
+  "master","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_gige_ctrl(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "gige_ctrl       (09 )", gige_ctrl_desc);
+}
+
+CEXTERN void
+vsc8601_phy_mii_write_gige_ctrl(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 9, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_gige_ctrl(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_mii_read_gige_ctrl(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_mii_write_gige_ctrl(unit, phy_addr, reg);
+}
+
+/* gige status RO */
+
+CEXTERN uint16_t
+vsc8601_phy_read_gige_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 10);
+}
+
+static char *gige_status_desc[16*2] = {
+  "ms-fault","", /* 15 */
+  "is-master","", /* 14 */
+  "loc-rcv-ok","", /* 13 */
+  "rem-rcv-ok","", /* 12 */
+  "fdx-cap","", /* 11 */
+  "hdx-cap","", /* 10 */
+  "","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_gige_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, " gige_status     (10 )", gige_status_desc);
+  generic_printk("    idle-err-cnt: %02x\n", val&0xff);
+}
+
+/* gige status extension 1 todo */
+
+/* 100 base_t status extension RO */
+
+CEXTERN uint16_t
+vsc8601_phy_read_100_status_ex(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 16);
+}
+
+static char *l00_status_ex_desc[16*2] = {
+  "descram-lock","", /* 15 */
+  "descram-err","", /* 14 */
+  "disc","", /* 13 */
+  "link-act","", /* 12 */
+  "rcv-err","", /* 11 */
+  "xmt-err","", /* 10 */
+  "sos-err","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_100_status_ex(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "100_status_ex   (16 )", l00_status_ex_desc);
+}
+
+/* gige status extention 2 RO */
+
+CEXTERN uint16_t
+vsc8601_phy_read_gige_status_ex_2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 17);
+}
+
+static char *gige_status_ex_2_desc[16*2] = {
+  "descram-lock","", /* 15 */
+  "descram-err","", /* 14 */
+  "disc","", /* 13 */
+  "link-up","", /* 12 */
+  "rcv-err","", /* 11 */
+  "xmt-err","", /* 10 */
+  "ssd-err","", /*  9 */
+  "esd-err","", /*  8 */
+  "ce-err","", /*  7 */
+  "bcm-det","", /*  6 */
+  "mdi-x-err","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_gige_status_ex_2(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "gige_status_ex_2((17 )", gige_status_ex_2_desc);
+}
+
+/* Error counts of various types saturate at 0xff */
+
+CEXTERN uint16_t
+vsc8601_phy_read_rx_error_count(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 19);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_false_carrier_count(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 20);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_disconnect_count(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 21);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_ex_crtl_set_1(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 23);
+}
+
+static char *ex_crtl_set_1_desc[16*2] = {
+  "","", /* 15 */
+  "","", /* 14 */
+  "","", /* 13 */
+  "","", /* 12 */
+  "","", /* 11 */
+  "","", /* 10 */
+  "","", /*  9 */
+  "skew-2ns-rx-tx","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "actiphy","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "","", /*  2 */
+  "","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_ex_ctrl_set_1(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "ex_crtl_set_1   (23 )", ex_crtl_set_1_desc);
+}
+
+CEXTERN void
+vsc8601_phy_write_ex_crtl_set_1(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 23, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_ex_crtl_set_1(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_ex_crtl_set_1(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_ex_crtl_set_1(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_ex_crtl_set_2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 24);
+}
+
+CEXTERN void
+vsc8601_phy_write_ex_crtl_set_2(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 24, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_ex_crtl_set_2(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_ex_crtl_set_2(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_ex_crtl_set_2(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_irq_msk(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 25);
+}
+
+CEXTERN void
+vsc8601_phy_write_irq_msk(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_main(unit, phy_addr, 25, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_irq_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 26);
+}
+static char *irq_status_desc[16*2] = {
+  "pending","", /* 15 */
+  "speed","", /* 14 */
+  "link","", /* 13 */
+  "fdx","", /* 12 */
+  "auto-err","", /* 11 */
+  "auto-cmpl","", /* 10 */
+  "inl-pwr","", /*  9 */
+  "","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "","", /*  5 */
+  "","", /*  4 */
+  "","", /*  3 */
+  "dwn-shft","", /*  2 */
+  "ms-err","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_irq_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "irq_status      (26 )", irq_status_desc);
+}
+
+#if 0
+/* RO */
+
+CEXTERN uint16_t
+vsc8601_phy_read_aux_ctrl_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 28);
+}
+
+static char *aux_ctrl_status_desc[16*2] = {
+  "auto-cmplt","", /* 15 */
+  "auto-dis","", /* 14 */
+  "cross-over","", /* 13 */
+  "cd swap","", /* 12 */
+  "a-pol","", /* 11 */
+  "b-pol","", /* 10 */
+  "c-pol","", /*  9 */
+  "d-pol","", /*  8 */
+  "","", /*  7 */
+  "","", /*  6 */
+  "fdx","", /*  5 */
+  "gige","", /*  4 */
+  "100-base-T","", /*  3 */
+  "","", /*  2 */
+  "sticky","", /*  1 */
+  "","", /*  0 */
+};
+
+CEXTERN void
+vsc8601_phy_mii_print_aux_ctrl_status(uint16_t val)
+{
+  vsc8601_phy_print_val_bit_desc (val, "aux_ctrl_status (28 )", aux_ctrl_status_desc);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_delay_skew_status(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_main(unit, phy_addr, 29);
+}
+
+CEXTERN void
+vsc8601_phy_mii_print_delay_skew_status(uint16_t val)
+{
+  generic_printk(" delay_skew_     (29 )=%04x\n", val);
+  generic_printk("    pair a delay: %02x\n", (val>>12)&7);
+  generic_printk("    pair b delay: %02x\n", (val>> 8)&7);
+  generic_printk("    pair c delay: %02x\n", (val>> 4)&7);
+  generic_printk("    pair d delay: %02x\n", (val>> 0)&7);
+}
+
+/* Extended registers - specific to chips? */
+
+CEXTERN uint16_t
+vsc8601_phy_read_crc_good_counter(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 18);
+}
+
+/* Resistor calibration */
+
+CEXTERN uint16_t
+vsc8601_phy_read_mac_resistor_calibration(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 19);
+}
+
+CEXTERN void
+vsc8601_phy_write_mac_resistor_calibration(int unit, uint32_t phy_addr, uint16_t val)
+{
+  vsc8601_phy_mii_write_ex(unit, phy_addr, 19, val);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_mac_resistor_calibration(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_mac_resistor_calibration(unit, phy_addr);
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_mac_resistor_calibration(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_ex_crtl_set_5(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 27);
+}
+
+CEXTERN void
+vsc8601_phy_mii_print_ex_crtl_set_5(uint16_t val)
+{
+  generic_printk(" ex_crtl_set_5   (27E)=%04x\n", val);
+  generic_printk("    crs:         %x\n", (val>>12)&7);
+  generic_printk("    100  tx amp: %x\n", (val>> 6)&7);
+  generic_printk("    gige tx amp: %x\n", (val>> 3)&7);
+  generic_printk("    gige edge:   %x\n", (val>> 0)&7);
+
+  if (val & 1<<10)
+    generic_printk("   FAR-END-LOOPBACK\n");
+}
+
+CEXTERN void
+vsc8601_phy_write_ex_crtl_set_5(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 27, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_ex_crtl_set_5(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_ex_crtl_set_5(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_ex_crtl_set_5(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_skew_ctrl(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 28);
+}
+
+CEXTERN void
+vsc8601_phy_mii_print_skew_ctrl(uint16_t val)
+{
+  generic_printk(" skew_ctrl       (28E)=%04x\n", val);
+  generic_printk("    tx cmp: %x\n", (val>>14)&3);
+  generic_printk("    rx cmp: %x\n", (val>>12)&7);
+  generic_printk("    jumbo:  %x\n", (val>>10)&7);
+}
+
+CEXTERN void
+vsc8601_phy_write_skew_ctrl(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 28, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_skew_ctrl(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_skew_ctrl(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_skew_ctrl(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_epg_1(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 29);
+}
+
+CEXTERN void
+vsc8601_phy_write_epg_1(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 29, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_epg_1(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_epg_1(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_epg_1(unit, phy_addr, reg);
+}
+
+CEXTERN uint16_t
+vsc8601_phy_read_epg_2(int unit, uint32_t phy_addr)
+{
+  return vsc8601_phy_mii_read_ex(unit, phy_addr, 20);
+}
+
+CEXTERN void
+vsc8601_phy_write_epg_2(int unit, uint32_t phy_addr, uint16_t reg)
+{
+  return vsc8601_phy_mii_write_ex(unit, phy_addr, 30, reg);
+}
+
+CEXTERN void
+vsc8601_phy_rmw_epg_2(int unit, uint32_t phy_addr, uint32_t mask, uint32_t val)
+{
+  uint16_t reg = vsc8601_phy_read_epg_2(unit, phy_addr);
+  if (reg == 0xffff)
+    return;
+  reg &= ~mask;
+  reg |=  val;
+  vsc8601_phy_write_epg_2(unit, phy_addr, reg);
+}
+#endif
+
+/* Functions */
+
+CEXTERN void
+vsc8601_phy_mii_soft_reset(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<15, 1<<15);
+  generic_udelay(10);
+}
+
+CEXTERN void
+vsc8601_phy_mii_set_loopback(int unit, uint32_t phy_addr, int onOff)
+{
+  uint32_t   val = onOff ? 1<<14 : 0;
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<14, val);
+}
+
+CEXTERN void
+vsc8601_phy_mii_set_auto(int unit, uint32_t phy_addr, int onOff)
+{
+  uint32_t   val = onOff ? 1<<12 : 0;
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<12, val);
+}
+
+CEXTERN void
+vsc8601_phy_mii_force_speed(int unit, uint32_t phy_addr, int speed)
+{
+  uint32_t val=0;
+  if (speed & 1<<0) val |= 1<<6;
+  if (speed & 2<<0) val |= 1<<13;
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<6 | 1<<13 , val);
+}
+
+CEXTERN void
+vsc8601_phy_mii_restart_auto(int unit, uint32_t phy_addr, int onOff)
+{
+  uint32_t   val = onOff ? 1<<9 : 0;
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<9, val);
+}
+
+CEXTERN void
+vsc8601_phy_mii_set_duplex(int unit, uint32_t phy_addr, int onOff)
+{
+  uint32_t   val = onOff ? 1<<8 : 0;
+  vsc8601_phy_mii_rmw_ctrl(unit, phy_addr, 1<<8, val);
+}
+
+/* IEEE GIGE extended control */
+
+CEXTERN void
+vsc8601_phy_set_gige_test_normal(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 0<<13);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_test_waveform(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 1<<13);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_test_jitter_master(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 2<<13);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_test_jitter_slave(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 3<<13);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_test_distortion(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 7<<13, 4<<13);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_test_master(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 3<<11, 3<<11);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_test_slave(int unit, uint32_t phy_addr)
+{
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 3<<11, 2<<11);
+}
+
+CEXTERN void
+vsc8601_phy_set_gige_multiport(int unit, uint32_t phy_addr, int onOff)
+{
+  uint32_t   val = onOff ? 1<<10 : 0;
+  vsc8601_phy_rmw_gige_ctrl(unit, phy_addr, 1<<10, val);
+}
+
+#if 0
+CEXTERN uint16_t
+vsc8601_phy_get_speed(uint16_t unit, uint16_t phy_addr)
+{
+  uint16_t speed = (vsc8601_phy_read_aux_ctrl_status(unit, phy_addr) >> 3) & 3;
+
+  switch(speed) {
+  case 0:
+    return AG7100_PHY_SPEED_10T;
+  case 1:
+    return AG7100_PHY_SPEED_100TX;
+  case 2:
+    return AG7100_PHY_SPEED_1000T;
+  default:
+    generic_printk("ERROR: Unkown speed read!\n");
+    return 0;
+  }
+}
+#endif
+
+static void
+vsc8601_phy_setup_generic(uint16_t unit, uint16_t phy_addr)
+{
+  vsc8601_phy_mii_set_duplex(unit, phy_addr, 1);
+#ifdef CONFIG_AR9100
+  ag7100_mii_write(unit, phy_addr, 0x1f,  0x1);
+  ag7100_mii_write(unit, phy_addr, 0x1c,  0x3000);
+  ag7100_mii_write(unit, phy_addr, 0x1f,  0x0);
+#endif
+}
+
+static void
+vsc8601_phy_setup_vsc8601_Rev_A(uint16_t unit, uint16_t phy_addr)
+{
+  uint16_t uu;
+
+  /* Weird patch in vsc86-1 datasheet Errata */
+
+  ag7100_mii_write(unit, phy_addr, 31, 0x52b5);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0xaf8a);
+
+  uu=ag7100_mii_read(unit, phy_addr, 18);
+  ag7100_mii_write(unit, phy_addr, 18, uu);
+
+  uu=ag7100_mii_read(unit, phy_addr, 17);
+  uu&=~0x000c;
+  uu|= 0x0008;
+  ag7100_mii_write(unit, phy_addr, 17, uu);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0x8f8a);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0xaf86);
+
+  uu=ag7100_mii_read(unit, phy_addr, 18);
+  uu&=~0x000c;
+  uu|= 0x0008;
+  ag7100_mii_write(unit, phy_addr, 18, uu);
+
+  uu=ag7100_mii_read(unit, phy_addr, 17);
+  ag7100_mii_write(unit, phy_addr, 17, uu);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0x8f86);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0xaf82);
+
+  uu=ag7100_mii_read(unit, phy_addr, 18);
+  ag7100_mii_write(unit, phy_addr, 18, uu);
+
+  uu=ag7100_mii_read(unit, phy_addr, 17);
+  uu&=~0x0180;
+  uu|= 0x0100;
+  ag7100_mii_write(unit, phy_addr, 17, uu);
+
+  ag7100_mii_write(unit, phy_addr, 16, 0x8f82);
+
+  ag7100_mii_write(unit, phy_addr, 31, 0);
+
+  /* Skew stuff */
+  vsc8601_phy_rmw_ex_crtl_set_1(unit, phy_addr, 1<<8, 1<<8);
+}
+
+static void
+vsc8601_phy_setup_vsc8601_Rev_B(uint16_t unit, uint16_t phy_addr)
+{
+  vsc8601_phy_mii_set_duplex(unit, phy_addr, 1);
+#ifdef CONFIG_AR9100
+  vsc8601_phy_rmw_ex_crtl_set_1(unit, phy_addr, 1<<8, 1<<8);
+#endif
+}
+
+CEXTERN int
+vsc8601_phy_discover_and_setup_phy(int unit)
+{
+  uint16_t phy_addr;
+  uint16_t unit_cnt;
+
+  unit_cnt=0;
+  nmbr_phys=0;
+
+  for (phy_addr=0; phy_addr<31; phy_addr++) {
+
+    uint16_t id1 = vsc8601_phy_mii_read_id1(unit, phy_addr);
+    uint32_t id2 = vsc8601_phy_mii_read_id2(unit, phy_addr);
+    uint32_t id  = id1<<16 | id2;
+
+    uint32_t id_sav = 0;
+    uint16_t phy_status = 0;
+
+    if (id1 > 0 && id1 < 0x7ff) {
+      vsc8601_phy_mii_soft_reset( unit, phy_addr );
+      phy_status=vsc8601_phy_mii_read_mode_status(unit, phy_addr);
+#ifndef COMPRESSED_UBOOT
+      generic_printk(" VSCXXX Found %d  unit %d:%d  phy_addr: %d  id: %08x\n",
+		     nmbr_phys, unit, unit_cnt, phy_addr, id);
+#endif
+      phy_info[nmbr_phys].id=id;
+      phy_info[nmbr_phys].phy_addr=phy_addr;
+      phy_info[nmbr_phys].mac_unit=unit_cnt;
+      phy_info[nmbr_phys].is_enet_port=0;
+
+      if (id != id_sav) {
+	switch(id) {
+	case 0x00070420:
+#ifndef COMPRESSED_UBOOT
+	  generic_printk(" PHY is Vitesse VSC8601 Rev A\n");
+#endif
+	  vsc8601_phy_setup_vsc8601_Rev_A(unit, phy_addr);
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+
+	case 0x00070421:
+#ifndef COMPRESSED_UBOOT
+	  generic_printk(" PHY is Vitesse VSC8601 Rev B\n");
+#endif
+	  vsc8601_phy_setup_vsc8601_Rev_B(unit, phy_addr);
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+
+	case 0x000fc413:
+#ifndef COMPRESSED_UBOOT
+	  generic_printk(" PHY is Vitesse VSC8201 Phy\n");
+#endif
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+
+        case 0x02430d80:
+#ifndef COMPRESSED_UBOOT
+          generic_printk(" PHY is ICPlus IP175B Switch\n");
+#endif
+          vsc8601_phy_setup_generic(unit, phy_addr);
+          phy_info[nmbr_phys].is_enet_port=1;
+          unit_cnt++;
+          break;
+
+	default:
+#ifndef COMPRESSED_UBOOT
+	  generic_printk(" PHY is unknown, using generic IEEE interface\n");
+#endif
+	  vsc8601_phy_setup_generic(unit, phy_addr);
+	  phy_info[nmbr_phys].is_enet_port=1;
+	  unit_cnt++;
+	  break;
+	}
+	id_sav=id;
+      }
+      nmbr_phys++;
+    }
+  }
+  if (nmbr_phys == 0) {
+    generic_printk(" ERROR: No PHY IDs found \n");
+    return 1;
+  }
+  if (unit_cnt == 0) {
+    generic_printk(" ERROR: No PHY IDs assigned to unit\n");
+    return 1;
+  }
+  return 0;
+}
+
+#if 0
+CEXTERN int
+vsc8601_phy_print_status(uint16_t unit, uint16_t phy_addr)
+{
+
+#if ( VERBOSE > 1 )
+
+  /* Generic IEEE */
+
+  uint16_t mc  = vsc8601_phy_mii_read_mode_ctrl            (unit, phy_addr);
+  uint16_t ms  = vsc8601_phy_mii_read_mode_status          (unit, phy_addr);
+  uint16_t id1 = vsc8601_phy_mii_read_id1                  (unit, phy_addr);
+  uint32_t id2 = vsc8601_phy_mii_read_id2                  (unit, phy_addr);
+  uint32_t id  = id1<<16 | id2;
+  uint16_t rec = vsc8601_phy_read_rx_error_count           (unit, phy_addr);
+  uint16_t fcc = vsc8601_phy_read_false_carrier_count      (unit, phy_addr);
+  uint16_t dc  = vsc8601_phy_read_disconnect_count         (unit, phy_addr);
+  uint16_t cs1 = vsc8601_phy_read_ex_crtl_set_1            (unit, phy_addr);
+  uint16_t cs2 = vsc8601_phy_read_ex_crtl_set_2            (unit, phy_addr);
+  uint16_t im  = vsc8601_phy_read_irq_msk                  (unit, phy_addr);
+  uint16_t is  = vsc8601_phy_read_irq_status               (unit, phy_addr);
+  uint16_t acs = vsc8601_phy_read_aux_ctrl_status          (unit, phy_addr);
+  uint16_t dss = vsc8601_phy_read_delay_skew_status        (unit, phy_addr);
+
+  generic_printk("VSCXXX unit %d  phy_addr %d\n", unit, phy_addr);
+  vsc8601_phy_mii_print_mode_ctrl(mc);
+  vsc8601_phy_mii_print_mode_status(ms);
+  generic_printk("  id1             (02 )=%02x\n", id1 & 0xff);
+  generic_printk("  id2             (03 )=%02x\n", id2 & 0xff);
+  generic_printk("  rcv-error       (19 )=%04x\n", rec & 0xff);
+  generic_printk("  false-carrier   (20 )=%04x\n", fcc & 0xff);
+  generic_printk("  disconnect_cnt  (21 )=%04x\n", dc  & 0xff);
+  vsc8601_phy_mii_print_ex_ctrl_set_1(cs1);
+
+  generic_printk("  ex_crtl_set_2   (24 )=%04x\n", cs2);
+  generic_printk("  irq_msk         (25 )=%04x\n", im);
+  vsc8601_phy_mii_print_irq_status(is);
+  vsc8601_phy_mii_print_aux_ctrl_status(acs);
+  vsc8601_phy_mii_print_delay_skew_status(dss);
+
+  /* Chip specific */
+
+  switch( id ) {
+  case 0x00070420:
+    {
+      uint16_t cgc = vsc8601_phy_read_crc_good_counter         (unit, phy_addr);
+      uint16_t mcr = vsc8601_phy_read_mac_resistor_calibration (unit, phy_addr);
+      uint16_t cs5 = vsc8601_phy_read_ex_crtl_set_5            (unit, phy_addr);
+      uint16_t skc = vsc8601_phy_read_skew_ctrl                (unit, phy_addr);
+      uint16_t ep1 = vsc8601_phy_read_epg_1                    (unit, phy_addr);
+      uint16_t ep2 = vsc8601_phy_read_epg_1                    (unit, phy_addr);
+
+      generic_printk("  crc_good        (18E)=%04x\n", cgc);
+      generic_printk("  resistor        (19E)=%04x\n", mcr);
+      vsc8601_phy_mii_print_ex_crtl_set_5(cs5);
+      vsc8601_phy_mii_print_skew_ctrl(skc);
+      generic_printk("  epg_1           (29E)=%04x\n", ep1);
+      generic_printk("  epg_2           (30E)=%04x\n", ep2);
+    }
+    break;
+  }
+
+  /* Speed specific */
+
+  switch(vsc8601_phy_get_speed(unit, phy_addr)) {
+  case AG7100_PHY_SPEED_10T:
+    generic_printk("  * current speed 10 base-t\n");
+    break;
+
+  case AG7100_PHY_SPEED_100TX:
+    {
+      uint16_t es = vsc8601_phy_read_100_status_ex (unit, phy_addr);
+      vsc8601_phy_mii_print_100_status_ex(es);
+      generic_printk("  * current speed 100 base-t\n");
+    }
+    break;
+
+  case AG7100_PHY_SPEED_1000T:
+    {
+      uint16_t gc  = vsc8601_phy_mii_read_gige_ctrl     (unit, phy_addr);
+      uint16_t gs  = vsc8601_phy_read_gige_status       (unit, phy_addr);
+      uint16_t gs2 = vsc8601_phy_read_gige_status_ex_2  (unit, phy_addr);
+
+      vsc8601_phy_mii_print_gige_ctrl(gc);
+      vsc8601_phy_mii_print_gige_status(gs);
+      vsc8601_phy_mii_print_gige_status_ex_2(gs2);
+
+      generic_printk("  * current speed gige\n");
+    }
+    break;
+
+  default:
+    generic_printk("  * current speed unknown\n");
+    break;
+  }
+  generic_printk("\n");
+
+#else
+#if ( VERBOSE > 0 )
+
+  uint16_t ms  = vsc8601_phy_mii_read_mode_status     (unit, phy_addr);
+  uint16_t mc  = vsc8601_phy_mii_read_mode_ctrl       (unit, phy_addr);
+  uint16_t rec = vsc8601_phy_read_rx_error_count      (unit, phy_addr);
+  uint16_t fcc = vsc8601_phy_read_false_carrier_count (unit, phy_addr);
+  uint16_t dc  = vsc8601_phy_read_disconnect_count    (unit, phy_addr);
+
+  generic_printk("VSCXXX unit %d  phy_addr %d\n", unit, phy_addr);
+  vsc8601_phy_mii_print_mode_ctrl(mc);
+  vsc8601_phy_mii_print_mode_status(ms);
+  generic_printk("  rcv-error       (19 )=%04x\n", rec & 0xff);
+  generic_printk("  false-carrier   (20 )=%04x\n", fcc & 0xff);
+  generic_printk("  disconnect_cnt  (21 )=%04x\n", dc  & 0xff);
+
+#else
+
+  uint16_t ms  = vsc8601_phy_mii_read_mode_status     (unit, phy_addr);
+  generic_printk("VSCXXX unit %d  phy_addr %d\n", unit, phy_addr);
+  vsc8601_phy_mii_print_mode_status(ms);
+
+#endif
+#endif
+
+  return 0;
+}
+#endif
+
+/* ***********************************************************
+ *
+ * These are exported for use by ag7100_phy.h
+ *
+ * *********************************************************** */
+
+int
+vsc8601_phy_setup(int unit)
+{
+  int ii;
+  vsc8601_phy_t *phy;
+
+  if (vsc8601_phy_discover_and_setup_phy(unit))
+    return -1;
+
+#if 0
+  for (ii = 0; ii < sizeof(phy_info)/sizeof(phy_info[0]); ii++) {
+    phy = &phy_info[ii];
+    if (phy->is_enet_port && (phy->mac_unit == unit))
+      vsc8601_phy_print_status(phy->mac_unit, phy->phy_addr);
+  }
+#endif
+  return 0;
+}
+
+#if 0
+unsigned int
+vsc8601_phy_get_link_status(int unit, int *link, int *fdx, int *speed, unsigned int *cfg)
+{
+  unsigned short ms;
+  unsigned short acs;
+  unsigned int   tc;
+  vsc8601_phy_t *phy = vsc8601_phy_find(unit);
+
+  if (!phy)
+    return 0;
+
+  ms = vsc8601_phy_mii_read_mode_status (unit, phy->phy_addr);
+
+  if (link) *link   = (ms & 1<<2) > 0;
+  if (speed) *speed = vsc8601_phy_get_speed(unit, phy->phy_addr);
+  if (fdx) {
+    acs = vsc8601_phy_read_aux_ctrl_status(unit, phy->phy_addr);
+    *fdx = (acs & 1<<5) > 0;
+  }
+  tc = phy->status != ms;
+  phy->status = ms;
+
+#if VERBOSE > 0
+  if (tc)
+    vsc8601_phy_print_status(unit, phy->phy_addr);
+#endif
+
+  if (cfg)
+    *cfg=tc;
+
+  return tc;
+}
+#endif
diff --git a/board/ar7100/common/vsc8601_phy.h b/board/ar7100/common/vsc8601_phy.h
new file mode 100644
index 0000000000..9b2e7e7230
--- /dev/null
+++ b/board/ar7100/common/vsc8601_phy.h
@@ -0,0 +1,19 @@
+/* vsc8601.h
+ *
+ * History:
+ * Jan 14, 2007 wclewis ready common BDI/ECOS/Linux
+ */
+
+#ifndef _VSC8601_PHY_H
+#define _VSC8601_PHY_H
+
+#ifndef CEXTERN
+#define  CEXTERN static inline
+#endif
+
+int vsc8601_phy_setup(int unit);
+
+unsigned int
+vsc8601_phy_get_link_status(int unit, int *link, int *fdx, int *speed, unsigned int *cfg);
+
+#endif
diff --git a/board/ar7100/common/vsc_phy.c b/board/ar7100/common/vsc_phy.c
new file mode 100644
index 0000000000..4cde4da6d5
--- /dev/null
+++ b/board/ar7100/common/vsc_phy.c
@@ -0,0 +1,15 @@
+#include <config.h>
+#include "phy.h"
+
+void
+vsc_phy_setup(int unit)
+{
+    phy_reg_write(0, CFG_PHY_ADDR, 0, 0x8000);
+    phy_reg_write(0, CFG_PHY_ADDR, 0x1c, 0x4);
+    phy_reg_write(0, CFG_PHY_ADDR, 0x17, 0x1000);
+    //ag7100_mii_write(0, CFG_PHY_ADDR, 0, 0x2100);
+    phy_reg_write(0, CFG_PHY_ADDR, 31, 0x2a30);
+    phy_reg_write(0, CFG_PHY_ADDR, 8, 0x10);
+    phy_reg_write(0, CFG_PHY_ADDR, 31, 0);
+    phy_reg_write(0, CFG_PHY_ADDR, 0x12, 0x0008);
+}
diff --git a/board/ar7100/pb42/Makefile b/board/ar7100/pb42/Makefile
new file mode 100644
index 0000000000..3bc62362bf
--- /dev/null
+++ b/board/ar7100/pb42/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/pb42/config.mk b/board/ar7100/pb42/config.mk
new file mode 100755
index 0000000000..3c410579c0
--- /dev/null
+++ b/board/ar7100/pb42/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/pb42/flash.c b/board/ar7100/pb42/flash.c
new file mode 100644
index 0000000000..94d797f77a
--- /dev/null
+++ b/board/ar7100/pb42/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7100/pb42/pb42.c b/board/ar7100/pb42/pb42.c
new file mode 100644
index 0000000000..eb41abf5ff
--- /dev/null
+++ b/board/ar7100/pb42/pb42.c
@@ -0,0 +1,72 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include "ar7100_soc.h"
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    ar7100_ddr_width_t width;
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x7);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x7);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x7);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x7);
+#endif
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+    /* XXX - these don't really belong here! */
+    *(volatile unsigned int *)0xb8050004 = 0x50C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0xee;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("PB42 (ar7100) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7100/pb42/u-boot.lds b/board/ar7100/pb42/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/pb42/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/pb44/Makefile b/board/ar7100/pb44/Makefile
new file mode 100644
index 0000000000..ec1cf768cb
--- /dev/null
+++ b/board/ar7100/pb44/Makefile
@@ -0,0 +1,13 @@
+
+include $(TOPDIR)/config.mk
+LIB = lib$(BOARD).a
+OBJS = $(BOARD).o ../common/ar7100_flash.o ../common/generic_i2c.o ../common/generic_spi.o ../common/vsc73xx.o ../common/vsc8601_phy.o pb44_pci.o
+SOBJS = lowlevel_init.o
+
+$(LIB): .depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+.depend: Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+	$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
diff --git a/board/ar7100/pb44/config.mk b/board/ar7100/pb44/config.mk
new file mode 100644
index 0000000000..58dff26537
--- /dev/null
+++ b/board/ar7100/pb44/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xbf000000
+else
+TEXT_BASE = 0xbf000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/pb44/lowlevel_init.S b/board/ar7100/pb44/lowlevel_init.S
new file mode 100755
index 0000000000..c769f918e6
--- /dev/null
+++ b/board/ar7100/pb44/lowlevel_init.S
@@ -0,0 +1,428 @@
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**
+**
+**
+**  Copyright (c) 200x Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val_reg(_reg, _mask, _valreg)           \
+    li  t7, _reg;                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    or  t8, t8, _valreg;                            \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_reg(_mask, _reg)                    \
+    set_val_reg(AR7100_CPU_PLL_CONFIG,  _mask, _reg)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/* at 16 bytes offset from the beginning of last sector of 8MB flash part */
+#define CFG_FLASH_PLL_SETTING_ADDR  0x1fff0010
+#define AR7100_SPI_CLOCK (AR7100_SPI_BASE + 4)
+
+/* t0 - t5 will have the return results. a0 clobbered */
+get_flash_pll_setting:
+    /* Disable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x43
+    sw      t0, 0(a0)
+
+    /* Now read pll setting fm flash */
+    li      t0, KSEG1ADDR(CFG_FLASH_PLL_SETTING_ADDR)
+    lw      t1, 0(t0)
+
+    /* Enable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x3
+    sw      t0, 0(a0)
+
+    /*
+    ** check the range of values
+    */
+
+    li      t0, CFG_PLL_200_200_100
+    blt     t1, t0, 1f
+    nop
+    li      t0, CFG_PLL_680_340_170
+    ble     t1, t0, 2f
+    nop
+
+1:
+        /* Value is bad use compiled value */
+
+#if (CFG_PLL_FREQ == CFG_PLL_680_340_170)
+    li      t1, CFG_PLL_680_340_170
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+    li      t1, CFG_PLL_400_400_100
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+    li      t1, CFG_PLL_360_360_180
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+    li      t1, CFG_PLL_400_400_200
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+    li      t1, CFG_PLL_266_266_66
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+    li      t1, CFG_PLL_266_266_133
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+    li      t1, CFG_PLL_333_333_166
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+    li      t1, CFG_PLL_300_300_150
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+    li      t1, CFG_PLL_200_200_100
+#else
+#error: must define CFG_PLL_FREQ
+#endif
+2:
+    li      t2, CFG_PLL_680_340_170
+    beq     t1, t2, pll_680_340_170
+    nop
+    li      t2, CFG_PLL_400_400_100
+    beq     t1, t2, pll_400_400_100
+    nop
+    li      t2, CFG_PLL_360_360_180
+    beq     t1, t2, pll_360_360_180
+    nop
+    li      t2, CFG_PLL_400_400_200
+    beq     t1, t2, pll_400_400_200
+    nop
+    li      t2, CFG_PLL_266_266_66
+    beq     t1, t2, pll_266_266_66
+    nop
+    li      t2, CFG_PLL_266_266_133
+    beq     t1, t2, pll_266_266_133
+    nop
+    li      t2, CFG_PLL_333_333_166
+    beq     t1, t2, pll_333_333_166
+    nop
+    li      t2, CFG_PLL_300_300_150
+    beq     t1, t2, pll_300_300_150
+    nop
+    li      t2, CFG_PLL_200_200_100
+    b       pll_200_200_100
+    nop
+
+pll_680_340_170:
+    li      t0, (0x0  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x10 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x1  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_400_400_100:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_360_360_180:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1b << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x5  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_400_400_200:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_66:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_133:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_333_333_166:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x18 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_300_300_150:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1d << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_200_200_100:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+got_setting:
+    jr ra
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+#if 1
+    /* store return address to return to caller function */
+    move s0, ra
+    /* regs t0-t5 will have the settings */
+    la   t9, get_flash_pll_setting
+    jalr t9
+    nop
+    /* restore return address */
+    move ra, s0
+    pll_set_reg(PLL_CONFIG_CPU_DIV_MASK, t0)
+    pll_set_reg(PLL_CONFIG_AHB_DIV_MASK, t2)
+    pll_set_reg(PLL_CONFIG_DDR_DIV_MASK, t1)
+    pll_set_reg(PLL_CONFIG_PLL_DIVOUT_MASK, t5)
+
+#else
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+    pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+#endif
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+#if 1
+    pll_set_reg(PLL_CONFIG_PLL_FB_MASK, t3)
+    pll_set_reg(PLL_CONFIG_PLL_LOOP_BW_MASK, t4)
+#else
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting the mode register
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
+ /* end of file */
diff --git a/board/ar7100/pb44/pb44.c b/board/ar7100/pb44/pb44.c
new file mode 100644
index 0000000000..12b001a2bd
--- /dev/null
+++ b/board/ar7100/pb44/pb44.c
@@ -0,0 +1,233 @@
+/*****************************************************************************/
+/*! file pb44.c
+** /brief Boot support for PB44 board. First version identical to pb45.c
+**
+**  This provides the support code required for the AP94 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the PB44.
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x400050C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x76; /* 66MHz at 1GHz PLL */
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+#ifndef COMPRESSED_UBOOT
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+#endif /* #ifndef COMPRESSED_UBOOT */
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "PB44 (ar7100) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    unsigned long pll, pll_div, cpu_div, ahb_div, ddr_div, freq;
+
+    printf("PB44 (ar7100) U-boot \n");
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div  = ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT) + 1;
+    freq     = pll_div * 40;
+    cpu_div  = ((pll & PLL_CONFIG_CPU_DIV_MASK) >> PLL_CONFIG_CPU_DIV_SHIFT) + 1;
+    ddr_div  = ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+    ahb_div  = (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    printf("Frequency: CPU %d MHz, DDR %d MHz, AHB %dMHz \n", freq/cpu_div, freq/ddr_div, (freq/cpu_div)/ahb_div);
+
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+#ifndef COMPRESSED_UBOOT
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+#endif /* #ifndef COMPRESSED_UBOOT */
+    return (flash_info->size);
+
+}
+
+extern flash_info_t flash_info[];
+
+#if defined(CONFIG_CMD_PLL)
+int do_ar7100_pll (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    char    sectorBuff[65536];
+    int     index;
+
+    /*
+    ** read the flash sector
+    */
+    memcpy(sectorBuff,(void *)BOARDCAL, 65536);
+    if (argc == 1)  {
+        printf("current PLL setting %d\n", sectorBuff[19]);
+        return 0;
+    }
+
+    /*
+    ** Argv[1] contains the value string.  Convert to binary
+    */
+
+    index = simple_strtoul(argv[1],0,10);
+
+    /*
+    ** If the serial number is less than 0, or greater than 8, it's out of range
+    */
+
+    if(index < 0 || index > 8)
+    {
+        printf("index %d out of range\n", index);
+        return 1;
+    }
+
+    /* store a u32 at offset 16. we are on big-endian arch, so ... */
+    sectorBuff[16] = 0;
+    sectorBuff[17] = 0;
+    sectorBuff[18] = 0;
+    sectorBuff[19] = index;
+
+    flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+    write_buff(flash_info,sectorBuff, BOARDCAL, 65536);
+
+    return 0;
+}
+
+/* N.B.: These values should match CFG_PLL_* values in ar7100.h */
+U_BOOT_CMD(
+    ar7100_pll, 2, 0, do_ar7100_pll,
+    "ar7100_pll - Set CPU/DDR/AHB frequencies\n",
+    "ar7100_pll <index> - Set CPU/DDR/AHB frequencies based on the list below:\n"
+    "\t0 - 200/200/100\n"
+    "\t1 - 300/300/150\n"
+    "\t2 - 333/333/166\n"
+    "\t3 - 266/266/133\n"
+    "\t4 - 266/266/66\n"
+    "\t5 - 400/400/200\n"
+    "\t6 - 360/360/180\n"
+    "\t7 - 400/400/100\n"
+    "\t8 - 680/340/170\n"
+);
+#endif /* #if defined(CONFIG_CMD_PLL) */
+
+#ifdef AG7100_DEBUG
+extern int ag7100_rxdbg;
+int do_rxdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_rxdbg = 1;
+    else ag7100_rxdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    rxdbg, 2, 0, do_rxdbg_ctl,
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+extern int ag7100_txdbg;
+int do_txdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_txdbg = 1;
+    else ag7100_txdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    txdbg, 2, 0, do_txdbg_ctl,
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+#endif /* AG7100_DEBUG */
diff --git a/board/ar7100/pb44/pb44_pci.c b/board/ar7100/pb44/pb44_pci.c
new file mode 100644
index 0000000000..6a475a2ee6
--- /dev/null
+++ b/board/ar7100/pb44/pb44_pci.c
@@ -0,0 +1,372 @@
+/*****************************************************************************/
+/*! file ap94_pci.c
+** /brief PCI support for PB45 board derived from AP94. plat_dev_init()
+** is removed as PB45 has two mini-PCI slots and no calibration data in
+** Flash.
+**
+**  This provides the support code required for PCI support on the PB45
+**  board in the U-Boot environment.  This board is a Hydra based system.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7100_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+/*
+ * Mask table, bits to mask for quantity of size 1, 2 or 4 bytes.
+ * 0 and 3 are not valid indexes...
+ */
+static uint32_t bytemask[] = {
+	/*0*/	0,
+	/*1*/	0xff,
+	/*2*/	0xffff,
+	/*3*/	0,
+	/*4*/	0xffffffff,
+};
+
+static void crp_read(uint32_t ad_cbe, uint32_t *data);
+static void crp_write(uint32_t ad_cbe, uint32_t data);
+static int  ar7100_check_error(int verbose);
+static int  ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data);
+static int  ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data);
+static uint32_t ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where);
+static uint32_t local_byte_lane_enable_bits(uint32_t n, int size);
+static int  ar7100_local_read_config(int where, int size, uint32_t *value);
+static int  ar7100_local_write_config(int where, int size, uint32_t value);
+
+
+/*
+ * Read from PCI config space (host ctrl)
+ */
+static void crp_read(uint32_t ad_cbe, uint32_t *data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, ad_cbe);
+	*data     =  ar7100_reg_rd(AR7100_PCI_CRP_RDDATA);
+}
+
+/*
+ * Write to PCI config space (host ctrl)
+ */
+static void crp_write(uint32_t ad_cbe, uint32_t data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, (AR7100_CRP_CMD_WRITE | ad_cbe));
+	ar7100_reg_wr(AR7100_PCI_CRP_WRDATA, data);
+}
+
+
+/*
+ * Check for PCI errors (aborts, parity etc.), for configuration cycles
+ * PCI error reg: 1:0
+ * AHB error reg: 0
+ * Both write-back-1 to clear.
+ */
+static int
+ar7100_check_error(int verbose)
+{
+    uint32_t error = 0, trouble = 0, status;
+
+    error = ar7100_reg_rd(AR7100_PCI_ERROR) & 3;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("PCI error %d at PCI addr 0x%x status %#x\n",
+                    error, ar7100_reg_rd(AR7100_PCI_ERROR_ADDRESS),
+                    status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_ERROR, error);
+        ar7100_local_write_config(PCI_STATUS, 2, status);
+        /*
+         * flush
+         */
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+        trouble = 1;
+    }
+
+    error = 0;
+    error = ar7100_reg_rd(AR7100_PCI_AHB_ERROR) & 1;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("AHB error %d at AHB address 0x%x status %#x\n",
+                   ar7100_reg_rd(AR7100_PCI_AHB_ERROR_ADDRESS), status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_AHB_ERROR, error);
+        trouble = 1;
+    }
+
+    return trouble;
+}
+
+static int
+ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/*
+     * the result of the read is now in CFG_RDATA
+     */
+    if (!ar7100_check_error(0))
+        *data = ar7100_reg_rd(AR7100_PCI_CFG_RDDATA);
+    else {
+        *data = 0xffffffff;
+        retval = 1;
+    }
+
+	return retval;
+}
+
+static int
+ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/*
+     * execute the write by writing to CFG_WDATA
+     */
+    ar7100_reg_wr(AR7100_PCI_CFG_WRDATA, data);
+
+    if (ar7100_check_error(0))
+        retval = 1;
+
+	return retval;
+}
+
+/*
+ * This is assuming idsel of device 0 is connected to Address line 17
+ * Address for type 0 config is as follows:
+ * AD:
+ *  1:0 00 indicates type zero transaction
+ *  7:2    indicates the target config dword
+ *  10:8   indicates the target function within the physical device
+ *  31:11  are reserved (and most probably used to connect idsels)
+ */
+static uint32_t
+ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where)
+{
+	uint32_t addr;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = (1 << (AR7100_PCI_IDSEL_ADLINE_START + PCI_DEV(devfn))) |
+               ((PCI_FUNC(devfn)) << 8)                                 |
+		       (where & ~3);
+	} else {
+		/* type 1 */
+		addr = (bus_num << 16) | ((PCI_DEV(devfn)) << 11) |
+			((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;
+	}
+
+	return addr;
+}
+
+
+static uint32_t
+local_byte_lane_enable_bits(uint32_t n, int size)
+{
+	if (size == 1)
+		return (0xf & ~BIT(n)) << 20;
+	if (size == 2)
+		return (0xf & ~(BIT(n) | BIT(n+1))) << 20;
+	if (size == 4)
+		return 0;
+	return 0xffffffff;
+}
+
+static int
+ar7100_local_read_config(int where, int size, uint32_t *value)
+{
+	uint32_t n, data;
+
+	/*printk("ar7100_local_read_config from %d size %d\n", where, size);*/
+	n = where % 4;
+	crp_read(where & ~3, &data);
+	*value = (data >> (8*n)) & bytemask[size];
+	/*printk("ar7100_local_read_config read %#x\n", *value);*/
+
+	return 0;
+}
+
+static int
+ar7100_local_write_config(int where, int size, uint32_t value)
+{
+	uint32_t n, byte_enables, data;
+
+	n = where % 4;
+	byte_enables = local_byte_lane_enable_bits(n, size);
+	if (byte_enables == 0xffffffff)
+		return -1;
+	data = value << (8*n);
+	crp_write((where & ~3) | byte_enables, data);
+
+	return 0;
+}
+
+
+static int ar7100_pci_read_config(struct pci_controller *hose,
+			      pci_dev_t dev, int offset, u32* value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_read(addr, AR7100_CFG_CMD_READ, value);
+
+	return 0;
+}
+
+
+static int
+ar7100_pci_write_config(struct pci_controller *hose, pci_dev_t dev, int offset, u32 value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_write(addr, AR7100_CFG_CMD_WRITE, value);
+	return 0;
+}
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7100 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef COMPRESSED_UBOOT
+int  pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+    uint32_t cmd, val;
+
+    ar7100_reg_rmw_set(AR7100_RESET,
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_reg_rmw_clear(AR7100_RESET,
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_write_pci_window(0);
+    ar7100_write_pci_window(1);
+    ar7100_write_pci_window(2);
+    ar7100_write_pci_window(3);
+    ar7100_write_pci_window(4);
+    ar7100_write_pci_window(5);
+    ar7100_write_pci_window(6);
+    ar7100_write_pci_window(7);
+
+    udelay(1000 * 1000);
+
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+          PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+    ar7100_local_write_config(PCI_COMMAND, 4, cmd);
+
+    /*
+     * clear any lingering errors and register core error IRQ
+     */
+    ar7100_check_error(0);
+
+#ifndef COMPRESSED_UBOOT
+    /*
+    ** Now, configure for u-boot tools
+    */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region( &hose.regions[0],
+		            0x80000000,
+		            0x00000000,
+		            32 * 1024 * 1024,
+		            PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region( &hose.regions[1],
+		            0x10000000,
+		            0x10000000,
+		            128 * 1024 * 1024,
+		            PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(&hose,
+		pci_hose_read_config_byte_via_dword,
+		pci_hose_read_config_word_via_dword,
+		ar7100_pci_read_config,
+		pci_hose_write_config_byte_via_dword,
+		pci_hose_write_config_word_via_dword,
+		ar7100_pci_write_config);
+#else
+    return 0;
+#endif /* #ifndef COMPRESSED_UBOOT */
+}
diff --git a/board/ar7100/pb44/u-boot-bootstrap.lds b/board/ar7100/pb44/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..2f01270d05
--- /dev/null
+++ b/board/ar7100/pb44/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7100/pb44/u-boot.lds b/board/ar7100/pb44/u-boot.lds
new file mode 100644
index 0000000000..9ac25bead9
--- /dev/null
+++ b/board/ar7100/pb44/u-boot.lds
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/pb47/Makefile b/board/ar7100/pb47/Makefile
new file mode 100644
index 0000000000..534be3709b
--- /dev/null
+++ b/board/ar7100/pb47/Makefile
@@ -0,0 +1,13 @@
+
+include $(TOPDIR)/config.mk
+LIB = lib$(BOARD).a
+OBJS = $(BOARD).o ../common/ar7100_flash.o ../common/generic_spi.o ../common/athrf1_phy.o pb47_pci.o
+SOBJS = ../common/lowlevel_init.o
+
+$(LIB): .depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+.depend: Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+	$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
diff --git a/board/ar7100/pb47/config.mk b/board/ar7100/pb47/config.mk
new file mode 100644
index 0000000000..4a032b7f0c
--- /dev/null
+++ b/board/ar7100/pb47/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa0010000
diff --git a/board/ar7100/pb47/lowlevel_init.S b/board/ar7100/pb47/lowlevel_init.S
new file mode 100755
index 0000000000..c769f918e6
--- /dev/null
+++ b/board/ar7100/pb47/lowlevel_init.S
@@ -0,0 +1,428 @@
+/*****************************************************************************/
+/*! file lowlevel_init.s
+** /brief Low Level initialization routine for AP94
+**
+**
+**
+**  Copyright (c) 200x Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7100_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val_reg(_reg, _mask, _valreg)           \
+    li  t7, _reg;                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    or  t8, t8, _valreg;                            \
+    sw  t8, 0(t7)
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                                   \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7100_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7100_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_reg(_mask, _reg)                    \
+    set_val_reg(AR7100_CPU_PLL_CONFIG,  _mask, _reg)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7100_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                               \
+    clear_mask(AR7100_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                         \
+    set_val(AR7100_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)              \
+    get_val(AR7100_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+#define MEMDELAY(count, reg)	\
+	li	    reg, count;	\
+9:	addi	reg, -1;	\
+	bgtz	reg, 9b;	\
+	nop
+
+
+#define PLL_CONFIG_SW_UPDATE_VAL (1 << 31)
+#define CLOCK_CTRL_SWITCH_VAL (1 << 1)
+
+/* at 16 bytes offset from the beginning of last sector of 8MB flash part */
+#define CFG_FLASH_PLL_SETTING_ADDR  0x1fff0010
+#define AR7100_SPI_CLOCK (AR7100_SPI_BASE + 4)
+
+/* t0 - t5 will have the return results. a0 clobbered */
+get_flash_pll_setting:
+    /* Disable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x43
+    sw      t0, 0(a0)
+
+    /* Now read pll setting fm flash */
+    li      t0, KSEG1ADDR(CFG_FLASH_PLL_SETTING_ADDR)
+    lw      t1, 0(t0)
+
+    /* Enable SPI remap */
+    li      a0, KSEG1ADDR(AR7100_SPI_CLOCK)
+    li      t0, 0x3
+    sw      t0, 0(a0)
+
+    /*
+    ** check the range of values
+    */
+
+    li      t0, CFG_PLL_200_200_100
+    blt     t1, t0, 1f
+    nop
+    li      t0, CFG_PLL_680_340_170
+    ble     t1, t0, 2f
+    nop
+
+1:
+        /* Value is bad use compiled value */
+
+#if (CFG_PLL_FREQ == CFG_PLL_680_340_170)
+    li      t1, CFG_PLL_680_340_170
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_100)
+    li      t1, CFG_PLL_400_400_100
+#elif (CFG_PLL_FREQ == CFG_PLL_360_360_180)
+    li      t1, CFG_PLL_360_360_180
+#elif (CFG_PLL_FREQ == CFG_PLL_400_400_200)
+    li      t1, CFG_PLL_400_400_200
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_66)
+    li      t1, CFG_PLL_266_266_66
+#elif (CFG_PLL_FREQ == CFG_PLL_266_266_133)
+    li      t1, CFG_PLL_266_266_133
+#elif (CFG_PLL_FREQ == CFG_PLL_333_333_166)
+    li      t1, CFG_PLL_333_333_166
+#elif (CFG_PLL_FREQ == CFG_PLL_300_300_150)
+    li      t1, CFG_PLL_300_300_150
+#elif (CFG_PLL_FREQ == CFG_PLL_200_200_100)
+    li      t1, CFG_PLL_200_200_100
+#else
+#error: must define CFG_PLL_FREQ
+#endif
+2:
+    li      t2, CFG_PLL_680_340_170
+    beq     t1, t2, pll_680_340_170
+    nop
+    li      t2, CFG_PLL_400_400_100
+    beq     t1, t2, pll_400_400_100
+    nop
+    li      t2, CFG_PLL_360_360_180
+    beq     t1, t2, pll_360_360_180
+    nop
+    li      t2, CFG_PLL_400_400_200
+    beq     t1, t2, pll_400_400_200
+    nop
+    li      t2, CFG_PLL_266_266_66
+    beq     t1, t2, pll_266_266_66
+    nop
+    li      t2, CFG_PLL_266_266_133
+    beq     t1, t2, pll_266_266_133
+    nop
+    li      t2, CFG_PLL_333_333_166
+    beq     t1, t2, pll_333_333_166
+    nop
+    li      t2, CFG_PLL_300_300_150
+    beq     t1, t2, pll_300_300_150
+    nop
+    li      t2, CFG_PLL_200_200_100
+    b       pll_200_200_100
+    nop
+
+pll_680_340_170:
+    li      t0, (0x0  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x10 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x1  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_400_400_100:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_360_360_180:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1b << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x5  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_400_400_200:
+    li      t0, (0x1  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x1  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_66:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x1  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_266_266_133:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_333_333_166:
+    li      t0, (0x2  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x2  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x18 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_300_300_150:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x1d << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x0  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+pll_200_200_100:
+    li      t0, (0x3  << PLL_CONFIG_CPU_DIV_SHIFT)
+    li      t1, (0x3  << PLL_CONFIG_DDR_DIV_SHIFT)
+    li      t2, (0x0  << PLL_CONFIG_AHB_DIV_SHIFT)
+    li      t3, (0x13 << PLL_CONFIG_PLL_FB_SHIFT)
+    li      t4, (0x3  << PLL_CONFIG_PLL_LOOP_BW_SHIFT)
+    li      t5, (0x0  << PLL_CONFIG_PLL_DIVOUT_SHIFT)
+    b       got_setting
+    nop
+
+got_setting:
+    jr ra
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+#if 1
+    /* store return address to return to caller function */
+    move s0, ra
+    /* regs t0-t5 will have the settings */
+    la   t9, get_flash_pll_setting
+    jalr t9
+    nop
+    /* restore return address */
+    move ra, s0
+    pll_set_reg(PLL_CONFIG_CPU_DIV_MASK, t0)
+    pll_set_reg(PLL_CONFIG_AHB_DIV_MASK, t2)
+    pll_set_reg(PLL_CONFIG_DDR_DIV_MASK, t1)
+    pll_set_reg(PLL_CONFIG_PLL_DIVOUT_MASK, t5)
+
+#else
+    pll_set(PLL_CONFIG_CPU_DIV_MASK,    PLL_CONFIG_CPU_DIV_VAL)
+    pll_set(PLL_CONFIG_AHB_DIV_MASK,    PLL_CONFIG_AHB_DIV_VAL)
+    pll_set(PLL_CONFIG_DDR_DIV_MASK,    PLL_CONFIG_DDR_DIV_VAL)
+    pll_set(PLL_CONFIG_PLL_DIVOUT_MASK, PLL_CONFIG_PLL_DIVOUT_VAL)
+#endif
+
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+
+    /*
+     * Will cause a reset
+     */
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CTRL_SWITCH_VAL)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+initialize_pll:
+    pll_set(PLL_CONFIG_SW_UPDATE_MASK, PLL_CONFIG_SW_UPDATE_VAL)
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+#if 1
+    pll_set_reg(PLL_CONFIG_PLL_FB_MASK, t3)
+    pll_set_reg(PLL_CONFIG_PLL_LOOP_BW_MASK, t4)
+#else
+    pll_set(PLL_CONFIG_PLL_FB_MASK, PLL_CONFIG_PLL_FB_VAL)
+    pll_set(PLL_CONFIG_PLL_LOOP_BW_MASK, PLL_CONFIG_PLL_LOOP_BW_VAL)
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_POWER_DOWN_MASK);
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK);
+
+wait_for_pll_lock:
+    pll_get(PLL_CONFIG_LOCKED_MASK, PLL_CONFIG_LOCKED_SHIFT, t6)
+    beq zero, t6, wait_for_pll_lock
+    nop
+
+
+pll_locked:
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 1)
+
+    /*
+    ** Now, time to initialize memory.  We'll do the early initialization here
+    ** (taken directly from Redboot), and the later initialization will not be
+    ** performed.  Better all around.
+    **
+    ** Since AP-94 is a fixed design, we'll ensure the config value has the correct
+    ** CAS latency.
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONFIG)
+	li	    t0, CFG_DDR_CONFIG_VAL
+	sw	    t0, 0(a0)
+	nop
+
+    /*
+    ** Load all other values
+    */
+
+	li      a1, KSEG1ADDR(AR7100_DDR_CONFIG2)
+	li	    t8, CFG_DDR_CONFIG2_VAL
+	sw	    t8, 0(a1)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting the mode register
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_CONTROL)
+    li      a1, KSEG1ADDR(AR7100_DDR_EXT_MODE)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, CFG_DDR_EXT_MODE_VAL
+    sw      t5, 0(a1)
+    MEMDELAY(30, t2)
+
+    li      t5, 2
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      t5, 8
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+	/*
+    **  Want to set the mode value.  since AP-94 only operates at
+    ** one speed, we don't need to check the speed setting
+    */
+
+    li      a2, KSEG1ADDR(AR7100_DDR_MODE)
+	li	    t5, CFG_DDR_MODE_VAL
+    sw	    t5, 0(a2)
+	MEMDELAY(30, t2)
+
+    li      t5, 1
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    /*
+    ** Setting refresh, data this cycle, and tap words
+    */
+
+    li      a0, KSEG1ADDR(AR7100_DDR_REFRESH)
+    li      t5, CFG_DDR_REFRESH_VAL
+    sw      t5, 0(a0)
+    MEMDELAY(30, t2)
+
+    li      a2, KSEG1ADDR(AR7100_DDR_RD_DATA_THIS_CYCLE)
+	li	    t5, CFG_DDR_RD_DATA_THIS_CYCLE_VAL
+	sw	    t5, 0(a2)
+
+    li      a1, 0x07
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL0)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL1)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL2)
+    sw      a1, 0(a0)
+    li      a0, KSEG1ADDR(AR7100_DDR_TAP_CONTROL3)
+    sw      a1, 0(a0)
+    nop
+
+    jr ra
+
+ /* end of file */
diff --git a/board/ar7100/pb47/pb47.c b/board/ar7100/pb47/pb47.c
new file mode 100644
index 0000000000..5320eb8f73
--- /dev/null
+++ b/board/ar7100/pb47/pb47.c
@@ -0,0 +1,220 @@
+/*****************************************************************************/
+/*! file pb47.c
+** /brief Boot support for PB47 board. First version identical to pb45.c
+**
+**  This provides the support code required for the AP94 board in the U-Boot
+**  environment.  This board is a Hydra based system with two Merlin WLAN
+**  interfaces.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7100_soc.h"
+
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_mem_config
+**
+**  This is a "C" level implementation of the memory configuration interface
+**  for the PB47.
+**
+**  \return RAM size in bytes
+*/
+
+int
+ar7100_mem_config(void)
+{
+
+    /* XXX - should be set based board configuration */
+    *(volatile unsigned int *)0xb8050004 = 0x400050C0;
+    udelay(10);
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+    *(volatile unsigned int *)0xb805001c = 0x76; /* 66MHz at 1GHz PLL */
+    udelay(10);
+    *(volatile unsigned int *)0xb8050010 = 0x1099;
+    udelay(10);
+
+    return (ar7100_ddr_find_size());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+long int initdram(int board_type)
+{
+    printf("b8050000: 0x%x\n",* (unsigned long *)(0xb8050000));
+    return (ar7100_mem_config());
+}
+
+/******************************************************************************/
+/*!
+**  \brief ar7100_usb_initial_config
+**
+**  -- Enter Detailed Description --
+**
+**  \param param1 Describe Parameter 1
+**  \param param2 Describe Parameter 2
+**  \return Describe return value, or N/A for void
+*/
+
+int checkboard (void)
+{
+    unsigned long pll, pll_div, cpu_div, ahb_div, ddr_div, freq;
+
+    printf("PB47 (ar7100) U-boot \n");
+
+    pll = ar7100_reg_rd(AR7100_CPU_PLL_CONFIG);
+
+    pll_div  = ((pll & PLL_CONFIG_PLL_FB_MASK) >> PLL_CONFIG_PLL_FB_SHIFT) + 1;
+    freq     = pll_div * 40;
+    cpu_div  = ((pll & PLL_CONFIG_CPU_DIV_MASK) >> PLL_CONFIG_CPU_DIV_SHIFT) + 1;
+    ddr_div  = ((pll & PLL_CONFIG_DDR_DIV_MASK) >> PLL_CONFIG_DDR_DIV_SHIFT) + 1;
+    ahb_div  = (((pll & PLL_CONFIG_AHB_DIV_MASK) >> PLL_CONFIG_AHB_DIV_SHIFT) + 1)*2;
+
+    printf("Frequency: CPU %d MHz, DDR %d MHz, AHB %dMHz \n", freq/cpu_div, freq/ddr_div, (freq/cpu_div)/ahb_div);
+
+    return 0;
+}
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = 8*1024*1024; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
+
+extern flash_info_t flash_info[];
+
+int do_ar7100_pll (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    char    sectorBuff[65536];
+    int     index;
+
+    /*
+    ** read the flash sector
+    */
+    memcpy(sectorBuff,(void *)BOARDCAL, 65536);
+    if (argc == 1)  {
+        printf("current PLL setting %d\n", sectorBuff[19]);
+        return 0;
+    }
+
+    /*
+    ** Argv[1] contains the value string.  Convert to binary
+    */
+
+    index = simple_strtoul(argv[1],0,10);
+
+    /*
+    ** If the serial number is less than 0, or greater than 8, it's out of range
+    */
+
+    if(index < 0 || index > 8)
+    {
+        printf("index %d out of range\n", index);
+        return 1;
+    }
+
+    /* store a u32 at offset 16. we are on big-endian arch, so ... */
+    sectorBuff[16] = 0;
+    sectorBuff[17] = 0;
+    sectorBuff[18] = 0;
+    sectorBuff[19] = index;
+
+    flash_erase(flash_info,CAL_SECTOR,CAL_SECTOR);
+    write_buff(flash_info,sectorBuff, BOARDCAL, 65536);
+
+    return 0;
+}
+
+/* N.B.: These values should match CFG_PLL_* values in ar7100.h */
+U_BOOT_CMD(
+    ar7100_pll, 2, 0, do_ar7100_pll,
+    "ar7100_pll - Set CPU/DDR/AHB frequencies\n",
+    "ar7100_pll <index> - Set CPU/DDR/AHB frequencies based on the list below:\n"
+    "\t0 - 200/200/100\n"
+    "\t1 - 300/300/150\n"
+    "\t2 - 333/333/166\n"
+    "\t3 - 266/266/133\n"
+    "\t4 - 266/266/66\n"
+    "\t5 - 400/400/200\n"
+    "\t6 - 360/360/180\n"
+    "\t7 - 400/400/100\n"
+    "\t8 - 680/340/170\n"
+);
+
+
+#ifdef AG7100_DEBUG
+extern int ag7100_rxdbg;
+int do_rxdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_rxdbg = 1;
+    else ag7100_rxdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    rxdbg, 2, 0, do_rxdbg_ctl,
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "rxdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+extern int ag7100_txdbg;
+int do_txdbg_ctl (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    uint16_t val;
+    if (argc != 2) {
+        printf("incorrect format\n");
+        return 1;
+    }
+    val = simple_strtoul (argv[1], NULL, 16);
+    if (val) ag7100_txdbg = 1;
+    else ag7100_txdbg = 0;
+    return 0;
+}
+U_BOOT_CMD(
+    txdbg, 2, 0, do_txdbg_ctl,
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n",
+    "txdbg - 1 to turn on rx pkt prints, 0 to turn off\n"
+);
+
+#endif /* AG7100_DEBUG */
diff --git a/board/ar7100/pb47/pb47_pci.c b/board/ar7100/pb47/pb47_pci.c
new file mode 100644
index 0000000000..acc1d51f79
--- /dev/null
+++ b/board/ar7100/pb47/pb47_pci.c
@@ -0,0 +1,366 @@
+/*****************************************************************************/
+/*! file ap94_pci.c
+** /brief PCI support for PB45 board derived from AP94. plat_dev_init()
+** is removed as PB45 has two mini-PCI slots and no calibration data in
+** Flash.
+**
+**  This provides the support code required for PCI support on the PB45
+**  board in the U-Boot environment.  This board is a Hydra based system.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7100_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+/*
+ * Mask table, bits to mask for quantity of size 1, 2 or 4 bytes.
+ * 0 and 3 are not valid indexes...
+ */
+static uint32_t bytemask[] = {
+	/*0*/	0,
+	/*1*/	0xff,
+	/*2*/	0xffff,
+	/*3*/	0,
+	/*4*/	0xffffffff,
+};
+
+static void crp_read(uint32_t ad_cbe, uint32_t *data);
+static void crp_write(uint32_t ad_cbe, uint32_t data);
+static int  ar7100_check_error(int verbose);
+static int  ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data);
+static int  ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data);
+static uint32_t ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where);
+static uint32_t local_byte_lane_enable_bits(uint32_t n, int size);
+static int  ar7100_local_read_config(int where, int size, uint32_t *value);
+static int  ar7100_local_write_config(int where, int size, uint32_t value);
+
+
+/*
+ * Read from PCI config space (host ctrl)
+ */
+static void crp_read(uint32_t ad_cbe, uint32_t *data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, ad_cbe);
+	*data     =  ar7100_reg_rd(AR7100_PCI_CRP_RDDATA);
+}
+
+/*
+ * Write to PCI config space (host ctrl)
+ */
+static void crp_write(uint32_t ad_cbe, uint32_t data)
+{
+    ar7100_reg_wr(AR7100_PCI_CRP_AD_CBE, (AR7100_CRP_CMD_WRITE | ad_cbe));
+	ar7100_reg_wr(AR7100_PCI_CRP_WRDATA, data);
+}
+
+
+/*
+ * Check for PCI errors (aborts, parity etc.), for configuration cycles
+ * PCI error reg: 1:0
+ * AHB error reg: 0
+ * Both write-back-1 to clear.
+ */
+static int
+ar7100_check_error(int verbose)
+{
+    uint32_t error = 0, trouble = 0, status;
+
+    error = ar7100_reg_rd(AR7100_PCI_ERROR) & 3;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("PCI error %d at PCI addr 0x%x status %#x\n",
+                    error, ar7100_reg_rd(AR7100_PCI_ERROR_ADDRESS),
+                    status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_ERROR, error);
+        ar7100_local_write_config(PCI_STATUS, 2, status);
+        /*
+         * flush
+         */
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+        trouble = 1;
+    }
+
+    error = 0;
+    error = ar7100_reg_rd(AR7100_PCI_AHB_ERROR) & 1;
+
+    if (error) {
+        ar7100_local_read_config(PCI_STATUS, 2, &status);
+
+        if (verbose) {
+            printf("AHB error %d at AHB address 0x%x status %#x\n",
+                   ar7100_reg_rd(AR7100_PCI_AHB_ERROR_ADDRESS), status);
+        }
+
+        ar7100_reg_wr(AR7100_PCI_AHB_ERROR, error);
+        trouble = 1;
+    }
+
+    return trouble;
+}
+
+static int
+ar7100_pci_read(uint32_t addr, uint32_t cmd, uint32_t* data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/*
+     * the result of the read is now in CFG_RDATA
+     */
+    if (!ar7100_check_error(0))
+        *data = ar7100_reg_rd(AR7100_PCI_CFG_RDDATA);
+    else {
+        *data = 0xffffffff;
+        retval = 1;
+    }
+
+	return retval;
+}
+
+static int
+ar7100_pci_write(uint32_t addr, uint32_t cmd, uint32_t data)
+{
+	int retval = 0;
+
+    ar7100_reg_wr(AR7100_PCI_CFG_AD, addr);
+    ar7100_reg_wr(AR7100_PCI_CFG_CBE, cmd);
+
+	/*
+     * execute the write by writing to CFG_WDATA
+     */
+    ar7100_reg_wr(AR7100_PCI_CFG_WRDATA, data);
+
+    if (ar7100_check_error(0))
+        retval = 1;
+
+	return retval;
+}
+
+/*
+ * This is assuming idsel of device 0 is connected to Address line 17
+ * Address for type 0 config is as follows:
+ * AD:
+ *  1:0 00 indicates type zero transaction
+ *  7:2    indicates the target config dword
+ *  10:8   indicates the target function within the physical device
+ *  31:11  are reserved (and most probably used to connect idsels)
+ */
+static uint32_t
+ar7100_config_addr(uint8_t bus_num, uint16_t devfn, int where)
+{
+	uint32_t addr;
+
+	if (!bus_num) {
+		/* type 0 */
+		addr = (1 << (AR7100_PCI_IDSEL_ADLINE_START + PCI_DEV(devfn))) |
+               ((PCI_FUNC(devfn)) << 8)                                 |
+		       (where & ~3);
+	} else {
+		/* type 1 */
+		addr = (bus_num << 16) | ((PCI_DEV(devfn)) << 11) |
+			((PCI_FUNC(devfn)) << 8) | (where & ~3) | 1;
+	}
+
+	return addr;
+}
+
+
+static uint32_t
+local_byte_lane_enable_bits(uint32_t n, int size)
+{
+	if (size == 1)
+		return (0xf & ~BIT(n)) << 20;
+	if (size == 2)
+		return (0xf & ~(BIT(n) | BIT(n+1))) << 20;
+	if (size == 4)
+		return 0;
+	return 0xffffffff;
+}
+
+static int
+ar7100_local_read_config(int where, int size, uint32_t *value)
+{
+	uint32_t n, data;
+
+	/*printk("ar7100_local_read_config from %d size %d\n", where, size);*/
+	n = where % 4;
+	crp_read(where & ~3, &data);
+	*value = (data >> (8*n)) & bytemask[size];
+	/*printk("ar7100_local_read_config read %#x\n", *value);*/
+
+	return 0;
+}
+
+static int
+ar7100_local_write_config(int where, int size, uint32_t value)
+{
+	uint32_t n, byte_enables, data;
+
+	n = where % 4;
+	byte_enables = local_byte_lane_enable_bits(n, size);
+	if (byte_enables == 0xffffffff)
+		return -1;
+	data = value << (8*n);
+	crp_write((where & ~3) | byte_enables, data);
+
+	return 0;
+}
+
+
+static int ar7100_pci_read_config(struct pci_controller *hose,
+			      pci_dev_t dev, int offset, u32* value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_read(addr, AR7100_CFG_CMD_READ, value);
+
+	return 0;
+}
+
+
+static int
+ar7100_pci_write_config(struct pci_controller *hose, pci_dev_t dev, int offset, u32 value)
+{
+	uint32_t    addr;
+	uint8_t     bus_num = PCI_BUS(dev);
+    uint16_t    devfn = dev & 0xffff;
+
+	addr = ar7100_config_addr(bus_num, devfn, offset);
+	ar7100_pci_write(addr, AR7100_CFG_CMD_WRITE, value);
+	return 0;
+}
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7100 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+void pci_init_board (void)
+{
+    uint32_t cmd, val;
+
+    ar7100_reg_rmw_set(AR7100_RESET,
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_reg_rmw_clear(AR7100_RESET,
+                      (AR7100_RESET_PCI_BUS|AR7100_RESET_PCI_CORE));
+    udelay(1000 * 1000);
+
+    ar7100_write_pci_window(0);
+    ar7100_write_pci_window(1);
+    ar7100_write_pci_window(2);
+    ar7100_write_pci_window(3);
+    ar7100_write_pci_window(4);
+    ar7100_write_pci_window(5);
+    ar7100_write_pci_window(6);
+    ar7100_write_pci_window(7);
+
+    udelay(1000 * 1000);
+
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+          PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+    ar7100_local_write_config(PCI_COMMAND, 4, cmd);
+
+    /*
+     * clear any lingering errors and register core error IRQ
+     */
+    ar7100_check_error(0);
+
+    /*
+    ** Now, configure for u-boot tools
+    */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region( &hose.regions[0],
+		            0x80000000,
+		            0x00000000,
+		            32 * 1024 * 1024,
+		            PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region( &hose.regions[1],
+		            0x10000000,
+		            0x10000000,
+		            128 * 1024 * 1024,
+		            PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(&hose,
+		pci_hose_read_config_byte_via_dword,
+		pci_hose_read_config_word_via_dword,
+		ar7100_pci_read_config,
+		pci_hose_write_config_byte_via_dword,
+		pci_hose_write_config_word_via_dword,
+		ar7100_pci_write_config);
+
+    return 0;
+}
diff --git a/board/ar7100/pb47/u-boot.lds b/board/ar7100/pb47/u-boot.lds
new file mode 100644
index 0000000000..9ac25bead9
--- /dev/null
+++ b/board/ar7100/pb47/u-boot.lds
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/tb225/Makefile b/board/ar7100/tb225/Makefile
new file mode 100644
index 0000000000..f3e8c66cf6
--- /dev/null
+++ b/board/ar7100/tb225/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/vsc_phy.o ../common/ipPhy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/tb225/config.mk b/board/ar7100/tb225/config.mk
new file mode 100644
index 0000000000..f834c98c11
--- /dev/null
+++ b/board/ar7100/tb225/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbfc00000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/tb225/flash.c b/board/ar7100/tb225/flash.c
new file mode 100644
index 0000000000..ff99f9b044
--- /dev/null
+++ b/board/ar7100/tb225/flash.c
@@ -0,0 +1,26 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size      = (CFG_MAX_FLASH_BANKS * CFG_MAX_FLASH_SECT *
+                            CFG_FLASH_SECTOR_SIZE);
+    flash_info->sector_count = CFG_MAX_FLASH_SECT;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+	printf ("flash size %dMB\n", flash_info->size/(1024*1024));
+	return (flash_info->size);
+}
diff --git a/board/ar7100/tb225/tb225.c b/board/ar7100/tb225/tb225.c
new file mode 100644
index 0000000000..edb8490ad6
--- /dev/null
+++ b/board/ar7100/tb225/tb225.c
@@ -0,0 +1,55 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include "ar7100_soc.h"
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    ar7100_ddr_width_t width;
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+    ar7100_ddr_tap_config();
+
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("TB42 (ar7100) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7100/tb225/u-boot.lds b/board/ar7100/tb225/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/tb225/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7100/tb243/Makefile b/board/ar7100/tb243/Makefile
new file mode 100644
index 0000000000..e3785e760f
--- /dev/null
+++ b/board/ar7100/tb243/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7100_flash.o
+SOBJS	= ../common/lowlevel_init_ar9100.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7100/tb243/config.mk b/board/ar7100/tb243/config.mk
new file mode 100755
index 0000000000..1d06cc5eb1
--- /dev/null
+++ b/board/ar7100/tb243/config.mk
@@ -0,0 +1,6 @@
+# ROM version
+#TEXT_BASE = 0x80500000
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0xa1000000
diff --git a/board/ar7100/tb243/tb243.c b/board/ar7100/tb243/tb243.c
new file mode 100644
index 0000000000..d61186fe7a
--- /dev/null
+++ b/board/ar7100/tb243/tb243.c
@@ -0,0 +1,83 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include "ar7100_soc.h"
+
+int
+ar7100_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+#if 0
+    ar7100_ddr_width_t width;
+#endif
+
+    ar7100_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7100_ddr_tap_config();
+#else
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL0, 0x5);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL1, 0x5);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL2, 0x5);
+    ar7100_reg_wr (AR7100_DDR_TAP_CONTROL3, 0x5);
+#endif
+
+#if 0
+    ddr_config   = ar7100_reg_rd(AR7100_DDR_CONFIG);
+    ddr_config2  = ar7100_reg_rd(AR7100_DDR_CONFIG2);
+    width        = ar7100_ddr_get_width();
+
+    if (width != AR7100_DDR_32B)
+        ddr_config |= AR7100_DDR_CONFIG_16BIT;
+    if (width == AR7100_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7100_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7100_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7100_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7100_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7100_reg_wr(AR7100_DDR_CONFIG, ddr_config);
+    ar7100_reg_wr(AR7100_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here! */
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+#ifndef AR9100
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+#endif
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+
+    /* Temp addition - check with Ravi */
+    *(volatile unsigned int *)0xb8080008 = 0x00000040;
+    udelay(100);
+    return (ar7100_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7100_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("TB243 (ar7100) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7100/tb243/u-boot.lds b/board/ar7100/tb243/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7100/tb243/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap101-2.6.31/Makefile b/board/ar7240/ap101-2.6.31/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap101-2.6.31/ap101-2.6.31.c b/board/ar7240/ap101-2.6.31/ap101-2.6.31.c
new file mode 100644
index 0000000000..099a578b66
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/ap101-2.6.31.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP101 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP101 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap101-2.6.31/config.mk b/board/ar7240/ap101-2.6.31/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap101-2.6.31/flash.c b/board/ar7240/ap101-2.6.31/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap101-2.6.31/u-boot.lds b/board/ar7240/ap101-2.6.31/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap101-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap101-small/Makefile b/board/ar7240/ap101-small/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap101-small/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap101-small/ap101-small.c b/board/ar7240/ap101-small/ap101-small.c
new file mode 100644
index 0000000000..099a578b66
--- /dev/null
+++ b/board/ar7240/ap101-small/ap101-small.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP101 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP101 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap101-small/config.mk b/board/ar7240/ap101-small/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap101-small/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap101-small/flash.c b/board/ar7240/ap101-small/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap101-small/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap101-small/u-boot.lds b/board/ar7240/ap101-small/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap101-small/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap101/Makefile b/board/ar7240/ap101/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap101/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap101/ap101.c b/board/ar7240/ap101/ap101.c
new file mode 100644
index 0000000000..099a578b66
--- /dev/null
+++ b/board/ar7240/ap101/ap101.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP101 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP101 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap101/config.mk b/board/ar7240/ap101/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap101/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap101/flash.c b/board/ar7240/ap101/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap101/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap101/u-boot.lds b/board/ar7240/ap101/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap101/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap111-2.6.31/Makefile b/board/ar7240/ap111-2.6.31/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap111-2.6.31/ap111-2.6.31.c b/board/ar7240/ap111-2.6.31/ap111-2.6.31.c
new file mode 100644
index 0000000000..d609814ed1
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/ap111-2.6.31.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP111 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP111 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap111-2.6.31/config.mk b/board/ar7240/ap111-2.6.31/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap111-2.6.31/flash.c b/board/ar7240/ap111-2.6.31/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap111-2.6.31/u-boot.lds b/board/ar7240/ap111-2.6.31/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap111-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap111/Makefile b/board/ar7240/ap111/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/ap111/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap111/ap111.c b/board/ar7240/ap111/ap111.c
new file mode 100644
index 0000000000..d609814ed1
--- /dev/null
+++ b/board/ar7240/ap111/ap111.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP111 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP111 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap111/config.mk b/board/ar7240/ap111/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap111/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap111/flash.c b/board/ar7240/ap111/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap111/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap111/u-boot.lds b/board/ar7240/ap111/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap111/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap120/Makefile b/board/ar7240/ap120/Makefile
new file mode 100644
index 0000000000..045813bfdd
--- /dev/null
+++ b/board/ar7240/ap120/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap120/ap120.c b/board/ar7240/ap120/ap120.c
new file mode 100644
index 0000000000..cfedf2aa12
--- /dev/null
+++ b/board/ar7240/ap120/ap120.c
@@ -0,0 +1,177 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+
+#if 0
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot AP120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot AP120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/ap120/config.mk b/board/ar7240/ap120/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/ap120/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/ap120/flash.c b/board/ar7240/ap120/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/ap120/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/ap120/u-boot-bootstrap.lds b/board/ar7240/ap120/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/ap120/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap120/u-boot.lds b/board/ar7240/ap120/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/ap120/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap121/Makefile b/board/ar7240/ap121/Makefile
new file mode 100644
index 0000000000..73fe788152
--- /dev/null
+++ b/board/ar7240/ap121/Makefile
@@ -0,0 +1,22 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+ifeq ($(BOARD), ap121)
+SOBJS	+= hornet_pll_init.o
+endif
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap121/ap121.c b/board/ar7240/ap121/ap121.c
new file mode 100644
index 0000000000..5aaf1b5e20
--- /dev/null
+++ b/board/ar7240/ap121/ap121.c
@@ -0,0 +1,142 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef CONFIG_HORNET_EMU
+extern void ar7240_ddr_initial_config_for_fpga(void);
+#endif
+
+void
+ar7240_usb_initial_config(void)
+{
+#ifndef CONFIG_HORNET_EMU
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+#endif
+}
+
+void
+ar7240_usb_otp_config(void)
+{
+    unsigned int addr, reg_val, reg_usb;
+    int time_out, status, usb_valid;
+
+    for (addr = 0xb8114014; ;addr -= 0x10) {
+        status = 0;
+        time_out = 20;
+
+        reg_val = ar7240_reg_rd(addr);
+
+        while ((time_out > 0) && (~status)) {
+            if ((( ar7240_reg_rd(0xb8115f18)) & 0x7) == 0x4) {
+                status = 1;
+            } else {
+                status = 0;
+            }
+            time_out--;
+        }
+
+        reg_val = ar7240_reg_rd(0xb8115f1c);
+        if ((reg_val & 0x80) == 0x80){
+            usb_valid = 1;
+            reg_usb = reg_val & 0x000000ff;
+        }
+
+        if (addr == 0xb8114004) {
+            break;
+        }
+    }
+
+    if (usb_valid) {
+        reg_val = ar7240_reg_rd(0xb8116c88);
+        reg_val &= ~0x03f00000;
+        reg_val |= (reg_usb & 0xf) << 22;
+        ar7240_reg_wr(0xb8116c88, reg_val);
+    }
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs
+     * clk_obs1(gpio13/bit8),  clk_obs2(gpio14/bit9), clk_obs3(gpio15/bit10),
+     * clk_obs4(gpio16/bit11), clk_obs5(gpio17/bit12)
+     * clk_obs0(gpio1/bit19), 6(gpio11/bit20)
+     */
+    ar7240_reg_wr (AR7240_GPIO_FUNC,
+        (ar7240_reg_rd(AR7240_GPIO_FUNC) & ~((0x1f<<8)|(0x3<<19))));
+
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | (0x1f<<3)));
+
+    /* Clear AR7240_GPIO_FUNC BIT2 to ensure that software can control LED5(GPIO16) and LED6(GPIO17)  */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & ~(0x1<<2)));
+
+    /* Set HORNET_BOOTSTRAP_STATUS BIT18 to ensure that software can control GPIO26 and GPIO27 */
+    //ar7240_reg_wr (HORNET_BOOTSTRAP_STATUS, (ar7240_reg_rd(HORNET_BOOTSTRAP_STATUS) | (0x1<<18)));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+#ifdef CONFIG_HORNET_EMU
+    ar7240_ddr_initial_config_for_fpga();
+#else
+    //ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#endif
+
+/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, CFG_DDR_TAP0_VAL);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, CFG_DDR_TAP1_VAL);
+
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+#ifndef CONFIG_HORNET_EMU
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+#endif
+
+    //ar7240_usb_initial_config();
+    ar7240_usb_otp_config();
+
+    hornet_ddr_tap_init();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+#if (BOARD_STRING == WAPI)
+    strcpy(board_string, "AP121 (ar9331) U-boot");
+#else
+    strcpy(board_string, "AP121-2MB (ar9330) U-boot");
+#endif
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP121-2MB (ar9330) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap121/config.mk b/board/ar7240/ap121/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap121/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap121/flash.c b/board/ar7240/ap121/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap121/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap121/hornet_pll_init.S b/board/ar7240/ap121/hornet_pll_init.S
new file mode 100755
index 0000000000..1172cbe446
--- /dev/null
+++ b/board/ar7240/ap121/hornet_pll_init.S
@@ -0,0 +1,377 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+    .globl hornet_pll_init
+	.text
+	.align 4
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+/*     or  t8, t8, t9;                                 \ */
+#define set_reg(_reg, _val)                         \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, _val;                                   \
+    sw  t9, 0(t7);
+
+hornet_pll_init:
+
+#if 1
+/* These three wlan reset will avoid original issue,
+so full chip reset isn't needed here. */
+    set_reg(0xb806001c, 0x00c06b30)
+    nop
+    set_reg(0xb806001c, 0x00c06330)
+    nop
+    set_reg(0xb806001c, 0x00c06b30)
+    nop
+    set_reg(0xb806001c, 0x00c06330)
+    nop
+reset_wlan:
+    set_reg(0xb806001c, 0x00c06b30)
+    nop
+    set_reg(0xb806001c, 0x00c06330)
+    nop
+
+    li  t5, 0x20
+check_val:
+    beq zero, t5, reset_wlan
+    addi t5, t5, -1
+    li  t6, 0xb80600ac
+    lw  t7, 0(t6)
+    li  t8, 0x10
+    and t7, t7, t8
+    bne zero, t7, check_val
+
+    set_reg(HORNET_BOOTSTRAP_STATUS, 0x0002110e)
+    nop
+#else
+/* clear wlan reset bit in RESET_Register 0x1c */
+    set_reg(AR7240_RESET, 0x00c06b30)
+    nop
+    set_reg(AR7240_RESET, 0x00c06330)
+    nop
+
+/* cleck bootstrap status, wait for bit4 on, then clear bit16 */
+wait_loop0:
+    li  t6, KSEG1ADDR(HORNET_BOOTSTRAP_STATUS)
+    lw  t7, 0(t6)
+    li  t8, 0x10
+    and t7, t7, t8
+    bne zero, t7, wait_loop0
+    nop
+    set_reg(HORNET_BOOTSTRAP_STATUS, 0x0002110e)
+    nop
+#endif
+
+/* RTC reset */
+    set_reg(0x1810704c, 0x00000003)
+    nop
+    nop
+    set_reg(0x18107040, 0x00000000)
+    nop
+    nop
+    set_reg(0x18107040, 0x00000001)
+    nop
+wait_loop1:
+    li  t6, KSEG1ADDR(0x18107044)
+    lw  t7, 0(t6)
+    li  t8, 0x2
+    and t7, t7, t8
+    bne t8, t7, wait_loop1
+    nop
+
+    /* AHB/APH reset */
+    set_reg(0x18104000, 0x00000003)
+    nop
+    set_reg(0x18104000, 0x00000000)
+    nop
+
+    /* MAC reset */
+    set_reg(0x18107000, 0x0000000F)
+    nop
+    set_reg(0x18107000, 0x00000000)
+    nop
+
+#if 1  /* fetch pmu1.refv and ctrl2.tx from OTP */
+    li  t1, KSEG1ADDR(0x18114014)
+    lw  t2, 0(t1)
+otp_loop0:
+    li  t3, KSEG1ADDR(0x18115f18)
+    lw  t4, 0(t3)
+    nop
+    li  t5, 0x7
+    and t4, t4, t5
+    li  t5, 0x4
+    bne t4, t5, otp_loop0
+    nop
+
+    li  t6, KSEG1ADDR(0x18115f1c)
+    lw  t7, 0(t6)
+    nop
+    li  t8, 0x80000080
+    and t9, t7, t8
+    beq t8, t9, fetch_otp
+otp_loop0_end:
+
+    li  t1, KSEG1ADDR(0x18114004)
+    lw  t2, 0(t1)
+otp_loop1:
+    li  t3, KSEG1ADDR(0x18115f18)
+    lw  t4, 0(t3)
+    nop
+    li  t5, 0x7
+    and t4, t4, t5
+    li  t5, 0x4
+    bne t4, t5, otp_loop1
+    nop
+
+    li  t6, KSEG1ADDR(0x18115f1c)
+    lw  t7, 0(t6)
+    nop
+    li  t8, 0x80000080
+    and t9, t7, t8
+default_pmu:
+    li  t5, 0x80             /* default 0x031c4386 */
+    bne t8, t9, otp_end
+otp_loop1_end:
+
+fetch_otp:
+    srl t8, t7, 0x18
+    li  t1, 0xf
+    and t2, t1 , t7         /* USB */
+    and t5, t1 , t8         /* PMU */
+
+check_pmu:
+    li t0, 0x4                         /* PMU range should be 0x4~0xa */
+    bgt t0, t5, default_pmu
+    nop
+    li t0, 0xa                         /* PMU range should be 0x4~0xa */
+    blt t0, t5, default_pmu
+    nop
+    li  t0, 0x4
+    sll t5, t5, t0
+
+otp_end:
+#endif
+
+#if 1 /* Program PMU */
+#define PMU_TEST_NO 1000
+    li  t6, KSEG1ADDR(0x18116c40)
+    li  t9, 0xbd000010
+    li  t0, 0
+    li  t1, 0
+    li  t2, 0
+
+    li  t3, PMU_TEST_NO
+    sw  t3, 12(t9)
+pmu_loop0:
+    beq zero, t3, pmu_loop0_end
+    nop
+    addi t3, t3, -1
+
+    #li  t7, 0x10000000 /* ldo_tune 0x0 */
+    #li  t7, 0x10080000 /* ldo_tune 0x1 */
+    #li  t7, 0x10100000 /* ldo_tune 0x2 */
+    li  t7, 0x10180000  /* ldo_tune 0x3 */
+    nop
+    sw  t7, 4(t6)
+    nop
+    lw  t8, 4(t6)
+    nop
+    beq t8, t7, pmu_loop0_end
+    nop
+
+    addiu  t0, t0, 1
+    b   pmu_loop0
+    nop
+pmu_loop0_end:
+
+    li  t3, PMU_TEST_NO
+pmu_loop1:
+    beq zero, t3, pmu_loop1_end
+    nop
+    addi t3, t3, -1
+
+    //li  t7, 0x031c4326    /* 1.100V */
+    //li  t7, 0x031c4336    /* 1.125V */
+    //li  t7, 0x031c4346    /* 1.150V */
+    //li  t7, 0x031c4356    /* 1.175V */
+    //li  t7, 0x031c4366    /* 1.200V */
+    //li  t7, 0x031c4376    /* 1.225V */
+    li  t7, 0x031c4386    /* 1.250V */
+    //li  t7, 0x031c4396    /* 1.275V */
+    //li  t7, 0x031c43a6    /* 1.300V */
+    nop
+#if 1 /* from OTP */
+    li  t8, 0xffffff0f
+    and t7, t7, t8
+    or  t7, t7, t5
+#endif
+    sw  t7, 0(t6)
+    nop
+    lw  t8, 0(t6)
+    nop
+    beq t8, t7, pmu_loop1_end
+    nop
+
+    addiu  t1, t1, 1
+    b   pmu_loop1
+    nop
+pmu_loop1_end:
+
+    li  t3, PMU_TEST_NO
+pmu_loop2:
+    beq zero, t3, pmu_loop2_end
+    nop
+    addi t3, t3, -1
+
+    #li  t7, 0x10200000 /* ldo_tune 0x0 */
+    #li  t7, 0x10280000 /* ldo_tune 0x1 */
+    #li  t7, 0x10300000 /* ldo_tune 0x2 */
+    li  t7, 0x10380000  /* ldo_tune 0x3 */
+    nop
+    sw  t7, 4(t6)
+    nop
+    lw  t8, 4(t6)
+    nop
+    beq t8, t7, pmu_loop2_end
+    nop
+
+    addiu  t2, t2, 1
+    b   pmu_loop2
+    nop
+pmu_loop2_end:
+
+    sw  t0, 0(t9)
+    nop
+    sw  t1, 4(t9)
+    nop
+    sw  t2, 8(t9)
+    nop
+#endif
+
+#if 1 /* Program ki, kd */
+    /* Program ki/kd */
+#if CONFIG_40MHZ_XTAL_SUPPORT
+    set_reg(0x18116244, 0x19e82f01)
+#else
+    set_reg(0x18116244, 0x18e82f01)
+#endif
+    nop
+
+    /* Program phase shift */
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0xc07fffff
+    and t7, t7, t8
+    li  t8, 0x800000
+    or  t7, t7, t8
+    sw  t7, 0(t6)
+    nop
+#endif
+
+/* set PLL bypass(Bit 2), CPU_POST_DIV, DDR_POST_DIV, AHB_POST_DIV in CPU clock control */
+    set_reg(AR7240_CPU_CLOCK_CONTROL, 0x00018004)
+    nop
+
+/* set SETTLE_TIME in CPU PLL */
+    set_reg(AR7240_USB_PLL_CONFIG, CPU_PLL_SETTLE_TIME_VAL)
+    nop
+
+pll_unlock_handler:
+
+/* set nint, frac, refdiv, outdiv, range in CPU PLL configuration resiter */
+    set_reg(AR7240_CPU_PLL_CONFIG, CPU_PLL_CONFIG_VAL1)
+    nop
+
+wait_loop2:
+    li  t6, KSEG1ADDR(AR7240_CPU_PLL_CONFIG)
+    lw  t7, 0(t6)
+    li  t8, 0x80000000
+    and t7, t7, t8
+    bne zero, t7, wait_loop2
+    nop
+
+/* put frac bit19:10 configuration */
+    set_reg(AR7240_PCIE_PLL_CONFIG, CPU_PLL_DITHER_FRAC_VAL)
+    nop
+
+/* clear PLL power down bit in CPU PLLl configuration */
+    set_reg(AR7240_CPU_PLL_CONFIG, CPU_PLL_CONFIG_VAL2)
+    nop
+wait_loop3:
+    li  t6, KSEG1ADDR(AR7240_CPU_PLL_CONFIG)
+    lw  t7, 0(t6)
+    li  t8, 0x80000000
+    and t7, t7, t8
+    bne zero, t7, wait_loop3
+    nop
+
+/* confirm DDR PLL lock */
+    li  t3, 100
+    li  t4, 0
+start_meas0:
+    addi t4, t4, 1
+    bgt t4, t3, pll_unlock_handler
+    nop
+    li  t5, 5
+start_meas:
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0xbfffffff
+    and t7, t7, t8
+    sw  t7, 0(t6)
+    nop
+
+/* delay */
+    li t9, 10
+delayloop0:
+    subu t9, t9, 1
+    bne t9, zero, delayloop0
+    nop
+
+    li  t8, 0x40000000
+    or  t7, t7, t8
+    sw  t7, 0(t6)
+    nop
+
+meas_done_statue:
+    li  t6, KSEG1ADDR(0x1811624c)
+    lw  t7, 0(t6)
+    li  t8, 0x8
+    and t7, t7, t8
+    beq zero, t7, meas_done_statue
+    nop
+
+meas_result:
+    li  t6, KSEG1ADDR(0x18116248)
+    lw  t7, 0(t6)
+    li  t8, 0x007ffff8
+    and t7, t7, t8
+    srl t7, t7, 3
+    li  t8, 0x4000
+    bgt t7, t8, start_meas0
+    nop
+    addi t5, t5, -1
+    bne zero, t5, start_meas
+    nop
+
+/* clear PLL bypass(Bit 2), CPU_POST_DIV, DDR_POST_DIV, AHB_POST_DIV in CPU clock control */
+    set_reg(AR7240_CPU_CLOCK_CONTROL, CPU_CLK_CONTROL_VAL2)
+    nop
+
+/* Sync mode , Set Bit 8 of DDR Tap Conrtol 3 register */
+    set_reg(AR7240_DDR_TAP_CONTROL3, 0x10105);
+    nop
+
+    jr ra
+    nop
+
+ /* end of file */
diff --git a/board/ar7240/ap121/u-boot-bootstrap.lds b/board/ar7240/ap121/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap121/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap121/u-boot.lds b/board/ar7240/ap121/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap121/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap123/Makefile b/board/ar7240/ap123/Makefile
new file mode 100644
index 0000000000..045813bfdd
--- /dev/null
+++ b/board/ar7240/ap123/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap123/ap123.c b/board/ar7240/ap123/ap123.c
new file mode 100644
index 0000000000..9df940a18b
--- /dev/null
+++ b/board/ar7240/ap123/ap123.c
@@ -0,0 +1,171 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/ap123/config.mk b/board/ar7240/ap123/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/ap123/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/ap123/flash.c b/board/ar7240/ap123/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/ap123/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/ap123/u-boot-bootstrap.lds b/board/ar7240/ap123/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/ap123/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap123/u-boot.lds b/board/ar7240/ap123/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/ap123/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91-2MB/Makefile b/board/ar7240/ap91-2MB/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91-2MB/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91-2MB/ap91-2MB.c b/board/ar7240/ap91-2MB/ap91-2MB.c
new file mode 100644
index 0000000000..401bdc2130
--- /dev/null
+++ b/board/ar7240/ap91-2MB/ap91-2MB.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91-2MB/ar9285gpio.c b/board/ar7240/ap91-2MB/ar9285gpio.c
new file mode 100644
index 0000000000..4e7401db3f
--- /dev/null
+++ b/board/ar7240/ap91-2MB/ar9285gpio.c
@@ -0,0 +1,140 @@
+#include <config.h>
+#include <common.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+
+#define AR9285_BASE     0x10000000
+
+#define AR9285_NUM_GPIO     10
+
+#define AR9285_GPIO_IN_OUT                           0x4048 // GPIO input / output register
+#define AR9285_GPIO_IN_VAL                           0x000FFC00
+#define AR9285_GPIO_IN_VAL_S                         10
+
+#define AR9285_GPIO_OE_OUT                           0x404c // GPIO output register
+#define AR9285_GPIO_OE_OUT_DRV                       0x3    // 2 bit field mask, shifted by 2*bitpos
+#define AR9285_GPIO_OE_OUT_DRV_NO                    0x0    // tristate
+#define AR9285_GPIO_OE_OUT_DRV_LOW                   0x1    // drive if low
+#define AR9285_GPIO_OE_OUT_DRV_HI                    0x2    // drive if high
+#define AR9285_GPIO_OE_OUT_DRV_ALL                   0x3    // drive always
+
+#define AR9285_GPIO_OUTPUT_MUX1                      0x4060
+#define AR9285_GPIO_OUTPUT_MUX2                      0x4064
+
+#define AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT             0
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED 1
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     2
+#define AR9285_GPIO_OUTPUT_MUX_AS_TX_FRAME           3
+#define AR9285_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL  4
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    5
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      6
+
+
+#define MS(_v, _f)  (((_v) & _f) >> _f##_S)
+
+#define AR9285_GPIO_BIT(_gpio)  (1 << (_gpio))
+
+#define ar9285_reg_wr(_off, _val)   ar7240_reg_wr(((_off) + AR9285_BASE), (_val))
+#define ar9285_reg_rd(_off)   (ar7240_reg_rd((_off) + AR9285_BASE))
+#define ar9285_reg_rmw(_off, _set, _clr)   do { \
+            ar7240_reg_rmw_clear(((_off) + AR9285_BASE), (_clr)); \
+            ar7240_reg_rmw_set(((_off) + AR9285_BASE), (_set)); \
+} while(0)
+
+
+/*
+ * Configure GPIO Output Mux control
+ */
+static void
+ar9285GpioCfgOutputMux(unsigned int gpio, u32 type)
+{
+    int          addr;
+    u32    gpio_shift;
+
+    // each MUX controls 6 GPIO pins
+    if (gpio > 5) {
+        addr = AR9285_GPIO_OUTPUT_MUX2;
+    } else {
+        addr = AR9285_GPIO_OUTPUT_MUX1;
+    }
+
+    // 5 bits per GPIO pin. Bits 0..4 for 1st pin in that mux, bits 5..9 for 2nd pin, etc.
+    gpio_shift = (gpio % 6) * 5;
+
+    ar9285_reg_rmw(addr, (type << gpio_shift), (0x1f << gpio_shift));
+}
+
+/*
+ * Configure GPIO Output lines
+ */
+void
+ar9285GpioCfgOutput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    // Configure the MUX
+    ar9285GpioCfgOutputMux(gpio, AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT);
+
+    // 2 bits per output mode
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT,
+               (AR9285_GPIO_OE_OUT_DRV_ALL << gpio_shift),
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Configure GPIO Input lines
+ */
+void
+ar9285GpioCfgInput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    /* TODO: configure input mux for AR5416 */
+    /* If configured as input, set output to tristate */
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT,
+               (AR9285_GPIO_OE_OUT_DRV_NO << gpio_shift),
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Once configured for I/O - set output lines
+ */
+void
+ar9285GpioSet(unsigned int gpio, int val)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+
+    ar9285_reg_rmw(AR9285_GPIO_IN_OUT, ((val&1) << gpio), AR9285_GPIO_BIT(gpio));
+}
+
+/*
+ * Once configured for I/O - get input lines
+ */
+u32
+ar9285GpioGet(unsigned int gpio)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return 0xffffffff;
+    }
+
+    // Read output value for all gpio's, shift it left, and verify whether a
+    // specific gpio bit is set.
+    return (MS(ar9285_reg_rd(AR9285_GPIO_IN_OUT), AR9285_GPIO_IN_VAL) & AR9285_GPIO_BIT(gpio)) != 0;
+}
diff --git a/board/ar7240/ap91-2MB/config.mk b/board/ar7240/ap91-2MB/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap91-2MB/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91-2MB/flash.c b/board/ar7240/ap91-2MB/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap91-2MB/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91-2MB/u-boot-bootstrap.lds b/board/ar7240/ap91-2MB/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91-2MB/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91-2MB/u-boot.lds b/board/ar7240/ap91-2MB/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91-2MB/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91-2x8/Makefile b/board/ar7240/ap91-2x8/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91-2x8/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91-2x8/ap91-2x8.c b/board/ar7240/ap91-2x8/ap91-2x8.c
new file mode 100644
index 0000000000..203aba32e5
--- /dev/null
+++ b/board/ar7240/ap91-2x8/ap91-2x8.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 (ar7240) u-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91-2x8/config.mk b/board/ar7240/ap91-2x8/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap91-2x8/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91-2x8/flash.c b/board/ar7240/ap91-2x8/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap91-2x8/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91-2x8/u-boot-bootstrap.lds b/board/ar7240/ap91-2x8/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91-2x8/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91-2x8/u-boot.lds b/board/ar7240/ap91-2x8/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91-2x8/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91-router/Makefile b/board/ar7240/ap91-router/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91-router/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91-router/ap91-router.c b/board/ar7240/ap91-router/ap91-router.c
new file mode 100644
index 0000000000..3bc886a94b
--- /dev/null
+++ b/board/ar7240/ap91-router/ap91-router.c
@@ -0,0 +1,58 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 Router (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 Router (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91-router/config.mk b/board/ar7240/ap91-router/config.mk
new file mode 100755
index 0000000000..7e602fd66a
--- /dev/null
+++ b/board/ar7240/ap91-router/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80010000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91-router/flash.c b/board/ar7240/ap91-router/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap91-router/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91-router/u-boot-bootstrap.lds b/board/ar7240/ap91-router/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91-router/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91-router/u-boot.lds b/board/ar7240/ap91-router/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91-router/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap91/Makefile b/board/ar7240/ap91/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap91/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap91/ap91.c b/board/ar7240/ap91/ap91.c
new file mode 100644
index 0000000000..941b59b9b4
--- /dev/null
+++ b/board/ar7240/ap91/ap91.c
@@ -0,0 +1,70 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_gpio_config();
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP91 (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("AP91 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/ap91/ar9285gpio.c b/board/ar7240/ap91/ar9285gpio.c
new file mode 100644
index 0000000000..b0c14f0393
--- /dev/null
+++ b/board/ar7240/ap91/ar9285gpio.c
@@ -0,0 +1,152 @@
+#include <config.h>
+#include <common.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+
+#define AR9285_BASE     0x10000000
+
+#define AR9285_NUM_GPIO     10
+
+#define AR9285_GPIO_IN_OUT                           0x4048 // GPIO input / output register
+#define AR9285_GPIO_IN_VAL                           0x000FFC00
+#define AR9285_GPIO_IN_VAL_S                         10
+
+#define AR9285_GPIO_OE_OUT                           0x404c // GPIO output register
+#define AR9285_GPIO_OE_OUT_DRV                       0x3    // 2 bit field mask, shifted by 2*bitpos
+#define AR9285_GPIO_OE_OUT_DRV_NO                    0x0    // tristate
+#define AR9285_GPIO_OE_OUT_DRV_LOW                   0x1    // drive if low
+#define AR9285_GPIO_OE_OUT_DRV_HI                    0x2    // drive if high
+#define AR9285_GPIO_OE_OUT_DRV_ALL                   0x3    // drive always
+
+#define AR9285_GPIO_IN_ENABLE                        (AR9285_BASE + 0x4054)
+#define AR9285_GPIO_JTAG_DISABLE                     (1u << 17)
+#define AR9285_GPIO_OUTPUT_MUX1                      0x4060
+#define AR9285_GPIO_OUTPUT_MUX2                      0x4064
+
+#define AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT             0
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED 1
+#define AR9285_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     2
+#define AR9285_GPIO_OUTPUT_MUX_AS_TX_FRAME           3
+#define AR9285_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL  4
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    5
+#define AR9285_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      6
+
+
+#define MS(_v, _f)  (((_v) & _f) >> _f##_S)
+
+#define AR9285_GPIO_BIT(_gpio)  (1 << (_gpio))
+
+#define ar9285_reg_wr(_off, _val)   ar7240_reg_wr(((_off) + AR9285_BASE), (_val))
+#define ar9285_reg_rd(_off)   (ar7240_reg_rd((_off) + AR9285_BASE))
+#define ar9285_reg_rmw(_off, _set, _clr)   do { \
+            ar7240_reg_rmw_clear(((_off) + AR9285_BASE), (_clr)); \
+            ar7240_reg_rmw_set(((_off) + AR9285_BASE), (_set)); \
+} while(0)
+
+
+/*
+ * Configure GPIO Output Mux control
+ */
+static void
+ar9285GpioCfgOutputMux(unsigned int gpio, u32 type)
+{
+    int          addr;
+    u32    gpio_shift;
+
+    // each MUX controls 6 GPIO pins
+    if (gpio > 5) {
+        addr = AR9285_GPIO_OUTPUT_MUX2;
+    } else {
+        addr = AR9285_GPIO_OUTPUT_MUX1;
+    }
+
+    // 5 bits per GPIO pin. Bits 0..4 for 1st pin in that mux, bits 5..9 for 2nd pin, etc.
+    gpio_shift = (gpio % 6) * 5;
+
+    ar9285_reg_rmw(addr, (type << gpio_shift), (0x1f << gpio_shift));
+}
+
+/*
+ * Configure GPIO Output lines
+ */
+void
+ar9285GpioCfgOutput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    // Configure the MUX
+    ar9285GpioCfgOutputMux(gpio, AR9285_GPIO_OUTPUT_MUX_AS_OUTPUT);
+
+    // 2 bits per output mode
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT,
+               (AR9285_GPIO_OE_OUT_DRV_ALL << gpio_shift),
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Configure GPIO Input lines
+ */
+void
+ar9285GpioCfgInput(unsigned int gpio)
+{
+    u32    gpio_shift;
+
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+    /* TODO: configure input mux for AR5416 */
+    /* If configured as input, set output to tristate */
+    gpio_shift = 2*gpio;
+
+    ar9285_reg_rmw(AR9285_GPIO_OE_OUT,
+               (AR9285_GPIO_OE_OUT_DRV_NO << gpio_shift),
+               (AR9285_GPIO_OE_OUT_DRV << gpio_shift));
+}
+
+/*
+ * Once configured for I/O - set output lines
+ */
+void
+ar9285GpioSet(unsigned int gpio, int val)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return;
+    }
+
+    ar9285_reg_rmw(AR9285_GPIO_IN_OUT, ((val&1) << gpio), AR9285_GPIO_BIT(gpio));
+}
+
+/*
+ * Once configured for I/O - get input lines
+ */
+u32
+ar9285GpioGet(unsigned int gpio)
+{
+    if (gpio >= AR9285_NUM_GPIO) {
+        printf("Invalid GPIO\n");
+        return 0xffffffff;
+    }
+
+    // Read output value for all gpio's, shift it left, and verify whether a
+    // specific gpio bit is set.
+    return (MS(ar9285_reg_rd(AR9285_GPIO_IN_OUT), AR9285_GPIO_IN_VAL) & AR9285_GPIO_BIT(gpio)) != 0;
+}
+
+u32
+ar9285DisableJtag(void)
+{
+	/*
+	 * Disable ar9285's JTAG access. Else, gpio 0 - 4 will be used
+	 * by the jtag. This does NOT affect board's JTAG interface
+	 */
+	ar7240_reg_rmw_set(AR9285_GPIO_IN_ENABLE, AR9285_GPIO_JTAG_DISABLE);
+}
diff --git a/board/ar7240/ap91/config.mk b/board/ar7240/ap91/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap91/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap91/flash.c b/board/ar7240/ap91/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap91/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap91/u-boot-bootstrap.lds b/board/ar7240/ap91/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap91/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap91/u-boot.lds b/board/ar7240/ap91/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap91/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap93-hgw/Makefile b/board/ar7240/ap93-hgw/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap93-hgw/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap93-hgw/ap93-hgw.c b/board/ar7240/ap93-hgw/ap93-hgw.c
new file mode 100644
index 0000000000..0de5b7a357
--- /dev/null
+++ b/board/ar7240/ap93-hgw/ap93-hgw.c
@@ -0,0 +1,53 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x7);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("AP93 Home Gateway (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/ap93-hgw/config.mk b/board/ar7240/ap93-hgw/config.mk
new file mode 100755
index 0000000000..f110fcb6ff
--- /dev/null
+++ b/board/ar7240/ap93-hgw/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap93-hgw/flash.c b/board/ar7240/ap93-hgw/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap93-hgw/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap93-hgw/u-boot.lds b/board/ar7240/ap93-hgw/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap93-hgw/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap93/Makefile b/board/ar7240/ap93/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap93/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap93/ap93.c b/board/ar7240/ap93/ap93.c
new file mode 100644
index 0000000000..bf781acc77
--- /dev/null
+++ b/board/ar7240/ap93/ap93.c
@@ -0,0 +1,60 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+/* Default tap values for starting the tap_init*/
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x7);
+
+    ar7240_gpio_config();
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("AP93 (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/ap93/config.mk b/board/ar7240/ap93/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap93/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap93/flash.c b/board/ar7240/ap93/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/ap93/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap93/u-boot.lds b/board/ar7240/ap93/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap93/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap98/Makefile b/board/ar7240/ap98/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap98/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap98/ap98.c b/board/ar7240/ap98/ap98.c
new file mode 100644
index 0000000000..a71c3fca33
--- /dev/null
+++ b/board/ar7240/ap98/ap98.c
@@ -0,0 +1,87 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string, "AP98 (ar7241 - Virian) Compressed U-boot");
+    else
+        strcpy(board_string, "AP98 (ar7240 - Python) Compressed U-boot");
+    return 0;
+
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP98 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP98 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap98/config.mk b/board/ar7240/ap98/config.mk
new file mode 100755
index 0000000000..e485e03667
--- /dev/null
+++ b/board/ar7240/ap98/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80310000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap98/flash.c b/board/ar7240/ap98/flash.c
new file mode 100644
index 0000000000..f9e51f8286
--- /dev/null
+++ b/board/ar7240/ap98/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap98/u-boot-bootstrap.lds b/board/ar7240/ap98/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap98/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap98/u-boot.lds b/board/ar7240/ap98/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap98/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-2.6.31/Makefile b/board/ar7240/ap99-2.6.31/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-2.6.31/ap99-2.6.31.c b/board/ar7240/ap99-2.6.31/ap99-2.6.31.c
new file mode 100644
index 0000000000..7d6a02956d
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/ap99-2.6.31.c
@@ -0,0 +1,73 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap99-2.6.31/config.mk b/board/ar7240/ap99-2.6.31/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-2.6.31/flash.c b/board/ar7240/ap99-2.6.31/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds b/board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99-2.6.31/u-boot.lds b/board/ar7240/ap99-2.6.31/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-hgw/Makefile b/board/ar7240/ap99-hgw/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-hgw/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-hgw/ap99-hgw.c b/board/ar7240/ap99-hgw/ap99-hgw.c
new file mode 100644
index 0000000000..21ec65c72a
--- /dev/null
+++ b/board/ar7240/ap99-hgw/ap99-hgw.c
@@ -0,0 +1,83 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP99 HGW (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap99-hgw/config.mk b/board/ar7240/ap99-hgw/config.mk
new file mode 100755
index 0000000000..7e602fd66a
--- /dev/null
+++ b/board/ar7240/ap99-hgw/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80010000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-hgw/flash.c b/board/ar7240/ap99-hgw/flash.c
new file mode 100644
index 0000000000..f9e51f8286
--- /dev/null
+++ b/board/ar7240/ap99-hgw/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-hgw/u-boot-bootstrap.lds b/board/ar7240/ap99-hgw/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap99-hgw/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99-hgw/u-boot.lds b/board/ar7240/ap99-hgw/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-hgw/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-ivi/Makefile b/board/ar7240/ap99-ivi/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-ivi/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-ivi/ap99-ivi.c b/board/ar7240/ap99-ivi/ap99-ivi.c
new file mode 100644
index 0000000000..21ec65c72a
--- /dev/null
+++ b/board/ar7240/ap99-ivi/ap99-ivi.c
@@ -0,0 +1,83 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "AP99 HGW (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap99-ivi/config.mk b/board/ar7240/ap99-ivi/config.mk
new file mode 100755
index 0000000000..7e602fd66a
--- /dev/null
+++ b/board/ar7240/ap99-ivi/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80010000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-ivi/flash.c b/board/ar7240/ap99-ivi/flash.c
new file mode 100644
index 0000000000..f9e51f8286
--- /dev/null
+++ b/board/ar7240/ap99-ivi/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-ivi/u-boot-bootstrap.lds b/board/ar7240/ap99-ivi/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..2f01270d05
--- /dev/null
+++ b/board/ar7240/ap99-ivi/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99-ivi/u-boot.lds b/board/ar7240/ap99-ivi/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-ivi/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-small/Makefile b/board/ar7240/ap99-small/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99-small/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99-small/ap99-small.c b/board/ar7240/ap99-small/ap99-small.c
new file mode 100644
index 0000000000..7ba5e34da7
--- /dev/null
+++ b/board/ar7240/ap99-small/ap99-small.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap99-small/config.mk b/board/ar7240/ap99-small/config.mk
new file mode 100644
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/ap99-small/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99-small/flash.c b/board/ar7240/ap99-small/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/ap99-small/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99-small/u-boot.lds b/board/ar7240/ap99-small/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99-small/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ap99-test/ap99-test.c b/board/ar7240/ap99-test/ap99-test.c
new file mode 100644
index 0000000000..7ba5e34da7
--- /dev/null
+++ b/board/ar7240/ap99-test/ap99-test.c
@@ -0,0 +1,71 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
diff --git a/board/ar7240/ap99/Makefile b/board/ar7240/ap99/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ap99/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ap99/ap99.c b/board/ar7240/ap99/ap99.c
new file mode 100644
index 0000000000..bb726f8441
--- /dev/null
+++ b/board/ar7240/ap99/ap99.c
@@ -0,0 +1,86 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+#ifndef COMPRESSED_UBOOT
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string, "AP99 (ar7241 - Virian) Compressed U-boot");
+    else
+        strcpy(board_string, "AP99 (ar7240 - Python) Compressed U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+	printf("AP99 (ar7241 - Virian) U-boot\n");
+    else
+	printf("AP99 (ar7240 - Python) U-boot\n");
+
+	return 0;
+}
+#endif
diff --git a/board/ar7240/ap99/config.mk b/board/ar7240/ap99/config.mk
new file mode 100755
index 0000000000..e485e03667
--- /dev/null
+++ b/board/ar7240/ap99/config.mk
@@ -0,0 +1,13 @@
+# ROM version
+
+ifeq ($(COMPRESSED_UBOOT),1)
+# change the text base to ram address
+TEXT_BASE = 0x80310000
+# set to BOOTSTRAP text base to cached base address
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ap99/flash.c b/board/ar7240/ap99/flash.c
new file mode 100644
index 0000000000..f9e51f8286
--- /dev/null
+++ b/board/ar7240/ap99/flash.c
@@ -0,0 +1,38 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+#ifndef COMPRESSED_UBOOT
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else
+#endif
+    {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ap99/u-boot-bootstrap.lds b/board/ar7240/ap99/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/ap99/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/ap99/u-boot.lds b/board/ar7240/ap99/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ap99/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/aph126/Makefile b/board/ar7240/aph126/Makefile
new file mode 100644
index 0000000000..dd3465eba2
--- /dev/null
+++ b/board/ar7240/aph126/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/aph126/aph126.c b/board/ar7240/aph126/aph126.c
new file mode 100644
index 0000000000..958b38b617
--- /dev/null
+++ b/board/ar7240/aph126/aph126.c
@@ -0,0 +1,163 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/aph126/config.mk b/board/ar7240/aph126/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/aph126/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/aph126/flash.c b/board/ar7240/aph126/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/aph126/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/aph126/u-boot-bootstrap.lds b/board/ar7240/aph126/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/aph126/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/aph126/u-boot.lds b/board/ar7240/aph126/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/aph126/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/aph128/Makefile b/board/ar7240/aph128/Makefile
new file mode 100644
index 0000000000..dd3465eba2
--- /dev/null
+++ b/board/ar7240/aph128/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/aph128/aph128.c b/board/ar7240/aph128/aph128.c
new file mode 100644
index 0000000000..b78cf0d1e8
--- /dev/null
+++ b/board/ar7240/aph128/aph128.c
@@ -0,0 +1,175 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/*  Enable xLNBIAS signal on GPIO (19, 20) */
+	ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+	ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+	ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/aph128/config.mk b/board/ar7240/aph128/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/aph128/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/aph128/flash.c b/board/ar7240/aph128/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/aph128/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/aph128/u-boot-bootstrap.lds b/board/ar7240/aph128/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/aph128/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/aph128/u-boot.lds b/board/ar7240/aph128/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/aph128/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/ar7240_emu/Makefile b/board/ar7240/ar7240_emu/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/ar7240_emu/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/ar7240_emu/ar7240_emu.c b/board/ar7240/ar7240_emu/ar7240_emu.c
new file mode 100644
index 0000000000..d5bdfaa384
--- /dev/null
+++ b/board/ar7240/ar7240_emu/ar7240_emu.c
@@ -0,0 +1,144 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x00001030);
+}
+
+int
+ar7240_mem_config()
+{
+    uint32_t  ddr_config, ddr_config2;
+    int i;
+#if 0
+    ar7240_ddr_width_t width;
+#endif
+
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+#if 0
+    ar7240_ddr_tap_config();
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x5);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x5);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+#endif
+
+#if 0
+    ddr_config   = ar7240_reg_rd(AR7240_DDR_CONFIG);
+    ddr_config2  = ar7240_reg_rd(AR7240_DDR_CONFIG2);
+    width        = ar7240_ddr_get_width();
+
+    if (width != AR7240_DDR_32B)
+        ddr_config |= AR7240_DDR_CONFIG_16BIT;
+    if (width == AR7240_DDR_16B_HIGH)
+        ddr_config2 &= ~AR7240_DDR_CONFIG2_HALF_WIDTH_L;
+
+    ddr_config2 &= ~((0x1f << AR7240_DDR_CONFIG2_TRTW_SHIFT) |
+                     (0x1f << AR7240_DDR_CONFIG2_TWTR_SHIFT) |
+                      0xf);
+
+    ddr_config2 |= ((CFG_DDR_TRTW_VAL << AR7240_DDR_CONFIG2_TRTW_SHIFT) |
+                    (CFG_DDR_TWTR_VAL << AR7240_DDR_CONFIG2_TWTR_SHIFT) |
+                    AR7240_DDR_CONFIG2_BL2);
+    /*
+     * XXX These bits are reserved...
+     */
+    ddr_config2 |= (1 << 26)|(1 << 27)|(1 << 30);
+
+    printf("programming config1 %#x, config2 %#x\n", ddr_config, ddr_config2);
+
+    ar7240_reg_wr(AR7240_DDR_CONFIG, ddr_config);
+    ar7240_reg_wr(AR7240_DDR_CONFIG2, ddr_config2);
+#endif
+
+    /* XXX - these don't really belong here!
+    *(volatile unsigned int *)0xb8050004 = 0x00001032;
+    udelay(100);
+*/
+#if 0
+    *(volatile unsigned int *)0xb8050018 = 0x1313;
+    udelay(10);
+
+    *(volatile unsigned int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    *(volatile unsigned int *)0xb8050014 = 0x14000044;
+    udelay(100);
+#endif
+#if 0
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 25));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(1 << 16));
+    *(volatile int *)0xb8050004 = i;
+    while ((*(volatile int *)0xb8050004) & (1 << 17));
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3f << 19);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    *(volatile int *)0xb8050014 = 0x13000a44;
+/*
+    *(volatile int *)0xb8050014 = 0x13000044;
+    *(volatile int *)0xb8050014 = 0x13111321;
+    *(volatile int *)0xb8050014 = 0x00111321;
+    *(volatile int *)0xb8050014 = 0x00001344;
+    *(volatile int *)0xb8050014 = 0x14000044;
+    *(volatile int *)0xb8050014 = 0x14000f44;
+    *(volatile int *)0xb8050014 = 0x00001044;
+    *(volatile int *)0xb8050014 = 0x14001044;
+    *(volatile int *)0xb8050014 = 0x14001f44;
+    *(volatile int *)0xb8050014 = 0x1f001044;
+    *(volatile int *)0xb8050014 = 0x1f001f44;
+*/
+
+    *(volatile int *)0xb805001c = 0x00000909;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3b << 19));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i | (0x3 << 20);
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    i = *(volatile int *)0xb8050004;
+    i = i & (~(0x3 << 20));
+    *(volatile int *)0xb8050004 = i;
+    udelay(100);
+
+    /* Temp addition - check with Ravi */
+    *(volatile unsigned int *)0xb8080008 = 0x00000040;
+    udelay(100);
+#endif
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("Python Emulation (ar7240) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7240/ar7240_emu/config.mk b/board/ar7240/ar7240_emu/config.mk
new file mode 100755
index 0000000000..f110fcb6ff
--- /dev/null
+++ b/board/ar7240/ar7240_emu/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/ar7240_emu/flash.c b/board/ar7240/ar7240_emu/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/ar7240_emu/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/ar7240_emu/u-boot.lds b/board/ar7240/ar7240_emu/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/ar7240_emu/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/common/ar7240_flash.c b/board/ar7240/common/ar7240_flash.c
new file mode 100644
index 0000000000..06f234cfdf
--- /dev/null
+++ b/board/ar7240/common/ar7240_flash.c
@@ -0,0 +1,249 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include "ar7240_soc.h"
+#include "ar7240_flash.h"
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#undef display
+#define display(x)  ;
+
+/*
+ * statics
+ */
+static void ar7240_spi_write_enable(void);
+static void ar7240_spi_poll(void);
+#if !defined(ATH_SST_FLASH)
+static void ar7240_spi_write_page(uint32_t addr, uint8_t * data, int len);
+#endif
+static void ar7240_spi_sector_erase(uint32_t addr);
+
+static void
+ath_spi_read_id(void)
+{
+	u32 rd = 0x777777;
+
+	ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_RDID);
+	ar7240_spi_delay_8();
+	ar7240_spi_delay_8();
+	ar7240_spi_delay_8();
+	ar7240_spi_go();
+
+	rd = ar7240_reg_rd(AR7240_SPI_RD_STATUS);
+
+	printf("Flash Manuf Id 0x%x, DeviceId0 0x%x, DeviceId1 0x%x\n",
+		(rd >> 16) & 0xff, (rd >> 8) & 0xff, (rd >> 0) & 0xff);
+}
+
+
+#ifdef ATH_SST_FLASH
+void ar7240_spi_flash_unblock(void)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_WRITE_SR);
+	ar7240_spi_bit_banger(0x0);
+	ar7240_spi_go();
+	ar7240_spi_poll();
+}
+#endif
+
+unsigned long flash_init(void)
+{
+#ifndef CONFIG_WASP
+#ifdef ATH_SST_FLASH
+	ar7240_reg_wr_nf(AR7240_SPI_CLOCK, 0x3);
+	ar7240_spi_flash_unblock();
+	ar7240_reg_wr(AR7240_SPI_FS, 0);
+#else
+	ar7240_reg_wr_nf(AR7240_SPI_CLOCK, 0x43);
+#endif
+#endif
+	ar7240_reg_rmw_set(AR7240_SPI_FS, 1);
+	ath_spi_read_id();
+	ar7240_reg_rmw_clear(AR7240_SPI_FS, 1);
+
+	/*
+	 * hook into board specific code to fill flash_info
+	 */
+	return (flash_get_geom(&flash_info[0]));
+}
+
+void
+flash_print_info(flash_info_t *info)
+{
+	printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int i, sector_size = info->size / info->sector_count;
+
+#ifdef FLASH_DEBUG
+	printf("\nFirst %#x last %#x sector size %#x\n",
+	       s_first, s_last, sector_size);
+#endif
+
+	for (i = s_first; i <= s_last; i++) {
+#ifdef FLASH_DEBUG
+		printf("\b\b\b\b%4d", i);
+#else
+		puts(".");
+#endif
+		ar7240_spi_sector_erase(i * sector_size);
+	}
+	ar7240_spi_done();
+	printf("\n");
+
+	return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+#ifdef ATH_SST_FLASH
+void
+ar7240_spi_flash_chip_erase(void)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_CHIP_ERASE);
+	ar7240_spi_go();
+	ar7240_spi_poll();
+}
+
+int
+write_buff(flash_info_t *info, uchar *src, ulong dst, ulong len)
+{
+	uint32_t val;
+
+	dst = dst - CFG_FLASH_BASE;
+	printf("write len: %lu dst: 0x%x src: %p\n", len, dst, src);
+
+	for (; len; len--, dst++, src++) {
+		ar7240_spi_write_enable();	// dont move this above 'for'
+		ar7240_spi_bit_banger(AR7240_SPI_CMD_PAGE_PROG);
+		ar7240_spi_send_addr(dst);
+
+		val = *src & 0xff;
+		ar7240_spi_bit_banger(val);
+
+		ar7240_spi_go();
+		ar7240_spi_poll();
+	}
+	/*
+	 * Disable the Function Select
+	 * Without this we can't read from the chip again
+	 */
+	ar7240_reg_wr(AR7240_SPI_FS, 0);
+
+	if (len) {
+		// how to differentiate errors ??
+		return ERR_PROG_ERROR;
+	} else {
+		return ERR_OK;
+	}
+}
+#else
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+	int total = 0, len_this_lp, bytes_this_page, counter = 0;
+	ulong dst;
+	uchar *src;
+
+#ifdef FLASH_DEBUG
+	printf("write addr: %x\n", addr);
+#endif
+	addr = addr - CFG_FLASH_BASE;
+
+	while (total < len) {
+		src = source + total;
+		dst = addr + total;
+		bytes_this_page =
+		    AR7240_SPI_PAGE_SIZE - (addr & AR7240_SPI_PAGE_SIZE-1);
+		len_this_lp =
+		    ((len - total) >
+		     bytes_this_page) ? bytes_this_page : (len - total);
+		ar7240_spi_write_page(dst, src, len_this_lp);
+		total += len_this_lp;
+		if(counter>=255)
+		{
+			puts(".");
+			counter = 0;
+		}
+		else
+		{
+			counter++;
+		}
+	}
+
+	ar7240_spi_done();
+
+	return 0;
+}
+#endif
+
+static void
+ar7240_spi_write_enable()
+{
+	ar7240_reg_wr_nf(AR7240_SPI_FS, 1);
+	ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_WREN);
+	ar7240_spi_go();
+}
+
+static void
+ar7240_spi_poll()
+{
+	int rd;
+
+	do {
+		ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS);
+		ar7240_spi_bit_banger(AR7240_SPI_CMD_RD_STATUS);
+		ar7240_spi_delay_8();
+		rd = (ar7240_reg_rd(AR7240_SPI_RD_STATUS) & 1);
+	} while (rd);
+}
+
+#if !defined(ATH_SST_FLASH)
+static void
+ar7240_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+	int i;
+	uint8_t ch;
+
+	display(0x77);
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_PAGE_PROG);
+	ar7240_spi_send_addr(addr);
+
+	for (i = 0; i < len; i++) {
+		ch = *(data + i);
+		ar7240_spi_bit_banger(ch);
+	}
+
+	ar7240_spi_go();
+	display(0x66);
+	ar7240_spi_poll();
+	display(0x6d);
+}
+#endif
+
+static void
+ar7240_spi_sector_erase(uint32_t addr)
+{
+	ar7240_spi_write_enable();
+	ar7240_spi_bit_banger(AR7240_SPI_CMD_SECTOR_ERASE);
+	ar7240_spi_send_addr(addr);
+	ar7240_spi_go();
+	display(0x7d);
+	ar7240_spi_poll();
+}
diff --git a/board/ar7240/common/ar7240_flash.h b/board/ar7240/common/ar7240_flash.h
new file mode 100644
index 0000000000..de6aae7acf
--- /dev/null
+++ b/board/ar7240/common/ar7240_flash.h
@@ -0,0 +1,64 @@
+#ifndef _FLASH_H
+#define _FLASH_H
+
+#include "ar7240_soc.h"
+
+#define AR7240_SPI_FS           0x1f000000
+#define AR7240_SPI_CLOCK        0x1f000004
+#define AR7240_SPI_WRITE        0x1f000008
+#define AR7240_SPI_READ         0x1f000000
+#define AR7240_SPI_RD_STATUS    0x1f00000c
+
+#define AR7240_SPI_CS_DIS       0x70000
+#define AR7240_SPI_CE_LOW       0x60000
+#define AR7240_SPI_CE_HIGH      0x60100
+
+#define AR7240_SPI_CMD_WRITE_SR     0x01
+#define AR7240_SPI_CMD_WREN         0x06
+#define AR7240_SPI_CMD_RD_STATUS    0x05
+#define AR7240_SPI_CMD_FAST_READ    0x0b
+#define AR7240_SPI_CMD_PAGE_PROG    0x02
+#define AR7240_SPI_CMD_SECTOR_ERASE 0xd8
+#define AR7240_SPI_CMD_CHIP_ERASE   0xc7
+#define AR7240_SPI_CMD_RDID         0x9f
+
+#define AR7240_SPI_SECTOR_SIZE      (1024*64)
+#define AR7240_SPI_PAGE_SIZE        256
+
+
+#define display(_x)     ar7240_reg_wr_nf(0x18040008, (_x))
+
+/*
+ * primitives
+ */
+
+#define ar7240_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ar7240_spi_bit_banger(_byte)  do {        \
+    int i;                                      \
+    for(i = 0; i < 8; i++) {                    \
+        ar7240_reg_wr_nf(AR7240_SPI_WRITE,      \
+                        AR7240_SPI_CE_LOW | ar7240_be_msb(_byte, i));  \
+        ar7240_reg_wr_nf(AR7240_SPI_WRITE,      \
+                        AR7240_SPI_CE_HIGH | ar7240_be_msb(_byte, i)); \
+    }       \
+}while(0);
+
+#define ar7240_spi_go() do {        \
+    ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CE_LOW); \
+    ar7240_reg_wr_nf(AR7240_SPI_WRITE, AR7240_SPI_CS_DIS); \
+}while(0);
+
+
+#define ar7240_spi_send_addr(__a) do {			\
+    ar7240_spi_bit_banger(((__a & 0xff0000) >> 16));	\
+    ar7240_spi_bit_banger(((__a & 0x00ff00) >> 8));	\
+    ar7240_spi_bit_banger(__a & 0x0000ff);		\
+} while (0)
+
+#define ar7240_spi_delay_8()    ar7240_spi_bit_banger(0)
+#define ar7240_spi_done()       ar7240_reg_wr_nf(AR7240_SPI_FS, 0)
+
+extern unsigned long flash_get_geom (flash_info_t *flash_info);
+
+#endif /*_FLASH_H*/
diff --git a/board/ar7240/common/ar7240_pci.c b/board/ar7240/common/ar7240_pci.c
new file mode 100644
index 0000000000..8b2d69eec8
--- /dev/null
+++ b/board/ar7240/common/ar7240_pci.c
@@ -0,0 +1,584 @@
+/*****************************************************************************/
+/*! file ap93_pci.c
+** /brief PCI support for AP91/93 board
+**
+**  This provides the support code required for PCI support on the AP91/93
+**  board in the U-Boot environment.  This board is a Python based system
+**  with a Merlin WLAN interface.  This file also contains the support
+**  for initialization of the Merlin radios on the PCi bus, required for
+**  pre-configuration for use by Linux.
+**
+**  Copyright (c) 2008 Atheros Communications Inc.  All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include "ar7240_soc.h"
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+static int  ar7240_local_read_config(int where, int size, uint32_t *value);
+static int  ar7240_local_write_config(int where, int size, uint32_t value);
+
+static int
+ar7240_local_read_config(int where, int size, uint32_t *value)
+{
+    *value = ar7240_reg_rd(AR7240_PCI_CRP + where);
+    return 0;
+}
+
+static int
+ar7240_local_write_config(int where, int size, uint32_t value)
+{
+    ar7240_reg_wr((AR7240_PCI_CRP + where),value);
+    return 0;
+}
+
+static int
+ar7240_pci_read_config(struct pci_controller *hose,
+                           pci_dev_t dev, int where, uint32_t *value)
+{
+        *value = ar7240_reg_rd(AR7240_PCI_DEV_CFGBASE + where);
+        return 0;
+}
+
+static int
+ar7240_pci_write_config(struct pci_controller *hose,
+                           pci_dev_t dev, int where,  uint32_t value)
+{
+        ar7240_reg_wr((AR7240_PCI_DEV_CFGBASE + where),value);
+        return 0;
+}
+
+/*
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+    u32     val;
+    u32     addr;
+    u32     BaseAddr = 0x10000000;
+    u32     CalAddr = WLANCAL;
+    volatile u16     *calData;
+
+    /*
+     * Copy the device ID from Flash to device config space.
+     */
+
+    calData = (u16 *)CalAddr;
+
+#ifndef CONFIG_PCI_CONFIG_DATA_IN_OTP
+    if(calData[0] != 0xa55a && calData[0] != 0x5aa5  )
+    {
+        /*
+        ** Board is not calibrated.
+        */
+#ifndef COMPRESSED_UBOOT
+        printf("BOARD IS NOT CALIBRATED!!!\n");
+#endif
+        return;
+    }
+#else
+    return;
+#endif
+    /*
+    ** Need to setup the PCI device to access the internal registers
+    */
+    if ((is_ar7241() || is_ar7242()))
+        ar7240_pci_write_config(&hose, NULL, 0x10, 0x1000ffff);
+    else
+        ar7240_pci_write_config(&hose, NULL, 0x10, 0xffff);
+
+    ar7240_pci_write_config(&hose, NULL, 0x04, 0x6);
+
+    /*
+    ** Set pointer to first reg address
+    */
+
+    calData += AR7240_ART_PCICFG_OFFSET;
+
+    while(*calData != 0xffff)
+    {
+        u16 cd;
+
+        cd = *calData++;
+        addr = BaseAddr + cd;
+        val  = *calData++;
+        val |= (*calData++) << 16;
+
+        ar7240_reg_wr_nf(addr,val);
+        udelay(100);
+    }
+
+    return;
+}
+
+
+/******************************************************************************/
+/*!
+**  \brief pci host initialization
+**
+**  Sets up the PCI controller on the host.  For AR7240 this may not be necessary,
+**  but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially  for any AHB address generated by the CPU,
+** 1. the MSB  four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef CONFIG_WASP_SUPPORT
+static int ar7240_pcibios_init(void)
+{
+        if (is_ar9341()) {
+                return 0;
+        }
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("***** Warning *****: PCIe WLAN H/W not found !!!\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+#define pci_udelay(n)	do { uint32_t i; /* printf("--- %s[%d] udelay(%u)\n", __func__, __LINE__, n); */ for (i = 0; i < ((n)/10); i++) udelay(10); } while (0)
+
+char *
+__print_llx(unsigned long long u, char *num)
+{
+	char dec[] = "0123456789";
+	int i;
+
+	if (u == 0)	return "0";
+
+	memset(num, 0, 32);
+
+	for (i = 24; u; i--) {
+		num[i] = dec[u % 10];
+		u = u / 10;
+	}
+
+	return &num[i+1];
+}
+
+#define print_llx(n)	__print_llx(n, str_##n)
+
+#ifdef COMPRESSED_UBOOT
+int pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+#ifdef CONFIG_AP123
+	return;
+#else
+	uint32_t cmd = 0, reg_val;
+
+
+	//printf("%s: PCIe PLL 0x%x\n", __func__, mips3_cp0_count_read());
+	//printf("%s: PCIe PLL 0x%x  0xb8000008 =  0x%08x\n", __func__, mips3_cp0_count_read(), ar7240_reg_rd(0xb8040008));
+
+	pci_udelay(100000);
+	//count ++;
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MAX,
+			PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0) |
+			PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(1) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x20) |
+			PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0));
+	} else {
+#ifndef COMPRESSED_UBOOT
+		printf("%s: PCIe PLL not set for 40MHz refclk\n", __func__);
+#endif
+	}
+
+	ar7240_reg_rmw_set(AR7240_RESET, AR7240_RESET_PCIE);	// core in reset
+	pci_udelay(10000);
+	ar7240_reg_rmw_set(AR7240_RESET, AR7240_RESET_PCIE_PHY);// phy in reset
+	pci_udelay(10000);
+	ar7240_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1)); // pci phy analog in reset
+	pci_udelay(10000);
+	ar7240_reg_wr(0x180f0000, 0x1ffc0);			// ltssm is disabled
+	pci_udelay(100);
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 0);	// End point in reset
+	pci_udelay(100000);
+
+
+	//ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);
+
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(1) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(1) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(0));
+		pci_udelay(1000);
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			ar7240_reg_rd(AR934X_PCIE_PLL_CONFIG) &
+			(~PCIE_PLL_CONFIG_BYPASS_SET(1)));
+		pci_udelay(1000);
+	} else {
+		ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG,
+			PCIE_PLL_CONFIG_REFDIV_SET(2) |
+			PCIE_PLL_CONFIG_BYPASS_SET(1) |
+			PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+
+		if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+			ar7240_reg_wr_nf(0xb8116c00, (0x5 << 27) | (160 << 18) | 0);
+		} else {
+			ar7240_reg_wr_nf(0xb8116c00, (0x2 << 27) | (0x28 << 18) | 0);
+		}
+		do {
+			ar7240_reg_wr_nf(0xb8116c04, (0x1 << 30) | (0x4 << 26) | (0x32 << 19) | (1 << 16) | (3 << 13) | (0x1e << 7));
+			ar7240_reg_wr_nf(0xb8116c08, (6 << 23));
+			pci_udelay(10000);
+			ar7240_reg_wr_nf(0xb8116c04, (0x1 << 30) | (0x4 << 26) | (0x32 << 19) | (3 << 13) | (0x1e << 7));
+
+			ar7240_reg_rmw_clear(KSEG1ADDR(PCIe_DPLL3_ADDRESS), PCIe_DPLL3_DO_MEAS_SET(1));
+			ar7240_reg_rmw_set(KSEG1ADDR(PCIe_DPLL3_ADDRESS), PCIe_DPLL3_DO_MEAS_SET(1));
+
+			ar7240_reg_wr(0xb804000c, 1 << 2);
+
+			pci_udelay(1000);
+
+			while (((cmd = ar7240_reg_rd(PCIe_DPLL4_ADDRESS)) & PCIe_DPLL4_MEAS_DONE_SET(1)) == 0) {
+				printf("0x%x 0x%x 0x%x\n", KSEG1ADDR(PCIe_DPLL4_ADDRESS), cmd);
+				pci_udelay(10);
+			}
+
+			{ int i; for (i = 0; i < 100; i++) udelay(10); }
+#if 0
+			msdvc = PCIe_DPLL4_MEAN_DVC_GET(cmd);
+			cmd = PCIe_DPLL3_SQSUM_DVC_GET(ar7240_reg_rd(PCIe_DPLL3_ADDRESS));
+
+			if (msdvc & 0x400) msdvc = ((~msdvc & 0x7FF) + 1); /* 11 bit signed number , but not intentioanlly multiply by (-1), ASK VIPUL*/
+			msdvc =  cmd - (msdvc *msdvc);
+			msdvc_sq = msdvc * msdvc;
+
+			if (cmd >= 0x40000) {
+				err_count++;
+				if (sqsum_min_fail == 0)
+					sqsum_min_fail = cmd;
+				if (cmd > sqsum_max_fail)
+					sqsum_max_fail = cmd;
+				if (cmd < sqsum_min_fail)
+					sqsum_min_fail = cmd;
+				sqsum_avg_fail = (sqsum_avg_fail - (sqsum_avg_fail / err_count)) + (cmd / err_count);
+
+				if (num_pll_loops == 0)
+					err_pll1++;
+				if (num_pll_loops == 1)
+					err_pll2++;
+				if (num_pll_loops == 2)
+					err_pll3++;
+				if (num_pll_loops == 3)
+					err_pll4++;
+				if (num_pll_loops == 4) {
+					err_pll5++;
+					break;
+				}
+			} else {
+				if (sqsum_min == 0)
+					sqsum_min = cmd;
+				if (cmd < sqsum_min)
+					sqsum_min = cmd;
+				if (cmd > sqsum_max)
+					sqsum_max = cmd;
+				//sqsum_avg = (sqsum_avg - (sqsum_avg / count)) + (cmd / count);
+				sqsum_avg += cmd;
+
+				/*msdvc calc*/
+				if (msdvc_min == 0) msdvc_min = msdvc;
+				if (msdvc < msdvc_min) msdvc_min =msdvc;
+				if (msdvc > msdvc_max) msdvc_max =msdvc;
+				msdvc_avg += msdvc;
+				msdvc_sq_avg += msdvc_sq;
+
+			}
+			num_pll_loops++;
+#endif
+
+		} while ((cmd = PCIe_DPLL3_SQSUM_DVC_GET(ar7240_reg_rd(PCIe_DPLL3_ADDRESS))) >= 0x40000);
+
+		ar7240_reg_rmw_clear(AR934X_PCIE_PLL_CONFIG, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+		pci_udelay(10000);
+		ar7240_reg_rmw_clear(AR934X_PCIE_PLL_CONFIG, PCIE_PLL_CONFIG_BYPASS_SET(1));
+		pci_udelay(10000);
+
+		/*
+		 * PCIe Dithering configuration
+		 */
+		if (is_ar934x_12_or_later()) {
+			ar7240_reg_wr_nf(PCIe_DPLL2_ADDRESS,
+					PCIe_DPLL2_LOCAL_PLL_SET(0) |
+					PCIe_DPLL2_KI_SET(0x4)|
+					PCIe_DPLL2_KD_SET(0x40));
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x40010800);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MAX, 0xc013fffe);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_DITHER_DIV_MIN, 0x0013e666);
+
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x00010800);
+			ar7240_reg_wr_nf(AR934X_PCIE_PLL_CONFIG, 0x00000800);
+		}
+
+		//run_command("md 0xb8116c00 4", 0);
+	}
+	ar7240_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1)); // pci phy analog out of reset
+	pci_udelay(10000);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);	// phy out of reset
+	pci_udelay(10000);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE);	// core out of reset
+	pci_udelay(1000);
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	      PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar7240_local_write_config(PCI_COMMAND, 4, cmd);		// pci cmd reg init
+	ar7240_local_write_config(0x20, 4, 0x1ff01000);		// membase setting
+	ar7240_local_write_config(0x24, 4, 0x1ff01000);		// prefetch membase setting
+
+
+	if ((is_ar7241() || is_ar7242() || is_wasp())) {
+		ar7240_reg_wr(0x180f0000, 0x1ffc1);		// ltssm enable
+	} else {
+		ar7240_reg_wr(0x180f0000, 0x1);
+	}
+	pci_udelay(100000);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 4);		// EP out of reset
+	pci_udelay(100000);
+
+
+#ifdef COMPRESSED_UBOOT
+	pci_udelay(100);
+#else
+	/*
+	 *  Delay increased from 100 to 1000, so as to
+	 *  get the correct status from PCI LCL RESET register
+	 */
+	pci_udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+
+#ifdef CONFIG_SHUTDOWN_PCIE_USB
+    printf("Shutdown PCIE and USB!\n");
+    ar7240_reg_wr(0xb806001c, 0x2404c8f8);
+    pci_udelay(10000);
+
+    ar7240_reg_wr(0xb8030008, 0x00000001);
+    pci_udelay(10000);
+
+	ar7240_reg_wr(0xb80600bc, 0x00080000);
+	pci_udelay(10000);
+	ar7240_reg_wr(0xb8116cc0, 0x1061060e);
+	pci_udelay(10000);
+	ar7240_reg_wr(0xb8116d00, 0x1061060e);
+	pci_udelay(10000);
+	ar7240_reg_wr(0xb8116d08, 0x00005c0c);
+	pci_udelay(10000);
+#endif
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ar7240_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ar7240_pci_write_config);
+#endif
+	plat_dev_init();
+#endif	// CONFIG_AP123
+#ifdef COMPRESSED_UBOOT
+	return 0;
+#endif
+}
+#else
+// For non - wasp
+#ifdef COMPRESSED_UBOOT
+int pci_init_board (void)
+#else
+void pci_init_board (void)
+#endif /* #ifdef COMPRESSED_UBOOT */
+{
+	uint32_t cmd;
+
+
+	ar7240_reg_rmw_clear(AR7240_RESET,AR7240_RESET_PCIE_PHY_SERIAL);
+	udelay(100);
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE_PHY);
+
+
+	ar7240_reg_rmw_clear(AR7240_RESET, AR7240_RESET_PCIE);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 0);
+	udelay(100000);
+
+	/*
+	 * Initialize PCIE PLL and get it out of RESET
+	 */
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x02050800);
+
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x00050800);
+	udelay(100);
+
+	ar7240_reg_wr(AR7240_PCIE_PLL_CONFIG,0x00040800);
+	udelay(100000);
+
+	ar7240_reg_wr_nf(AR7240_PCI_LCL_RESET, 4);
+	udelay(100000);
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+	      PCI_COMMAND_PARITY|PCI_COMMAND_SERR|PCI_COMMAND_FAST_BACK;
+
+	ar7240_local_write_config(PCI_COMMAND, 4, cmd);
+	ar7240_local_write_config(0x20, 4, 0x1ff01000);
+	ar7240_local_write_config(0x24, 4, 0x1ff01000);
+
+	if ((is_ar7241() || is_ar7242() || is_wasp())) {
+		ar7240_reg_wr(0x180f0000, 0x1ffc1);
+	} else {
+		ar7240_reg_wr(0x180f0000, 0x1);
+	}
+
+#ifdef COMPRESSED_UBOOT
+	udelay(100);
+#else
+	udelay(1000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+
+	if (((ar7240_reg_rd(AR7240_PCI_LCL_RESET)) & 0x1) == 0x0) {
+		printf("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ar7240_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ar7240_pci_write_config);
+#endif
+	plat_dev_init();
+#ifdef COMPRESSED_UBOOT
+	return 0;
+#endif
+}
+#endif /* CONFIG_WASP_SUPPORT */
diff --git a/board/ar7240/common/ar7240_s26_phy.c b/board/ar7240/common/ar7240_s26_phy.c
new file mode 100644
index 0000000000..50efcf0e05
--- /dev/null
+++ b/board/ar7240/common/ar7240_s26_phy.c
@@ -0,0 +1,915 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "ar7240_s26_phy.h"
+
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS26"
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+static uint8_t athr26_init_flag = 0,athr26_init_flag1 = 0;
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs26_phy_is_link_alive(int phyUnit);
+uint32_t athrs26_reg_read(uint32_t reg_addr);
+void athrs26_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs26_powersave_off(int phy_addr)
+{
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs26_sleep_off(int phy_addr)
+{
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s26_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs26_reg_init(void)
+{
+
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    uint32_t ar7240_revid;
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+
+    if (athr26_init_flag)
+        return;
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid == AR7240_REV_1_0) {
+#ifdef S26_FORCE_100M
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL,0x800);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0xa100);
+#endif
+
+#ifdef S26_FORCE_10M
+        athrs26_powersave_off(ATHR_PHY4_ADDR);
+        athrs26_sleep_off(ATHR_PHY4_ADDR);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL,0x800);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x8100);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x0);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,0x12ee);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_ADDRESS,0x3);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_DEBUG_PORT_DATA,0x3bf0);
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x8100);
+#endif
+    } else {
+        s26_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+    }
+
+#if S26_PHY_DEBUG
+    rd_val = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_PHY_FUNC_CONTROL);
+    printf("S26 PHY FUNC CTRL  (%d) :%x\n",ATHR_PHY4_ADDR, rd_val);
+    rd_val = s26_rd_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL);
+    printf("S26 PHY CTRL  (%d) :%x\n",ATHR_PHY4_ADDR, rd_val);
+#endif
+
+    athr26_init_flag = 1;
+}
+
+void athrs26_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+    uint32_t ar7240_revid;
+
+    /* if using header for register configuration, we have to     */
+    /* configure s26 register after frame transmission is enabled */
+    if (athr26_init_flag1)
+        return;
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s26\n");
+    athrs26_reg_write(0x0, athrs26_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        if(!is_ar933x())
+	    sysMsDelay(100);
+	if(!(athrs26_reg_read(0x0)&0x80000000))
+		break;
+    }
+    printf(MODULE_NAME ": s26 reset done\n");
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX - 1; phyUnit++) {
+
+    foundPhy = TRUE;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid == AR7240_REV_1_0) {
+#ifdef S26_FORCE_100M
+        /*
+         *  Force MDI and MDX to alternate ports
+         *  Phy 0 and 2 -- MDI
+         *  Phy 1 and 3 -- MDX
+         */
+        if(phyUnit%2)
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+        else
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0xa100);
+#endif
+
+#ifdef S26_FORCE_10M
+        /*
+         *  Force MDI and MDX to alternate ports
+         *  Phy 0 and 2 -- MDI
+         *  Phy 1 and 3 -- MDX
+         */
+        if(phyUnit%2)
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+        else
+            s26_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+
+        athrs26_powersave_off(phyAddr);
+        athrs26_sleep_off(phyAddr);
+
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x8100);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_ADDRESS,0x0);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_DATA,0x12ee);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_ADDRESS,0x3);
+        s26_wr_phy(phyAddr,ATHR_DEBUG_PORT_DATA,0x3bf0);
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x8100);
+#endif
+    } else {
+        s26_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+    }
+
+#if S26_PHY_DEBUG
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_ID1);
+    printf("S26 PHY ID  (%d) :%x\n",phyAddr,rd_val);
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+    printf("S26 PHY CTRL  (%d) :%x\n",phyAddr,rd_val);
+    rd_val = s26_rd_phy(phyAddr,ATHR_PHY_STATUS);
+    printf("S26 ATHR PHY STATUS  (%d) :%x\n",phyAddr,rd_val);
+#endif
+    }
+    /*
+     * CPU port Enable
+     */
+    athrs26_reg_write(CPU_PORT_REGISTER,(1 << 8));
+
+    /*
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+#ifdef CONFIG_AR7240_EMU
+    athrs26_reg_write(PORT_STATUS_REGISTER0, 0x7e);  /* CPU Port */
+    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x3c);
+    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x3c);
+#else
+    athrs26_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs26_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs26_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs26_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+#endif
+
+    /* QM Control */
+    athrs26_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef CONFIG_AR7240_EMU
+    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x04);
+    athrs26_reg_write(PORT_CONTROL_REGISTER1, 0x4004);
+#else
+   /* Atheros Header Disable */
+    athrs26_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+   /* Tag Priority Mapping */
+    athrs26_reg_write(0x70, 0xfa50);
+
+   /* Enable ARP packets to CPU port */
+    athrs26_reg_write(S26_ARL_TBL_CTRL_REG,(athrs26_reg_read(S26_ARL_TBL_CTRL_REG) | 0x100000));
+
+#if S26_PHY_DEBUG
+    rd_val = athrs26_reg_read ( CPU_PORT_REGISTER );
+    printf("S26 CPU_PORT_REGISTER :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER0 );
+    printf("S26 PORT_STATUS_REGISTER0  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER1 );
+    printf("S26 PORT_STATUS_REGISTER1  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER2 );
+    printf("S26 PORT_STATUS_REGISTER2  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER3 );
+    printf("S26 PORT_STATUS_REGISTER3  :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_STATUS_REGISTER4 );
+    printf("S26 PORT_STATUS_REGISTER4  :%x\n",rd_val);
+
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER0 );
+    printf("S26 PORT_CONTROL_REGISTER0 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER1 );
+    printf("S26 PORT_CONTROL_REGISTER1 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER2 );
+    printf("S26 PORT_CONTROL_REGISTER2 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER3 );
+    printf("S26 PORT_CONTROL_REGISTER3 :%x\n",rd_val);
+    rd_val = athrs26_reg_read ( PORT_CONTROL_REGISTER4 );
+    printf("S26 PORT_CONTROL_REGISTER4 :%x\n",rd_val);
+#endif
+
+    athr26_init_flag1 = 1;
+}
+static unsigned int phy_val_saved = 0;
+/******************************************************************************
+*
+* athrs26_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs26_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = s26_rd_phy( phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs26_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs26_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+#if S26_PHY_DEBUG
+    uint32_t  rd_val = 0;
+#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+	s26_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+#if S26_PHY_DEBUG
+        rd_val = s26_rd_phy(phyAddr,ATHR_AUTONEG_ADVERT  );
+        printf("%s ATHR_AUTONEG_ADVERT %d :%x\n",__func__,phyAddr, rd_val);
+#endif
+
+    ar7240_revid = ar7240_reg_rd(AR7240_REV_ID) & AR7240_REV_ID_MASK;
+    if(ar7240_revid != AR7240_REV_1_0) {
+        s26_wr_phy( phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+#if S26_PHY_DEBUG
+        rd_val = s26_rd_phy(phyAddr,ATHR_AUTONEG_ADVERT  );
+        rd_val = s26_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+        printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr, rd_val);
+#endif
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if(!is_ar933x()) {
+        if (ethUnit == ENET_UNIT_LAN)
+            sysMsDelay(1000);
+        else
+            sysMsDelay(3000);
+    }
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s26_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            if(!is_ar933x())
+                sysMsDelay(150);
+        }
+
+
+#ifdef S26_VER_1_0
+        //turn off power saving
+       s26_wr_phy(phyUnit, 29, 41);
+       s26_wr_phy(phyUnit, 30, 0);
+       printf("def_ S26_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs26_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs26_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+
+/******************************************************************************
+*
+* athrs26_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               _10BASET, _100BASET;
+*               _1000BASET;
+*/
+
+int
+athrs26_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs26_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+            do {
+	        phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+#ifdef CONFIG_MACH_HORNET
+                /* For IEEE 100M voltage test */
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x4);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_DATA, 0xebbb);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                s26_wr_phy(phyAddr, ATHR_DEBUG_PORT_DATA, 0x2c47);
+#endif /* CONFIG_MACH_HORNET */
+                return _100BASET;
+            case 2:
+                return _1000BASET;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs26_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+            phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+             * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)
+                   linkCount++;
+                else {
+                    lostLinks++;
+		}
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */
+
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = s26_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                        lastStatus->isPhyAlive = TRUE;
+                   }
+            }
+        }
+    }
+
+    return (linkCount);
+
+#if S26_PHY_DEBUG
+    if (linkCount == 0) {
+        if (lostLinks) {
+            /* We just lost the last link for this MAC */
+            phyLinkLost(ethUnit);
+        }
+    } else {
+        if (gainedLinks == linkCount) {
+            /* We just gained our first link(s) for this MAC */
+            phyLinkGained(ethUnit);
+        }
+    }
+#endif
+}
+
+uint32_t
+athrs26_reg_read(unsigned int s26_addr)
+{
+        unsigned int addr_temp;
+        unsigned int s26_rd_csr_low, s26_rd_csr_high, s26_rd_csr;
+        unsigned int data, unit = 0;
+        unsigned int phy_address, reg_address;
+
+        addr_temp = (s26_addr & 0xfffffffc) >>2;
+        data = addr_temp >> 7;
+
+        phy_address = 0x1f;
+        reg_address = 0x10;
+
+        if (is_ar7240()) {
+           unit = 0;
+        }
+        else if (is_ar7241() || is_ar7242() || is_ar933x()) {
+            unit = 1;
+        }
+
+        phy_reg_write(unit,phy_address, reg_address, data);
+
+        phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+        reg_address = ((addr_temp << 1) & 0x1e);
+        s26_rd_csr_low = (uint32_t) phy_reg_read(unit, phy_address, reg_address);
+
+        reg_address = reg_address | 0x1;
+        s26_rd_csr_high = (uint32_t) phy_reg_read(unit, phy_address, reg_address);
+        s26_rd_csr = (s26_rd_csr_high << 16) | s26_rd_csr_low ;
+
+        return(s26_rd_csr);
+}
+
+void
+athrs26_reg_write(unsigned int s26_addr, unsigned int s26_write_data)
+{
+        unsigned int addr_temp;
+        unsigned int data, unit = 0;
+        unsigned int phy_address, reg_address;
+
+
+        addr_temp = (s26_addr &  0xfffffffc) >>2;
+        data = addr_temp >> 7;
+
+        phy_address = 0x1f;
+        reg_address = 0x10;
+
+        if (is_ar7240()) {
+           unit = 0;
+        }
+        else if (is_ar7241() || is_ar7242()|| is_ar933x()) {
+            unit = 1;
+        }
+
+#ifdef CONFIG_MACH_HORNET
+        //The write sequence , 0x98: L->H, 0x40 H->L, 0x50 H->L , others should not care.
+        if(s26_addr!=0x98)
+        {
+            //printf("[%s:%d] unit=%d\n",__FUNCTION__,__LINE__,unit);
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            phy_address = 0x17 & ((addr_temp >> 4) | 0x10);
+            reg_address = ((addr_temp << 1) & 0x1e) | 0x1;
+            data =  s26_write_data >> 16;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            reg_address = reg_address & 0x1e;
+            data = s26_write_data  & 0xffff;
+            phy_reg_write(unit, phy_address, reg_address, data);
+        }
+        else
+        {
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+            reg_address = ((addr_temp << 1) & 0x1e);
+
+            data = s26_write_data  & 0xffff;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+            reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+            data = s26_write_data >> 16;
+            phy_reg_write(unit, phy_address, reg_address, data);
+
+        }
+#else
+        phy_reg_write(unit, phy_address, reg_address, data);
+
+        phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+        reg_address = ((addr_temp << 1) & 0x1e);
+        data = s26_write_data  & 0xffff;
+        phy_reg_write(unit, phy_address, reg_address, data);
+
+        reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+        data = s26_write_data >> 16;
+        phy_reg_write(unit, phy_address, reg_address, data);
+#endif
+}
+
+
+unsigned int s26_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+         unsigned int rddata;
+
+        // MDIO_CMD is set for read
+
+        rddata = athrs26_reg_read(0x98);
+        rddata = (rddata & 0x0) | (reg_addr<<16) | (phy_addr<<21) | (1<<27) | (1<<30) | (1<<31) ;
+        athrs26_reg_write(0x98, rddata);
+
+        rddata = athrs26_reg_read(0x98);
+        rddata = rddata & (1<<31);
+
+        // Check MDIO_BUSY status
+        while(rddata){
+        rddata = athrs26_reg_read(0x98);
+        rddata = rddata & (1<<31);
+        }
+
+
+        // Read the data from phy
+
+        rddata = athrs26_reg_read(0x98) & 0xffff;
+
+        return(rddata);
+}
+
+void s26_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+         unsigned int rddata;
+
+        // MDIO_CMD is set for read
+
+      rddata = athrs26_reg_read(0x98);
+      rddata = (rddata & 0x0) | (write_data & 0xffff) | (reg_addr<<16) | (phy_addr<<21) | (0<<27) | (1<<30) | (1<<31) ;
+      athrs26_reg_write(0x98, rddata);
+
+      rddata = athrs26_reg_read(0x98);
+      rddata = rddata & (1<<31);
+
+        // Check MDIO_BUSY status
+      while(rddata){
+      rddata = athrs26_reg_read(0x98);
+      rddata = rddata & (1<<31);
+      }
+
+}
+
+int
+athrs26_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs26_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
diff --git a/board/ar7240/common/ar7240_s26_phy.h b/board/ar7240/common/ar7240_s26_phy.h
new file mode 100644
index 0000000000..a124873916
--- /dev/null
+++ b/board/ar7240/common/ar7240_s26_phy.h
@@ -0,0 +1,119 @@
+#ifndef _ATHRS26_PHY_H
+#define _ATHRS26_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S26 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0204
+#define PORT_CONTROL_REGISTER3               0x0204
+#define PORT_CONTROL_REGISTER4               0x0204
+#define PORT_CONTROL_REGISTER5               0x0204
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S26_ARL_TBL_FUNC_REG0                0x0050
+#define S26_ARL_TBL_FUNC_REG1                0x0054
+#define S26_ARL_TBL_FUNC_REG2                0x0058
+#define S26_ARL_TBL_CTRL_REG                 0x005c
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#define S26_FORCE_100M 1
+
+#endif
diff --git a/board/ar7240/common/ath_nand.c b/board/ar7240/common/ath_nand.c
new file mode 100644
index 0000000000..b9899f8126
--- /dev/null
+++ b/board/ar7240/common/ath_nand.c
@@ -0,0 +1,1597 @@
+/*
+ * linux/drivers/mtd/nand/ath_nand.c
+ * vim: tabstop=8 : noexpandtab
+ * Derived from alauda.c
+ */
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <ar7240_soc.h>
+#include <malloc.h>
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#define ENOMEM		12
+#define EINVAL		22
+
+#define writesize		oobblock
+#define ath_reg_rd		ar7240_reg_rd
+#define ath_reg_wr		ar7240_reg_wr
+#define ath_reg_rmw_set		ar7240_reg_rmw_set
+#define ath_reg_rmw_clear	ar7240_reg_rmw_clear
+
+#define DRV_NAME	"ath-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Atheros"
+#define DRV_DESC	"Atheros on-chip NAND FLash Controller Driver"
+
+#define ATH_NF_COMMAND		(ATH_NAND_FLASH_BASE + 0x200u)
+#define ATH_NF_CTRL		(ATH_NAND_FLASH_BASE + 0x204u)
+#define ATH_NF_STATUS		(ATH_NAND_FLASH_BASE + 0x208u)
+#define ATH_NF_INT_MASK		(ATH_NAND_FLASH_BASE + 0x20cu)
+#define ATH_NF_INT_STATUS	(ATH_NAND_FLASH_BASE + 0x210u)
+#define ATH_NF_ECC_CTRL		(ATH_NAND_FLASH_BASE + 0x214u)
+#define ATH_NF_ECC_OFFSET	(ATH_NAND_FLASH_BASE + 0x218u)
+#define ATH_NF_ADDR0_0		(ATH_NAND_FLASH_BASE + 0x21cu)
+#define ATH_NF_ADDR1_0		(ATH_NAND_FLASH_BASE + 0x220u)
+#define ATH_NF_ADDR0_1		(ATH_NAND_FLASH_BASE + 0x224u)
+#define ATH_NF_ADDR1_1		(ATH_NAND_FLASH_BASE + 0x228u)
+#define ATH_NF_SPARE_SIZE	(ATH_NAND_FLASH_BASE + 0x230u)
+#define ATH_NF_PROTECT		(ATH_NAND_FLASH_BASE + 0x238u)
+#define ATH_NF_LOOKUP_EN	(ATH_NAND_FLASH_BASE + 0x240u)
+#define ATH_NF_LOOKUP0		(ATH_NAND_FLASH_BASE + 0x244u)
+#define ATH_NF_LOOKUP1		(ATH_NAND_FLASH_BASE + 0x248u)
+#define ATH_NF_LOOKUP2		(ATH_NAND_FLASH_BASE + 0x24cu)
+#define ATH_NF_LOOKUP3		(ATH_NAND_FLASH_BASE + 0x250u)
+#define ATH_NF_LOOKUP4		(ATH_NAND_FLASH_BASE + 0x254u)
+#define ATH_NF_LOOKUP5		(ATH_NAND_FLASH_BASE + 0x258u)
+#define ATH_NF_LOOKUP6		(ATH_NAND_FLASH_BASE + 0x25cu)
+#define ATH_NF_LOOKUP7		(ATH_NAND_FLASH_BASE + 0x260u)
+#define ATH_NF_DMA_ADDR		(ATH_NAND_FLASH_BASE + 0x264u)
+#define ATH_NF_DMA_COUNT	(ATH_NAND_FLASH_BASE + 0x268u)
+#define ATH_NF_DMA_CTRL		(ATH_NAND_FLASH_BASE + 0x26cu)
+#define ATH_NF_MEM_CTRL		(ATH_NAND_FLASH_BASE + 0x280u)
+#define ATH_NF_PG_SIZE		(ATH_NAND_FLASH_BASE + 0x284u)
+#define ATH_NF_RD_STATUS	(ATH_NAND_FLASH_BASE + 0x288u)
+#define ATH_NF_TIME_SEQ		(ATH_NAND_FLASH_BASE + 0x28cu)
+#define ATH_NF_TIMINGS_ASYN	(ATH_NAND_FLASH_BASE + 0x290u)
+#define ATH_NF_TIMINGS_SYN	(ATH_NAND_FLASH_BASE + 0x294u)
+#define ATH_NF_FIFO_DATA	(ATH_NAND_FLASH_BASE + 0x298u)
+#define ATH_NF_TIME_MODE	(ATH_NAND_FLASH_BASE + 0x29cu)
+#define ATH_NF_DMA_ADDR_OFFSET	(ATH_NAND_FLASH_BASE + 0x2a0u)
+#define ATH_NF_FIFO_INIT	(ATH_NAND_FLASH_BASE + 0x2b0u)
+#define ATH_NF_GENERIC_SEQ_CTRL	(ATH_NAND_FLASH_BASE + 0x2b4u)
+
+#define ATH_NF_TIMING_ASYN	0x11
+#define ATH_NF_STATUS_OK	0x40	//0xc0
+#define ATH_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH_NF_COMMAND_CMD_2(x)		(((x) & 0xff) << 24)	// A code of the third command in a sequence.
+#define ATH_NF_COMMAND_CMD_1(x)		(((x) & 0xff) << 16)	// A code of the second command in a sequence.
+#define ATH_NF_COMMAND_CMD_0(x)		(((x) & 0xff) <<  8)	// A code of the first command in a sequence.
+#define ATH_NF_COMMAND_ADDR_SEL		(1 << 7)		// Address register select flag:
+								// 0  the address register 0 selected
+								// 1  the address register 1 selected
+#define ATH_NF_COMMAND_INPUT_SEL_DMA	(1 << 6)		// Input module select flag:
+								// 0  select the SIU module as input
+								// 1  select the DMA module as input
+#define ATH_NF_COMMAND_CMD_SEQ_0	0x00
+#define ATH_NF_COMMAND_CMD_SEQ_1	0x21
+#define ATH_NF_COMMAND_CMD_SEQ_2	0x22
+#define ATH_NF_COMMAND_CMD_SEQ_3	0x03
+#define ATH_NF_COMMAND_CMD_SEQ_4	0x24
+#define ATH_NF_COMMAND_CMD_SEQ_5	0x25
+#define ATH_NF_COMMAND_CMD_SEQ_6	0x26
+#define ATH_NF_COMMAND_CMD_SEQ_7	0x27
+#define ATH_NF_COMMAND_CMD_SEQ_8	0x08
+#define ATH_NF_COMMAND_CMD_SEQ_9	0x29
+#define ATH_NF_COMMAND_CMD_SEQ_10	0x2A
+#define ATH_NF_COMMAND_CMD_SEQ_11	0x2B
+#define ATH_NF_COMMAND_CMD_SEQ_12	0x0C
+#define ATH_NF_COMMAND_CMD_SEQ_13	0x0D
+#define ATH_NF_COMMAND_CMD_SEQ_14	0x0E
+#define ATH_NF_COMMAND_CMD_SEQ_15	0x2F
+#define ATH_NF_COMMAND_CMD_SEQ_16	0x30
+#define ATH_NF_COMMAND_CMD_SEQ_17	0x11
+#define ATH_NF_COMMAND_CMD_SEQ_18	0x32
+#define ATH_NF_COMMAND_CMD_SEQ_19	0x13
+
+
+#define ATH_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000 - incrementing precise burst of precisely four transfers
+ * 001 - stream burst (address const)
+ * 010 - single transfer (address increment)
+ * 011 - burst of unspecified length (address increment)
+ * 100 - incrementing precise burst of precisely eight transfers
+ * 101 - incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH_NF_ECC_CTRL_ECC_2_BITS	ATH_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH_NF_ECC_CTRL_ECC_4_BITS	ATH_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH_NF_ECC_CTRL_ECC_6_BITS	ATH_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH_NF_ECC_CTRL_ECC_8_BITS	ATH_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH_NF_ECC_CTRL_ECC_10_BITS	ATH_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH_NF_ECC_CTRL_ECC_12_BITS	ATH_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH_NF_ECC_CTRL_ECC_14_BITS	ATH_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH_NF_ECC_CTRL_ECC_16_BITS	ATH_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH_NF_ECC_ERROR		(ATH_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH_NF_CMD_END_INT		(1 << 1)
+
+#define ATH_NF_HW_ECC		1
+#define ATH_NF_STATUS_RETRY	1000
+
+#define ath_nand_get_cmd_end_status(void)	\
+	(ath_reg_rd(ATH_NF_INT_STATUS) & ATH_NF_CMD_END_INT)
+
+#define ath_nand_clear_int_status()	ath_reg_wr(ATH_NF_INT_STATUS, 0)
+
+#define ATH_NAND_BLK_DONT_KNOW	0x0
+#define ATH_NAND_BLK_GOOD	0x1
+#define ATH_NAND_BLK_BAD	0x2
+#define ATH_NAND_BLK_ERASED	0x3
+
+#define ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR	(1 << 17)
+#define ATH_NF_GENERIC_SEQ_CTRL_DATA_EN		(1 << 16)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_CODE(x)	(((x) & 0xff) << 8)
+#define ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(x)	(((x) & 3) << 6)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_EN		(1 << 5)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD2_EN		(1 << 4)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR1_EN	(1 << 3)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD1_EN		(1 << 2)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN	(1 << 1)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN		(1 << 0)
+
+#define ATH_NAND_JFFS2_ECC_OFF	0x04	// Give 4 bytes for Factory Bad Block Marker
+#define ATH_NAND_JFFS2_ECC_LEN	0x10	// Space for JFFS2 Clean Marker
+
+/*
+ * Note: The byte positions might not match the spec.
+ * It is to handle the endianness issues.
+ */
+#define ONFI_NUM_ADDR_CYCLES	102	/* see note */
+#define ONFI_DEV_DESC		32
+#define ONFI_DEV_DESC_SZ	32
+#define ONFI_PAGE_SIZE		80
+#define ONFI_SPARE_SIZE		86	/* see note */
+#define ONFI_PAGES_PER_BLOCK	92
+#define ONFI_BLOCKS_PER_LUN	96
+#define ONFI_NUM_LUNS		103	/* see note */
+#define ONFI_RD_PARAM_PAGE_SZ	128
+#define READ_PARAM_STATUS_OK	0x40
+#define READ_PARAM_STATUS_MASK	0x41
+
+#define ATH_NAND_IO_DBG		0
+#define ATH_NAND_OOB_DBG	0
+#define ATH_NAND_IN_DBG		0
+
+#if ATH_NAND_IO_DBG
+#	define iodbg	printk
+#else
+#	define iodbg(...)
+#endif
+
+#if ATH_NAND_OOB_DBG
+#	define oobdbg	printk
+#else
+#	define oobdbg(...)
+#endif
+
+#if ATH_NAND_IN_DBG
+#	define indbg(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#	define indbg(...)
+#	define indbg1(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#endif
+
+/*
+ * Data structures for ath nand flash controller driver
+ */
+
+typedef union {
+	uint8_t			byte_id[8];
+
+	struct {
+		uint8_t		sa1	: 1,	// Serial access time (bit 1)
+				org	: 1,	// Organisation
+				bs	: 2,	// Block size
+				sa0	: 1,	// Serial access time (bit 0)
+				ss	: 1,	// Spare size per 512 bytes
+				ps	: 2,	// Page Size
+
+				wc	: 1,	// Write Cache
+				ilp	: 1,	// Interleaved Programming
+				nsp	: 2,	// No. of simult prog pages
+				ct	: 2,	// Cell type
+				dp	: 2,	// Die/Package
+
+				did,		// Device id
+				vid,		// Vendor id
+
+				res1	: 2,	// Reserved
+				pls	: 2,	// Plane size
+				pn	: 2,	// Plane number
+				res2	: 2;	// Reserved
+	} __details;
+} ath_nand_id_t;
+
+uint64_t ath_plane_size[] = {
+	64 << 20,
+	 1 << 30,
+	 2 << 30,
+	 4 << 30,
+	 8 << 30
+};
+
+typedef struct {
+	uint8_t		vid,
+			did,
+			b3,
+			addrcyc,
+			small,
+			spare;	// for small block;
+	uint16_t	pgsz;	// for small block
+	uint32_t	blk;	// for small block
+} ath_nand_vend_data_t;
+
+#define is_small_block_device(x)	((x)->entry && (x)->entry->small)
+
+ath_nand_vend_data_t ath_nand_arr[] = {
+	{ 0x20, 0xda, 0x10, 5, },	// NU2g3B2D
+	{ 0x20, 0xf1, 0x00, 4, },	// NU1g3B2C
+	{ 0x20, 0xdc, 0x10, 5, },	// NU4g3B2D
+	{ 0x20, 0xd3, 0x10, 5, },	// NU8g3F2A
+	{ 0x20, 0xd3, 0x14, 5, },	// NU8g3C2B
+	{ 0xad, 0xf1, 0x00, 4, },	// HY1g2b
+	{ 0xad, 0xda, 0x10, 5, },	// HY2g2b
+	{ 0xec, 0xf1, 0x00, 4, },	// Samsung 3,3V 8-bit [128MB]
+	{ 0x98, 0xd1, 0x90, 4, },	// Toshiba
+	{ 0xad, 0x76, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0xad, 0x36, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0x20, 0x76, 0x20, 5, 1, 16, 512, 16 << 10 },	// ST Micro 64MB NAND Flash
+};
+
+#define NUM_ARRAY_ENTRIES(a)	(sizeof((a)) / sizeof((a)[0]))
+#define NUM_ATH_NAND		NUM_ARRAY_ENTRIES(ath_nand_arr)
+
+/* ath nand info */
+typedef struct {
+	/* mtd info */
+	struct mtd_info		*mtd;
+
+	/* platform info */
+	unsigned short		page_size,
+				data_width;
+
+	/* NAND MTD partition information */
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+
+	unsigned		*bbt;
+
+	ath_nand_vend_data_t	*entry;
+
+	unsigned		ba0,
+				ba1,
+				cmd;	// Current command
+	ath_nand_id_t		__id;	// for readid
+	uint8_t			onfi[ONFI_RD_PARAM_PAGE_SZ];
+#if ATH_NF_HW_ECC
+	uint32_t		ecc_offset;
+#endif
+	uint32_t		nf_ctrl;
+} ath_nand_sc_t;
+
+ath_nand_sc_t ath_nand_sc;
+static int ath_nand_hw_init(ath_nand_sc_t *, void *);
+
+struct mtd_info nand_info[CFG_MAX_NAND_DEVICE];
+int nand_curr_device = 0;
+
+#define	nid	__id.__details
+#define	bid	__id.byte_id
+
+static int ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs);
+void ath_nand_dump_buf(loff_t addr, void *v, unsigned count);
+
+/* max page size (16k) + oob buf size */
+uint8_t	ath_nand_io_buf[24 << 10] __attribute__((aligned(4096)));
+#define get_ath_nand_io_buf()	ath_nand_io_buf
+
+#define	bbt_index	(sizeof(*sc->bbt) * 8 / 2)
+
+/*
+ * MTD layer assumes the NAND device as a linear array of bytes.
+ * However, the NAND devices are organised into blocks, pages,
+ * spare area etc. Hence, the address provided by Linux has to
+ * converted to format expected by the devices.
+ *
+ * [in] mtd: MTD info pointer
+ * [in] addr: Linear Address as provided by MTD layer
+ * [out] addr0: Value to be set into ADDR0_0 register
+ * [out] addr1: Value to be set into ADDR0_1 register
+ * [in] small_block_erase: Address conversion for small block
+ *	is different. Hence, special case it.
+ */
+inline void
+ath_nand_conv_addr(struct mtd_info *mtd, loff_t addr, uint32_t *addr0,
+			uint32_t *addr1, int small_block_erase)
+{
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc) && small_block_erase) {
+		/*
+		 * The block address loading is accomplished three
+		 * cycles. Erase is a SEQ_14 type command. Hence, the
+		 * controller starts shifting from ADDR_0[16:32] &
+		 * ADDR_1 based on the number of address cycles in our
+		 * case... The device data sheet assumes to have 3
+		 * address cycles for having page address + block
+		 * address for erase. Ideally, SMALL_BLOCK_EN in the
+		 * NF_CTRL register should help but, that doesn't seem
+		 * to work as expected. Hence, the following
+		 * conversion.
+		 */
+
+		// Get the block no.
+		uint32_t b = (addr >> mtd->erasesize_shift);
+
+		*addr0 = (b & 0xfff) << 21;
+		*addr1 = (b >> 11) & 0x1;
+	} else if (is_small_block_device(sc)) {
+		/* +-----+----+----+----+----+----+----+----+----+
+		 * |cycle|I/O7|I/O6|I/O5|I/O4|I/O3|I/O2|I/O1|I/O0|
+		 * +-----+----+----+----+----+----+----+----+----+
+		 * | 1st | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 |
+		 * | 2nd |A16 |A15 |A14 |A13 |A12 |A11 |A10 | A9 |
+		 * | 3rd |A24 |A23 |A22 |A21 |A20 |A19 |A18 |A17 |
+		 * | 4th | x  | x  | x  | x  | x  | x  | x  |A25 |
+		 * +-----+----+----+----+----+----+----+----+----+
+		 */
+		addr &= ~(mtd->writesize_mask);
+		*addr0 = ((addr & 0xff) |
+			  ((addr >> 1) & (~0xffu))) & ((1 << 25) - 1);
+		*addr1 = 0;
+	} else {
+		/* +-----+---+---+---+---+---+---+---+---+
+		 * |Cycle|IO0|IO1|IO2|IO3|IO4|IO5|IO6|IO7|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 * | 1st | A0| A1| A2| A3| A4| A5| A6| A7|
+		 * | 2nd | A8| A9|A10|A11| x | x | x | x |
+		 * | 3rd |A12|A13|A14|A15|A16|A17|A18|A19|
+		 * | 4th |A20|A21|A22|A23|A24|A25|A26|A27|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 */
+		*addr0 = ((addr >> mtd->writesize_shift) << 16);
+		*addr1 = ((addr >> (mtd->writesize_shift + 16)) & 0xf);
+	}
+}
+
+inline unsigned
+ath_nand_get_blk_state(struct mtd_info *mtd, loff_t b)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return ATH_NAND_BLK_DONT_KNOW;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	return (sc->bbt[x] >> (y * 2)) & 0x3;
+}
+
+inline void
+ath_nand_set_blk_state(struct mtd_info *mtd, loff_t b, unsigned state)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	sc->bbt[x] = (sc->bbt[x] & ~(3 << (y * 2))) | (state << (y * 2));
+}
+
+static unsigned
+ath_nand_status(ath_nand_sc_t *sc, unsigned *ecc)
+{
+	unsigned	rddata, i, j, dmastatus;
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(5);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	for (j = 0; j < ATH_NF_STATUS_RETRY && !(dmastatus & 1); j++) {
+		udelay(5);
+		dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	}
+
+	if ((i == ATH_NF_STATUS_RETRY) || (j == ATH_NF_STATUS_RETRY)) {
+		//printk("ath_nand_status: i = %u j = %u\n", i, j);
+		ath_nand_hw_init(sc, NULL);
+		return -1;
+	}
+	if (ecc) {
+		*ecc = ath_reg_rd(ATH_NF_ECC_CTRL);
+	}
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL, 0);
+	ath_reg_wr(ATH_NF_COMMAND, 0x07024);	// READ STATUS
+	while (ath_nand_get_cmd_end_status() == 0);
+	rddata = ath_reg_rd(ATH_NF_RD_STATUS);
+
+	return rddata;
+}
+
+static unsigned
+ath_check_all_0xff(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1, unsigned *all_0xff)
+{
+	uint8_t		*pa, *buf = ath_nand_io_buf, *end;
+	struct mtd_info	*mtd = sc->mtd;
+	unsigned	i, count = mtd->writesize + mtd->oobsize;
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+	ath_reg_wr(ATH_NF_DMA_CTRL, ATH_NF_DMA_CTRL_DMA_START |
+				ATH_NF_DMA_CTRL_DMA_DIR_READ |
+				ATH_NF_DMA_CTRL_DMA_BURST_3);
+	ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+	ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+	ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+	ath_reg_wr(ATH_NF_PG_SIZE, count);
+	pa = (void *)virt_to_phys(buf);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+	ath_reg_wr(ATH_NF_COMMAND, 0x30006a);	// Read page
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	i = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+	memcpy(buf, pa, count);	// cache sync equivalent
+	if (i != ATH_NF_STATUS_OK) {
+		return 0;
+	}
+	end = buf + count;
+	for (buf += sc->ecc_offset; (*buf == 0xff) && buf != end; buf ++);
+
+	*all_0xff = 1;
+
+	if (buf == end) {
+		/* This page was read without ECC. From the spare area
+		 * content we see that it a blank page (i.e. full 0xff).
+		 * To take care of bit flips if any, force 0xff on it.
+		 */
+		memset(ath_nand_io_buf, 0xff, mtd->writesize);
+	} else {
+		ath_nand_dump_buf(addr0, ath_nand_io_buf, mtd->writesize + mtd->oobsize);
+	}
+	return (buf == end);
+}
+
+static unsigned
+ath_nand_rw_page(ath_nand_sc_t *sc, int rd, unsigned addr0, unsigned addr1, unsigned count, unsigned char *buf, unsigned ecc_needed)
+{
+	unsigned	ecc, i = 0, tmp, rddata, all_0xff = 0;
+#if ATH_NF_HW_ECC
+	unsigned	mlc_retry = 0;
+#endif
+	char		*err[] = { "Write", "Read" };
+#define ATH_MAX_RETRY	25
+#define ATH_MLC_RETRY	3
+retry:
+	ecc = 0;
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)buf);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+#if ATH_NF_HW_ECC
+	if (ecc_needed && sc->ecc_offset && (count & sc->mtd->writesize_mask) == 0) {
+		/*
+		 * ECC can operate only on the device's pages.
+		 * Cannot be used for non-page-sized read/write
+		 */
+		ath_reg_wr(ATH_NF_ECC_OFFSET, sc->ecc_offset);
+		ath_reg_wr(ATH_NF_ECC_CTRL, ATH_NF_ECC_CTRL_ERR_THRESH(4) |
+						ATH_NF_ECC_CTRL_ECC_4_BITS);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_ECC_EN);
+		ath_reg_wr(ATH_NF_SPARE_SIZE, sc->mtd->oobsize);
+	} else
+#endif
+	{
+		ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+		ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+	}
+
+	if (rd) {	// Read Page
+		if (is_small_block_device(sc)) {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL,
+						ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR |
+						ATH_NF_GENERIC_SEQ_CTRL_DATA_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(1) |
+						ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN);
+			ath_reg_wr(ATH_NF_COMMAND,
+						ATH_NF_COMMAND_CMD_SEQ_18 |
+						ATH_NF_COMMAND_INPUT_SEL_DMA |
+						ATH_NF_COMMAND_CMD_0(0));
+		} else {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_COMMAND, 0x30006a);
+		}
+	} else {	// Write Page
+		ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+		ath_reg_wr(ATH_NF_DMA_CTRL,
+					ATH_NF_DMA_CTRL_DMA_START |
+					ATH_NF_DMA_CTRL_DMA_DIR_WRITE |
+					ATH_NF_DMA_CTRL_DMA_BURST_3);
+		ath_reg_wr(ATH_NF_COMMAND, 0x10804c);
+	}
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	//printk(KERN_DEBUG "%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', addr0, addr1, count, buf);
+
+	rddata = (tmp = ath_nand_status(sc, &ecc)) & ATH_NF_RD_STATUS_MASK;
+	if ((rddata != ATH_NF_STATUS_OK) && (i < ATH_MAX_RETRY)) {
+		i++;
+		goto retry;
+	}
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+	ath_reg_wr(ATH_NF_FIFO_INIT, 1);
+	ath_reg_wr(ATH_NF_FIFO_INIT, 0);
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("%s: %s Failed. tmp = 0x%x, status = 0x%x 0x%x retries = %d\n", __func__,
+			err[rd], tmp, rddata, ath_reg_rd(ATH_NF_DMA_CTRL), i);
+	}
+#if ATH_NF_HW_ECC
+	else {
+#define DDR_WB_FLUSH_USB_ADDRESS		0x180000a4
+
+		ath_reg_wr(DDR_WB_FLUSH_USB_ADDRESS, 1);
+		while (ath_reg_rd(DDR_WB_FLUSH_USB_ADDRESS) & 1);
+		udelay(2);
+
+		if (ecc_needed && (ecc & ATH_NF_ECC_ERROR)) {
+			if (rd && all_0xff == 0) {
+				if (ath_check_all_0xff(sc, addr0, addr1, &all_0xff)) {
+					return ATH_NF_STATUS_OK;
+				}
+			}
+
+			if (mlc_retry < ATH_MLC_RETRY) {
+				mlc_retry ++;
+				i = 0;
+				goto retry;
+			} else {
+				printk("%s: %s uncorrectable errors. ecc = 0x%x\n",
+					__func__, err[rd], ecc);
+				return -1;
+			}
+		}
+	}
+#endif
+	return rddata;
+}
+
+void
+ath_nand_dump_buf(loff_t addr, void *v, unsigned count)
+{
+	unsigned	*buf = v,
+			*end = buf + (count / sizeof(*buf));
+
+	iodbg("____ Dumping %d bytes at 0x%p 0x%lx_____\n", count, buf, (ulong)addr);
+
+	for (; buf && buf < end; buf += 4, addr += 16) {
+		printk("%08lx: %08x %08x %08x %08x\n",
+			(unsigned)addr, buf[0], buf[1], buf[2], buf[3]);
+	}
+	iodbg("___________________________________\n");
+	//while(1);
+}
+
+static int
+ath_nand_rw_buff(struct mtd_info *mtd, int rd, uint8_t *buf,
+		loff_t addr, size_t len, size_t *iodone)
+{
+	unsigned	iolen, ret = ATH_NF_STATUS_OK, ecc_needed;
+	unsigned char	*pa;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	*iodone = 0;
+
+	while (len) {
+		uint32_t c, ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, addr)) {
+			printk("Skipping bad block[0x%x]\n", (unsigned)addr);
+			addr += mtd->erasesize;
+			continue;
+		}
+
+		c = (addr & mtd->writesize_mask);
+
+		ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+		if (c) {
+			iolen = mtd->writesize - c;
+		} else {
+			iolen = mtd->writesize;
+		}
+
+		if (len < iolen) {
+			iolen = len;
+		}
+
+		if (rd) {
+			ecc_needed = (ath_nand_get_blk_state(mtd, addr) != ATH_NAND_BLK_ERASED);
+		} else {
+			int i;
+
+			for (i = 0; (i < mtd->writesize) && (buf[i] == 0xff); i++);
+			if (i == mtd->writesize) {
+				ret = ATH_NF_STATUS_OK;
+				//printk("Skipping write for 0x%x\n", (ulong)addr);
+				goto skip_write_for_all_0xff;
+			}
+
+			/* FIXME for writes FIXME */
+			memcpy(ath_nand_io_buf, buf, iolen);
+			ecc_needed = 1;
+		}
+
+		pa = (void *)virt_to_phys(ath_nand_io_buf);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+		//	rd ? 'r' : 'w', ba0, ba1, iolen, pa);
+
+		ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize, pa, ecc_needed);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		if (rd) {
+			memcpy(buf, ath_nand_io_buf + c, iolen);
+		}
+skip_write_for_all_0xff:
+		//ath_nand_dump_buf(addr, buf, iolen);
+
+		if (ret != ATH_NF_STATUS_OK) {
+			return 1;
+		}
+
+		len -= iolen;
+		buf += iolen;
+		addr += iolen;
+		*iodone += iolen;
+	}
+
+	return 0;
+}
+
+#define ath_nand_write_verify	0
+
+#if ath_nand_write_verify
+uint8_t	ath_nand_rd_buf[4096 + 256] __attribute__((aligned(4096)));
+#endif
+
+static int
+ath_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int	ret;
+#if ath_nand_write_verify
+	int	r, rl;
+#endif
+
+	if (!len || !retlen) return (0);
+
+	indbg("0x%llx	%u", to, len);
+
+	ret = ath_nand_rw_buff(mtd, 0 /* write */, (u_char *)buf, to, len, retlen);
+#if ath_nand_write_verify
+	//printk("Verifying 0x%llx 0x%x\n", to, len);
+	r = ath_nand_rw_buff(mtd, 1 /* read */, ath_nand_rd_buf, to, len, &rl);
+	if (r || memcmp(ath_nand_rd_buf, buf, len)) {
+		printk("write failed at 0x%llx 0x%x\n", to, len);
+		while (1);
+	}
+#endif
+	return ret;
+}
+
+static int
+ath_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int	ret;
+
+	if (!len || !retlen) return (0);
+
+	ret = ath_nand_rw_buff(mtd, 1 /* read */, buf, from, len, retlen);
+
+	return ret;
+}
+
+static inline int
+ath_nand_block_erase(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1)
+{
+	unsigned	rddata;
+
+	indbg("0x%x 0x%x", addr1, addr0);
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_COMMAND, 0xd0600e);	// BLOCK ERASE
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	rddata = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("Erase Failed. status = 0x%x\n", rddata);
+		return 1;
+	}
+	return 0;
+}
+
+
+static int
+ath_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	ulong		s_first, i;
+	unsigned	n, j;
+	int		ret, bad = 0;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return (-EINVAL);
+	}
+
+	s_first = instr->addr;
+	n = instr->len >> mtd->erasesize_shift;
+
+	if (instr->len & mtd->erasesize_mask) n ++;
+
+	indbg("0x%llx 0x%x 0x%x", instr->addr, n, mtd->erasesize);
+
+	printk("%s: 0x%x %u\n", __func__, s_first, n);
+
+	for (j = 0, i = s_first; j < n; j++, i += mtd->erasesize) {
+		uint32_t ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, i)) {
+			bad ++;
+			continue;
+		}
+
+		ath_nand_conv_addr(mtd, i, &ba0, &ba1, 1);
+
+		printk("\b\b\b\b%4d", j);
+
+		if ((ret = ath_nand_block_erase(sc, ba0, ba1)) != 0) {
+			printf("%s: erase failed 0x%x 0x%x 0x%x %x "
+				"%lx %lx\n", __func__, instr->addr, n,
+				mtd->erasesize, i, ba1, ba0);
+			break;
+		}
+		ath_nand_set_blk_state(mtd, i, ATH_NAND_BLK_ERASED);
+	}
+
+	if (instr->callback) {
+		if (j < n) {
+			instr->state = MTD_ERASE_FAILED;
+		} else {
+			instr->state = MTD_ERASE_DONE;
+		}
+		mtd_erase_callback(instr);
+	}
+
+	printk("Skipped %d bad blocks\n", bad);
+
+	return ret;
+}
+
+/* lifted from linux */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+struct mtd_oob_ops {
+	mtd_oob_mode_t  mode;
+	size_t          len;
+	size_t          retlen;
+	size_t          ooblen;
+	size_t          oobretlen;
+	uint32_t        ooboffs;
+	uint8_t         *datbuf;
+	uint8_t         *oobbuf;
+};
+
+static int
+ath_nand_rw_oob(struct mtd_info *mtd, int rd, loff_t addr,
+		struct mtd_oob_ops *ops)
+{
+	unsigned	ret = ATH_NF_STATUS_OK;
+	unsigned char	*pa;
+	uint32_t	ba0, ba1;
+	uint8_t		*oob = ath_nand_io_buf + mtd->writesize;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+	if (!rd) {
+		if (ops->datbuf) {
+			/*
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 * We assume that the caller gives us a full
+			 * page to write. We don't read the page and
+			 * update the changed portions alone.
+			 *
+			 * Hence, not checking for len < or > pgsz etc...
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 */
+			memcpy(ath_nand_io_buf, ops->datbuf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// clean markers
+			oob[0] = oob[1] = 0xff;
+			oob += 2;
+		}
+		memcpy(oob, ops->oobbuf, ops->ooblen);
+	}
+
+	pa = (void *)virt_to_phys(ath_nand_io_buf);
+	if (!rd) flush_cache(ath_nand_io_buf, mtd->writesize + mtd->oobsize);	// for writes...
+
+	//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', ba0, ba1, mtd->writesize + mtd->oobsize, pa);
+
+	ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize + mtd->oobsize, pa, 0);
+
+	if (ret != ATH_NF_STATUS_OK) {
+		return 1;
+	}
+
+	if (rd) {
+		memcpy(ath_nand_io_buf, KSEG1ADDR(pa), mtd->writesize + mtd->oobsize);	// for reads...
+
+		if (ops->datbuf) {
+			memcpy(ops->datbuf, ath_nand_io_buf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// copy after clean marker
+			oob += 2;
+		}
+		memcpy(ops->oobbuf, oob, ops->ooblen);
+	}
+
+	//if (rd) {
+	//	ath_nand_dump_buf(addr, ops->datbuf, ops->len);
+	//	ath_nand_dump_buf(addr, ops->oobbuf, ops->ooblen);
+	//}
+
+	if (ops->datbuf) {
+		ops->retlen = ops->len;
+	}
+	ops->oobretlen = ops->ooblen;
+
+	return 0;
+}
+
+//static int
+//ath_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct mtd_oob_ops ops = { MTD_OOB_RAW, len, 0, ooblen, 0,
+					0, buf, buf + mtd->writesize };
+
+	oobdbg(	"%s: from: 0x%lx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, (uint32_t)from,
+		ops.mode, ops.len, ops.retlen, ops.ooblen,
+		ops.oobretlen, ops.ooboffs, ops.datbuf,
+		ops.oobbuf);
+
+	oobdbg("0x%lx %p %p %u\n", (uint32_t)from, ops.oobbuf, ops.datbuf, ops.len);
+
+	if (len == 0) {
+		ops.datbuf = 0;
+		ops.oobbuf = buf;
+	}
+	if (ooblen == 0) {
+		ops.oobbuf = NULL;
+	}
+
+	return ath_nand_rw_oob(mtd, 1 /* read */, from, &ops);
+}
+
+#if 0
+static int
+ath_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret;
+	unsigned char oob[128];
+	struct mtd_oob_ops	rops = {
+		.mode	= MTD_OOB_RAW,
+		.ooblen	= mtd->oobsize,
+		.oobbuf	= oob,
+	};
+
+	if (ops->mode == MTD_OOB_AUTO) {
+		/* read existing oob */
+		if (ath_nand_read_oob(mtd, to, &rops) ||
+			rops.oobretlen != rops.ooblen) {
+			printk("%s: oob read failed at 0x%llx\n", __func__, to);
+			return 1;
+		}
+		memcpy(oob + 2, ops->oobbuf, ops->ooblen);
+		rops = *ops;
+		ops->oobbuf = oob;
+		ops->ooblen = mtd->oobsize;
+		ops->mode = MTD_OOB_RAW;
+	}
+
+	oobdbg(	"%s: from: 0x%llx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, to,
+		ops->mode, ops->len, ops->retlen, ops->ooblen,
+		ops->oobretlen, ops->ooboffs, ops->datbuf,
+		ops->oobbuf);
+
+	indbg("0x%llx", to);
+
+	ret = ath_nand_rw_oob(mtd, 0 /* write */, to, ops);
+
+	if (rops.mode == MTD_OOB_AUTO) {
+		if (ret == 0) { // rw oob success
+			rops.oobretlen = rops.ooblen;
+			rops.retlen = rops.len;
+		}
+		*ops = rops;
+	}
+
+	return ret;
+}
+#endif
+
+static int
+ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	unsigned char		oob[256];
+	unsigned		bs, i;
+	unsigned		*force = (unsigned *)0xbd000000;
+
+	if (*force == 0x12345678) {
+		return 0;
+	}
+
+	bs = ath_nand_get_blk_state(mtd, ofs);
+
+	if ((bs == ATH_NAND_BLK_ERASED) || (bs == ATH_NAND_BLK_GOOD)) {
+		return 0;
+	}
+
+	if (bs == ATH_NAND_BLK_BAD) {
+		return 1;
+	}
+
+	/*
+	 * H27U1G8F2B Series [1 Gbit (128 M x 8 bit) NAND Flash]
+	 *
+	 * The Bad Block Information is written prior to shipping. Any
+	 * block where the 1st Byte in the spare area of the 1st or
+	 * 2nd th page (if the 1st page is Bad) does not contain FFh
+	 * is a Bad Block. The Bad Block Information must be read
+	 * before any erase is attempted as the Bad Block Information
+	 * may be erased. For the system to be able to recognize the
+	 * Bad Blocks based on the original information it is
+	 * recommended to create a Bad Block table following the
+	 * flowchart shown in Figure 24. The 1st block, which is
+	 *                               ^^^^^^^^^^^^^
+	 * placed on 00h block address is guaranteed to be a valid
+	 * block.                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
+	 */
+
+	for (i = 0; i < 2; i++, ofs += mtd->writesize) {
+		if (nand_read_raw(mtd, oob, ofs, 0, mtd->oobsize)) {
+			printk("%s: oob read failed at 0x%lx\n", __func__, (unsigned)ofs);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_DONT_KNOW);
+			return 1;
+		}
+
+		/* First two bytes of oob data are clean markers */
+		if (oob[0] != 0xff || oob[1] != 0xff) {
+			oobdbg("%s: block is bad at 0x%lx\n", __func__, (unsigned)ofs);
+			oobdbg(	"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				0xff & oob[ 0], 0xff & oob[ 1], 0xff & oob[ 2],
+				0xff & oob[ 3], 0xff & oob[ 4], 0xff & oob[ 5],
+				0xff & oob[ 6], 0xff & oob[ 7], 0xff & oob[ 8],
+				0xff & oob[ 9], 0xff & oob[10], 0xff & oob[11],
+				0xff & oob[12], 0xff & oob[13], 0xff & oob[14],
+				0xff & oob[15], 0xff & oob[16], 0xff & oob[17],
+				0xff & oob[18], 0xff & oob[19], 0xff & oob[20],
+				0xff & oob[21], 0xff & oob[22], 0xff & oob[23],
+				0xff & oob[24], 0xff & oob[25], 0xff & oob[26],
+				0xff & oob[27], 0xff & oob[28], 0xff & oob[29],
+				0xff & oob[30], 0xff & oob[31], 0xff & oob[32],
+				0xff & oob[33], 0xff & oob[34], 0xff & oob[35],
+				0xff & oob[36], 0xff & oob[37], 0xff & oob[38],
+				0xff & oob[39], 0xff & oob[40], 0xff & oob[41],
+				0xff & oob[42], 0xff & oob[43], 0xff & oob[44],
+				0xff & oob[45], 0xff & oob[46], 0xff & oob[47],
+				0xff & oob[48], 0xff & oob[49], 0xff & oob[50],
+				0xff & oob[51], 0xff & oob[52], 0xff & oob[53],
+				0xff & oob[54], 0xff & oob[55], 0xff & oob[56],
+				0xff & oob[57], 0xff & oob[58], 0xff & oob[59],
+				0xff & oob[60], 0xff & oob[61], 0xff & oob[62],
+				0xff & oob[63]);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_BAD);
+			return 1;
+		}
+	}
+
+	for (i = 0; (i < mtd->oobsize) && (oob[i] == 0xff); i++);
+
+	if (i == mtd->oobsize) {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_ERASED);
+	} else {
+	      ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_GOOD);
+	}
+
+	return 0;
+}
+
+static int
+ath_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	indbg("unimplemented 0x%llx", ofs);
+	return 0;
+}
+
+static unsigned long
+ath_parse_read_id(ath_nand_sc_t *sc)
+{
+	int	i;
+
+	extern struct nand_manufacturers nand_manuf_ids[];
+	extern struct nand_flash_dev nand_flash_ids[];
+
+	iodbg(	"____ %s _____\n"
+		"  vid did wc  ilp nsp ct  dp  sa1 org bs  sa0 ss  "
+		"ps  res1 pls pn  res2\n"
+		"0x%3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x "
+		"%3x %3x  %3x %3x %3x\n-------------\n", __func__,
+			sc->nid.vid, sc->nid.did, sc->nid.wc, sc->nid.ilp,
+			sc->nid.nsp, sc->nid.ct, sc->nid.dp, sc->nid.sa1,
+			sc->nid.org, sc->nid.bs, sc->nid.sa0, sc->nid.ss,
+			sc->nid.ps, sc->nid.res1, sc->nid.pls, sc->nid.pn,
+			sc->nid.res2);
+
+	for (i = 0; i < nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == sc->nid.vid) {
+			printk(nand_manuf_ids[i].name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nand_flash_ids[i].id; i++) {
+		if (nand_flash_ids[i].id == sc->nid.did) {
+			printk(" %s [%uMB]\n", nand_flash_ids[i].name,
+				nand_flash_ids[i].chipsize);
+			return nand_flash_ids[i].chipsize;
+		}
+	}
+
+	return 0;
+}
+
+ath_nand_vend_data_t *
+nand_get_entry(ath_nand_id_t *nand_id, ath_nand_vend_data_t *tbl, int count)
+{
+	int     i;
+
+	for (i = 0; i < count; i++, tbl ++) {
+		if ((nand_id->__details.vid == tbl->vid) &&
+		    (nand_id->__details.did == tbl->did) &&
+		    (nand_id->byte_id[1] == tbl->b3)) {
+			return tbl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void
+ath_nand_onfi_endian_convert(uint8_t *buf)
+{
+	uint32_t	i, *u = (uint32_t *)(buf + ONFI_DEV_DESC);
+
+	for (i = 0; i < (ONFI_DEV_DESC_SZ / sizeof(*u)); i++) {
+		u[i] = __le32_to_cpu(u[i]);
+	}
+
+	// Hope nobody has a 20 character device description
+	buf[ONFI_DEV_DESC + ONFI_DEV_DESC_SZ - 1] = 0;
+}
+
+int
+nand_param_page(ath_nand_sc_t *sc, uint8_t *buf, unsigned count)
+{
+	unsigned int	tries, rddata;
+	uint8_t		*pa;
+
+	pa = virt_to_phys(buf);
+
+	for (tries = 3; tries; tries --) {
+		// ADDR0_0 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+
+		// ADDR0_1 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+
+		// DMA Start Addr
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+
+		// DMA count
+		ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+		// Custom Page Size
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+
+		// DMA Control Reg
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+
+		ath_nand_clear_int_status();
+		// READ PARAMETER PAGE
+		ath_reg_wr(ATH_NF_COMMAND, 0xec62);
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL) & READ_PARAM_STATUS_MASK;
+		if (rddata == READ_PARAM_STATUS_OK) {
+			break;
+		} else {
+			printk("\nParam Page Failure: 0x%x", rddata);
+			ath_nand_hw_init(sc, NULL);
+		}
+	}
+
+	memcpy(buf, KSEG1ADDR(buf), count);	// get into the cache
+
+	//ath_nand_dump_buf(buf, buf, count);
+
+	if ((rddata == READ_PARAM_STATUS_OK) &&
+	    (buf[3] == 'O' && buf[2] == 'N' && buf[1] == 'F' && buf[0] == 'I')) {
+		ath_nand_onfi_endian_convert(buf);
+		printf("ONFI %s\n", buf + ONFI_DEV_DESC);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * System initialization functions
+ */
+static int
+ath_nand_hw_init(ath_nand_sc_t *sc, void *p)
+{
+	uint8_t		id[8];
+	unsigned char	*pa;
+	unsigned	rddata, i;
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(250);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(100);
+
+	ath_reg_wr(ATH_NF_INT_MASK, ATH_NF_CMD_END_INT);
+	ath_nand_clear_int_status();
+
+	// TIMINGS_ASYN Reg Settings
+	ath_reg_wr(ATH_NF_TIMINGS_ASYN, ATH_NF_TIMING_ASYN);
+
+	// NAND Mem Control Reg
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);
+
+	// Reset Command
+	ath_reg_wr(ATH_NF_COMMAND, 0xff00);
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	udelay(1000);
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(25);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	if (i == ATH_NF_STATUS_RETRY) {
+		printf("device reset failed\n");
+		while(1);
+	}
+
+	if (p) {
+		ath_nand_vend_data_t *entry;
+
+		ath_nand_clear_int_status();
+		pa = (void *)virt_to_phys(p ? p : id);
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+		ath_reg_wr(ATH_NF_DMA_COUNT, 0x8);
+		ath_reg_wr(ATH_NF_PG_SIZE, 0x8);
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+		ath_reg_wr(ATH_NF_COMMAND, 0x9061);	// READ ID
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL);
+		if ((rddata & ATH_NF_RD_STATUS_MASK) != ATH_NF_STATUS_OK) {
+			printf("%s: ath nand status = 0x%x\n", __func__, rddata);
+		}
+
+		pa = p;
+		printk("Ath Nand ID[%p]: %02x:%02x:%02x:%02x:%02x\n",
+				pa, pa[3], pa[2], pa[1], pa[0], pa[7]);
+
+		sc->onfi[0] = 0;
+
+		entry = nand_get_entry((ath_nand_id_t *)p, ath_nand_arr, NUM_ATH_NAND);
+		if (entry) {
+			//sc->entry = entry;
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(entry->addrcyc);
+		} else if (nand_param_page(sc, sc->onfi, sizeof(sc->onfi)) == 0) {
+			rddata = sc->onfi[ONFI_NUM_ADDR_CYCLES];
+			rddata = ((rddata >> 4) & 0xf) + (rddata & 0xf);
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(rddata);
+		} else {
+			printk("Attempting to use unknown device\n");
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(5);
+		}
+
+		iodbg("******* %s done ******\n", __func__);
+	}
+
+	return 0;
+}
+
+/*
+ * Copied from drivers/mtd/nand/nand_base.c
+ * http://ptgmedia.pearsoncmg.com/images/chap17_9780132396554/elementLinks/17fig04.gif
+ *
+ * +---...---+--+----------+---------+
+ * |  2048   |  |          |         |
+ * | File    |cm| FS spare | ecc data|
+ * | data    |  |          |         |
+ * +---...---+--+----------+---------+
+ * cm -> clean marker (2 bytes)
+ * FS Spare -> bytes available for jffs2
+ */
+
+static void
+ath_nand_ecc_init(struct mtd_info *mtd)
+{
+#if ATH_NF_HW_ECC
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc)) {
+		// ECC cannot be supported...
+		sc->ecc_offset = 0;
+	} else {
+		sc->ecc_offset = mtd->writesize + ATH_NAND_JFFS2_ECC_OFF +
+						ATH_NAND_JFFS2_ECC_LEN;
+	}
+#else
+	sc->ecc_offset = 0;
+#endif
+}
+
+void
+ath_nand_set_ns(struct mtd_info *mtd)
+{
+#define ATH_DEF_PAGE_SIZE	(2u << 10)
+#define ATH_DEF_BLK_SIZE	(128u << 10)
+#define ATH_NAND_SPEC		"ns"
+
+	char ns[64], *p;
+
+	if ((p = getenv(ATH_NAND_SPEC))) {
+		/* don't override user setting */
+		return;
+	}
+
+	if (mtd->writesize == ATH_DEF_PAGE_SIZE &&
+	    mtd->erasesize == ATH_DEF_BLK_SIZE) {
+		return;
+	}
+
+	sprintf(ns, "-0x%x-0x%x", mtd->erasesize, mtd->writesize);
+	setenv(ATH_NAND_SPEC, ns);
+	printf("set " ATH_NAND_SPEC " %s\n", ns);
+}
+
+/*
+ * ath_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static ulong ath_nand_probe(void)
+{
+	ath_nand_sc_t	*sc = NULL;
+	struct mtd_info	*mtd = NULL;
+	int		i, err = 0, bbt_size;
+	unsigned	nf_ctrl_pg[][2] = {
+		/* page size in bytes, register val */
+		{   256, ATH_NF_CTRL_PAGE_SIZE_256	},
+		{   512, ATH_NF_CTRL_PAGE_SIZE_512	},
+		{  1024, ATH_NF_CTRL_PAGE_SIZE_1024	},
+		{  2048, ATH_NF_CTRL_PAGE_SIZE_2048	},
+		{  4096, ATH_NF_CTRL_PAGE_SIZE_4096	},
+		{  8192, ATH_NF_CTRL_PAGE_SIZE_8192	},
+		{ 16384, ATH_NF_CTRL_PAGE_SIZE_16384	},
+		{     0, ATH_NF_CTRL_PAGE_SIZE_0	},
+		};
+	unsigned	nf_ctrl_blk[][2] = {
+		/* no. of pages, register val */
+		{  32, ATH_NF_CTRL_BLOCK_SIZE_32	},
+		{  64, ATH_NF_CTRL_BLOCK_SIZE_64	},
+		{ 128, ATH_NF_CTRL_BLOCK_SIZE_128	},
+		{ 256, ATH_NF_CTRL_BLOCK_SIZE_256	},
+		{   0, 0				},
+		};
+
+	sc = &ath_nand_sc;
+	sc->mtd = &nand_info[nand_curr_device];
+
+	/* initialise the hardware */
+	err = ath_nand_hw_init(sc, &sc->nid);
+	if (err) {
+		goto out_err_hw_init;
+	}
+
+	/* initialise mtd sc data struct */
+	mtd = sc->mtd;
+	mtd->size = ath_parse_read_id(sc) << 20;
+
+	mtd->name		= DRV_NAME;
+	if (mtd->size == 0) {
+		mtd->size	= ath_plane_size[sc->nid.pls] << sc->nid.pn;
+	}
+
+	if (is_small_block_device(sc)) {
+		mtd->writesize		= sc->entry->pgsz;
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= mtd->writesize - 1;
+
+		mtd->erasesize		= sc->entry->blk;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= mtd->erasesize - 1;
+
+		mtd->oobsize		= sc->entry->spare;
+		mtd->oobavail		= mtd->oobsize;
+	} else if (!sc->onfi[0]) {
+		mtd->writesize_shift	= 10 + sc->nid.ps;
+		mtd->writesize		= (1 << mtd->writesize_shift);
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize_shift	= 16 + sc->nid.bs;
+		mtd->erasesize		= (1 << mtd->erasesize_shift);
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= (mtd->writesize / 512) * (8 << sc->nid.ss);
+		mtd->oobavail		= mtd->oobsize;
+	} else {
+		mtd->writesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGE_SIZE]);
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGES_PER_BLOCK]) *
+					  mtd->writesize;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= *(uint16_t *)(&sc->onfi[ONFI_SPARE_SIZE]);
+		mtd->oobavail		= mtd->oobsize;
+
+		mtd->size		= mtd->erasesize *
+					  (*(uint32_t *)(&sc->onfi[ONFI_BLOCKS_PER_LUN])) *
+					  sc->onfi[ONFI_NUM_LUNS];
+	}
+
+	for (i = 0; nf_ctrl_pg[i][0]; i++) {
+		if (nf_ctrl_pg[i][0] == mtd->writesize) {
+			sc->nf_ctrl |= nf_ctrl_pg[i][1];
+			break;
+		}
+	}
+
+	for (i = 0; nf_ctrl_blk[i][0]; i++) {
+		if (nf_ctrl_blk[i][0] == (mtd->erasesize / mtd->writesize)) {
+			sc->nf_ctrl |= nf_ctrl_blk[i][1];
+			break;
+		}
+	}
+
+	ath_nand_set_ns(mtd);
+
+	mtd->type		= MTD_NANDFLASH;
+	mtd->flags		= MTD_CAP_NANDFLASH;
+
+	mtd->read		= ath_nand_read;
+	mtd->write		= ath_nand_write;
+	mtd->erase		= ath_nand_erase;
+
+	//mtd->read_oob		= ath_nand_read_oob;
+	//mtd->write_oob		= ath_nand_write_oob;
+
+	mtd->block_isbad	= ath_nand_block_isbad;
+	mtd->block_markbad	= ath_nand_block_markbad;
+
+	mtd->priv		= sc;
+
+	ath_nand_ecc_init(mtd);
+
+	// bbt has 2 bits per block
+	bbt_size = ((mtd->size >> mtd->erasesize_shift) * 2) / 8;
+	sc->bbt = malloc(bbt_size);
+
+	if (sc->bbt) {
+		memset(sc->bbt, 0, bbt_size);
+	}
+
+	printf(	"====== NAND Parameters ======\n"
+		"sc = 0x%p bbt = 0x%p bbt_size = 0x%x nf_ctrl = 0x%x\n"
+		"page = 0x%x block = 0x%x oob = 0x%x\nsize = %uMB\n", sc, sc->bbt, bbt_size,
+		sc->nf_ctrl, mtd->writesize, mtd->erasesize, mtd->oobsize, mtd->size >> 20);
+
+	return mtd->size;
+
+out_err_hw_init:
+	return 0;
+}
+
+#if 0
+static struct platform_driver ath_nand_driver = {
+	//.probe		= ath_nand_probe,
+	.remove		= __exit_p(ath_nand_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+#endif
+
+ulong ath_nand_init(void)
+{
+	printk(DRV_DESC ", Version " DRV_VERSION
+		" (c) 2010 Atheros Communications, Ltd.\n");
+
+	//return platform_driver_register(&ath_nand_driver);
+	//return platform_driver_probe(&ath_nand_driver, ath_nand_probe);
+	return ath_nand_probe();
+}
diff --git a/board/ar7240/common/athr_s27_phy.c b/board/ar7240/common/athr_s27_phy.c
new file mode 100644
index 0000000000..8d8497559c
--- /dev/null
+++ b/board/ar7240/common/athr_s27_phy.c
@@ -0,0 +1,877 @@
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athr_s27_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS27"
+
+/*
+ * Track per-PHY port information.
+ */
+
+
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+
+   {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs27_phy_is_link_alive(int phyUnit);
+uint32_t athrs27_reg_read(uint32_t reg_addr);
+void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs27_powersave_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs27_sleep_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs27_force_100M(int phyAddr,int duplex)
+{
+   /*
+    *  Force MDI and MDX to alternate ports
+    *  Phy 0,2 and 4 -- MDI
+    *  Phy 1 and 3 -- MDX
+    */
+
+    if(phyAddr%2) {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+    }
+    else {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+    }
+
+    s27_wr_phy(phyAddr,0x1d,0x29);
+    s27_wr_phy(phyAddr,0x1e,0x0);
+    s27_wr_phy(phyAddr,0x10,0xc60);
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0xa000|(duplex << 8)));
+}
+
+void athrs27_force_10M(int phyAddr,int duplex)
+{
+
+    athrs27_powersave_off(phyAddr);
+    athrs27_sleep_off(phyAddr);
+
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0x8000 |(duplex << 8)));
+}
+
+int athrs27_reg_init(void)
+{
+#if S27_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+
+    /* if using header for register configuration, we have to     */
+    /* configure s27 register after frame transmission is enabled */
+    athrs27_reg_rmw(0x8,(1<<28));  /* Set WAN port is connected to GE0 */
+
+#if defined(S27_FORCE_100M)
+    athrs27_force_100M(ATHR_PHY4_ADDR,1);
+#elif  defined(S27_FORCE_10M)
+    athrs27_force_10M(ATHR_PHY4_ADDR,1);
+#else
+    s27_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+
+#endif
+#ifdef S27_PHY_DEBUG
+    printf(MODULE_NAME":OPERATIONAL_MODE_REG0:%x\n",athrs27_reg_read(OPERATIONAL_MODE_REG0));
+    printf(MODULE_NAME":REG 0x4-->:%x\n",athrs27_reg_read(0x4));
+    printf(MODULE_NAME":REG 0x2c-->:%x\n",athrs27_reg_read(0x2c));
+    printf(MODULE_NAME":REG 0x8-->:%x\n",athrs27_reg_read(0x8));
+#endif
+
+    return 0;
+}
+
+int athrs27_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s27\n");
+    athrs27_reg_write(0x0, athrs27_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        sysMsDelay(100);
+        if(!(athrs27_reg_read(0x0)&0x80000000))
+            break;
+    }
+    printf(MODULE_NAME ": s27 reset done\n");
+    athrs27_reg_write(PORT_STATUS_REGISTER0,0x4e);
+
+    athrs27_reg_rmw(OPERATIONAL_MODE_REG0,(1<<6));  /* Set GMII mode */
+
+    if (is_emu() || is_wasp()) {
+       athrs27_reg_rmw(0x2c,((1<<26)| (1<<16) | 0x1)); /* FiX ME: EBU debug */
+    }
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+#if defined(S27_FORCE_100M)
+        athrs27_force_100M(phyAddr,1);
+#elif defined(S27_FORCE_10M)
+        athrs27_force_10M(phyAddr,1);
+#else
+        s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+#endif
+
+#if S27_PHY_DEBUG
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_FUNC_CONTROL);
+        printf("S27 ATHR_PHY_FUNC_CONTROL (%d):%x\n",phyAddr,rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_ID1);
+        printf("S27 PHY ID  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+        printf("S27 PHY CTRL  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_STATUS);
+        printf("S27 ATHR PHY STATUS  (%d) :%x\n",phyAddr, rd_val);
+#endif
+    }
+
+    /*
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x01 - 100Mbps, 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+    athrs27_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs27_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs27_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs27_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+
+    if (is_emu()) {
+        athrs27_reg_write(PORT_STATUS_REGISTER1, 0x4C);  /* LAN - 1 */
+        athrs27_reg_write(PORT_STATUS_REGISTER2, 0x4c);  /* LAN - 2 */
+        athrs27_reg_write(PORT_STATUS_REGISTER3, 0x4c);  /* LAN - 3 */
+        athrs27_reg_write(PORT_STATUS_REGISTER4, 0x4c);  /* LAN - 4 */
+    }
+
+    /* QM Control */
+    athrs27_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef ATHEROS_HEADER_EN
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+#else
+   /* Atheros Header Disable */
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+    /* Tag Priority Mapping */
+    athrs27_reg_write(0x70, 0xfa50);
+
+    /* Enable ARP packets to CPU port */
+    athrs27_reg_write(S27_ARL_TBL_CTRL_REG,(athrs27_reg_read(S27_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs27_reg_write(S27_FLD_MASK_REG,(athrs27_reg_read(S27_FLD_MASK_REG) |
+                           S27_ENABLE_CPU_BROADCAST | S27_ENABLE_CPU_BCAST_FWD ));
+
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs27_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+BOOL
+athrs27_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+//#if S27_PHY_DEBUG
+    uint32_t  rd_val = 0;
+//#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        if (!is_emu()) {
+           s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+           s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+        }
+        else  {
+		printf("############ is emulation ############\n");
+
+           if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+           else {
+
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,(ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE |
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL));
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+       }
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+       printf("%s ATHR_PHY_CONTROL %d :%x\n",__func__,phyAddr,rd_val);
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+       printf("%s ATHR_PHY_SPEC_STAUS %d :%x\n",__func__,phyAddr,rd_val);
+    }
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if (ethUnit == ENET_UNIT_LAN)
+        sysMsDelay(100);// changed by lsz, sysMsDelay(1000);
+    else
+        sysMsDelay(300);// changed by lsz, sysMsDelay(3000);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN)
+            continue;
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+        /* extend the cable length */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x14);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xf52);
+
+       /* Force Class A setting phys */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 4);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xebbb);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 5);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x2c47);
+
+        /* fine-tune PHYs */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x3c);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x1c1);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x37);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xd600);
+
+
+#ifdef S27_VER_1_0
+        /* turn off power saving */
+        s27_wr_phy(phyUnit, 29, 41);
+        s27_wr_phy(phyUnit, 30, 0);
+        printf("def_ S27_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s27_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs27_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s27_rd_phy (phyAddr, ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            } while(--ii);
+            if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+/******************************************************************************
+*
+* athrs27_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               ATHR_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               ATHR_PHY_SPEED_1000T;
+*/
+
+int
+athrs27_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    int       phySpeed;
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = _10BASET;
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            }while(--ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = _10BASET;
+		break;
+            case 1:
+                phySpeed = _100BASET;
+		break;
+            case 2:
+                phySpeed = _1000BASET;
+		break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+        phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+
+        if(phySpeed == _100BASET) {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = _1000BASET;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs27_phy_is_up(int ethUnit)
+{
+
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+    int           phyUnit;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                printf("enet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            if(is_emu())
+            {
+                phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+                if(phyAddr%2) {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+                }
+                else {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+                }
+
+                if((phyHwStatus & 0x4)==0)
+                {
+                   s27_wr_phy(phyAddr,0x9,0x0);
+                   if(phyAddr !=0x4)
+                       s27_wr_phy(phyAddr,0x4,0x41);
+                   s27_wr_phy(phyAddr,0x0,0x9000);
+                }
+            }
+
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+             phyHwControl = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+             phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                printf("enet%d port%d up\n",ethUnit, phyUnit);
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+    return (linkCount);
+}
+
+unsigned int athrs27_reg_read(unsigned int s27_addr)
+{
+    unsigned int addr_temp;
+    unsigned int s27_rd_csr_low, s27_rd_csr_high, s27_rd_csr;
+    unsigned int data,unit = 0;
+    unsigned int phy_address, reg_address;
+
+    addr_temp = s27_addr >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()) {
+        unit = 1;
+    }
+
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+    reg_address = ((addr_temp << 1) & 0x1e);
+    s27_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+
+    reg_address = reg_address | 0x1;
+    s27_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+    s27_rd_csr = (s27_rd_csr_high << 16) | s27_rd_csr_low ;
+
+    return(s27_rd_csr);
+}
+
+void athrs27_reg_write(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    unsigned int addr_temp;
+    unsigned int data;
+    unsigned int phy_address, reg_address,unit = 0;
+
+    addr_temp = (s27_addr ) >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()) {
+        unit = 1;
+    }
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+
+    reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+    data = (s27_write_data >> 16) & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s27_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+}
+
+void athrs27_reg_rmw(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    int val = athrs27_reg_read(s27_addr);
+    athrs27_reg_write(s27_addr,(val | s27_write_data));
+}
+
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+     unsigned int rddata, i = 100;
+
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = (rddata & 0x0) | (reg_addr<<16)
+              | (phy_addr<<21) | (1<<27)
+              | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg:%X rddata:%X\n",
+                __func__,phy_addr,reg_addr,rddata);
+    /* Read the data from phy */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & 0xffff;
+    return(rddata);
+}
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    unsigned int rddata,i = 100;
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+
+    rddata = (rddata & 0x0) | (write_data & 0xffff)
+               | (reg_addr<<16) | (phy_addr<<21)
+               | (0<<27) | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg%X\n",__func__,phy_addr,reg_addr);
+
+}
+
+int athrs27_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs27_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
diff --git a/board/ar7240/common/athr_s27_phy.h b/board/ar7240/common/athr_s27_phy.h
new file mode 100644
index 0000000000..69540189db
--- /dev/null
+++ b/board/ar7240/common/athr_s27_phy.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS27_PHY_H
+#define _ATHRS27_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+#define ATHR_PHY_INTR_ENABLE             0x12
+#define ATHR_PHY_INTR_STATUS             0x13
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF		      0x0100
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DUPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#define OPERATIONAL_MODE_REG0                0x4
+
+/* S27 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0304
+#define PORT_CONTROL_REGISTER3               0x0404
+#define PORT_CONTROL_REGISTER4               0x0504
+#define PORT_CONTROL_REGISTER5               0x0604
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S27_ARL_TBL_FUNC_REG0                0x0050
+#define S27_ARL_TBL_FUNC_REG1                0x0054
+#define S27_ARL_TBL_FUNC_REG2                0x0058
+#define S27_FLD_MASK_REG                     0x002c
+#define S27_ARL_TBL_CTRL_REG                 0x005c
+#define S27_GLOBAL_INTR_REG                  0x10
+#define S27_GLOBAL_INTR_MASK_REG             0x14
+
+
+#define S27_ENABLE_CPU_BROADCAST             (1 << 26)
+#define S27_ENABLE_CPU_BCAST_FWD             (1 << 25)
+
+#define PHY_LINK_CHANGE_REG		     0x4
+#define PHY_LINK_UP		             0x400
+#define PHY_LINK_DOWN		             0x800
+#define PHY_LINK_DUPLEX_CHANGE		     0x2000
+#define PHY_LINK_SPEED_CHANGE		     0x4000
+#define PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
+#define ATHR_QOS_PORT_1			0x210
+#define ATHR_QOS_PORT_2			0x310
+#define ATHR_QOS_PORT_3			0x410
+#define ATHR_QOS_PORT_4			0x510
+
+#define ATHR_ENABLE_TOS                 (1 << 16)
+
+#define ATHR_QOS_MODE_REGISTER          0x030
+#define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                 ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#undef S27_VER_1_0
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+typedef enum {
+    PORT_EG_UNMODIFIED = 0,  /**<  egress transmit packets unmodified */
+    PORT_EG_UNTAGGED,        /**<  egress transmit packets without vlan tag */
+    PORT_EG_TAGGED,          /**<  egress transmit packets with vlan tag */
+} port_1q_egmode_t;
+
+extern void set_packet_inspection_flag(int flag);
+
+#endif
diff --git a/board/ar7240/common/athrs16_phy.c b/board/ar7240/common/athrs16_phy.c
new file mode 100644
index 0000000000..9a2edcec93
--- /dev/null
+++ b/board/ar7240/common/athrs16_phy.c
@@ -0,0 +1,684 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrs16_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+
+/*depend on connection between cpu mac and s16 mac*/
+#if defined (CONFIG_PORT0_AS_SWITCH)
+#define ENET_UNIT_LAN 0
+#define ENET_UNIT_WAN 1
+#define CFG_BOARD_AP96 1
+
+#elif defined (CONFIG_AG7240_GE0_IS_CONNECTED)
+#define ENET_UNIT_LAN 0
+#define CFG_BOARD_PB45 0
+#define CFG_BOARD_AP96 1
+#else
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+#define CFG_BOARD_PB45 1
+#endif
+
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS16"
+#define S16_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,//ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr16_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs16_phy_is_link_alive(int phyUnit);
+uint32_t athrs16_reg_read(uint32_t reg_addr);
+void athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void)
+{
+#ifdef ATHRS16_VER_1_0
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+    /*rx delay*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+    /*tx delay*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+#endif
+}
+
+void athrs16_reg_init()
+{
+    /* if using header for register configuration, we have to     */
+    /* configure s16 register after frame transmission is enabled */
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x208, 0x2fd0001);  /*tx delay*/
+    athrs16_reg_write(0x108, 0x2be0001);  /*mac0 rgmii mode*/
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x8, 0x012e1bea);
+    athrs16_reg_write(0x8, 0x01261be2);
+#endif
+
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER0, 0x7e);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER1, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER2, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER3, 0x200);
+    athrs16_reg_write(S16_PORT_STATUS_REGISTER4, 0x200);
+#if CFG_BOARD_PB45
+    athrs16_reg_write(0x600, 0x200);
+#elif CFG_BOARD_AP96
+    //athrs16_reg_write(0x600, 0x0);
+    athrs16_reg_write(0x600, 0x200);
+#endif
+
+//    athrs16_reg_write(S16_FLD_MASK_REG, 0x003f003f);
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#ifdef HEADER_EN
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x6004);
+#endif
+
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER1, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER2, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER3, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER4, 0x6004);
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER5, 0x6004);
+#else
+#ifdef HEADER_EN
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4804);
+#else
+    athrs16_reg_write(S16_PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+#endif
+
+#ifdef FULL_FEATURE
+	hsl_dev_init(0, 2);
+#endif
+
+   /* Enable ARP packets to CPU port */
+    athrs16_reg_write(S16_ARL_TBL_CTRL_REG,(athrs16_reg_read(S16_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs16_reg_write(S16_FLD_MASK_REG,(athrs16_reg_read(S16_FLD_MASK_REG) | S16_ENABLE_CPU_BROADCAST ));
+
+    athrs16_reg_write(0x80,0x40000000);
+
+    athr16_init_flag = 1;
+#ifdef S16_PHY_DEBUG
+    printf("S16 CPU_PORT_REGISTER :%x\n", athrs16_reg_read ( S16_CPU_PORT_REGISTER ));
+    printf("S16 PORT_STATUS_REGISTER0  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER0 ));
+    printf("S16 PORT_STATUS_REGISTER1  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER1 ));
+    printf("S16 PORT_STATUS_REGISTER2  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER2 ));
+    printf("S16 PORT_STATUS_REGISTER3  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER3 ));
+    printf("S16 PORT_STATUS_REGISTER4  :%x\n", athrs16_reg_read ( S16_PORT_STATUS_REGISTER4 ));
+
+    printf("S16 PORT_CONTROL_REGISTER0 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER0 ));
+    printf("S16 PORT_CONTROL_REGISTER1 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER1 ));
+    printf("S16 PORT_CONTROL_REGISTER2 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER2 ));
+    printf("S16 PORT_CONTROL_REGISTER3 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER3 ));
+    printf("S16 PORT_CONTROL_REGISTER4 :%x\n", athrs16_reg_read ( S16_PORT_CONTROL_REGISTER4 ));
+#endif
+
+    printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs16_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs16_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+        ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs16_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs16_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr,
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                sysMsDelay(10);
+            } while(--ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs16_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs16_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs16_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+                break;
+            case 2:
+                return _1000BASET;
+                break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs16_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus)) {
+                continue;
+            }
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;
+}
+
+void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
diff --git a/board/ar7240/common/athrs16_phy.h b/board/ar7240/common/athrs16_phy.h
new file mode 100644
index 0000000000..07e9d249ad
--- /dev/null
+++ b/board/ar7240/common/athrs16_phy.h
@@ -0,0 +1,141 @@
+#ifndef _ATHRS16_PHY_H
+#define _ATHRS16_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S16 CSR Registers */
+
+#define S16_PORT_STATUS_REGISTER0                0x0100
+#define S16_PORT_STATUS_REGISTER1                0x0200
+#define S16_PORT_STATUS_REGISTER2                0x0300
+#define S16_PORT_STATUS_REGISTER3                0x0400
+#define S16_PORT_STATUS_REGISTER4                0x0500
+#define S16_PORT_STATUS_REGISTER5                0x0600
+
+#define S16_RATE_LIMIT_REGISTER0                 0x010C
+#define S16_RATE_LIMIT_REGISTER1                 0x020C
+#define S16_RATE_LIMIT_REGISTER2                 0x030C
+#define S16_RATE_LIMIT_REGISTER3                 0x040C
+#define S16_RATE_LIMIT_REGISTER4                 0x050C
+#define S16_RATE_LIMIT_REGISTER5                 0x060C
+
+#define S16_PORT_CONTROL_REGISTER0               0x0104
+#define S16_PORT_CONTROL_REGISTER1               0x0204
+#define S16_PORT_CONTROL_REGISTER2               0x0304
+#define S16_PORT_CONTROL_REGISTER3               0x0404
+#define S16_PORT_CONTROL_REGISTER4               0x0504
+#define S16_PORT_CONTROL_REGISTER5               0x0604
+
+#define S16_CPU_PORT_REGISTER                    0x0078
+#define S16_MDIO_CTRL_REGISTER                   0x0098
+
+#define S16_ARL_TBL_FUNC_REG0                0x0050
+#define S16_ARL_TBL_FUNC_REG1                0x0054
+#define S16_ARL_TBL_FUNC_REG2                0x0058
+#define S16_FLD_MASK_REG                     0x002c
+#define S16_ARL_TBL_CTRL_REG                 0x005c
+#define S16_GLOBAL_INTR_REG                  0x10
+#define S16_GLOBAL_INTR_MASK_REG             0x14
+#define S16_PWR_ON_STRAP_REG                 0x8
+
+
+#define S16_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S16_PHY_LINK_CHANGE_REG		     0x4
+#define S16_PHY_LINK_UP		             0x400
+#define S16_PHY_LINK_DOWN		             0x800
+#define S16_PHY_LINK_DUPLEX_CHANGE		     0x2000
+#define S16_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S16_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S16_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs16_reg_init(void);
+int athrs16_phy_is_up(int unit);
+int athrs16_phy_is_fdx(int unit);
+int athrs16_phy_speed(int unit);
+BOOL athrs16_phy_setup(int unit);
+
+#endif
diff --git a/board/ar7240/common/athrs17_phy.c b/board/ar7240/common/athrs17_phy.c
new file mode 100644
index 0000000000..f8d177b982
--- /dev/null
+++ b/board/ar7240/common/athrs17_phy.c
@@ -0,0 +1,625 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrs17_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE0 0
+#define ENET_UNIT_GE1 1
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS17"
+#define S17_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* phy port 0 -- LAN port 0 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_GE0,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+     FALSE,
+     ENET_UNIT_GE0,//ENET_UNIT_GE1,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+     TRUE,
+     ENET_UNIT_GE0,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+};
+
+static uint8_t athr17_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
+
+/* Forward references */
+BOOL athrs17_phy_is_link_alive(int phyUnit);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void)
+{
+#ifdef ATHRS17_VER_1_0
+    /*work around for phy4 rgmii mode*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+    /*rx delay*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+    /*tx delay*/
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+    phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+#endif
+}
+
+void athrs17_reg_init()
+{
+
+    int phy_addr = 0;
+
+    /* if using header for register configuration, we have to     */
+    /* configure s17 register after frame transmission is enabled */
+
+    if (athr17_init_flag)
+        return;
+
+    athrs17_reg_write(0x624 , 0x7f7f7f7f);
+    athrs17_reg_write(0x10  , 0x40000000);
+    athrs17_reg_write(0x4   , 0x07600000);
+    athrs17_reg_write(0xc   , 0x01000000);
+    athrs17_reg_write(0x7c  , 0x0000007e);
+
+    /* AR8327/AR8328 v1.0 fixup */
+    if ((athrs17_reg_read(0x0) & 0xffff) == 0x1201)
+    {
+        for (phy_addr = 0x0; phy_addr <= ATHR_PHY_MAX; phy_addr++)
+        {
+            /* For 100M waveform */
+            phy_reg_write(0, phy_addr, 0x1d, 0x0);
+            phy_reg_write(0, phy_addr, 0x1e, 0x02ea);
+            /* Turn On Gigabit Clock */
+            phy_reg_write(0, phy_addr, 0x1d, 0x3d);
+            phy_reg_write(0, phy_addr, 0x1e, 0x68a0);
+        }
+    }
+
+
+    athr17_init_flag = 1;
+    printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs17_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+                      ATHR_ADVERTISE_ALL);
+
+        phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+                      ATHR_ADVERTISE_1000FULL);
+
+        /* Reset PHYs*/
+        phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+                      ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                      | ATHR_CTRL_SOFTWARE_RESET);
+
+    }
+
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    sysMsDelay(1000);
+
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+#if 0
+	/* Enable RGMII */
+	phy_reg_write(0,phyUnit,0x1d,0x12);
+	phy_reg_write(0,phyUnit,0x1e,0x8);
+	/* Tx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x5);
+	phy_reg_write(0,phyUnit,0x1e,0x100);
+
+	/* Rx delay on PHY */
+	phy_reg_write(0,phyUnit,0x1d,0x0);
+	phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+        ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            phy_reg_read(ATHR_PHYBASE(phyUnit),
+                         ATHR_PHYADDR(phyUnit),
+                         ATHR_PHY_SPEC_STATUS)));
+    }
+    phy_mode_setup();
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs17_phy_is_fdx(int ethUnit)
+{
+    int       phyUnit;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+
+    if (ethUnit == ENET_UNIT_GE0)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read (phyBase, phyAddr,
+                                               ATHR_PHY_SPEC_STATUS);
+		if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			break;
+                sysMsDelay(10);
+            } while(--ii);
+
+            if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+                return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100TX;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athrs17_phy_speed(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_GE0)
+        return _1000BASET;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs17_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+		        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+			        break;
+                sysMsDelay(10);
+            } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                return _10BASET;
+            case 1:
+                return _100BASET;
+                break;
+            case 2:
+                return _1000BASET;
+                break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+    }
+
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs17_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+            if (!ATHR_RESET_DONE(phyHwStatus)) {
+                continue;
+            }
+
+            phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+
+    return (linkCount);
+
+}
+
+uint32_t
+athrs17_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;
+}
+
+void
+athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
diff --git a/board/ar7240/common/athrs17_phy.h b/board/ar7240/common/athrs17_phy.h
new file mode 100644
index 0000000000..63b18c422c
--- /dev/null
+++ b/board/ar7240/common/athrs17_phy.h
@@ -0,0 +1,107 @@
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S17 CSR Registers */
+
+#define S17_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S17_PHY_LINK_CHANGE_REG		     0x4
+#define S17_PHY_LINK_UP		             0x400
+#define S17_PHY_LINK_DOWN		             0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE		     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S17_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S17_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs17_reg_init(void);
+int athrs17_phy_is_up(int unit);
+int athrs17_phy_is_fdx(int unit);
+int athrs17_phy_speed(int unit);
+BOOL athrs17_phy_setup(int unit);
+
+#endif
diff --git a/board/ar7240/common/athrs_vir_phy.c b/board/ar7240/common/athrs_vir_phy.c
new file mode 100644
index 0000000000..a6a6c075ad
--- /dev/null
+++ b/board/ar7240/common/athrs_vir_phy.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+
+#define MODULE_NAME "ATHRS_VIR_PHY"
+
+#define TRUE    1
+#define FALSE   0
+#define BOOL	int
+
+/* Forward references */
+BOOL athr_vir_phy_is_link_alive(int phyUnit);
+
+
+/******************************************************************************
+*
+* athr_vir_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_vir_phy_is_link_alive(int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_vir_phy_setup(int ethUnit)
+{
+    return 0;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_vir_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_vir_phy_speed(int ethUnit,int phyUnit)
+{
+    return _1000BASET;
+}
+
+/*****************************************************************************
+*
+* athr_vir_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_vir_phy_is_up(int ethUnit)
+{
+    return 1;
+
+}
+/* Place holders */
+
+int
+athr_vir_reg_init(void *arg)
+{
+   return 0;
+}
diff --git a/board/ar7240/common/athrsf1_phy.c b/board/ar7240/common/athrsf1_phy.c
new file mode 100644
index 0000000000..598fc91123
--- /dev/null
+++ b/board/ar7240/common/athrsf1_phy.c
@@ -0,0 +1,433 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+unsigned int last_phy_speed;
+
+void athr_enable_linkIntrs(int ethUnit)
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit)
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit)
+{
+    int timeout = 0;
+    uint16_t phyHwStatus;
+
+    if(!is_emu()) {
+#if 0
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, ATHR_ADVERTISE_1000FULL);
+#endif
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+	phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+	    if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _10BASET;
+        case 1:
+	     if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _100BASET;
+        case 2:
+	      if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x0);
+                last_phy_speed = phyHwStatus;
+             }
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+      if (last_phy_speed != phyHwStatus)
+	{
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_ADDRESS, 0x0);
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_DATA, 0x14e);
+        last_phy_speed = phyHwStatus;
+     }
+
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */
+
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int
+athr_reg_init(void *arg)
+{
+   return 0;
+}
diff --git a/board/ar7240/common/athrsf1_phy.h b/board/ar7240/common/athrsf1_phy.h
new file mode 100644
index 0000000000..4495d94f76
--- /dev/null
+++ b/board/ar7240/common/athrsf1_phy.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+#define BOOL int
+#include "athr_s27_phy.h"
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+#endif
diff --git a/board/ar7240/common/athrsf2_phy.c b/board/ar7240/common/athrsf2_phy.c
new file mode 100644
index 0000000000..e5898d1a39
--- /dev/null
+++ b/board/ar7240/common/athrsf2_phy.c
@@ -0,0 +1,377 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF2_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_PHY5_ADDR   0x5
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,                /* phy Base */
+     ATHR_PHY5_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+
+void athr_enable_linkIntrs(int ethUnit)
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit)
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit)
+{
+    int timeout = 0;
+    uint16_t phyHwStatus;
+    int phyBase = 0,phyAddr =0;
+
+    phyUnit = 0;
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+
+    if(!is_emu()) {
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(phyBase, phyAddr,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", phyBase, phyAddr);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+
+	phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    phyUnit = 0;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(phyBase, phyAddr,ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    phyUnit = 0;
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(phyBase, phyAddr,ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+            return _10BASET;
+        case 1:
+            return _100BASET;
+        case 2:
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!!!!\n");
+        }
+    }
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit= 0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */
+
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(phyBase, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int
+athr_reg_init(void *arg)
+{
+   /* Feed 50 Mhz internal clk */
+   ar7240_reg_wr(AR7242_ETH_XMII_CONFIG,0x0);
+   printf("F2 phy:%s\n",__func__);
+   return 0;
+}
diff --git a/board/ar7240/common/lowlevel_init.S b/board/ar7240/common/lowlevel_init.S
new file mode 100644
index 0000000000..10372a7379
--- /dev/null
+++ b/board/ar7240/common/lowlevel_init.S
@@ -0,0 +1,213 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define clear_mask(_reg, _mask)                     \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val(_reg, _mask, _val)                  \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t9, _val;                                   \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+#define set_val_f(_reg, _mask, _val)                \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, ~_mask;                                 \
+    and t8, t8, t9;                                 \
+    li  t6, KSEG1ADDR(_val);                        \
+    lw  t9, 0(t6);                                  \
+    or  t8, t8, t9;                                 \
+    sw  t8, 0(t7)
+
+
+#define get_val(_reg, _mask, _shift, _res_reg)      \
+    li  t7, KSEG1ADDR(_reg);                        \
+    lw  t8, 0(t7);                                  \
+    li  t9, _mask;                                  \
+    and t8, t8, t9;                                 \
+    srl _res_reg, t8, _shift                        \
+
+#define pll_clr(_mask)                              \
+    clear_mask(AR7240_CPU_PLL_CONFIG, _mask)
+
+#define pll_set(_mask, _val)                        \
+    set_val(AR7240_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_set_f(_mask, _val)                      \
+    set_val_f(AR7240_CPU_PLL_CONFIG,  _mask, _val)
+
+#define pll_get(_mask, _shift, _res_reg)            \
+    get_val(AR7240_CPU_PLL_CONFIG, _mask, _shift, _res_reg)
+
+#define clk_clr(_mask)                              \
+    clear_mask(AR7240_CPU_CLOCK_CONTROL, _mask)
+
+#define clk_set(_mask, _val)                        \
+    set_val(AR7240_CPU_CLOCK_CONTROL,  _mask, _val)
+
+#define clk_get(_mask, _shift, _res_reg)            \
+    get_val(AR7240_CPU_CLOCK_CONTROL, _mask, _shift, _res_reg)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+
+lowlevel_init:
+
+    /*
+     * The code below is for the real chip. Wont work on FPGA
+     */
+    /* jr ra  */
+
+#if !defined(CONFIG_AR7240_EMU) && defined(CONFIG_WASP_SUPPORT)
+#if !defined(CONFIG_ATH_NAND_BR)
+	b ar934x_lowlevel_init
+#endif
+#else
+
+#ifndef CONFIG_HORNET_EMU
+#if defined(CONFIG_MACH_HORNET)
+    b hornet_pll_init
+#else
+wdt_reset:
+#ifndef CONFIG_AR7240_EMU
+	li	$3, -1207566336		# 0xffffffffb8060000
+	ori	$4, $3, 0x8
+	lw	$2, 0($4)
+	bltz	$2, $L6
+	nop
+	ori	$5, $3, 0xc
+
+	li	$3, 300			# 0x4
+	sw	$3, 0($5)
+	li	$3, 3			# 0x3
+	sw	$3, 0($4)
+$L3:
+	b	$L3
+	nop
+#endif
+$L6:
+	nop
+	nop
+#ifndef CONFIG_AR7240_EMU
+#ifndef COMPRESSED_UBOOT
+
+    /*
+     * WAR for the bug#55574: Set the CKE (bit 7 in DDR_CONFIG2 register)
+     * to low initially
+     */
+    li  t7, KSEG1ADDR(AR7240_DDR_CONFIG2);
+    lw  t8, 0(t7);
+    li  t9, 0xffffff7f;
+    and t8, t8, t9;
+    sw  t8, 0(t7);
+#endif
+
+    /*
+     * Check if the PLL is already set and CPU is Reset
+     */
+    clk_get(CLOCK_CONTROL_RST_SWITCH_MASK, CLOCK_CONTROL_RST_SWITCH_SHIFT, t6)
+    bne zero, t6, initialize_pll
+    nop
+
+init_pll_values:
+    li  a2,PLL_CONFIG_VAL_F                 # 0xffffffffbf040000
+    lw  a0,0(a2)
+    li  v1,PLL_MAGIC                        # 0xffffffffaabb0000
+    beq a0,v1,read_pll_from_flash
+    nop
+
+#ifdef CONFIG_SUPPORT_AR7241
+    li  t7, KSEG1ADDR(AR7240_REV_ID)
+    lw  t8, 0(t7)
+    li  t9, AR7240_REV_ID_MASK
+    and t8, t8, t9
+    li  v1, AR7241_REV_1_0
+    beq t8,v1,init_7241_pll
+    nop
+    li  v1, AR7242_REV_1_0
+    beq t8,v1,init_7241_pll
+    nop
+    bne t8,v1,init_default
+
+init_7241_pll:
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set( (PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,( PLL_7241_CONFIG_PLL_REF_DIV_VAL|PLL_7241_CONFIG_PLL_DIV_VAL|PLL_7241_CONFIG_AHB_DIV_VAL|PLL_7241_CONFIG_DDR_DIV_VAL|PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK)
+    b wait_for_pll_update
+    nop
+
+init_default:
+#endif
+
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set( (PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,( PLL_CONFIG_PLL_REF_DIV_VAL|PLL_CONFIG_PLL_DIV_VAL|PLL_CONFIG_AHB_DIV_VAL|PLL_CONFIG_DDR_DIV_VAL|PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK)
+    b wait_for_pll_update
+    nop
+
+read_pll_from_flash:
+    pll_clr(PLL_CONFIG_PLL_RESET_MASK)
+    pll_set_f((PLL_CONFIG_DDR_DIV_MASK | PLL_CONFIG_AHB_DIV_MASK | PLL_CONFIG_PLL_NOPWD_MASK | PLL_CONFIG_PLL_REF_DIV_MASK | PLL_CONFIG_PLL_DIV_MASK) ,((PLL_CONFIG_VAL_F + 4) | PLL_CONFIG_PLL_NOPWD_VAL))
+    pll_clr(PLL_CONFIG_PLL_BYPASS_MASK)
+    b wait_for_pll_update
+    nop
+
+
+wait_for_pll_update:
+    pll_get(PLL_CONFIG_PLL_UPDATE_MASK, PLL_CONFIG_PLL_UPDATE_SHIFT, t6)
+    bne zero, t6, wait_for_pll_update
+    nop
+
+    /*
+     * Will cause a reset
+     * The RESET_SWITCH need to be set first and then
+     * set the CLOCK_SWITCH for the CPU to boot properly
+     * after RESET.
+     */
+pll_locked:
+    clk_set(CLOCK_CONTROL_RST_SWITCH_MASK, 0x2)
+    clk_set(CLOCK_CONTROL_CLOCK_SWITCH_MASK, 0x1)
+    nop
+
+    /*
+     * When the PLL is already set and CPU is RESET
+     * The code will jump here
+     */
+initialize_pll:
+    clk_clr(CLOCK_CONTROL_RST_SWITCH_MASK)
+    clk_clr(CLOCK_CONTROL_CLOCK_SWITCH_MASK)
+#endif
+#endif /* CONFIG_MACH_HORNET */
+#endif /* CONFIG_HORNET_EMU */
+#endif /* CONFIG_MAC_WASP */
+    jr ra
+    nop
+
+ /* end of file */
diff --git a/board/ar7240/common/lowlevel_init_934x-1.1.S b/board/ar7240/common/lowlevel_init_934x-1.1.S
new file mode 100644
index 0000000000..e7d730e960
--- /dev/null
+++ b/board/ar7240/common/lowlevel_init_934x-1.1.S
@@ -0,0 +1,406 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define set_val(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~_mask;			\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	set_val(AR934X_CPU_PLL_CONFIG, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	set_val(AR934X_DDR_PLL_CONFIG, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	set_val(AR934X_CPU_DDR_CLOCK_CONTROL, _mask, _val)
+
+#define set_bb_pll(reg, val)		\
+	li	t7,	KSEG1ADDR(reg);	\
+	li	t8,	val;		\
+	sw	t8,	0(t7);
+
+#define set_srif_pll(reg, val)		\
+	li	t7,	KSEG1ADDR(reg);	\
+	li	t8,	val;		\
+	sw	t8,	0(t7);
+
+#define set_srif_pll_reg(reg, _r)	\
+	li	t7,	KSEG1ADDR(reg);	\
+	sw	_r,	0(t7);
+
+#define inc_loop_count(loc)		\
+	li	t9,	loc;		\
+	lw	t7,	0(t9);		\
+	addi	t7,	t7,	1;	\
+	sw	t7,	0(t9);
+
+#define clear_loop_count(loc)	\
+	li	t9,	loc;	\
+	sw	zero,	0(t9);
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl ar934x_1_dot_1_lowlevel_init
+	.type	ar934x_1_dot_1_lowlevel_init, @function
+	.text
+	.align 4
+ar934x_1_dot_1_lowlevel_init:
+
+	set_bb_pll(DPLL2_ADDRESS_c4, 0x13210f00);
+	set_bb_pll(DPLL3_ADDRESS_c8, 0x03000000);
+	set_bb_pll(DPLL2_ADDRESS_44, 0x13210f00);
+	set_bb_pll(DPLL3_ADDRESS_48, 0x03000000);
+	set_bb_pll(DPLL3_ADDRESS_88, 0x03000000);
+
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	setup_ref25_val
+	nop
+setup_ref40_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_40
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_40
+	li	t7,	CPU_PLL_NFRAC_40
+	li	t9,	DDR_PLL_NFRAC_40
+	b	1f
+	nop
+
+setup_ref25_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_25
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_25
+	li	t7,	CPU_PLL_NFRAC_25
+	li	t9,	DDR_PLL_NFRAC_25
+
+1:
+	li	t4,	(CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+			CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+	or	t4,	t4,	t7
+
+	li	t8,	(CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	or	t5,	t5,	t8
+
+	li	t8,	(DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL2);
+	or	t6,	t6,	t8
+
+#if 0 /* !defined(CONFIG_AP123) && !defined(CONFIG_MI124) */
+	/*
+	 * From: Ravi Subramanian
+	 * Subject: Workaround for 5G RX reset-reset variation
+	 * Date: Mon, 30 Aug 2010 12:53:49 +0530
+	 *
+	 * We are observing a reset to reset issue related to 5G RX
+	 * performance (and EVM). As a workaround, pushing the DDR
+	 * frequency from 400 MHz to 406 MHz, fixes this issue.
+	 * Could you please give us a new u-boot with the following
+	 * change?
+	 */
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#else
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#endif
+
+	or	t3,	t3,	t9
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_CONFIG);
+	li	t8,	CPU_PLL_CONFIG_PLLPWD_SET(1)
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_CONFIG);
+	li	t8,	DDR_PLL_CONFIG_PLLPWD_SET(1)
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_DDR_CLOCK_CONTROL);
+	li	t8,	(CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL | \
+			CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU | \
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+	sw	t8,	0(t7);
+#define cpu_from_srif	1
+#define ddr_from_srif	1
+
+pll_pwd_unset:
+#if !cpu_from_srif
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+#endif
+#if !ddr_from_srif
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+#endif
+
+srif_set:
+	/* See if we have to read the pll values from flash */
+	li	t7,	SRIF_PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	SRIF_PLL_MAGIC
+	beq	t7,	t8,	read_srif_from_flash
+	nop
+
+	/* Use built in values, based on ref clock */
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	1f
+	nop
+#if !defined(CONFIG_AP123)
+	/*		refdiv		nint		nfrac */
+#if cpu_from_srif
+	li	t4,	((0x8 << 27) | (112 << 18) | 0);// cpu freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+#if ddr_from_srif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	li	t5,	((0x8 << 27) | (160 << 18) | 0);// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#else
+	li	t5,	((0x8 << 27) | (90 << 18) | 0);	// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#endif /* CONFIG_ATH_NAND_SUPPORT */
+#endif
+	j	2f
+	nop
+1:
+#if cpu_from_srif
+	li	t4,	((0x5 << 27) | (112 << 18) | 0);// cpu freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+#if ddr_from_srif
+#ifdef CONFIG_ATH_NAND_SUPPORT
+	li	t5,	((0x5 << 27) | (160 << 18) | 0);// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#else
+	li	t5,	((0x5 << 27) | (90 << 18) | 0);	// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#endif /* CONFIG_ATH_NAND_SUPPORT */
+#endif
+	j	2f
+	nop
+#else	/* defined(CONFIG_AP123) */
+	/*		refdiv		nint		nfrac */
+#if cpu_from_srif
+	li	t4,	((0x8 << 27) | (107 << 18) | 0);// cpu freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+#if ddr_from_srif
+	li	t5,	((0x8 << 27) | (160 << 18) | 0);// ddr freq = (40 MHz refclk/refdiv 8) * Nint
+#endif
+	j	2f
+	nop
+1:
+#if cpu_from_srif
+	li	t4,	((0x5 << 27) | (107 << 18) | 0);// cpu freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+#if ddr_from_srif
+	li	t5,	((0x5 << 27) | (160 << 18) | 0);// ddr freq = (25 MHz refclk/refdiv 5) * Nint
+#endif
+	j	2f
+	nop
+#endif	/* !defined(CONFIG_AP123) */
+
+read_srif_from_flash:
+	li	t7,	SRIF_PLL_CONFIG_VAL_F + 4
+#if cpu_from_srif
+	lw	t4,	0(t7);	// CPU PLL
+#endif
+#if ddr_from_srif
+	lw	t5,	4(t7);	// DDR PLL
+#endif
+	/* CPU */
+2:
+
+	clear_loop_count(ATH_CPU_COUNT_LOC);
+
+cpu_pll_is_not_locked:
+
+	inc_loop_count(ATH_CPU_COUNT_LOC);
+
+#if cpu_from_srif
+	set_srif_pll(0xb81161c4, (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb81161c0, t4);
+	set_srif_pll(0xb81161c4, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb81161c8, (6 << 23));
+	set_srif_pll(0xb81161c4, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7));
+
+cpu_clear_do_meas1:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~CPU_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+cpu_set_do_meas:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	CPU_DPLL3_DO_MEAS_SET(1)
+	or	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+	li	t7,	KSEG1ADDR(CPU_DPLL4_ADDRESS)
+cpu_wait_for_meas_done:
+	lw	t8,	0(t7)
+	andi	t8,	t8,	CPU_DPLL4_MEAS_DONE_SET(1)
+	beqz	t8,	cpu_wait_for_meas_done
+	nop
+
+cpu_clear_do_meas2:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~CPU_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+cpu_read_sqsum_dvc:
+	li	t7,	KSEG1ADDR(CPU_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	CPU_DPLL3_SQSUM_DVC_MASK
+	and	t8,	t8,	t9
+	sra	t8,	t8,	CPU_DPLL3_SQSUM_DVC_LSB
+	li	t9,	0x40000
+	subu	t8,	t8,	t9
+	bgez	t8,	cpu_pll_is_not_locked
+	nop
+
+#endif
+
+	/* DDR */
+#if ddr_from_srif
+
+	clear_loop_count(ATH_DDR_COUNT_LOC)
+
+ddr_pll_is_not_locked:
+
+	inc_loop_count(ATH_DDR_COUNT_LOC)
+
+#if defined(CONFIG_ATH_NAND_SUPPORT)
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7));
+#elif !defined(CONFIG_AP123)
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x3 << 30) | (0x4 << 26) | (0x10 << 19) | (0x1e << 7));
+#else /* defined(CONFIG_AP123) */
+	/* AP123 uses outdiv = 1 for ddr pll */
+	set_srif_pll(0xb8116244, (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll_reg(0xb8116240, t5);
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7) | (1 << 16));
+	set_srif_pll(0xb8116248, (6 << 23));
+	set_srif_pll(0xb8116244, (0x1 << 30) | (0x4 << 26) | (0x10 << 19) | (1 << 13) | (0x1e << 7));
+#endif /* !defined(CONFIG_AP123) */
+
+ddr_clear_do_meas1:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~DDR_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+
+ddr_set_do_meas:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	DDR_DPLL3_DO_MEAS_SET(1)
+	or	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+	li	t7,	KSEG1ADDR(DDR_DPLL4_ADDRESS)
+ddr_wait_for_meas_done:
+	lw	t8,	0(t7)
+	andi	t8,	t8,	DDR_DPLL4_MEAS_DONE_SET(1)
+	beqz	t8,	ddr_wait_for_meas_done
+	nop
+
+ddr_clear_do_meas2:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	~DDR_DPLL3_DO_MEAS_SET(1)
+	and	t8,	t8,	t9
+	sw	t8,	0(t7)
+
+ddr_read_sqsum_dvc:
+	li	t7,	KSEG1ADDR(DDR_DPLL3_ADDRESS)
+	lw	t8,	0(t7)
+	li	t9,	DDR_DPLL3_SQSUM_DVC_MASK
+	and	t8,	t8,	t9
+	sra	t8,	t8,	DDR_DPLL3_SQSUM_DVC_LSB
+	li	t9,	0x40000
+	subu	t8,	t8,	t9
+	bgez	t8,	ddr_pll_is_not_locked
+	nop
+#endif
+
+pll_bypass_unset:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_DITHER);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_DITHER);
+	sw	t4,	0(t7);
+
+	jr ra
+	nop
+
+ /* end of file */
diff --git a/board/ar7240/common/lowlevel_init_934x.S b/board/ar7240/common/lowlevel_init_934x.S
new file mode 100644
index 0000000000..f105ebfa09
--- /dev/null
+++ b/board/ar7240/common/lowlevel_init_934x.S
@@ -0,0 +1,182 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <ar7240_soc.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define set_val(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~_mask;			\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	set_val(AR934X_CPU_PLL_CONFIG, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	set_val(AR934X_DDR_PLL_CONFIG, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	set_val(AR934X_CPU_DDR_CLOCK_CONTROL, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl ar934x_lowlevel_init
+	.type	ar934x_lowlevel_init, @function
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+ar934x_lowlevel_init:
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	li	t7,	AR7240_REV_ID
+	lw	t7,	0(t7)
+	andi	t9,	t7,	0xf
+	bne	zero,	t9,	ar934x_1_dot_1_lowlevel_init
+	nop
+
+	li	t5,	KSEG1ADDR(WASP_BOOTSTRAP_REG);
+	li	t6,	WASP_REF_CLK_25
+	lw	t7,	0(t5);
+	and	t6,	t7,	t6
+	beq	zero,	t6,	setup_ref25_val
+	nop
+setup_ref40_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_40
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_40
+	b	1f
+	nop
+
+setup_ref25_val:
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL_25
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL_25
+
+1:
+	li	t4,	(CPU_PLL_DITHER_DITHER_EN_SET(0) | \
+			CPU_PLL_DITHER_NFRAC_MAX_SET(0x3f) | \
+			CPU_PLL_NFRAC_MIN_SET | \
+			CPU_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			CPU_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#if 0
+	/*
+	 * From: Ravi Subramanian
+	 * Subject: Workaround for 5G RX reset-reset variation
+	 * Date: Mon, 30 Aug 2010 12:53:49 +0530
+	 *
+	 * We are observing a reset to reset issue related to 5G RX
+	 * performance (and EVM). As a workaround, pushing the DDR
+	 * frequency from 400 MHz to 406 MHz, fixes this issue.
+	 * Could you please give us a new u-boot with the following
+	 * change?
+	 */
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(1) | \
+			DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+			DDR_PLL_DITHER_NFRAC_MIN_SET(0x200) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#else
+	li	t3,	(DDR_PLL_DITHER_DITHER_EN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_MAX_SET(0x3ff) | \
+			DDR_PLL_DITHER_NFRAC_MIN_SET(0) | \
+			DDR_PLL_DITHER_NFRAC_STEP_SET(1) | \
+			DDR_PLL_DITHER_UPDATE_COUNT_SET(0xf));
+#endif
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_CONFIG);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_CONFIG);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	li	t7,	KSEG1ADDR(AR934X_CPU_DDR_CLOCK_CONTROL);
+	li	t8,	(CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL | \
+			CPU_DDR_CLOCK_CONTROL_AHB_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_DDR_CLK_DDR | \
+			CPU_DDR_CLOCK_CONTROL_CPU_CLK_CPU | \
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV | \
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) | \
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+	sw	t8,	0(t7);
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_DDR_PLL_DITHER);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(AR934X_CPU_PLL_DITHER);
+	sw	t4,	0(t7);
+
+#endif
+	jr ra
+	nop
+
+ /* end of file */
diff --git a/board/ar7240/common/phy.h b/board/ar7240/common/phy.h
new file mode 100644
index 0000000000..96aec4b489
--- /dev/null
+++ b/board/ar7240/common/phy.h
@@ -0,0 +1,19 @@
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+/*
+ * This file defines the interface between MAC and various phy switches.
+ */
+#define ag7240_unit2name(_unit) _unit ?  "eth1" : "eth0"
+extern int  ag7240_miiphy_read(char *devname, uint32_t phaddr,
+		uint8_t reg);
+extern int  ag7240_miiphy_write(char *devname, uint32_t phaddr,
+		uint8_t reg, uint16_t data);
+
+#define phy_reg_read(base, addr, reg)                    \
+    ag7240_miiphy_read(ag7240_unit2name(base), addr, reg)
+#define phy_reg_write(base, addr, reg, data)                   \
+        ag7240_miiphy_write(ag7240_unit2name(base), addr, reg, data)
+
+#endif
diff --git a/board/ar7240/cus136/Makefile b/board/ar7240/cus136/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/cus136/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/cus136/config.mk b/board/ar7240/cus136/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/cus136/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/cus136/cus136.c b/board/ar7240/cus136/cus136.c
new file mode 100644
index 0000000000..a333899e7d
--- /dev/null
+++ b/board/ar7240/cus136/cus136.c
@@ -0,0 +1,70 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_gpio_config();
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "CUS136 (ar7240) U-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("CUS136 (ar7240) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/cus136/flash.c b/board/ar7240/cus136/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/cus136/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/cus136/u-boot.lds b/board/ar7240/cus136/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/cus136/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/db12x-extender/.depend b/board/ar7240/db12x-extender/.depend
new file mode 100644
index 0000000..51919f7
--- /dev/null
+++ b/board/ar7240/db12x-extender/.depend
@@ -0,0 +1,220 @@
+lowlevel_init.o: ../common/lowlevel_init.S \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version_autogenerated.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/athversion.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/mipsregs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/addrspace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar7240_soc.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar934x_soc.h
+lowlevel_init_934x.o: ../common/lowlevel_init_934x.S \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version_autogenerated.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/athversion.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/mipsregs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/addrspace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar7240_soc.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar934x_soc.h
+db12x-extender.o: db12x-extender.c \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/common.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/stddef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/byteorder.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/big_endian.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/swab.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/generic.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/sgidefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/system.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/ptrace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/isadep.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/build/gcc-4.3.3/build_mips/staging_dir/usr/bin-ccache/../lib/gcc/mips-linux-uclibc/4.3.3/include/stdarg.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/part.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ide.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/flash.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/image.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/u-boot.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/global_data.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/command.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/mipsregs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/addrspace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version_autogenerated.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/athversion.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar7240_soc.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar934x_soc.h
+flash.o: flash.c \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/common.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/stddef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/byteorder.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/big_endian.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/swab.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/generic.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/sgidefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/system.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/ptrace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/isadep.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/build/gcc-4.3.3/build_mips/staging_dir/usr/bin-ccache/../lib/gcc/mips-linux-uclibc/4.3.3/include/stdarg.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/part.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ide.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/flash.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/image.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/u-boot.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/global_data.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h
+ar7240_pci.o: ../common/ar7240_pci.c \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/common.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/stddef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/byteorder.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/big_endian.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/swab.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/generic.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/sgidefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/system.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/ptrace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/isadep.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/build/gcc-4.3.3/build_mips/staging_dir/usr/bin-ccache/../lib/gcc/mips-linux-uclibc/4.3.3/include/stdarg.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/part.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ide.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/flash.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/image.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/u-boot.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/global_data.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/command.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/mipsregs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/addrspace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/version_autogenerated.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/athversion.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/pci.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/pci_ids.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar7240_soc.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar934x_soc.h
+ar7240_flash.o: ../common/ar7240_flash.c \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/common.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/stddef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/byteorder.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/big_endian.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/swab.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/generic.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/sgidefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/system.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/ptrace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/isadep.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/build/gcc-4.3.3/build_mips/staging_dir/usr/bin-ccache/../lib/gcc/mips-linux-uclibc/4.3.3/include/stdarg.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/part.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ide.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/flash.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/image.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/u-boot.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/global_data.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/jffs2/jffs2.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/jffs2/load_kernel.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/list.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/addrspace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar7240_soc.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar934x_soc.h \
+  ../common/ar7240_flash.h
+athr_s27_phy.o: ../common/athr_s27_phy.c \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/db12x-extender.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/configs/ar7240.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/cmd_confdefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/config.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/stddef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/posix_types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/types.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/common.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/bitops.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/byteorder.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/big_endian.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/swab.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/byteorder/generic.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/sgidefs.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/system.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/ptrace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/isadep.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/linux/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/string.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/build/gcc-4.3.3/build_mips/staging_dir/usr/bin-ccache/../lib/gcc/mips-linux-uclibc/4.3.3/include/stdarg.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/part.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ide.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/flash.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/image.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/u-boot.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/global_data.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/regdef.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/miiphy.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/net.h \
+  ../common/phy.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/asm/addrspace.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar7240_soc.h \
+  /home/pmq/depot/sw/branches/hybrid_dev/boot/u-boot/include/ar934x_soc.h \
+  ../common/athr_s27_phy.h
diff --git a/board/ar7240/db12x-extender/Makefile b/board/ar7240/db12x-extender/Makefile
new file mode 100644
index 0000000000..dd3465eba2
--- /dev/null
+++ b/board/ar7240/db12x-extender/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/db12x-extender/config.mk b/board/ar7240/db12x-extender/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/db12x-extender/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/db12x-extender/db12x-extender.c b/board/ar7240/db12x-extender/db12x-extender.c
new file mode 100644
index 0000000000..961dad3ac1
--- /dev/null
+++ b/board/ar7240/db12x-extender/db12x-extender.c
@@ -0,0 +1,136 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/db12x-extender/flash.c b/board/ar7240/db12x-extender/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/db12x-extender/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/db12x-extender/u-boot-bootstrap.lds b/board/ar7240/db12x-extender/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/db12x-extender/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/db12x-extender/u-boot.lds b/board/ar7240/db12x-extender/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/db12x-extender/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/db12x-hybrid/Makefile b/board/ar7240/db12x-hybrid/Makefile
new file mode 100644
index 0000000000..045813bfdd
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/db12x-hybrid/config.mk b/board/ar7240/db12x-hybrid/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/db12x-hybrid/db12x-hybrid.c b/board/ar7240/db12x-hybrid/db12x-hybrid.c
new file mode 100644
index 0000000000..21f3ea7062
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/db12x-hybrid.c
@@ -0,0 +1,170 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+#ifdef CONFIG_AP123
+	extern void ath_ddr_tap_cal(void);
+#endif
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+#ifdef CONFIG_AP123
+	ath_ddr_tap_cal();
+
+#ifndef COMPRESSED_UBOOT
+	printf("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+#endif
+#endif
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/db12x-hybrid/flash.c b/board/ar7240/db12x-hybrid/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/db12x-hybrid/u-boot-bootstrap.lds b/board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/db12x-hybrid/u-boot.lds b/board/ar7240/db12x-hybrid/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/db12x-hybrid/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/db12x/Makefile b/board/ar7240/db12x/Makefile
new file mode 100644
index 0000000000..b6a9439dc5
--- /dev/null
+++ b/board/ar7240/db12x/Makefile
@@ -0,0 +1,78 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/db12x/config.mk b/board/ar7240/db12x/config.mk
new file mode 100755
index 0000000000..df2665e385
--- /dev/null
+++ b/board/ar7240/db12x/config.mk
@@ -0,0 +1,35 @@
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/ar7240/db12x/db12x.c b/board/ar7240/db12x/db12x.c
new file mode 100644
index 0000000000..53361f53b0
--- /dev/null
+++ b/board/ar7240/db12x/db12x.c
@@ -0,0 +1,131 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, "U-Boot " a "Wasp 1.");		\
+	ver[0] += ar7240_reg_rd(AR7240_REV_ID) & 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg		printf
+#	define args		void
+#	define board_str(a)	printf(a)
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ar7240_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ar7240_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ar7240_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ar7240_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+}
+
+int
+wasp_mem_config(void)
+{
+	extern void ath_ddr_tap_cal(void);
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	ath_ddr_tap_cal();
+
+	prmsg("Tap value selected = 0x%x [0x%x - 0x%x]\n",
+		ar7240_reg_rd(AR7240_DDR_TAP_CONTROL0),
+		ar7240_reg_rd(0xbd007f10), ar7240_reg_rd(0xbd007f14));
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+	ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+
+	wasp_usb_initial_config();
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+
+	wasp_gpio_config();
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+int	checkboard(args)
+{
+#if CONFIG_AP123
+	board_str("AP123\n");
+#elif CONFIG_MI124
+	board_str("MI124\n");
+#elif CONFIG_CUS227
+	board_str("CUS227\n");
+#else
+	board_str("DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/db12x/extra.c b/board/ar7240/db12x/extra.c
new file mode 100644
index 0000000000..d9f74dce91
--- /dev/null
+++ b/board/ar7240/db12x/extra.c
@@ -0,0 +1,89 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	printf("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
diff --git a/board/ar7240/db12x/flash.c b/board/ar7240/db12x/flash.c
new file mode 100644
index 0000000000..0d511b13b4
--- /dev/null
+++ b/board/ar7240/db12x/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
diff --git a/board/ar7240/db12x/u-boot-bootstrap.lds b/board/ar7240/db12x/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/db12x/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/db12x/u-boot.lds b/board/ar7240/db12x/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/db12x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/dhp1565/Makefile b/board/ar7240/dhp1565/Makefile
new file mode 100644
index 0000000000..dd3465eba2
--- /dev/null
+++ b/board/ar7240/dhp1565/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/dhp1565/config.mk b/board/ar7240/dhp1565/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/dhp1565/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/dhp1565/dhp1565.c b/board/ar7240/dhp1565/dhp1565.c
new file mode 100644
index 0000000000..1f673fd45b
--- /dev/null
+++ b/board/ar7240/dhp1565/dhp1565.c
@@ -0,0 +1,171 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot DB120\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot DB120\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/dhp1565/flash.c b/board/ar7240/dhp1565/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/dhp1565/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/dhp1565/u-boot-bootstrap.lds b/board/ar7240/dhp1565/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/dhp1565/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/dhp1565/u-boot.lds b/board/ar7240/dhp1565/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/dhp1565/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/mi93/Makefile b/board/ar7240/mi93/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/mi93/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/mi93/config.mk b/board/ar7240/mi93/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/mi93/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/mi93/flash.c b/board/ar7240/mi93/flash.c
new file mode 100644
index 0000000000..130ea081d8
--- /dev/null
+++ b/board/ar7240/mi93/flash.c
@@ -0,0 +1,35 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+    if(*(volatile int *)CFG_FLASH_MAGIC_F != CFG_FLASH_MAGIC) {
+        flash_info->size = CFG_FLASH_SIZE; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+            flash_info->protect[i] = 0;
+        }
+    }
+    else {
+        flash_info->size = CFG_FLASH_SIZE_F; /* bytes */
+        flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE_F;
+        for (i = 0; i < flash_info->sector_count; i++) {
+            flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE_F);
+            flash_info->protect[i] = 0;
+        }
+    }
+
+    printf ("sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/mi93/mi93.c b/board/ar7240/mi93/mi93.c
new file mode 100644
index 0000000000..b08201a659
--- /dev/null
+++ b/board/ar7240/mi93/mi93.c
@@ -0,0 +1,67 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+	printf("MI93 (ar7241 - Virian) U-boot\n");
+	return 0;
+}
diff --git a/board/ar7240/mi93/u-boot.lds b/board/ar7240/mi93/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/mi93/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb90/Makefile b/board/ar7240/pb90/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/pb90/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb90/config.mk b/board/ar7240/pb90/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/pb90/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb90/flash.c b/board/ar7240/pb90/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/pb90/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb90/pb90.c b/board/ar7240/pb90/pb90.c
new file mode 100644
index 0000000000..14ecbd23e9
--- /dev/null
+++ b/board/ar7240/pb90/pb90.c
@@ -0,0 +1,59 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+/* Default tap values for starting the tap_init*/
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x7);
+
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("PB90 (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/pb90/u-boot.lds b/board/ar7240/pb90/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb90/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb92/Makefile b/board/ar7240/pb92/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/pb92/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb92/config.mk b/board/ar7240/pb92/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb92/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb92/flash.c b/board/ar7240/pb92/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/pb92/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb92/pb92.c b/board/ar7240/pb92/pb92.c
new file mode 100644
index 0000000000..d1368c752a
--- /dev/null
+++ b/board/ar7240/pb92/pb92.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "PB9x (ar7242) u-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("PB9x (ar7242) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/pb92/u-boot-bootstrap.lds b/board/ar7240/pb92/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb92/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb92/u-boot.lds b/board/ar7240/pb92/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb92/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb93/Makefile b/board/ar7240/pb93/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/pb93/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb93/config.mk b/board/ar7240/pb93/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/pb93/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb93/flash.c b/board/ar7240/pb93/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/pb93/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb93/pb93.c b/board/ar7240/pb93/pb93.c
new file mode 100644
index 0000000000..7cff566cc4
--- /dev/null
+++ b/board/ar7240/pb93/pb93.c
@@ -0,0 +1,72 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+        printf("PB93 (ar7241 - Virian) U-boot\n");
+    else
+        printf("PB93 (ar7240 - Python) U-boot\n");
+
+    return 0;
+}
diff --git a/board/ar7240/pb93/u-boot.lds b/board/ar7240/pb93/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb93/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb9x-2.6.31/Makefile b/board/ar7240/pb9x-2.6.31/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb9x-2.6.31/config.mk b/board/ar7240/pb9x-2.6.31/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb9x-2.6.31/flash.c b/board/ar7240/pb9x-2.6.31/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c b/board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c
new file mode 100644
index 0000000000..1e801de240
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/pb9x-2.6.31.c
@@ -0,0 +1,86 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+#ifndef COMPRESSED_UBOOT
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+#endif
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string,"pb9x (ar7241 - Virian) U-boot\n");
+    else
+        strcpy(board_string,"pb9x (ar7240 - Python) U-boot\n");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+        printf("PB93 (ar7241 - Virian) U-boot\n");
+    else
+        printf("PB93 (ar7240 - Python) U-boot\n");
+
+    return 0;
+}
+#endif
diff --git a/board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds b/board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb9x-2.6.31/u-boot.lds b/board/ar7240/pb9x-2.6.31/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb9x-2.6.31/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb9x-2x8/Makefile b/board/ar7240/pb9x-2x8/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb9x-2x8/config.mk b/board/ar7240/pb9x-2x8/config.mk
new file mode 100755
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb9x-2x8/flash.c b/board/ar7240/pb9x-2x8/flash.c
new file mode 100644
index 0000000000..f890bb23ec
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb9x-2x8/pb9x-2x8.c b/board/ar7240/pb9x-2x8/pb9x-2x8.c
new file mode 100644
index 0000000000..d1368c752a
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/pb9x-2x8.c
@@ -0,0 +1,75 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config(void)
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+#ifndef COMPRESSED_UBOOT
+    unsigned int tap_val1, tap_val2;
+#endif
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+#ifndef COMPRESSED_UBOOT
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#else
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x9);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0xa);
+#endif
+    ar7240_gpio_config();
+
+#ifndef COMPRESSED_UBOOT
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+#endif
+
+    ar7240_usb_initial_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    strcpy(board_string, "PB9x (ar7242) u-boot");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    printf("PB9x (ar7242) U-boot\n");
+    return 0;
+}
+#endif /* #ifdef COMPRESSED_UBOOT */
diff --git a/board/ar7240/pb9x-2x8/u-boot-bootstrap.lds b/board/ar7240/pb9x-2x8/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb9x-2x8/u-boot.lds b/board/ar7240/pb9x-2x8/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb9x-2x8/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/pb9x/Makefile b/board/ar7240/pb9x/Makefile
new file mode 100644
index 0000000000..0a4d419b24
--- /dev/null
+++ b/board/ar7240/pb9x/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o ../common/athrs16_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/pb9x/config.mk b/board/ar7240/pb9x/config.mk
new file mode 100644
index 0000000000..4e9c48e5e6
--- /dev/null
+++ b/board/ar7240/pb9x/config.mk
@@ -0,0 +1,10 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/pb9x/flash.c b/board/ar7240/pb9x/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/pb9x/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/pb9x/pb9x.c b/board/ar7240/pb9x/pb9x.c
new file mode 100644
index 0000000000..1e801de240
--- /dev/null
+++ b/board/ar7240/pb9x/pb9x.c
@@ -0,0 +1,86 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+#ifndef COMPRESSED_UBOOT
+        ar7240_ddr_tap_init();
+#endif
+    }
+    else {
+	ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+#ifndef COMPRESSED_UBOOT
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+#endif
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int checkboard (char *board_string)
+{
+    if ((is_ar7241() || is_ar7242()))
+        strcpy(board_string,"pb9x (ar7241 - Virian) U-boot\n");
+    else
+        strcpy(board_string,"pb9x (ar7240 - Python) U-boot\n");
+    return 0;
+}
+#else
+int checkboard (void)
+{
+    if ((is_ar7241() || is_ar7242()))
+        printf("PB93 (ar7241 - Virian) U-boot\n");
+    else
+        printf("PB93 (ar7240 - Python) U-boot\n");
+
+    return 0;
+}
+#endif
diff --git a/board/ar7240/pb9x/u-boot-bootstrap.lds b/board/ar7240/pb9x/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..1f1f757c86
--- /dev/null
+++ b/board/ar7240/pb9x/u-boot-bootstrap.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+    . = ALIGN(16);
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/pb9x/u-boot.lds b/board/ar7240/pb9x/u-boot.lds
new file mode 100644
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/pb9x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/reh132/Makefile b/board/ar7240/reh132/Makefile
new file mode 100644
index 0000000000..dd3465eba2
--- /dev/null
+++ b/board/ar7240/reh132/Makefile
@@ -0,0 +1,62 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o
+
+ifdef BOOT_FROM_NAND
+OBJS	+= ../common/ath_nand_flash.o
+else
+OBJS	+= ../common/ar7240_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/lowlevel_init_934x.o
+SOBJS	+= ../common/lowlevel_init_934x-1.1.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/reh132/config.mk b/board/ar7240/reh132/config.mk
new file mode 100644
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/ar7240/reh132/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/ar7240/reh132/flash.c b/board/ar7240/reh132/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/reh132/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/reh132/reh132.c b/board/ar7240/reh132/reh132.c
new file mode 100644
index 0000000000..f2b865b724
--- /dev/null
+++ b/board/ar7240/reh132/reh132.c
@@ -0,0 +1,176 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern int wasp_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#else
+#	define prmsg	printf
+#endif
+
+void
+wasp_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if ((ar7240_reg_rd(WASP_BOOTSTRAP_REG) & WASP_REF_CLK_25) == 0) {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ar7240_reg_wr_nf(AR934X_SWITCH_CLOCK_SPARE,
+			ar7240_reg_rd(AR934X_SWITCH_CLOCK_SPARE) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ar7240_reg_wr(AR7240_RESET,
+		ar7240_reg_rd(AR7240_RESET) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ar7240_reg_rd(AR7240_REV_ID) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ar7240_reg_wr(0xb8116c84 ,
+			ar7240_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void wasp_gpio_config(void)
+{
+        /*  Enable xLNBIAS signal on GPIO (19, 20) */
+        ar7240_reg_wr (AR7240_GPIO_FUNC4, ((ar7240_reg_rd(AR7240_GPIO_FUNC4) & 0x00ffffff)) | 0x2f000000);
+        ar7240_reg_wr (AR7240_GPIO_FUNC5, ((ar7240_reg_rd(AR7240_GPIO_FUNC5) & 0xffffff00)) | 0x2e);
+        ar7240_reg_wr (AR7240_GPIO_OE, (ar7240_reg_rd(AR7240_GPIO_OE) & 0xffe7ffff));
+
+#if 0
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep = (ar9300_eeprom_t *)WLANCAL;
+	uint32_t	val;
+
+
+	val = 0;
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		/* xtal_capin -bit 17:23 and xtag_capout -bit 24:30*/
+		val = (eep->params_for_tuning_caps[0] & 0x7f) << 17;
+		val |= (eep->params_for_tuning_caps[0] & 0x7f) << 24;
+	} else {
+		/* default when no caldata available*/
+		/* checking clock in bit 4 */
+		if (ar7240_reg_rd(RST_BOOTSTRAP_ADDRESS) & 0x10) {
+			val = (0x1020 << 17);  /*default 0x2040 for 40Mhz clock*/
+		} else {
+			val = (0x2040 << 17); /*default 0x4080 for 25Mhz clock*/
+		}
+	}
+	val |= (ar7240_reg_rd(XTAL_ADDRESS) & (((1 << 17) - 1) | (1 << 31)));
+	ar7240_reg_wr(XTAL_ADDRESS, val);
+	prmsg("Setting 0xb8116290 to 0x%x\n", val);
+	return;
+}
+
+int
+wasp_mem_config(void)
+{
+	unsigned int type, reg32;
+
+	type = wasp_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ar7240_reg_rd(AR7240_RESET);
+	reg32 = reg32 &  ~AR7240_RESET_WMAC;
+	ar7240_reg_wr_nf(AR7240_RESET, reg32);
+
+	/* Switching regulator settings */
+	ar7240_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_FL)
+	if (ar7240_reg_rd(AR7240_REV_ID) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ar7240_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ar7240_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	wasp_usb_initial_config();
+
+	wasp_gpio_config();
+
+	ath_set_tuning_caps(); /* Needed here not to mess with Ethernet clocks */
+
+	reg32 = ar7240_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (wasp_mem_config());
+}
+
+#ifdef COMPRESSED_UBOOT
+int	checkboard(char *s)
+#else
+int	checkboard(void)
+#endif
+{
+#ifdef COMPRESSED_UBOOT
+#if CONFIG_AP123
+	strcpy(s, "U-boot AP123\n");
+#elif CONFIG_MI124
+	strcpy(s, "U-boot MI124\n");
+#else
+	strcpy(s, "U-boot REH132\n");
+#endif
+#endif
+#if CONFIG_AP123
+	prmsg("U-boot AP123\n");
+#elif CONFIG_MI124
+	prmsg("U-boot MI124\n");
+#else
+	prmsg("U-boot REH132\n");
+#endif
+	return 0;
+}
diff --git a/board/ar7240/reh132/u-boot-bootstrap.lds b/board/ar7240/reh132/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/ar7240/reh132/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/ar7240/reh132/u-boot.lds b/board/ar7240/reh132/u-boot.lds
new file mode 100644
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/ar7240/reh132/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/tb327/Makefile b/board/ar7240/tb327/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/tb327/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/tb327/config.mk b/board/ar7240/tb327/config.mk
new file mode 100755
index 0000000000..f110fcb6ff
--- /dev/null
+++ b/board/ar7240/tb327/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0xbf000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/tb327/flash.c b/board/ar7240/tb327/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/tb327/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/tb327/tb327.c b/board/ar7240/tb327/tb327.c
new file mode 100644
index 0000000000..65461399c3
--- /dev/null
+++ b/board/ar7240/tb327/tb327.c
@@ -0,0 +1,52 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1,tap_val2;
+
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x7);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x7);
+
+    ar7240_usb_initial_config();
+
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+
+    printf("AP93 (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/ar7240/tb327/u-boot.lds b/board/ar7240/tb327/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/tb327/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/wasp_emu/Makefile b/board/ar7240/wasp_emu/Makefile
new file mode 100644
index 0000000000..8ed365cbcc
--- /dev/null
+++ b/board/ar7240/wasp_emu/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/athr_s27_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/wasp_emu/config.mk b/board/ar7240/wasp_emu/config.mk
new file mode 100755
index 0000000000..15c64df10c
--- /dev/null
+++ b/board/ar7240/wasp_emu/config.mk
@@ -0,0 +1,9 @@
+# ROM version
+# TEXT_BASE = 0x9f000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+#TEXT_BASE = 0x83fc0000
+TEXT_BASE = 0x80100000
diff --git a/board/ar7240/wasp_emu/flash.c b/board/ar7240/wasp_emu/flash.c
new file mode 100644
index 0000000000..8369fd8b4d
--- /dev/null
+++ b/board/ar7240/wasp_emu/flash.c
@@ -0,0 +1,28 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size 8MB, sector count = %d\n", flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/wasp_emu/u-boot.lds b/board/ar7240/wasp_emu/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/wasp_emu/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/wasp_emu/wasp_emu.c b/board/ar7240/wasp_emu/wasp_emu.c
new file mode 100644
index 0000000000..3b59730f8d
--- /dev/null
+++ b/board/ar7240/wasp_emu/wasp_emu.c
@@ -0,0 +1,69 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+	ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+	/* Disable clock obs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+	ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+}
+
+int
+ar7240_mem_config(void)
+{
+#if !defined(CONFIG_WASP_EMU)
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+    /* Default tap values for starting the tap_init*/
+    if (!(is_ar7241() || is_ar7242()))  {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+        ar7240_ddr_tap_init();
+    }
+    else {
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x2);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL2, 0x0);
+        ar7240_reg_wr (AR7240_DDR_TAP_CONTROL3, 0x0);
+    }
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+
+    printf("#### TAP VALUE 1 = 0x%x, 2 = 0x%x [0x%x: 0x%x]\n",
+                tap_val1, tap_val2, *(unsigned *)0x80500000,
+                *(unsigned *)0x80500004);
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+#endif
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+	return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+	printf("Wasp Emulation U-boot\n");
+	return 0;
+}
diff --git a/board/ar7240/wrt54g/Makefile b/board/ar7240/wrt54g/Makefile
new file mode 100644
index 0000000000..df215e93f7
--- /dev/null
+++ b/board/ar7240/wrt54g/Makefile
@@ -0,0 +1,18 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o ../common/ar7240_pci.o ../common/ar7240_flash.o ../common/ar7240_s26_phy.o
+SOBJS	= ../common/lowlevel_init.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/ar7240/wrt54g/config.mk b/board/ar7240/wrt54g/config.mk
new file mode 100755
index 0000000000..a1ae880417
--- /dev/null
+++ b/board/ar7240/wrt54g/config.mk
@@ -0,0 +1,5 @@
+# ROM version
+TEXT_BASE = 0x9f000000
+
+# SDRAM version
+#TEXT_BASE = 0x80000000
diff --git a/board/ar7240/wrt54g/flash.c b/board/ar7240/wrt54g/flash.c
new file mode 100644
index 0000000000..722e63baa6
--- /dev/null
+++ b/board/ar7240/wrt54g/flash.c
@@ -0,0 +1,42 @@
+/*****************************************************************************/
+/* \file flash.c
+** \brief flash read/write support
+**
+**  This file contains the routine that detects the flash geometry, and is used
+**  in the WRT54G project in u-boot.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+**
+**  This file is proprietary to Atheros Communications, Inc.'s and licensed only
+**  according to a Technology License Agreement approved and executed by Atheros,
+**  or sublicensed by an authorized sublicensor.
+*/
+
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+    int i;
+
+    /* XXX this is hardcoded until we figure out how to read flash id */
+
+    flash_info->flash_id  = FLASH_M25P64;
+    flash_info->size = CFG_FLASH_SIZE; /* bytes */
+    flash_info->sector_count = flash_info->size/CFG_FLASH_SECTOR_SIZE;
+
+    for (i = 0; i < flash_info->sector_count; i++) {
+        flash_info->start[i] = CFG_FLASH_BASE + (i * CFG_FLASH_SECTOR_SIZE);
+        flash_info->protect[i] = 0;
+    }
+
+    printf ("flash size %d, sector count = %d\n", flash_info->size, flash_info->sector_count);
+    return (flash_info->size);
+
+}
diff --git a/board/ar7240/wrt54g/u-boot.lds b/board/ar7240/wrt54g/u-boot.lds
new file mode 100755
index 0000000000..8dc2b764c7
--- /dev/null
+++ b/board/ar7240/wrt54g/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/ar7240/wrt54g/wrt54g.c b/board/ar7240/wrt54g/wrt54g.c
new file mode 100644
index 0000000000..c55c6c1581
--- /dev/null
+++ b/board/ar7240/wrt54g/wrt54g.c
@@ -0,0 +1,73 @@
+/*****************************************************************************/
+/* \file wrt54g.c
+** \brief wrt54g support routines
+**
+**  This file contains all of the support and initialization routines for the
+**  WRT54G project in u-boot.
+**
+**  Copyright (c) 2009 Atheros Communications Inc.  All rights reserved.
+**
+**  This file is proprietary to Atheros Communications, Inc.'s and licensed only
+**  according to a Technology License Agreement approved and executed by Atheros,
+**  or sublicensed by an authorized sublicensor.
+*/
+
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include "ar7240_soc.h"
+
+extern void ar7240_ddr_initial_config(uint32_t refresh);
+extern int ar7240_ddr_find_size(void);
+
+void
+ar7240_usb_initial_config(void)
+{
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0a04081e);
+    ar7240_reg_wr_nf(AR7240_USB_PLL_CONFIG, 0x0804081e);
+}
+
+void ar7240_gpio_config()
+{
+    /* Disable clock obs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+    /* Enable eth Switch LEDs */
+    ar7240_reg_wr (AR7240_GPIO_FUNC, (ar7240_reg_rd(AR7240_GPIO_FUNC) | 0xf8));
+}
+
+int
+ar7240_mem_config(void)
+{
+    unsigned int tap_val1, tap_val2;
+    ar7240_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+/* Default tap values for starting the tap_init*/
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL0, 0x8);
+    ar7240_reg_wr (AR7240_DDR_TAP_CONTROL1, 0x9);
+
+    ar7240_ddr_tap_init();
+
+    tap_val1 = ar7240_reg_rd(0xb800001c);
+    tap_val2 = ar7240_reg_rd(0xb8000020);
+    printf("#### TAP VALUE 1 = %x, 2 = %x\n",tap_val1, tap_val2);
+
+    ar7240_usb_initial_config();
+    ar7240_gpio_config();
+
+    return (ar7240_ddr_find_size());
+}
+
+long int initdram(int board_type)
+{
+    return (ar7240_mem_config());
+}
+
+int checkboard (void)
+{
+    printf("WRT54G (ar7240) U-boot\n");
+    return 0;
+}
diff --git a/board/atheros/aph131/Makefile b/board/atheros/aph131/Makefile
new file mode 100644
index 0000000000..8d89fc2154
--- /dev/null
+++ b/board/atheros/aph131/Makefile
@@ -0,0 +1,58 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-955x.o
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+ifeq ($(ETH_CONFIG2), _ar8033)
+OBJS	+= ../common/athr_ar8033_phy.o
+endif
+
+SOBJS	= ../common/955x.o ../common/tap-955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/aph131/aph131.c b/board/atheros/aph131/aph131.c
new file mode 100644
index 0000000000..0bfb6efe6d
--- /dev/null
+++ b/board/atheros/aph131/aph131.c
@@ -0,0 +1,143 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Scorpion 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	if (is_drqfn()) {
+		return;
+	}
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+#endif
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/board/atheros/aph131/config.mk b/board/atheros/aph131/config.mk
new file mode 100755
index 0000000000..df2665e385
--- /dev/null
+++ b/board/atheros/aph131/config.mk
@@ -0,0 +1,35 @@
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/atheros/aph131/extra.c b/board/atheros/aph131/extra.c
new file mode 100644
index 0000000000..a14942daf5
--- /dev/null
+++ b/board/atheros/aph131/extra.c
@@ -0,0 +1,103 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
+
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x45) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x45) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_ATBVREG_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x1) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SWREGCLK_EDGE_SEL_SET(0x0) |
+		XTAL_SPARE_SET(0xf);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff --git a/board/atheros/aph131/flash.c b/board/atheros/aph131/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/aph131/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/aph131/u-boot-bootstrap.lds b/board/atheros/aph131/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/atheros/aph131/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/atheros/aph131/u-boot.lds b/board/atheros/aph131/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/aph131/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/board953x/Makefile b/board/atheros/board953x/Makefile
new file mode 100755
index 0000000000..9c624b7adb
--- /dev/null
+++ b/board/atheros/board953x/Makefile
@@ -0,0 +1,68 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-953x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-953x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-953x.o
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/953x.o ../common/tap-953x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/board953x/board953x.c b/board/atheros/board953x/board953x.c
new file mode 100755
index 0000000000..7f1d20d863
--- /dev/null
+++ b/board/atheros/board953x/board953x.c
@@ -0,0 +1,145 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Honey Bee 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Honey Bee 1.%d", ath_reg_rd	\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) {
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+		udelay(1000);
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+		udelay(1000);
+
+		ath_reg_wr(PHY_CTRL5_ADDRESS, PHY_CTRL5_RESET_1);
+		udelay(1000);
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+		udelay(1000);
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+		udelay(1000);
+
+		ath_reg_rmw_clear(RST_CLKGAT_EN_ADDRESS, RST_CLKGAT_EN_USB1_SET(1));
+
+		return;
+	}
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+}
+
+void ath_gpio_config(void)
+{
+
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+#if 0
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+//#else
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x0));
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+#endif
+
+#if 0
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+//#else
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 13));
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 15));
+#endif
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd001f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	ath_usb_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/board/atheros/board953x/config.mk b/board/atheros/board953x/config.mk
new file mode 100755
index 0000000000..0240aa8c1b
--- /dev/null
+++ b/board/atheros/board953x/config.mk
@@ -0,0 +1,23 @@
+# ROM version
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/atheros/board953x/extra.c b/board/atheros/board953x/extra.c
new file mode 100755
index 0000000000..b27bcc1d7c
--- /dev/null
+++ b/board/atheros/board953x/extra.c
@@ -0,0 +1,55 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+        eep = (ar9300_eeprom_t *)WLANCAL;
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x4b) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x4b) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x0) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SPARE_SET(0x0);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+	ath_reg_wr(XTAL2_ADDRESS, XTAL2_DCA_BYPASS_SET(0x1) |
+					XTAL2_FSM_START_L_SET(0x1));
+	ath_reg_wr(XTAL3_ADDRESS, XTAL3_EVAL_LENGTH_SET(0x400) |
+					XTAL3_HARMONIC_NUMBER_SET(0x51));
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff --git a/board/atheros/board953x/flash.c b/board/atheros/board953x/flash.c
new file mode 100755
index 0000000000..cf16d62ec1
--- /dev/null
+++ b/board/atheros/board953x/flash.c
@@ -0,0 +1,30 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	/*printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);*/
+
+	return (flash_info->size);
+}
diff --git a/board/atheros/board953x/u-boot-bootstrap.lds b/board/atheros/board953x/u-boot-bootstrap.lds
new file mode 100755
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/atheros/board953x/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/atheros/board953x/u-boot.lds b/board/atheros/board953x/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/board953x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/board955x/Makefile b/board/atheros/board955x/Makefile
new file mode 100644
index 0000000000..54b1da2730
--- /dev/null
+++ b/board/atheros/board955x/Makefile
@@ -0,0 +1,97 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+#
+# The files included in EXTRA_OBJS use some functions that are not
+# available in the `bootstrap' portion of tuboot.bin resulting in
+# compile/link errors. Hence have them separate (i.e. don't include
+# into lib$(BOARD).a and include them only in `u-boot' portion of
+# tuboot.bin.
+#
+
+ifeq ($(strip $(COMPRESSED_UBOOT)),0) #{
+OBJS	+= $(BOARD_EXTRA_OBJS_tmp)
+else
+EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif #}
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ATH_RGMII_CAL),1)
+OBJS	+= ../common/rgmii-cal-955x.o
+OBJS	+= ../common/athrs17_lpbk.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _ar8033)
+OBJS	+= ../common/athr_ar8033_phy.o
+endif
+
+
+SOBJS	= ../common/955x.o ../common/tap-955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS) $(EXTRA_OBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/board955x/board955x.c b/board/atheros/board955x/board955x.c
new file mode 100644
index 0000000000..0bfb6efe6d
--- /dev/null
+++ b/board/atheros/board955x/board955x.c
@@ -0,0 +1,143 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(...)
+#	define args		char *s
+#	define board_str(a)	do {			\
+	char ver[] = "0";				\
+	strcpy(s, a " - Scorpion 1.");			\
+	ver[0] += ath_reg_rd(RST_REVISION_ID_ADDRESS)	\
+						& 0xf;	\
+	strcat(s, ver);					\
+} while (0)
+#else
+#	define prmsg	printf
+#	define args		void
+#	define board_str(a)				\
+	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+			(RST_REVISION_ID_ADDRESS) & 0xf)
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	if (is_drqfn()) {
+		return;
+	}
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_SET(0x80));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 4));
+	/* Set GPIO 13 as input for LED functionality to be OFF during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 13));
+	/* Turn off JUMPST_LED and 5Gz LED during bootup */
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
+	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+#endif
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(args)
+{
+	board_str(CONFIG_BOARD_NAME);
+	return 0;
+}
diff --git a/board/atheros/board955x/config.mk b/board/atheros/board955x/config.mk
new file mode 100755
index 0000000000..df2665e385
--- /dev/null
+++ b/board/atheros/board955x/config.mk
@@ -0,0 +1,35 @@
+# ROM version
+ifdef BOOT_FROM_NAND #{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0xa0100000
+else #}{
+TEXT_BASE = 0xa0100000
+endif #}
+else #}{
+ifeq ($(COMPRESSED_UBOOT),1) #{
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else #}{
+TEXT_BASE = 0x9f000000
+endif #}
+endif #}
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
+
+export BOARD_EXTRA_OBJS_tmp =
+
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(BOARDDIR)/extra.o
+ifeq ($(BOOT_FROM_NAND),1)
+BOARD_EXTRA_OBJS_tmp += $(TOPDIR)/board/$(VENDOR)/common/ath_nand.o $(TOPDIR)/drivers/nand/nand_ids.o
+endif
+
+ifeq ($(COMPRESSED_UBOOT),1) #{
+BOARD_EXTRA_OBJS = $(BOARD_EXTRA_OBJS_tmp)
+endif
diff --git a/board/atheros/board955x/extra.c b/board/atheros/board955x/extra.c
new file mode 100644
index 0000000000..a14942daf5
--- /dev/null
+++ b/board/atheros/board955x/extra.c
@@ -0,0 +1,103 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+void *
+ath_get_nand_cal_data(void)
+{
+	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
+
+        ulong           off,size;
+        int             ret;
+        static u_char   nand_cal_data[256 * 1024];
+        nand_info_t *nand;
+
+         /*
+          * caldata partition is of 128k
+          *
+          */
+        nand = &nand_info[nand_curr_device];
+        size = nand->erasesize;
+
+        /*
+         * Get the Offset of Caldata partition
+         */
+        off = ath_nand_get_cal_offset(getenv("bootargs"));
+        if(off == ATH_CAL_OFF_INVAL) {
+                printf("Invalid CAL offset \n");
+                return 1;
+        }
+
+        /*
+         * Get the values from flash, and program into the MAC address
+         * registers
+         */
+        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+        printf(" %d bytes %s: %s\n", size,
+                        "read", ret ? "ERROR" : "OK");
+        if(ret != 0 ) {
+                return NULL;
+        }
+
+        return nand_cal_data;
+}
+#endif
+
+void ath_set_tuning_caps(void)
+{
+	typedef struct {
+		u_int8_t	pad[0x28],
+				params_for_tuning_caps[2],
+				featureEnable;
+	} __attribute__((__packed__)) ar9300_eeprom_t;
+
+	ar9300_eeprom_t	*eep;
+	uint32_t	val;
+
+#ifdef CONFIG_ATH_NAND_BR
+        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+#else
+        eep = (ar9300_eeprom_t *)WLANCAL;
+#endif /* CONFIG_ATH_NAND_BR */
+
+	val =	XTAL_TCXODET_SET(0x0) |
+		XTAL_XTAL_CAPINDAC_SET(0x45) |
+		XTAL_XTAL_CAPOUTDAC_SET(0x45) |
+		XTAL_XTAL_DRVSTR_SET(0x3) |
+		XTAL_XTAL_SHORTXIN_SET(0x0) |
+		XTAL_XTAL_LOCALBIAS_SET(0x1) |
+		XTAL_XTAL_PWDCLKD_SET(0x0) |
+		XTAL_XTAL_BIAS2X_SET(0x0) |
+		XTAL_XTAL_LBIAS2X_SET(0x0) |
+		XTAL_XTAL_ATBVREG_SET(0x0) |
+		XTAL_XTAL_OSCON_SET(0x1) |
+		XTAL_XTAL_PWDCLKIN_SET(0x0) |
+		XTAL_LOCAL_XTAL_SET(0x1) |
+		XTAL_PWD_SWREGCLK_SET(0x0) |
+		XTAL_SWREGCLK_EDGE_SEL_SET(0x0) |
+		XTAL_SPARE_SET(0xf);
+
+	/* checking feature enable bit 6 and caldata is valid */
+	if ((eep->featureEnable & 0x40) && (eep->pad[0x0] != 0xff)) {
+		val &= ~(XTAL_XTAL_CAPINDAC_MASK | XTAL_XTAL_CAPOUTDAC_MASK);
+		val |=	XTAL_XTAL_CAPINDAC_SET(eep->params_for_tuning_caps[0]) |
+			XTAL_XTAL_CAPOUTDAC_SET(eep->params_for_tuning_caps[0]);
+	}
+
+	ath_reg_wr(XTAL_ADDRESS, val);
+
+#define __str(x)	# x
+#define str(x)		__str(x)
+
+	printf("Setting " str(XTAL_ADDRESS) " to 0x%x\n", val);
+	return;
+}
diff --git a/board/atheros/board955x/flash.c b/board/atheros/board955x/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/board955x/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/board955x/u-boot-bootstrap.lds b/board/atheros/board955x/u-boot-bootstrap.lds
new file mode 100644
index 0000000000..e628df2e7c
--- /dev/null
+++ b/board/atheros/board955x/u-boot-bootstrap.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start_bootstrap)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start_bootstrap = .;
+	.got  : { *(.got) }
+	__got_end_bootstrap = .;
+
+	.sdata  : { *(.sdata) }
+
+	uboot_end_data_bootstrap = .;
+	num_got_entries = (__got_end_bootstrap - __got_start_bootstrap) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end_bootstrap = .;
+}
diff --git a/board/atheros/board955x/u-boot.lds b/board/atheros/board955x/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/board955x/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/common/953x.S b/board/atheros/common/953x.S
new file mode 100755
index 0000000000..676dfe21ea
--- /dev/null
+++ b/board/atheros/common/953x.S
@@ -0,0 +1,153 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(2) | \
+				BB_DPLL2_KD_SET(0x10) | \
+				BB_DPLL2_PLL_PWD_SET(1));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(2) | \
+				PCIe_DPLL2_KD_SET(0x10) | \
+				PCIe_DPLL2_PLL_PWD_SET(1));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(2) | \
+				DDR_DPLL2_KD_SET(0x10) | \
+				DDR_DPLL2_PLL_PWD_SET(1));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(2) | \
+				CPU_DPLL2_KD_SET(0x10) | \
+				CPU_DPLL2_PLL_PWD_SET(1));
+
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL
+	li	t4,	CPU_PLL_DITHER_VAL
+	li	t3,	DDR_PLL_DITHER_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CLK_SRC_CONTROL |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER_ADDRESS);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER_ADDRESS);
+	sw	t4,	0(t7);
+
+	lui	t7,	47110;
+	lui	t8,	1020;
+	sw	t8,	0xb4(t7);
+
+
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
+
+ /* end of file */
diff --git a/board/atheros/common/955x.S b/board/atheros/common/955x.S
new file mode 100644
index 0000000000..133a4463e3
--- /dev/null
+++ b/board/atheros/common/955x.S
@@ -0,0 +1,155 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+/*
+ * Helper macros.
+ * These Clobber t7, t8 and t9
+ */
+#define reg_write(_reg, _val)			\
+	li	t7,	KSEG1ADDR(_reg);	\
+	li	t8,	_val;			\
+	sw	t8,	0(t7);
+
+#define reg_rmw_set(_reg, _mask, _val)		\
+	li	t7,	KSEG1ADDR(_reg);	\
+	lw	t8,	0(t7);			\
+	li	t9,	~(_mask);		\
+	and	t8,	t8,	t9;		\
+	li	t9,	_val;			\
+	or	t8,	t8,	t9;		\
+	sw	t8,	0(t7)
+
+#define cpu_pll_set(_mask, _val)	\
+	reg_rmw_set(CPU_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define ddr_pll_set(_mask, _val)	\
+	reg_rmw_set(DDR_PLL_CONFIG_ADDRESS, _mask, _val)
+
+#define cpu_ddr_control_set(_mask, _val)	\
+	reg_rmw_set(CPU_DDR_CLOCK_CONTROL_ADDRESS, _mask, _val)
+
+
+/******************************************************************************
+ * first level initialization:
+ *
+ * 0) If clock cntrl reset switch is already set, we're recovering from
+ *    "divider reset"; goto 3.
+ * 1) Setup divide ratios.
+ * 2) Reset.
+ * 3) Setup pll's, wait for lock.
+ *
+ *****************************************************************************/
+
+.globl lowlevel_init
+	.type	lowlevel_init, @function
+	.text
+	.align 4
+
+lowlevel_init:
+
+#if !defined(CONFIG_ATH_EMULATION)
+#if !defined(CONFIG_ATH_NAND_BR)
+
+	reg_write(BB_DPLL2_ADDRESS, BB_DPLL2_KI_SET(4) | \
+				BB_DPLL2_KD_SET(0x60) | \
+				BB_DPLL2_PLL_PWD_SET(1) | \
+				BB_DPLL2_DELTA_SET(0x1e));
+	reg_write(PCIe_DPLL2_ADDRESS, PCIe_DPLL2_KI_SET(4) | \
+				PCIe_DPLL2_KD_SET(0x60) | \
+				PCIe_DPLL2_PLL_PWD_SET(1) | \
+				PCIe_DPLL2_DELTA_SET(0x1e));
+	reg_write(DDR_DPLL2_ADDRESS, DDR_DPLL2_KI_SET(4) | \
+				DDR_DPLL2_KD_SET(0x60) | \
+				DDR_DPLL2_PLL_PWD_SET(1) | \
+				DDR_DPLL2_DELTA_SET(0x1e));
+	reg_write(CPU_DPLL2_ADDRESS, CPU_DPLL2_KI_SET(4) | \
+				CPU_DPLL2_KD_SET(0x60) | \
+				CPU_DPLL2_PLL_PWD_SET(1) | \
+				CPU_DPLL2_DELTA_SET(0x1e));
+
+	li	t5,	CPU_PLL_CONFIG_NINT_VAL
+	li	t6,	DDR_PLL_CONFIG_NINT_VAL
+	li	t4,	CPU_PLL_DITHER_VAL
+	li	t3,	DDR_PLL_DITHER_VAL
+
+	li	t7,	PLL_CONFIG_VAL_F
+	lw	t8,	0(t7)
+	li	t7,	PLL_MAGIC
+	beq	t7,	t8,	read_from_flash
+	nop
+	j	pll_bypass_set
+	nop
+read_from_flash:
+	li	t7,	PLL_CONFIG_VAL_F + 4
+	lw	t5,	0(t7)
+	lw	t4,	4(t7)
+	lw	t6,	8(t7)
+	lw	t3,	12(t7)
+
+
+pll_bypass_set:
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1));
+	cpu_ddr_control_set (CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+init_cpu_pll:
+	li	t7,	KSEG1ADDR(CPU_PLL_CONFIG_ADDRESS);
+	li	t8,	(CPU_PLL_CONFIG_PLLPWD_SET(1) | \
+			CPU_PLL_CONFIG_REF_DIV_VAL | \
+			CPU_PLL_CONFIG_RANGE_VAL | \
+			CPU_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t5
+	sw	t8,	0(t7);
+
+init_ddr_pll:
+	li	t7,	KSEG1ADDR(DDR_PLL_CONFIG_ADDRESS);
+	li	t8,	(DDR_PLL_CONFIG_PLLPWD_SET(1) | \
+			DDR_PLL_CONFIG_REF_DIV_VAL | \
+			DDR_PLL_CONFIG_RANGE_VAL | \
+			DDR_PLL_CONFIG_OUT_DIV_VAL1);
+	or	t8,	t8,	t6
+	sw	t8,	0(t7);
+
+init_ahb_pll:
+	reg_write(CPU_DDR_CLOCK_CONTROL_ADDRESS,
+			CPU_DDR_CLOCK_CONTROL_AHB_DIV_VAL |
+			AHB_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_DDR |
+			CPU_AND_DDR_CLK_FROM_CPU |
+			CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV |
+			CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(1) |
+			CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(1));
+
+pll_pwd_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_PLLPWD_MASK, CPU_PLL_CONFIG_PLLPWD_SET(0));
+	ddr_pll_set(DDR_PLL_CONFIG_PLLPWD_MASK, DDR_PLL_CONFIG_PLLPWD_SET(0));
+
+outdiv_unset:
+	cpu_pll_set(CPU_PLL_CONFIG_OUTDIV_MASK, CPU_PLL_CONFIG_OUT_DIV_VAL2);
+	ddr_pll_set(DDR_PLL_CONFIG_OUTDIV_MASK, DDR_PLL_CONFIG_OUT_DIV_VAL2);
+
+pll_bypass_unset:
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_CPU_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_DDR_PLL_BYPASS_SET(0));
+	cpu_ddr_control_set(CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_MASK, CPU_DDR_CLOCK_CONTROL_AHB_PLL_BYPASS_SET(0));
+
+ddr_pll_dither_unset:
+	li	t7,	KSEG1ADDR(DDR_PLL_DITHER_ADDRESS);
+	sw	t3,	0(t7);
+
+cpu_pll_dither_unset:
+	li	t7,	KSEG1ADDR(CPU_PLL_DITHER_ADDRESS);
+	sw	t4,	0(t7);
+
+#endif /* !defined(CONFIG_ATH_NAND_BR) */
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+	jr ra
+	nop
+
+ /* end of file */
diff --git a/board/atheros/common/ath_flash.c b/board/atheros/common/ath_flash.c
new file mode 100644
index 0000000000..ff10da1f28
--- /dev/null
+++ b/board/atheros/common/ath_flash.c
@@ -0,0 +1,322 @@
+#include <common.h>
+#include <jffs2/jffs2.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <atheros.h>
+#include "ath_flash.h"
+
+#if !defined(ATH_DUAL_FLASH)
+#	define	ath_spi_flash_print_info	flash_print_info
+#endif
+
+/*
+ * globals
+ */
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+/*
+ * statics
+ */
+static void ath_spi_write_enable(void);
+static void ath_spi_poll(void);
+#if !defined(ATH_SST_FLASH)
+static void ath_spi_write_page(uint32_t addr, uint8_t * data, int len);
+#endif
+static void ath_spi_sector_erase(uint32_t addr);
+
+static void
+ath_spi_read_id(void)
+{
+	u32 rd;
+
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_spi_bit_banger(ATH_SPI_CMD_RDID);
+	ath_spi_delay_8();
+	ath_spi_delay_8();
+	ath_spi_delay_8();
+	ath_spi_go();
+
+	rd = ath_reg_rd(ATH_SPI_RD_STATUS);
+
+	printf("Flash Manuf Id 0x%x, DeviceId0 0x%x, DeviceId1 0x%x\n",
+		(rd >> 16) & 0xff, (rd >> 8) & 0xff, (rd >> 0) & 0xff);
+}
+
+
+#ifdef ATH_SST_FLASH
+void ath_spi_flash_unblock(void)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_WRITE_SR);
+	ath_spi_bit_banger(0x0);
+	ath_spi_go();
+	ath_spi_poll();
+}
+#endif
+
+unsigned long flash_init(void)
+{
+#if !(defined(CONFIG_WASP_SUPPORT) || defined(CONFIG_MACH_QCA955x) || defined(CONFIG_MACH_QCA953x))
+#ifdef ATH_SST_FLASH
+	ath_reg_wr_nf(ATH_SPI_CLOCK, 0x3);
+	ath_spi_flash_unblock();
+	ath_reg_wr(ATH_SPI_FS, 0);
+#else
+	ath_reg_wr_nf(ATH_SPI_CLOCK, 0x43);
+#endif
+#endif
+	ath_reg_rmw_set(ATH_SPI_FS, 1);
+	ath_spi_read_id();
+	ath_reg_rmw_clear(ATH_SPI_FS, 1);
+
+	/*
+	 * hook into board specific code to fill flash_info
+	 */
+	return (flash_get_geom(&flash_info[0]));
+}
+
+void
+ath_spi_flash_print_info(flash_info_t *info)
+{
+	printf("The hell do you want flinfo for??\n");
+}
+
+int
+flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	int i, sector_size = info->size / info->sector_count;
+
+	printf("\nFirst %#x last %#x sector size %#x\n",
+		s_first, s_last, sector_size);
+
+	for (i = s_first; i <= s_last; i++) {
+		printf("\b\b\b\b%4d", i);
+		ath_spi_sector_erase(i * sector_size);
+	}
+	ath_spi_done();
+	printf("\n");
+
+	return 0;
+}
+
+/*
+ * Write a buffer from memory to flash:
+ * 0. Assumption: Caller has already erased the appropriate sectors.
+ * 1. call page programming for every 256 bytes
+ */
+#ifdef ATH_SST_FLASH
+void
+ath_spi_flash_chip_erase(void)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_CHIP_ERASE);
+	ath_spi_go();
+	ath_spi_poll();
+}
+
+int
+write_buff(flash_info_t *info, uchar *src, ulong dst, ulong len)
+{
+	uint32_t val;
+
+	dst = dst - CFG_FLASH_BASE;
+	printf("write len: %lu dst: 0x%x src: %p\n", len, dst, src);
+
+	for (; len; len--, dst++, src++) {
+		ath_spi_write_enable();	// dont move this above 'for'
+		ath_spi_bit_banger(ATH_SPI_CMD_PAGE_PROG);
+		ath_spi_send_addr(dst);
+
+		val = *src & 0xff;
+		ath_spi_bit_banger(val);
+
+		ath_spi_go();
+		ath_spi_poll();
+	}
+	/*
+	 * Disable the Function Select
+	 * Without this we can't read from the chip again
+	 */
+	ath_reg_wr(ATH_SPI_FS, 0);
+
+	if (len) {
+		// how to differentiate errors ??
+		return ERR_PROG_ERROR;
+	} else {
+		return ERR_OK;
+	}
+}
+#else
+int
+write_buff(flash_info_t *info, uchar *source, ulong addr, ulong len)
+{
+	int total = 0, len_this_lp, bytes_this_page;
+	ulong dst;
+	uchar *src;
+
+	printf("write addr: %x\n", addr);
+	addr = addr - CFG_FLASH_BASE;
+
+	while (total < len) {
+		src = source + total;
+		dst = addr + total;
+		bytes_this_page =
+			ATH_SPI_PAGE_SIZE - (addr % ATH_SPI_PAGE_SIZE);
+		len_this_lp =
+			((len - total) >
+			bytes_this_page) ? bytes_this_page : (len - total);
+		ath_spi_write_page(dst, src, len_this_lp);
+		total += len_this_lp;
+	}
+
+	ath_spi_done();
+
+	return 0;
+}
+#endif
+
+static void
+ath_spi_write_enable()
+{
+	ath_reg_wr_nf(ATH_SPI_FS, 1);
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+	ath_spi_bit_banger(ATH_SPI_CMD_WREN);
+	ath_spi_go();
+}
+
+static void
+ath_spi_poll()
+{
+	int rd;
+
+	do {
+		ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);
+		ath_spi_bit_banger(ATH_SPI_CMD_RD_STATUS);
+		ath_spi_delay_8();
+		rd = (ath_reg_rd(ATH_SPI_RD_STATUS) & 1);
+	} while (rd);
+}
+
+#if !defined(ATH_SST_FLASH)
+static void
+ath_spi_write_page(uint32_t addr, uint8_t *data, int len)
+{
+	int i;
+	uint8_t ch;
+
+	display(0x77);
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_PAGE_PROG);
+	ath_spi_send_addr(addr);
+
+	for (i = 0; i < len; i++) {
+		ch = *(data + i);
+		ath_spi_bit_banger(ch);
+	}
+
+	ath_spi_go();
+	display(0x66);
+	ath_spi_poll();
+	display(0x6d);
+}
+#endif
+
+static void
+ath_spi_sector_erase(uint32_t addr)
+{
+	ath_spi_write_enable();
+	ath_spi_bit_banger(ATH_SPI_CMD_SECTOR_ERASE);
+	ath_spi_send_addr(addr);
+	ath_spi_go();
+	display(0x7d);
+	ath_spi_poll();
+}
+
+#ifdef ATH_DUAL_FLASH
+void flash_print_info(flash_info_t *info)
+{
+	ath_spi_flash_print_info(NULL);
+	ath_nand_flash_print_info(NULL);
+}
+#endif
+
+#ifdef FW_RECOVERY/*  by huangwenzhong, 03May13 */
+
+/******************************************************************************
+* FUNCTION	: ar7240_auf_gpio_init()
+* AUTHOR	: HouXB <houxubo@tp-link.net>
+* DESCRIPTION		: set input and output indicator gpio, when auto upload firmware
+* INPUT				:
+*
+* OUTPUT	:
+* RETURN	:
+* OTHERS	:
+******************************************************************************/
+static void ath_gpio_set_val(int reg, int gpio, int val)
+{
+	if (val & 0x1) {
+		ath_reg_rmw_set(reg, (1 << gpio));
+	} else {
+		ath_reg_rmw_clear(reg, (1 << gpio));
+	}
+}
+
+void ath_auf_gpio_init()
+{
+	/* use reset button as input indicator */
+	ath_gpio_set_val(GPIO_OE_ADDRESS, FW_BUTTON_GPIO, 1);
+
+	/* use wps led as output indicator */
+	ath_gpio_set_val(GPIO_OE_ADDRESS, FW_LED_GPIO, 0);
+}
+
+/******************************************************************************
+* FUNCTION	: ar7240_is_rst_btn_pressed()
+* AUTHOR	: HouXB <houxubo@tp-link.net>
+* DESCRIPTION		: check whether the reset button was pressed
+* INPUT				:
+*
+* OUTPUT	:
+* RETURN	: 1, pressed; 0, not pressed
+* OTHERS	:
+******************************************************************************/
+int ath_is_rst_btn_pressed()
+{
+	int val;
+	int old_val;
+
+	udelay(10 * 1000); /* delay 1ms for input value stabile. by HouXB, 27Apr11 */
+	old_val = ath_reg_rd(GPIO_IN_ADDRESS);
+	udelay(1000);
+	val = ath_reg_rd(GPIO_IN_ADDRESS);
+
+	/* make sure the btn was pressed. by HouXB, 27Apr11 */
+	if(old_val != val)
+	{
+		return 0;
+	}
+	val = ((val & (1 << FW_BUTTON_GPIO)) >> FW_BUTTON_GPIO);
+	/* when pressed val is 0, return 1 to indicate pressed */
+	return (1 - val);
+}
+
+/******************************************************************************
+* FUNCTION	: ar7240_usb_led_on()
+* AUTHOR	: HouXB <houxubo@tp-link.net>
+* DESCRIPTION		: auto upload firmware output indicator
+* INPUT				:
+*
+* OUTPUT	:
+* RETURN	:
+* OTHERS	:
+******************************************************************************/
+void ath_fw_led_on()
+{
+	ath_gpio_set_val(GPIO_OUT_ADDRESS, FW_LED_GPIO, FW_LED_ON);
+}
+
+void ath_fw_led_off()
+{
+	ath_gpio_set_val(GPIO_OUT_ADDRESS, FW_LED_GPIO, FW_LED_OFF);
+}
+#endif
diff --git a/board/atheros/common/ath_flash.h b/board/atheros/common/ath_flash.h
new file mode 100644
index 0000000000..19cb60f2f6
--- /dev/null
+++ b/board/atheros/common/ath_flash.h
@@ -0,0 +1,53 @@
+#ifndef _ATH_FLASH_H
+#define _ATH_FLASH_H
+
+#define display(_x)
+
+/*
+ * primitives
+ */
+
+#define ath_be_msb(_val, _i) (((_val) & (1 << (7 - _i))) >> (7 - _i))
+
+#define ath_spi_bit_banger(_byte)	do {				\
+	int i;								\
+	for(i = 0; i < 8; i++) {					\
+		ath_reg_wr_nf(ATH_SPI_WRITE,				\
+			ATH_SPI_CE_LOW | ath_be_msb(_byte, i));		\
+		ath_reg_wr_nf(ATH_SPI_WRITE,				\
+			ATH_SPI_CE_HIGH | ath_be_msb(_byte, i));	\
+	}								\
+} while (0)
+
+#define ath_spi_go()	do {				\
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CE_LOW);	\
+	ath_reg_wr_nf(ATH_SPI_WRITE, ATH_SPI_CS_DIS);	\
+} while (0)
+
+
+#define ath_spi_send_addr(__a) do {			\
+	ath_spi_bit_banger(((__a & 0xff0000) >> 16));	\
+	ath_spi_bit_banger(((__a & 0x00ff00) >> 8));	\
+	ath_spi_bit_banger(__a & 0x0000ff);		\
+} while (0)
+
+#define ath_spi_delay_8()	ath_spi_bit_banger(0)
+#define ath_spi_done()		ath_reg_wr_nf(ATH_SPI_FS, 0)
+
+extern unsigned long flash_get_geom (flash_info_t *flash_info);
+
+#ifdef FW_RECOVERY/*  by huangwenzhong, 03May13 */
+
+#define FW_BUTTON_GPIO		(FW_RECOVERY_INPUT_BUTTON_GPIO)
+#define FW_LED_GPIO		(FW_RECOVERY_OUTPUT_LED_GPIO)
+#define FW_LED_ON			(FW_RECOVERY_OUTPUT_LED_ON)
+#define FW_LED_OFF			(!FW_LED_ON)
+
+void	ath_auf_gpio_init(void);
+int	ath_is_rst_btn_pressed(void);
+void	ath_fw_led_on(void);
+void	ath_fw_led_off(void);
+#endif
+
+
+#endif /* _ATH_FLASH_H */
diff --git a/board/atheros/common/ath_nand.c b/board/atheros/common/ath_nand.c
new file mode 100644
index 0000000000..f5ef9526ca
--- /dev/null
+++ b/board/atheros/common/ath_nand.c
@@ -0,0 +1,1593 @@
+/*
+ * linux/drivers/mtd/nand/ath_nand.c
+ * vim: tabstop=8 : noexpandtab
+ * Derived from alauda.c
+ */
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <config.h>
+#include <atheros.h>
+#include <malloc.h>
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#define ENOMEM		12
+#define EINVAL		22
+
+#define writesize		oobblock
+
+#define DRV_NAME	"ath-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Atheros"
+#define DRV_DESC	"Atheros on-chip NAND FLash Controller Driver"
+
+#define ATH_NF_COMMAND		(ATH_NAND_FLASH_BASE + 0x200u)
+#define ATH_NF_CTRL		(ATH_NAND_FLASH_BASE + 0x204u)
+#define ATH_NF_STATUS		(ATH_NAND_FLASH_BASE + 0x208u)
+#define ATH_NF_INT_MASK		(ATH_NAND_FLASH_BASE + 0x20cu)
+#define ATH_NF_INT_STATUS	(ATH_NAND_FLASH_BASE + 0x210u)
+#define ATH_NF_ECC_CTRL		(ATH_NAND_FLASH_BASE + 0x214u)
+#define ATH_NF_ECC_OFFSET	(ATH_NAND_FLASH_BASE + 0x218u)
+#define ATH_NF_ADDR0_0		(ATH_NAND_FLASH_BASE + 0x21cu)
+#define ATH_NF_ADDR1_0		(ATH_NAND_FLASH_BASE + 0x220u)
+#define ATH_NF_ADDR0_1		(ATH_NAND_FLASH_BASE + 0x224u)
+#define ATH_NF_ADDR1_1		(ATH_NAND_FLASH_BASE + 0x228u)
+#define ATH_NF_SPARE_SIZE	(ATH_NAND_FLASH_BASE + 0x230u)
+#define ATH_NF_PROTECT		(ATH_NAND_FLASH_BASE + 0x238u)
+#define ATH_NF_LOOKUP_EN	(ATH_NAND_FLASH_BASE + 0x240u)
+#define ATH_NF_LOOKUP0		(ATH_NAND_FLASH_BASE + 0x244u)
+#define ATH_NF_LOOKUP1		(ATH_NAND_FLASH_BASE + 0x248u)
+#define ATH_NF_LOOKUP2		(ATH_NAND_FLASH_BASE + 0x24cu)
+#define ATH_NF_LOOKUP3		(ATH_NAND_FLASH_BASE + 0x250u)
+#define ATH_NF_LOOKUP4		(ATH_NAND_FLASH_BASE + 0x254u)
+#define ATH_NF_LOOKUP5		(ATH_NAND_FLASH_BASE + 0x258u)
+#define ATH_NF_LOOKUP6		(ATH_NAND_FLASH_BASE + 0x25cu)
+#define ATH_NF_LOOKUP7		(ATH_NAND_FLASH_BASE + 0x260u)
+#define ATH_NF_DMA_ADDR		(ATH_NAND_FLASH_BASE + 0x264u)
+#define ATH_NF_DMA_COUNT	(ATH_NAND_FLASH_BASE + 0x268u)
+#define ATH_NF_DMA_CTRL		(ATH_NAND_FLASH_BASE + 0x26cu)
+#define ATH_NF_MEM_CTRL		(ATH_NAND_FLASH_BASE + 0x280u)
+#define ATH_NF_PG_SIZE		(ATH_NAND_FLASH_BASE + 0x284u)
+#define ATH_NF_RD_STATUS	(ATH_NAND_FLASH_BASE + 0x288u)
+#define ATH_NF_TIME_SEQ		(ATH_NAND_FLASH_BASE + 0x28cu)
+#define ATH_NF_TIMINGS_ASYN	(ATH_NAND_FLASH_BASE + 0x290u)
+#define ATH_NF_TIMINGS_SYN	(ATH_NAND_FLASH_BASE + 0x294u)
+#define ATH_NF_FIFO_DATA	(ATH_NAND_FLASH_BASE + 0x298u)
+#define ATH_NF_TIME_MODE	(ATH_NAND_FLASH_BASE + 0x29cu)
+#define ATH_NF_DMA_ADDR_OFFSET	(ATH_NAND_FLASH_BASE + 0x2a0u)
+#define ATH_NF_FIFO_INIT	(ATH_NAND_FLASH_BASE + 0x2b0u)
+#define ATH_NF_GENERIC_SEQ_CTRL	(ATH_NAND_FLASH_BASE + 0x2b4u)
+
+#define ATH_NF_TIMING_ASYN	0x11
+#define ATH_NF_STATUS_OK	0x40	//0xc0
+#define ATH_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH_NF_COMMAND_CMD_2(x)		(((x) & 0xff) << 24)	// A code of the third command in a sequence.
+#define ATH_NF_COMMAND_CMD_1(x)		(((x) & 0xff) << 16)	// A code of the second command in a sequence.
+#define ATH_NF_COMMAND_CMD_0(x)		(((x) & 0xff) <<  8)	// A code of the first command in a sequence.
+#define ATH_NF_COMMAND_ADDR_SEL		(1 << 7)		// Address register select flag:
+								// 0  the address register 0 selected
+								// 1  the address register 1 selected
+#define ATH_NF_COMMAND_INPUT_SEL_DMA	(1 << 6)		// Input module select flag:
+								// 0  select the SIU module as input
+								// 1  select the DMA module as input
+#define ATH_NF_COMMAND_CMD_SEQ_0	0x00
+#define ATH_NF_COMMAND_CMD_SEQ_1	0x21
+#define ATH_NF_COMMAND_CMD_SEQ_2	0x22
+#define ATH_NF_COMMAND_CMD_SEQ_3	0x03
+#define ATH_NF_COMMAND_CMD_SEQ_4	0x24
+#define ATH_NF_COMMAND_CMD_SEQ_5	0x25
+#define ATH_NF_COMMAND_CMD_SEQ_6	0x26
+#define ATH_NF_COMMAND_CMD_SEQ_7	0x27
+#define ATH_NF_COMMAND_CMD_SEQ_8	0x08
+#define ATH_NF_COMMAND_CMD_SEQ_9	0x29
+#define ATH_NF_COMMAND_CMD_SEQ_10	0x2A
+#define ATH_NF_COMMAND_CMD_SEQ_11	0x2B
+#define ATH_NF_COMMAND_CMD_SEQ_12	0x0C
+#define ATH_NF_COMMAND_CMD_SEQ_13	0x0D
+#define ATH_NF_COMMAND_CMD_SEQ_14	0x0E
+#define ATH_NF_COMMAND_CMD_SEQ_15	0x2F
+#define ATH_NF_COMMAND_CMD_SEQ_16	0x30
+#define ATH_NF_COMMAND_CMD_SEQ_17	0x11
+#define ATH_NF_COMMAND_CMD_SEQ_18	0x32
+#define ATH_NF_COMMAND_CMD_SEQ_19	0x13
+
+
+#define ATH_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000  incrementing precise burst of precisely four transfers
+ * 001  stream burst (address const)
+ * 010  single transfer (address increment)
+ * 011  burst of unspecified length (address increment)
+ * 100  incrementing precise burst of precisely eight transfers
+ * 101  incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH_NF_ECC_CTRL_ECC_2_BITS	ATH_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH_NF_ECC_CTRL_ECC_4_BITS	ATH_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH_NF_ECC_CTRL_ECC_6_BITS	ATH_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH_NF_ECC_CTRL_ECC_8_BITS	ATH_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH_NF_ECC_CTRL_ECC_10_BITS	ATH_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH_NF_ECC_CTRL_ECC_12_BITS	ATH_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH_NF_ECC_CTRL_ECC_14_BITS	ATH_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH_NF_ECC_CTRL_ECC_16_BITS	ATH_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH_NF_ECC_ERROR		(ATH_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH_NF_CMD_END_INT		(1 << 1)
+
+#define ATH_NF_HW_ECC		1
+#define ATH_NF_STATUS_RETRY	1000
+
+#define ath_nand_get_cmd_end_status(void)	\
+	(ath_reg_rd(ATH_NF_INT_STATUS) & ATH_NF_CMD_END_INT)
+
+#define ath_nand_clear_int_status()	ath_reg_wr(ATH_NF_INT_STATUS, 0)
+
+#define ATH_NAND_BLK_DONT_KNOW	0x0
+#define ATH_NAND_BLK_GOOD	0x1
+#define ATH_NAND_BLK_BAD	0x2
+#define ATH_NAND_BLK_ERASED	0x3
+
+#define ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR	(1 << 17)
+#define ATH_NF_GENERIC_SEQ_CTRL_DATA_EN		(1 << 16)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_CODE(x)	(((x) & 0xff) << 8)
+#define ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(x)	(((x) & 3) << 6)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD3_EN		(1 << 5)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD2_EN		(1 << 4)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR1_EN	(1 << 3)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD1_EN		(1 << 2)
+#define ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN	(1 << 1)
+#define ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN		(1 << 0)
+
+#define ATH_NAND_JFFS2_ECC_OFF	0x04	// Give 4 bytes for Factory Bad Block Marker
+#define ATH_NAND_JFFS2_ECC_LEN	0x10	// Space for JFFS2 Clean Marker
+
+/*
+ * Note: The byte positions might not match the spec.
+ * It is to handle the endianness issues.
+ */
+#define ONFI_NUM_ADDR_CYCLES	102	/* see note */
+#define ONFI_DEV_DESC		32
+#define ONFI_DEV_DESC_SZ	32
+#define ONFI_PAGE_SIZE		80
+#define ONFI_SPARE_SIZE		86	/* see note */
+#define ONFI_PAGES_PER_BLOCK	92
+#define ONFI_BLOCKS_PER_LUN	96
+#define ONFI_NUM_LUNS		103	/* see note */
+#define ONFI_RD_PARAM_PAGE_SZ	128
+#define READ_PARAM_STATUS_OK	0x40
+#define READ_PARAM_STATUS_MASK	0x41
+
+#define ATH_NAND_IO_DBG		0
+#define ATH_NAND_OOB_DBG	0
+#define ATH_NAND_IN_DBG		0
+
+#if ATH_NAND_IO_DBG
+#	define iodbg	printk
+#else
+#	define iodbg(...)
+#endif
+
+#if ATH_NAND_OOB_DBG
+#	define oobdbg	printk
+#else
+#	define oobdbg(...)
+#endif
+
+#if ATH_NAND_IN_DBG
+#	define indbg(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#else
+#	define indbg(...)
+#	define indbg1(a, ...)					\
+	do {							\
+		printk("--- %s(%d):" a "\n",			\
+			__func__, __LINE__, ## __VA_ARGS__);	\
+	} while (0)
+#endif
+
+/*
+ * Data structures for ath nand flash controller driver
+ */
+
+typedef union {
+	uint8_t			byte_id[8];
+
+	struct {
+		uint8_t		sa1	: 1,	// Serial access time (bit 1)
+				org	: 1,	// Organisation
+				bs	: 2,	// Block size
+				sa0	: 1,	// Serial access time (bit 0)
+				ss	: 1,	// Spare size per 512 bytes
+				ps	: 2,	// Page Size
+
+				wc	: 1,	// Write Cache
+				ilp	: 1,	// Interleaved Programming
+				nsp	: 2,	// No. of simult prog pages
+				ct	: 2,	// Cell type
+				dp	: 2,	// Die/Package
+
+				did,		// Device id
+				vid,		// Vendor id
+
+				res1	: 2,	// Reserved
+				pls	: 2,	// Plane size
+				pn	: 2,	// Plane number
+				res2	: 2;	// Reserved
+	} __details;
+} ath_nand_id_t;
+
+uint64_t ath_plane_size[] = {
+	64 << 20,
+	 1 << 30,
+	 2 << 30,
+	 4 << 30,
+	 8 << 30
+};
+
+typedef struct {
+	uint8_t		vid,
+			did,
+			b3,
+			addrcyc,
+			small,
+			spare;	// for small block;
+	uint16_t	pgsz;	// for small block
+	uint32_t	blk;	// for small block
+} ath_nand_vend_data_t;
+
+#define is_small_block_device(x)	((x)->entry && (x)->entry->small)
+
+ath_nand_vend_data_t ath_nand_arr[] = {
+	{ 0x20, 0xda, 0x10, 5, },	// NU2g3B2D
+	{ 0x20, 0xf1, 0x00, 4, },	// NU1g3B2C
+	{ 0x20, 0xdc, 0x10, 5, },	// NU4g3B2D
+	{ 0x20, 0xd3, 0x10, 5, },	// NU8g3F2A
+	{ 0x20, 0xd3, 0x14, 5, },	// NU8g3C2B
+	{ 0xad, 0xf1, 0x00, 4, },	// HY1g2b
+	{ 0xad, 0xda, 0x10, 5, },	// HY2g2b
+	{ 0xec, 0xf1, 0x00, 4, },	// Samsung 3,3V 8-bit [128MB]
+	{ 0x98, 0xd1, 0x90, 4, },	// Toshiba
+	{ 0xad, 0x76, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0xad, 0x36, 0xad, 5, 1, 16, 512, 16 << 10 },	// Hynix 64MB NAND Flash
+	{ 0x20, 0x76, 0x20, 5, 1, 16, 512, 16 << 10 },	// ST Micro 64MB NAND Flash
+};
+
+#define NUM_ARRAY_ENTRIES(a)	(sizeof((a)) / sizeof((a)[0]))
+#define NUM_ATH_NAND		NUM_ARRAY_ENTRIES(ath_nand_arr)
+
+/* ath nand info */
+typedef struct {
+	/* mtd info */
+	struct mtd_info		*mtd;
+
+	/* platform info */
+	unsigned short		page_size,
+				data_width;
+
+	/* NAND MTD partition information */
+	int			nr_partitions;
+	struct mtd_partition	*partitions;
+
+	unsigned		*bbt;
+
+	ath_nand_vend_data_t	*entry;
+
+	unsigned		ba0,
+				ba1,
+				cmd;	// Current command
+	ath_nand_id_t		__id;	// for readid
+	uint8_t			onfi[ONFI_RD_PARAM_PAGE_SZ];
+#if ATH_NF_HW_ECC
+	uint32_t		ecc_offset;
+#endif
+	uint32_t		nf_ctrl;
+} ath_nand_sc_t;
+
+ath_nand_sc_t ath_nand_sc;
+static int ath_nand_hw_init(ath_nand_sc_t *, void *);
+
+struct mtd_info nand_info[CFG_MAX_NAND_DEVICE];
+int nand_curr_device = 0;
+
+#define	nid	__id.__details
+#define	bid	__id.byte_id
+
+static int ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs);
+void ath_nand_dump_buf(loff_t addr, void *v, unsigned count);
+
+/* max page size (16k) + oob buf size */
+uint8_t	ath_nand_io_buf[24 << 10] __attribute__((aligned(4096)));
+#define get_ath_nand_io_buf()	ath_nand_io_buf
+
+#define	bbt_index	(sizeof(*sc->bbt) * 8 / 2)
+
+/*
+ * MTD layer assumes the NAND device as a linear array of bytes.
+ * However, the NAND devices are organised into blocks, pages,
+ * spare area etc. Hence, the address provided by Linux has to
+ * converted to format expected by the devices.
+ *
+ * [in] mtd: MTD info pointer
+ * [in] addr: Linear Address as provided by MTD layer
+ * [out] addr0: Value to be set into ADDR0_0 register
+ * [out] addr1: Value to be set into ADDR0_1 register
+ * [in] small_block_erase: Address conversion for small block
+ *	is different. Hence, special case it.
+ */
+inline void
+ath_nand_conv_addr(struct mtd_info *mtd, loff_t addr, uint32_t *addr0,
+			uint32_t *addr1, int small_block_erase)
+{
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc) && small_block_erase) {
+		/*
+		 * The block address loading is accomplished three
+		 * cycles. Erase is a SEQ_14 type command. Hence, the
+		 * controller starts shifting from ADDR_0[16:32] &
+		 * ADDR_1 based on the number of address cycles in our
+		 * case... The device data sheet assumes to have 3
+		 * address cycles for having page address + block
+		 * address for erase. Ideally, SMALL_BLOCK_EN in the
+		 * NF_CTRL register should help but, that doesn't seem
+		 * to work as expected. Hence, the following
+		 * conversion.
+		 */
+
+		// Get the block no.
+		uint32_t b = (addr >> mtd->erasesize_shift);
+
+		*addr0 = (b & 0xfff) << 21;
+		*addr1 = (b >> 11) & 0x1;
+	} else if (is_small_block_device(sc)) {
+		/* +-----+----+----+----+----+----+----+----+----+
+		 * |cycle|I/O7|I/O6|I/O5|I/O4|I/O3|I/O2|I/O1|I/O0|
+		 * +-----+----+----+----+----+----+----+----+----+
+		 * | 1st | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 |
+		 * | 2nd |A16 |A15 |A14 |A13 |A12 |A11 |A10 | A9 |
+		 * | 3rd |A24 |A23 |A22 |A21 |A20 |A19 |A18 |A17 |
+		 * | 4th | x  | x  | x  | x  | x  | x  | x  |A25 |
+		 * +-----+----+----+----+----+----+----+----+----+
+		 */
+		addr &= ~(mtd->writesize_mask);
+		*addr0 = ((addr & 0xff) |
+			  ((addr >> 1) & (~0xffu))) & ((1 << 25) - 1);
+		*addr1 = 0;
+	} else {
+		/* +-----+---+---+---+---+---+---+---+---+
+		 * |Cycle|IO0|IO1|IO2|IO3|IO4|IO5|IO6|IO7|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 * | 1st | A0| A1| A2| A3| A4| A5| A6| A7|
+		 * | 2nd | A8| A9|A10|A11| x | x | x | x |
+		 * | 3rd |A12|A13|A14|A15|A16|A17|A18|A19|
+		 * | 4th |A20|A21|A22|A23|A24|A25|A26|A27|
+		 * +-----+---+---+---+---+---+---+---+---+
+		 */
+		*addr0 = ((addr >> mtd->writesize_shift) << 16);
+		*addr1 = ((addr >> (mtd->writesize_shift + 16)) & 0xf);
+	}
+}
+
+inline unsigned
+ath_nand_get_blk_state(struct mtd_info *mtd, loff_t b)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return ATH_NAND_BLK_DONT_KNOW;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	return (sc->bbt[x] >> (y * 2)) & 0x3;
+}
+
+inline void
+ath_nand_set_blk_state(struct mtd_info *mtd, loff_t b, unsigned state)
+{
+	unsigned		x, y;
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (!sc->bbt)	return;
+
+	b = b >> mtd->erasesize_shift;
+
+	x = b / bbt_index;
+	y = b % bbt_index;
+
+	sc->bbt[x] = (sc->bbt[x] & ~(3 << (y * 2))) | (state << (y * 2));
+}
+
+static unsigned
+ath_nand_status(ath_nand_sc_t *sc, unsigned *ecc)
+{
+	unsigned	rddata, i, j, dmastatus;
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(5);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	for (j = 0; j < ATH_NF_STATUS_RETRY && !(dmastatus & 1); j++) {
+		udelay(5);
+		dmastatus = ath_reg_rd(ATH_NF_DMA_CTRL);
+	}
+
+	if ((i == ATH_NF_STATUS_RETRY) || (j == ATH_NF_STATUS_RETRY)) {
+		//printk("ath_nand_status: i = %u j = %u\n", i, j);
+		ath_nand_hw_init(sc, NULL);
+		return -1;
+	}
+	if (ecc) {
+		*ecc = ath_reg_rd(ATH_NF_ECC_CTRL);
+	}
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL, 0);
+	ath_reg_wr(ATH_NF_COMMAND, 0x07024);	// READ STATUS
+	while (ath_nand_get_cmd_end_status() == 0);
+	rddata = ath_reg_rd(ATH_NF_RD_STATUS);
+
+	return rddata;
+}
+
+static unsigned
+ath_check_all_0xff(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1, unsigned *all_0xff)
+{
+	uint8_t		*pa, *buf = ath_nand_io_buf, *end;
+	struct mtd_info	*mtd = sc->mtd;
+	unsigned	i, count = mtd->writesize + mtd->oobsize;
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+	ath_reg_wr(ATH_NF_DMA_CTRL, ATH_NF_DMA_CTRL_DMA_START |
+				ATH_NF_DMA_CTRL_DMA_DIR_READ |
+				ATH_NF_DMA_CTRL_DMA_BURST_3);
+	ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+	ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+	ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+	ath_reg_wr(ATH_NF_PG_SIZE, count);
+	pa = (void *)virt_to_phys(buf);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+	ath_reg_wr(ATH_NF_COMMAND, 0x30006a);	// Read page
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	i = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+	memcpy(buf, pa, count);	// cache sync equivalent
+	if (i != ATH_NF_STATUS_OK) {
+		return 0;
+	}
+	end = buf + count;
+	for (buf += sc->ecc_offset; (*buf == 0xff) && buf != end; buf ++);
+
+	*all_0xff = 1;
+
+	if (buf == end) {
+		/* This page was read without ECC. From the spare area
+		 * content we see that it a blank page (i.e. full 0xff).
+		 * To take care of bit flips if any, force 0xff on it.
+		 */
+		memset(ath_nand_io_buf, 0xff, mtd->writesize);
+	} else {
+		ath_nand_dump_buf(addr0, ath_nand_io_buf, mtd->writesize + mtd->oobsize);
+	}
+	return (buf == end);
+}
+
+static unsigned
+ath_nand_rw_page(ath_nand_sc_t *sc, int rd, unsigned addr0, unsigned addr1, unsigned count, unsigned char *buf, unsigned ecc_needed)
+{
+	unsigned	ecc, i = 0, tmp, rddata, all_0xff = 0;
+#if ATH_NF_HW_ECC
+	unsigned	mlc_retry = 0;
+#endif
+	char		*err[] = { "Write", "Read" };
+#define ATH_MAX_RETRY	25
+#define ATH_MLC_RETRY	3
+retry:
+	ecc = 0;
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)buf);
+	ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+#if ATH_NF_HW_ECC
+	if (ecc_needed && sc->ecc_offset && (count & sc->mtd->writesize_mask) == 0) {
+		/*
+		 * ECC can operate only on the device's pages.
+		 * Cannot be used for non-page-sized read/write
+		 */
+		ath_reg_wr(ATH_NF_ECC_OFFSET, sc->ecc_offset);
+		ath_reg_wr(ATH_NF_ECC_CTRL, ATH_NF_ECC_CTRL_ERR_THRESH(4) |
+						ATH_NF_ECC_CTRL_ECC_4_BITS);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_ECC_EN);
+		ath_reg_wr(ATH_NF_SPARE_SIZE, sc->mtd->oobsize);
+	} else
+#endif
+	{
+		ath_reg_wr(ATH_NF_ECC_OFFSET, 0);
+		ath_reg_wr(ATH_NF_ECC_CTRL, 0);
+		ath_reg_wr(ATH_NF_CTRL, sc->nf_ctrl | ATH_NF_CTRL_CUSTOM_SIZE_EN);
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+	}
+
+	if (rd) {	// Read Page
+		if (is_small_block_device(sc)) {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_GENERIC_SEQ_CTRL,
+						ATH_NF_GENERIC_SEQ_CTRL_COL_ADDR |
+						ATH_NF_GENERIC_SEQ_CTRL_DATA_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_DEL_EN(1) |
+						ATH_NF_GENERIC_SEQ_CTRL_ADDR0_EN |
+						ATH_NF_GENERIC_SEQ_CTRL_CMD0_EN);
+			ath_reg_wr(ATH_NF_COMMAND,
+						ATH_NF_COMMAND_CMD_SEQ_18 |
+						ATH_NF_COMMAND_INPUT_SEL_DMA |
+						ATH_NF_COMMAND_CMD_0(0));
+		} else {
+			ath_reg_wr(ATH_NF_DMA_CTRL,
+						ATH_NF_DMA_CTRL_DMA_START |
+						ATH_NF_DMA_CTRL_DMA_DIR_READ |
+						ATH_NF_DMA_CTRL_DMA_BURST_3);
+			ath_reg_wr(ATH_NF_COMMAND, 0x30006a);
+		}
+	} else {	// Write Page
+		ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+		ath_reg_wr(ATH_NF_DMA_CTRL,
+					ATH_NF_DMA_CTRL_DMA_START |
+					ATH_NF_DMA_CTRL_DMA_DIR_WRITE |
+					ATH_NF_DMA_CTRL_DMA_BURST_3);
+		ath_reg_wr(ATH_NF_COMMAND, 0x10804c);
+	}
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	//printk(KERN_DEBUG "%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', addr0, addr1, count, buf);
+
+	rddata = (tmp = ath_nand_status(sc, &ecc)) & ATH_NF_RD_STATUS_MASK;
+	if ((rddata != ATH_NF_STATUS_OK) && (i < ATH_MAX_RETRY)) {
+		i++;
+		goto retry;
+	}
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+	ath_reg_wr(ATH_NF_FIFO_INIT, 1);
+	ath_reg_wr(ATH_NF_FIFO_INIT, 0);
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("%s: %s Failed. tmp = 0x%x, status = 0x%x 0x%x retries = %d\n", __func__,
+			err[rd], tmp, rddata, ath_reg_rd(ATH_NF_DMA_CTRL), i);
+	}
+#if ATH_NF_HW_ECC
+	else {
+#define DDR_WB_FLUSH_USB_ADDRESS		0x180000a4
+
+		ath_reg_wr(DDR_WB_FLUSH_USB_ADDRESS, 1);
+		while (ath_reg_rd(DDR_WB_FLUSH_USB_ADDRESS) & 1);
+		udelay(2);
+
+		if (ecc_needed && (ecc & ATH_NF_ECC_ERROR)) {
+			if (rd && all_0xff == 0) {
+				if (ath_check_all_0xff(sc, addr0, addr1, &all_0xff)) {
+					return ATH_NF_STATUS_OK;
+				}
+			}
+
+			if (mlc_retry < ATH_MLC_RETRY) {
+				mlc_retry ++;
+				i = 0;
+				goto retry;
+			} else {
+				printk("%s: %s uncorrectable errors. ecc = 0x%x\n",
+					__func__, err[rd], ecc);
+				return -1;
+			}
+		}
+	}
+#endif
+	return rddata;
+}
+
+void
+ath_nand_dump_buf(loff_t addr, void *v, unsigned count)
+{
+	unsigned	*buf = v,
+			*end = buf + (count / sizeof(*buf));
+
+	iodbg("____ Dumping %d bytes at 0x%p 0x%lx_____\n", count, buf, (ulong)addr);
+
+	for (; buf && buf < end; buf += 4, addr += 16) {
+		printk("%08lx: %08x %08x %08x %08x\n",
+			(unsigned)addr, buf[0], buf[1], buf[2], buf[3]);
+	}
+	iodbg("___________________________________\n");
+	//while(1);
+}
+
+static int
+ath_nand_rw_buff(struct mtd_info *mtd, int rd, uint8_t *buf,
+		loff_t addr, size_t len, size_t *iodone)
+{
+	unsigned	iolen, ret = ATH_NF_STATUS_OK, ecc_needed;
+	unsigned char	*pa;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	*iodone = 0;
+
+	while (len) {
+		uint32_t c, ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, addr)) {
+			printk("Skipping bad block[0x%x]\n", (unsigned)addr);
+			addr += mtd->erasesize;
+			continue;
+		}
+
+		c = (addr & mtd->writesize_mask);
+
+		ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+		if (c) {
+			iolen = mtd->writesize - c;
+		} else {
+			iolen = mtd->writesize;
+		}
+
+		if (len < iolen) {
+			iolen = len;
+		}
+
+		if (rd) {
+			ecc_needed = (ath_nand_get_blk_state(mtd, addr) != ATH_NAND_BLK_ERASED);
+		} else {
+			int i;
+
+			for (i = 0; (i < mtd->writesize) && (buf[i] == 0xff); i++);
+			if (i == mtd->writesize) {
+				ret = ATH_NF_STATUS_OK;
+				//printk("Skipping write for 0x%x\n", (ulong)addr);
+				goto skip_write_for_all_0xff;
+			}
+
+			/* FIXME for writes FIXME */
+			memcpy(ath_nand_io_buf, buf, iolen);
+			ecc_needed = 1;
+		}
+
+		pa = (void *)virt_to_phys(ath_nand_io_buf);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+		//	rd ? 'r' : 'w', ba0, ba1, iolen, pa);
+
+		ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize, pa, ecc_needed);
+
+		flush_cache((unsigned)ath_nand_io_buf, mtd->writesize);
+
+		if (rd) {
+			memcpy(buf, ath_nand_io_buf + c, iolen);
+		}
+skip_write_for_all_0xff:
+		//ath_nand_dump_buf(addr, buf, iolen);
+
+		if (ret != ATH_NF_STATUS_OK) {
+			return 1;
+		}
+
+		len -= iolen;
+		buf += iolen;
+		addr += iolen;
+		*iodone += iolen;
+	}
+
+	return 0;
+}
+
+#define ath_nand_write_verify	0
+
+#if ath_nand_write_verify
+uint8_t	ath_nand_rd_buf[4096 + 256] __attribute__((aligned(4096)));
+#endif
+
+static int
+ath_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int	ret;
+#if ath_nand_write_verify
+	int	r, rl;
+#endif
+
+	if (!len || !retlen) return (0);
+
+	indbg("0x%llx	%u", to, len);
+
+	ret = ath_nand_rw_buff(mtd, 0 /* write */, (u_char *)buf, to, len, retlen);
+#if ath_nand_write_verify
+	//printk("Verifying 0x%llx 0x%x\n", to, len);
+	r = ath_nand_rw_buff(mtd, 1 /* read */, ath_nand_rd_buf, to, len, &rl);
+	if (r || memcmp(ath_nand_rd_buf, buf, len)) {
+		printk("write failed at 0x%llx 0x%x\n", to, len);
+		while (1);
+	}
+#endif
+	return ret;
+}
+
+static int
+ath_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int	ret;
+
+	if (!len || !retlen) return (0);
+
+	ret = ath_nand_rw_buff(mtd, 1 /* read */, buf, from, len, retlen);
+
+	return ret;
+}
+
+static inline int
+ath_nand_block_erase(ath_nand_sc_t *sc, unsigned addr0, unsigned addr1)
+{
+	unsigned	rddata;
+
+	indbg("0x%x 0x%x", addr1, addr0);
+
+	ath_nand_clear_int_status();
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);	// Remove write protect
+	ath_reg_wr(ATH_NF_ADDR0_0, addr0);
+	ath_reg_wr(ATH_NF_ADDR0_1, addr1);
+	ath_reg_wr(ATH_NF_COMMAND, 0xd0600e);	// BLOCK ERASE
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	rddata = ath_nand_status(sc, NULL) & ATH_NF_RD_STATUS_MASK;
+
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0x0000);	// Enable write protect
+
+	if (rddata != ATH_NF_STATUS_OK) {
+		printk("Erase Failed. status = 0x%x\n", rddata);
+		return 1;
+	}
+	return 0;
+}
+
+
+static int
+ath_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	ulong		s_first, i;
+	unsigned	n, j;
+	int		ret, bad = 0;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	if (instr->addr + instr->len > mtd->size) {
+		return (-EINVAL);
+	}
+
+	s_first = instr->addr;
+	n = instr->len >> mtd->erasesize_shift;
+
+	if (instr->len & mtd->erasesize_mask) n ++;
+
+	indbg("0x%llx 0x%x 0x%x", instr->addr, n, mtd->erasesize);
+
+	printk("%s: 0x%x %u\n", __func__, s_first, n);
+
+	for (j = 0, i = s_first; j < n; j++, i += mtd->erasesize) {
+		uint32_t ba0, ba1;
+
+		if (ath_nand_block_isbad(mtd, i)) {
+			bad ++;
+			continue;
+		}
+
+		ath_nand_conv_addr(mtd, i, &ba0, &ba1, 1);
+
+		printk("\b\b\b\b%4d", j);
+
+		if ((ret = ath_nand_block_erase(sc, ba0, ba1)) != 0) {
+			printf("%s: erase failed 0x%x 0x%x 0x%x %x "
+				"%lx %lx\n", __func__, instr->addr, n,
+				mtd->erasesize, i, ba1, ba0);
+			break;
+		}
+		ath_nand_set_blk_state(mtd, i, ATH_NAND_BLK_ERASED);
+	}
+
+	if (instr->callback) {
+		if (j < n) {
+			instr->state = MTD_ERASE_FAILED;
+		} else {
+			instr->state = MTD_ERASE_DONE;
+		}
+		mtd_erase_callback(instr);
+	}
+
+	printk("Skipped %d bad blocks\n", bad);
+
+	return ret;
+}
+
+/* lifted from linux */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+struct mtd_oob_ops {
+	mtd_oob_mode_t  mode;
+	size_t          len;
+	size_t          retlen;
+	size_t          ooblen;
+	size_t          oobretlen;
+	uint32_t        ooboffs;
+	uint8_t         *datbuf;
+	uint8_t         *oobbuf;
+};
+
+static int
+ath_nand_rw_oob(struct mtd_info *mtd, int rd, loff_t addr,
+		struct mtd_oob_ops *ops)
+{
+	unsigned	ret = ATH_NF_STATUS_OK;
+	unsigned char	*pa;
+	uint32_t	ba0, ba1;
+	uint8_t		*oob = ath_nand_io_buf + mtd->writesize;
+	ath_nand_sc_t	*sc = mtd->priv;
+
+	ath_nand_conv_addr(mtd, addr, &ba0, &ba1, 0);
+
+	if (!rd) {
+		if (ops->datbuf) {
+			/*
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 * We assume that the caller gives us a full
+			 * page to write. We don't read the page and
+			 * update the changed portions alone.
+			 *
+			 * Hence, not checking for len < or > pgsz etc...
+			 * XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
+			 */
+			memcpy(ath_nand_io_buf, ops->datbuf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// clean markers
+			oob[0] = oob[1] = 0xff;
+			oob += 2;
+		}
+		memcpy(oob, ops->oobbuf, ops->ooblen);
+	}
+
+	pa = (void *)virt_to_phys(ath_nand_io_buf);
+	if (!rd) flush_cache(ath_nand_io_buf, mtd->writesize + mtd->oobsize);	// for writes...
+
+	//printk("%s(%c): 0x%x 0x%x 0x%x 0x%p\n", __func__,
+	//	rd ? 'r' : 'w', ba0, ba1, mtd->writesize + mtd->oobsize, pa);
+
+	ret = ath_nand_rw_page(sc, rd, ba0, ba1, mtd->writesize + mtd->oobsize, pa, 0);
+
+	if (ret != ATH_NF_STATUS_OK) {
+		return 1;
+	}
+
+	if (rd) {
+		memcpy(ath_nand_io_buf, KSEG1ADDR(pa), mtd->writesize + mtd->oobsize);	// for reads...
+
+		if (ops->datbuf) {
+			memcpy(ops->datbuf, ath_nand_io_buf, ops->len);
+		}
+		if (ops->mode == MTD_OOB_PLACE) {
+			oob += ops->ooboffs;
+		} else if (ops->mode == MTD_OOB_AUTO) {
+			// copy after clean marker
+			oob += 2;
+		}
+		memcpy(ops->oobbuf, oob, ops->ooblen);
+	}
+
+	//if (rd) {
+	//	ath_nand_dump_buf(addr, ops->datbuf, ops->len);
+	//	ath_nand_dump_buf(addr, ops->oobbuf, ops->ooblen);
+	//}
+
+	if (ops->datbuf) {
+		ops->retlen = ops->len;
+	}
+	ops->oobretlen = ops->ooblen;
+
+	return 0;
+}
+
+//static int
+//ath_nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct mtd_oob_ops ops = { MTD_OOB_RAW, len, 0, ooblen, 0,
+					0, buf, buf + mtd->writesize };
+
+	oobdbg(	"%s: from: 0x%lx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, (uint32_t)from,
+		ops.mode, ops.len, ops.retlen, ops.ooblen,
+		ops.oobretlen, ops.ooboffs, ops.datbuf,
+		ops.oobbuf);
+
+	oobdbg("0x%lx %p %p %u\n", (uint32_t)from, ops.oobbuf, ops.datbuf, ops.len);
+
+	if (len == 0) {
+		ops.datbuf = 0;
+		ops.oobbuf = buf;
+	}
+	if (ooblen == 0) {
+		ops.oobbuf = NULL;
+	}
+
+	return ath_nand_rw_oob(mtd, 1 /* read */, from, &ops);
+}
+
+#if 0
+static int
+ath_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret;
+	unsigned char oob[128];
+	struct mtd_oob_ops	rops = {
+		.mode	= MTD_OOB_RAW,
+		.ooblen	= mtd->oobsize,
+		.oobbuf	= oob,
+	};
+
+	if (ops->mode == MTD_OOB_AUTO) {
+		/* read existing oob */
+		if (ath_nand_read_oob(mtd, to, &rops) ||
+			rops.oobretlen != rops.ooblen) {
+			printk("%s: oob read failed at 0x%llx\n", __func__, to);
+			return 1;
+		}
+		memcpy(oob + 2, ops->oobbuf, ops->ooblen);
+		rops = *ops;
+		ops->oobbuf = oob;
+		ops->ooblen = mtd->oobsize;
+		ops->mode = MTD_OOB_RAW;
+	}
+
+	oobdbg(	"%s: from: 0x%llx mode: 0x%x len: 0x%x retlen: 0x%x\n"
+		"ooblen: 0x%x oobretlen: 0x%x ooboffs: 0x%x datbuf: %p "
+		"oobbuf: %p\n", __func__, to,
+		ops->mode, ops->len, ops->retlen, ops->ooblen,
+		ops->oobretlen, ops->ooboffs, ops->datbuf,
+		ops->oobbuf);
+
+	indbg("0x%llx", to);
+
+	ret = ath_nand_rw_oob(mtd, 0 /* write */, to, ops);
+
+	if (rops.mode == MTD_OOB_AUTO) {
+		if (ret == 0) { // rw oob success
+			rops.oobretlen = rops.ooblen;
+			rops.retlen = rops.len;
+		}
+		*ops = rops;
+	}
+
+	return ret;
+}
+#endif
+
+static int
+ath_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	unsigned char		oob[256];
+	unsigned		bs, i;
+	unsigned		*force = (unsigned *)0xbd000000;
+
+	if (*force == 0x12345678) {
+		return 0;
+	}
+
+	bs = ath_nand_get_blk_state(mtd, ofs);
+
+	if ((bs == ATH_NAND_BLK_ERASED) || (bs == ATH_NAND_BLK_GOOD)) {
+		return 0;
+	}
+
+	if (bs == ATH_NAND_BLK_BAD) {
+		return 1;
+	}
+
+	/*
+	 * H27U1G8F2B Series [1 Gbit (128 M x 8 bit) NAND Flash]
+	 *
+	 * The Bad Block Information is written prior to shipping. Any
+	 * block where the 1st Byte in the spare area of the 1st or
+	 * 2nd th page (if the 1st page is Bad) does not contain FFh
+	 * is a Bad Block. The Bad Block Information must be read
+	 * before any erase is attempted as the Bad Block Information
+	 * may be erased. For the system to be able to recognize the
+	 * Bad Blocks based on the original information it is
+	 * recommended to create a Bad Block table following the
+	 * flowchart shown in Figure 24. The 1st block, which is
+	 *                               ^^^^^^^^^^^^^
+	 * placed on 00h block address is guaranteed to be a valid
+	 * block.                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
+	 */
+
+	for (i = 0; i < 2; i++, ofs += mtd->writesize) {
+		if (nand_read_raw(mtd, oob, ofs, 0, mtd->oobsize)) {
+			printk("%s: oob read failed at 0x%lx\n", __func__, (unsigned)ofs);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_DONT_KNOW);
+			return 1;
+		}
+
+		/* First two bytes of oob data are clean markers */
+		if (oob[0] != 0xff || oob[1] != 0xff) {
+			oobdbg("%s: block is bad at 0x%lx\n", __func__, (unsigned)ofs);
+			oobdbg(	"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x "
+				"%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				0xff & oob[ 0], 0xff & oob[ 1], 0xff & oob[ 2],
+				0xff & oob[ 3], 0xff & oob[ 4], 0xff & oob[ 5],
+				0xff & oob[ 6], 0xff & oob[ 7], 0xff & oob[ 8],
+				0xff & oob[ 9], 0xff & oob[10], 0xff & oob[11],
+				0xff & oob[12], 0xff & oob[13], 0xff & oob[14],
+				0xff & oob[15], 0xff & oob[16], 0xff & oob[17],
+				0xff & oob[18], 0xff & oob[19], 0xff & oob[20],
+				0xff & oob[21], 0xff & oob[22], 0xff & oob[23],
+				0xff & oob[24], 0xff & oob[25], 0xff & oob[26],
+				0xff & oob[27], 0xff & oob[28], 0xff & oob[29],
+				0xff & oob[30], 0xff & oob[31], 0xff & oob[32],
+				0xff & oob[33], 0xff & oob[34], 0xff & oob[35],
+				0xff & oob[36], 0xff & oob[37], 0xff & oob[38],
+				0xff & oob[39], 0xff & oob[40], 0xff & oob[41],
+				0xff & oob[42], 0xff & oob[43], 0xff & oob[44],
+				0xff & oob[45], 0xff & oob[46], 0xff & oob[47],
+				0xff & oob[48], 0xff & oob[49], 0xff & oob[50],
+				0xff & oob[51], 0xff & oob[52], 0xff & oob[53],
+				0xff & oob[54], 0xff & oob[55], 0xff & oob[56],
+				0xff & oob[57], 0xff & oob[58], 0xff & oob[59],
+				0xff & oob[60], 0xff & oob[61], 0xff & oob[62],
+				0xff & oob[63]);
+			ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_BAD);
+			return 1;
+		}
+	}
+
+	for (i = 0; (i < mtd->oobsize) && (oob[i] == 0xff); i++);
+
+	if (i == mtd->oobsize) {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_ERASED);
+	} else {
+		ath_nand_set_blk_state(mtd, ofs, ATH_NAND_BLK_GOOD);
+	}
+
+	return 0;
+}
+
+static int
+ath_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	indbg("unimplemented 0x%llx", ofs);
+	return 0;
+}
+
+static unsigned long
+ath_parse_read_id(ath_nand_sc_t *sc)
+{
+	int	i;
+
+	extern struct nand_manufacturers nand_manuf_ids[];
+	extern struct nand_flash_dev nand_flash_ids[];
+
+	iodbg(	"____ %s _____\n"
+		"  vid did wc  ilp nsp ct  dp  sa1 org bs  sa0 ss  "
+		"ps  res1 pls pn  res2\n"
+		"0x%3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x %3x "
+		"%3x %3x  %3x %3x %3x\n-------------\n", __func__,
+			sc->nid.vid, sc->nid.did, sc->nid.wc, sc->nid.ilp,
+			sc->nid.nsp, sc->nid.ct, sc->nid.dp, sc->nid.sa1,
+			sc->nid.org, sc->nid.bs, sc->nid.sa0, sc->nid.ss,
+			sc->nid.ps, sc->nid.res1, sc->nid.pls, sc->nid.pn,
+			sc->nid.res2);
+
+	for (i = 0; i < nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == sc->nid.vid) {
+			printk(nand_manuf_ids[i].name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nand_flash_ids[i].id; i++) {
+		if (nand_flash_ids[i].id == sc->nid.did) {
+			printk(" %s [%uMB]\n", nand_flash_ids[i].name,
+				nand_flash_ids[i].chipsize);
+			return nand_flash_ids[i].chipsize;
+		}
+	}
+
+	return 0;
+}
+
+ath_nand_vend_data_t *
+nand_get_entry(ath_nand_id_t *nand_id, ath_nand_vend_data_t *tbl, int count)
+{
+	int     i;
+
+	for (i = 0; i < count; i++, tbl ++) {
+		if ((nand_id->__details.vid == tbl->vid) &&
+		    (nand_id->__details.did == tbl->did) &&
+		    (nand_id->byte_id[1] == tbl->b3)) {
+			return tbl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline void
+ath_nand_onfi_endian_convert(uint8_t *buf)
+{
+	uint32_t	i, *u = (uint32_t *)(buf + ONFI_DEV_DESC);
+
+	for (i = 0; i < (ONFI_DEV_DESC_SZ / sizeof(*u)); i++) {
+		u[i] = __le32_to_cpu(u[i]);
+	}
+
+	// Hope nobody has a 20 character device description
+	buf[ONFI_DEV_DESC + ONFI_DEV_DESC_SZ - 1] = 0;
+}
+
+int
+nand_param_page(ath_nand_sc_t *sc, uint8_t *buf, unsigned count)
+{
+	unsigned int	tries, rddata;
+	uint8_t		*pa;
+
+	pa = virt_to_phys(buf);
+
+	for (tries = 3; tries; tries --) {
+		// ADDR0_0 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+
+		// ADDR0_1 Reg Settings
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+
+		// DMA Start Addr
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+
+		// DMA count
+		ath_reg_wr(ATH_NF_DMA_COUNT, count);
+
+		// Custom Page Size
+		ath_reg_wr(ATH_NF_PG_SIZE, count);
+
+		// DMA Control Reg
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+
+		ath_nand_clear_int_status();
+		// READ PARAMETER PAGE
+		ath_reg_wr(ATH_NF_COMMAND, 0xec62);
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL) & READ_PARAM_STATUS_MASK;
+		if (rddata == READ_PARAM_STATUS_OK) {
+			break;
+		} else {
+			printk("\nParam Page Failure: 0x%x", rddata);
+			ath_nand_hw_init(sc, NULL);
+		}
+	}
+
+	memcpy(buf, KSEG1ADDR(buf), count);	// get into the cache
+
+	//ath_nand_dump_buf(buf, buf, count);
+
+	if ((rddata == READ_PARAM_STATUS_OK) &&
+	    (buf[3] == 'O' && buf[2] == 'N' && buf[1] == 'F' && buf[0] == 'I')) {
+		ath_nand_onfi_endian_convert(buf);
+		printf("ONFI %s\n", buf + ONFI_DEV_DESC);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * System initialization functions
+ */
+static int
+ath_nand_hw_init(ath_nand_sc_t *sc, void *p)
+{
+	uint8_t		id[8];
+	unsigned char	*pa;
+	unsigned	rddata, i;
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(250);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_NANDF_RESET_MASK);
+	udelay(100);
+
+	ath_reg_wr(ATH_NF_INT_MASK, ATH_NF_CMD_END_INT);
+	ath_nand_clear_int_status();
+
+	// TIMINGS_ASYN Reg Settings
+	ath_reg_wr(ATH_NF_TIMINGS_ASYN, ATH_NF_TIMING_ASYN);
+
+	// NAND Mem Control Reg
+	ath_reg_wr(ATH_NF_MEM_CTRL, 0xff00);
+
+	// Reset Command
+	ath_reg_wr(ATH_NF_COMMAND, 0xff00);
+
+	while (ath_nand_get_cmd_end_status() == 0);
+
+	udelay(1000);
+
+	rddata = ath_reg_rd(ATH_NF_STATUS);
+	for (i = 0; i < ATH_NF_STATUS_RETRY && rddata != 0xff; i++) {
+		udelay(25);
+		rddata = ath_reg_rd(ATH_NF_STATUS);
+	}
+
+	if (i == ATH_NF_STATUS_RETRY) {
+		printf("device reset failed\n");
+		while(1);
+	}
+
+	if (p) {
+		ath_nand_vend_data_t *entry;
+
+		ath_nand_clear_int_status();
+		pa = (void *)virt_to_phys(p ? p : id);
+		ath_reg_wr(ATH_NF_DMA_ADDR, (unsigned)pa);
+		ath_reg_wr(ATH_NF_ADDR0_0, 0x0);
+		ath_reg_wr(ATH_NF_ADDR0_1, 0x0);
+		ath_reg_wr(ATH_NF_DMA_COUNT, 0x8);
+		ath_reg_wr(ATH_NF_PG_SIZE, 0x8);
+		ath_reg_wr(ATH_NF_DMA_CTRL, 0xcc);
+		ath_reg_wr(ATH_NF_COMMAND, 0x9061);	// READ ID
+		while (ath_nand_get_cmd_end_status() == 0);
+
+		rddata = ath_nand_status(sc, NULL);
+		if ((rddata & ATH_NF_RD_STATUS_MASK) != ATH_NF_STATUS_OK) {
+			printf("%s: ath nand status = 0x%x\n", __func__, rddata);
+		}
+
+		pa = p;
+		printk("Ath Nand ID[%p]: %02x:%02x:%02x:%02x:%02x\n",
+				pa, pa[3], pa[2], pa[1], pa[0], pa[7]);
+
+		sc->onfi[0] = 0;
+
+		entry = nand_get_entry((ath_nand_id_t *)p, ath_nand_arr, NUM_ATH_NAND);
+		if (entry) {
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(entry->addrcyc);
+		} else if (nand_param_page(sc, sc->onfi, sizeof(sc->onfi)) == 0) {
+			rddata = sc->onfi[ONFI_NUM_ADDR_CYCLES];
+			rddata = ((rddata >> 4) & 0xf) + (rddata & 0xf);
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(rddata);
+		} else {
+			printk("Attempting to use unknown device\n");
+			sc->nf_ctrl = ATH_NF_CTRL_ADDR_CYCLE0(5);
+		}
+
+		iodbg("******* %s done ******\n", __func__);
+	}
+
+	return 0;
+}
+
+/*
+ * Copied from drivers/mtd/nand/nand_base.c
+ * http://ptgmedia.pearsoncmg.com/images/chap17_9780132396554/elementLinks/17fig04.gif
+ *
+ * +---...---+--+----------+---------+
+ * |  2048   |  |          |         |
+ * | File    |cm| FS spare | ecc data|
+ * | data    |  |          |         |
+ * +---...---+--+----------+---------+
+ * cm -> clean marker (2 bytes)
+ * FS Spare -> bytes available for jffs2
+ */
+
+static void
+ath_nand_ecc_init(struct mtd_info *mtd)
+{
+#if ATH_NF_HW_ECC
+	ath_nand_sc_t		*sc = mtd->priv;
+
+	if (is_small_block_device(sc)) {
+		// ECC cannot be supported...
+		sc->ecc_offset = 0;
+	} else {
+		sc->ecc_offset = mtd->writesize + ATH_NAND_JFFS2_ECC_OFF +
+						ATH_NAND_JFFS2_ECC_LEN;
+	}
+#else
+	sc->ecc_offset = 0;
+#endif
+}
+
+void
+ath_nand_set_ns(struct mtd_info *mtd)
+{
+#define ATH_DEF_PAGE_SIZE	(2u << 10)
+#define ATH_DEF_BLK_SIZE	(128u << 10)
+#define ATH_NAND_SPEC		"ns"
+
+	char ns[64], *p;
+
+	if ((p = getenv(ATH_NAND_SPEC))) {
+		/* don't override user setting */
+		return;
+	}
+
+	if (mtd->writesize == ATH_DEF_PAGE_SIZE &&
+	    mtd->erasesize == ATH_DEF_BLK_SIZE) {
+		return;
+	}
+
+	sprintf(ns, "-0x%x-0x%x", mtd->erasesize, mtd->writesize);
+	setenv(ATH_NAND_SPEC, ns);
+	printf("set " ATH_NAND_SPEC " %s\n", ns);
+}
+
+/*
+ * ath_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static ulong ath_nand_probe(void)
+{
+	ath_nand_sc_t	*sc = NULL;
+	struct mtd_info	*mtd = NULL;
+	int		i, err = 0, bbt_size;
+	unsigned	nf_ctrl_pg[][2] = {
+		/* page size in bytes, register val */
+		{   256, ATH_NF_CTRL_PAGE_SIZE_256	},
+		{   512, ATH_NF_CTRL_PAGE_SIZE_512	},
+		{  1024, ATH_NF_CTRL_PAGE_SIZE_1024	},
+		{  2048, ATH_NF_CTRL_PAGE_SIZE_2048	},
+		{  4096, ATH_NF_CTRL_PAGE_SIZE_4096	},
+		{  8192, ATH_NF_CTRL_PAGE_SIZE_8192	},
+		{ 16384, ATH_NF_CTRL_PAGE_SIZE_16384	},
+		{     0, ATH_NF_CTRL_PAGE_SIZE_0	},
+		};
+	unsigned	nf_ctrl_blk[][2] = {
+		/* no. of pages, register val */
+		{  32, ATH_NF_CTRL_BLOCK_SIZE_32	},
+		{  64, ATH_NF_CTRL_BLOCK_SIZE_64	},
+		{ 128, ATH_NF_CTRL_BLOCK_SIZE_128	},
+		{ 256, ATH_NF_CTRL_BLOCK_SIZE_256	},
+		{   0, 0				},
+		};
+
+	sc = &ath_nand_sc;
+	sc->mtd = &nand_info[nand_curr_device];
+
+	/* initialise the hardware */
+	err = ath_nand_hw_init(sc, &sc->nid);
+	if (err) {
+		goto out_err_hw_init;
+	}
+
+	/* initialise mtd sc data struct */
+	mtd = sc->mtd;
+	mtd->size = ath_parse_read_id(sc) << 20;
+
+	mtd->name		= DRV_NAME;
+	if (mtd->size == 0) {
+		mtd->size	= ath_plane_size[sc->nid.pls] << sc->nid.pn;
+	}
+
+	if (is_small_block_device(sc)) {
+		mtd->writesize		= sc->entry->pgsz;
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= mtd->writesize - 1;
+
+		mtd->erasesize		= sc->entry->blk;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= mtd->erasesize - 1;
+
+		mtd->oobsize		= sc->entry->spare;
+		mtd->oobavail		= mtd->oobsize;
+	} else if (!sc->onfi[0]) {
+		mtd->writesize_shift	= 10 + sc->nid.ps;
+		mtd->writesize		= (1 << mtd->writesize_shift);
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize_shift	= 16 + sc->nid.bs;
+		mtd->erasesize		= (1 << mtd->erasesize_shift);
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= (mtd->writesize / 512) * (8 << sc->nid.ss);
+		mtd->oobavail		= mtd->oobsize;
+	} else {
+		mtd->writesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGE_SIZE]);
+		mtd->writesize_shift	= ffs(mtd->writesize) - 1;
+		mtd->writesize_mask	= (mtd->writesize - 1);
+
+		mtd->erasesize		= *(uint32_t *)(&sc->onfi[ONFI_PAGES_PER_BLOCK]) *
+					  mtd->writesize;
+		mtd->erasesize_shift	= ffs(mtd->erasesize) - 1;
+		mtd->erasesize_mask	= (mtd->erasesize - 1);
+
+		mtd->oobsize		= *(uint16_t *)(&sc->onfi[ONFI_SPARE_SIZE]);
+		mtd->oobavail		= mtd->oobsize;
+
+		mtd->size		= mtd->erasesize *
+					  (*(uint32_t *)(&sc->onfi[ONFI_BLOCKS_PER_LUN])) *
+					  sc->onfi[ONFI_NUM_LUNS];
+	}
+
+	for (i = 0; nf_ctrl_pg[i][0]; i++) {
+		if (nf_ctrl_pg[i][0] == mtd->writesize) {
+			sc->nf_ctrl |= nf_ctrl_pg[i][1];
+			break;
+		}
+	}
+
+	for (i = 0; nf_ctrl_blk[i][0]; i++) {
+		if (nf_ctrl_blk[i][0] == (mtd->erasesize / mtd->writesize)) {
+			sc->nf_ctrl |= nf_ctrl_blk[i][1];
+			break;
+		}
+	}
+
+	ath_nand_set_ns(mtd);
+
+	mtd->type		= MTD_NANDFLASH;
+	mtd->flags		= MTD_CAP_NANDFLASH;
+
+	mtd->read		= ath_nand_read;
+	mtd->write		= ath_nand_write;
+	mtd->erase		= ath_nand_erase;
+
+	//mtd->read_oob		= ath_nand_read_oob;
+	//mtd->write_oob		= ath_nand_write_oob;
+
+	mtd->block_isbad	= ath_nand_block_isbad;
+	mtd->block_markbad	= ath_nand_block_markbad;
+
+	mtd->priv		= sc;
+
+	ath_nand_ecc_init(mtd);
+
+	// bbt has 2 bits per block
+	bbt_size = ((mtd->size >> mtd->erasesize_shift) * 2) / 8;
+	sc->bbt = malloc(bbt_size);
+
+	if (sc->bbt) {
+		memset(sc->bbt, 0, bbt_size);
+	}
+
+	printf(	"====== NAND Parameters ======\n"
+		"sc = 0x%p bbt = 0x%p bbt_size = 0x%x nf_ctrl = 0x%x\n"
+		"page = 0x%x block = 0x%x oob = 0x%x\nsize = %uMB\n", sc, sc->bbt, bbt_size,
+		sc->nf_ctrl, mtd->writesize, mtd->erasesize, mtd->oobsize, mtd->size >> 20);
+
+	return mtd->size;
+
+out_err_hw_init:
+	return 0;
+}
+
+#if 0
+static struct platform_driver ath_nand_driver = {
+	//.probe		= ath_nand_probe,
+	.remove		= __exit_p(ath_nand_remove),
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+#endif
+
+ulong ath_nand_init(void)
+{
+	printk(DRV_DESC ", Version " DRV_VERSION
+		" (c) 2010 Atheros Communications, Ltd.\n");
+
+	//return platform_driver_register(&ath_nand_driver);
+	//return platform_driver_probe(&ath_nand_driver, ath_nand_probe);
+	return ath_nand_probe();
+}
diff --git a/board/atheros/common/ath_pci.c b/board/atheros/common/ath_pci.c
new file mode 100644
index 0000000000..71c49d6001
--- /dev/null
+++ b/board/atheros/common/ath_pci.c
@@ -0,0 +1,421 @@
+/*****************************************************************************/
+/*! file ath_pci.c
+** /brief PCI support for Atheros boards
+**
+** This provides the support code required for PCI support on the AP91/93
+** board in the U-Boot environment. This board is a Python based system
+** with a Merlin WLAN interface. This file also contains the support
+** for initialization of the Merlin radios on the PCi bus, required for
+** pre-configuration for use by Linux.
+**
+** Copyright (c) 2008 Atheros Communications Inc. All rights reserved.
+**
+*/
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <pci.h>
+#include <atheros.h>
+
+/*
+** PCI controller "hose" value
+*/
+
+static struct pci_controller hose;
+
+static int ath_local_read_config(int where, int size, uint32_t *value);
+static int ath_local_write_config(int where, int size, uint32_t value);
+
+static int
+ath_local_read_config(int where, int size, uint32_t *value)
+{
+	*value = ath_reg_rd(ATH_PCI_CRP + where);
+	return 0;
+}
+
+static int
+ath_local_write_config(int where, int size, uint32_t value)
+{
+	ath_reg_wr((ATH_PCI_CRP + where),value);
+	return 0;
+}
+
+static int
+ath_pci_read_config(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t *value)
+{
+	*value = ath_reg_rd(ATH_PCI_DEV_CFGBASE + where);
+	return 0;
+}
+
+static int
+ath_pci_write_config(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t value)
+{
+	ath_reg_wr((ATH_PCI_DEV_CFGBASE + where), value);
+	return 0;
+}
+
+#ifdef PCIE2_APP_ADDRESS
+static int
+ath_local_read_config_rc2(int where, int size, uint32_t *value)
+{
+	*value = ath_reg_rd(0x18250000 + where);
+	return 0;
+}
+
+static int
+ath_local_write_config_rc2(int where, int size, uint32_t value)
+{
+	ath_reg_wr((0x18250000 + where),value);
+	return 0;
+}
+
+static int
+ath_pci_read_config_rc2(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t *value)
+{
+	*value = ath_reg_rd(0xb6000000 + where);
+	return 0;
+}
+
+static int
+ath_pci_write_config_rc2(struct pci_controller *hose,
+			pci_dev_t dev, int where, uint32_t value)
+{
+	ath_reg_wr((0xb6000000 + where), value);
+	return 0;
+}
+#endif
+
+/*
+** We will use the ART configuration information stored in flash to initialize
+** these devices as required.
+*/
+
+void plat_dev_init(void)
+{
+	u32	val;
+	u32	addr;
+	u32	BaseAddr = 0x10000000;
+	u32	CalAddr = WLANCAL;
+	volatile u16 *calData;
+
+	/*
+	 * Copy the device ID from Flash to device config space.
+	 */
+
+	calData = (u16 *)CalAddr;
+
+#ifndef CONFIG_PCI_CONFIG_DATA_IN_OTP
+	if (calData[0] != 0xa55a && calData[0] != 0x5aa5)
+	{
+#ifndef COMPRESSED_UBOOT
+		prmsg("BOARD IS NOT CALIBRATED!!!\n");
+#endif
+		return;
+	}
+#else
+	return;
+#endif
+	/*
+	** Need to setup the PCI device to access the internal registers
+	*/
+	if ((is_ar7241() || is_ar7242()))
+		ath_pci_write_config(&hose, NULL, 0x10, 0x1000ffff);
+	else
+		ath_pci_write_config(&hose, NULL, 0x10, 0xffff);
+
+	ath_pci_write_config(&hose, NULL, 0x04, 0x6);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_pci_write_config_rc2(&hose, NULL, 0x10, 0xffff);
+
+	ath_pci_write_config_rc2(&hose, NULL, 0x04, 0x6);
+#endif
+
+	/*
+	** Set pointer to first reg address
+	*/
+
+	calData += ATH_ART_PCICFG_OFFSET;
+
+	while(*calData != 0xffff)
+	{
+		u16 cd;
+
+		cd = *calData++;
+		addr = BaseAddr + cd;
+		val = *calData++;
+		val |= (*calData++) << 16;
+
+		ath_reg_wr_nf(addr,val);
+		udelay(100);
+	}
+
+	return;
+}
+
+
+/******************************************************************************/
+/*!
+** \brief pci host initialization
+**
+** Sets up the PCI controller on the host. For AR7240 this may not be necessary,
+** but this function is required for board support.
+**
+** We want a 1:1 mapping between PCI and DDR for inbound and outbound.
+** The PCI<---AHB decoding works as follows:
+**
+** 8 registers in the DDR unit provide software configurable 32 bit offsets
+** for each of the eight 16MB PCI windows in the 128MB. The offsets will be
+** added to any address in the 16MB segment before being sent to the PCI unit.
+**
+** Essentially for any AHB address generated by the CPU,
+** 1. the MSB four bits are stripped off, [31:28],
+** 2. Bit 27 is used to decide between the lower 128Mb (PCI) or the rest of
+**    the AHB space
+** 3. Bits 26:24 are used to access one of the 8 window registers and are
+**    masked off.
+** 4. If it is a PCI address, then the WINDOW offset in the WINDOW register
+**    corresponding to the next 3 bits (bit 26:24) is ADDED to the address,
+**    to generate the address to PCI unit.
+**
+**     eg. CPU address = 0x100000ff
+**         window 0 offset = 0x10000000
+**         This points to lowermost 16MB window in PCI space.
+**         So the resulting address would be 0x000000ff+0x10000000
+**         = 0x100000ff
+**
+**         eg2. CPU address = 0x120000ff
+**         WINDOW 2 offset = 0x12000000
+**         resulting address would be 0x000000ff+0x12000000
+**                         = 0x120000ff
+**
+** There is no translation for inbound access (PCI device as a master)
+**
+**  \return N/A
+*/
+
+#ifdef  COMPRESSED_UBOOT
+#	define PCI_INIT_RET_TYPE	int
+#	define PCI_INIT_RETURN		return 0
+#else
+#	define PCI_INIT_RET_TYPE	void
+#	define PCI_INIT_RETURN		return
+#endif
+
+PCI_INIT_RET_TYPE
+pci_init_board (void)
+{
+#ifdef CONFIG_ATH_EMULATION
+	prmsg("--- Skipping %s for emulation\n", __func__);
+#else
+	uint32_t cmd;
+
+	if (is_drqfn() && !is_qca953x()) {
+		/*
+		 * Dont enable PCIe in DRQFN package as it has some issues
+		 * related to PCIe
+		 */
+		PCI_INIT_RETURN;
+	}
+
+#if defined(CONFIG_MACH_QCA953x)
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_TESTROM_ENABLE_MASK) {
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+
+		ath_reg_wr(PCIE_PHY_REG_1_ADDRESS, PCIE_PHY_REG_1_RESET_1);
+		ath_reg_wr(PCIE_PHY_REG_3_ADDRESS, PCIE_PHY_REG_3_RESET_1);
+
+	ath_reg_rmw_set(PCIE_PWR_MGMT_ADDRESS, PCIE_PWR_MGMT_ASSERT_CLKREQN_SET(1));
+
+	ath_reg_rmw_set(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+		ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+
+		ath_reg_rmw_clear(RST_CLKGAT_EN_ADDRESS, RST_CLKGAT_EN_PCIE_RC_SET(1));
+
+	PCI_INIT_RETURN;
+	}
+#endif
+
+	// common for rc1 and rc2
+	ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MAX_ADDRESS,
+		PCIE_PLL_DITHER_DIV_MAX_EN_DITHER_SET(0x1) |
+		PCIE_PLL_DITHER_DIV_MAX_USE_MAX_SET(0x1) |
+		PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_INT_SET(0x14) |
+		PCIE_PLL_DITHER_DIV_MAX_DIV_MAX_FRAC_SET(0x3ff));
+
+	ath_reg_wr_nf(PCIE_PLL_DITHER_DIV_MIN_ADDRESS,
+		PCIE_PLL_DITHER_DIV_MIN_DIV_MIN_INT_SET(0x14));
+
+	ath_reg_wr_nf(PCIE_PLL_CONFIG_ADDRESS,
+		PCIE_PLL_CONFIG_REFDIV_SET(1) |
+		PCIE_PLL_CONFIG_BYPASS_SET(1) |
+		PCIE_PLL_CONFIG_PLLPWD_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_PLLPWD_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(PCIE_PLL_CONFIG_ADDRESS, PCIE_PLL_CONFIG_BYPASS_SET(1));
+	udelay(1000);
+
+#ifdef PCIE2_APP_ADDRESS
+	if (!(ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_PCIE_RC_EP_SELECT_MASK)) {
+		pci_rc2_init_board();
+		return;
+	}
+#endif
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+	udelay(10000);
+#endif
+
+	ath_reg_wr_nf(PCIE_RESET_ADDRESS, 0);	// Put endpoint in reset
+	udelay(100000);
+
+#ifdef PCIE2_APP_ADDRESS
+	ath_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY_SET(1));
+	udelay(10000);
+#endif
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE_APP_ADDRESS, PCIE_APP_PCIE_BAR_MSN_SET(1) |
+					PCIE_APP_CFG_BE_SET(0xf) |
+					PCIE_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+					PCIE_APP_LTSSM_ENABLE_SET(1));
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	ath_local_write_config(PCI_COMMAND, 4, cmd);
+	ath_local_write_config(0x20, 4, 0x1ff01000);
+	ath_local_write_config(0x24, 4, 0x1ff01000);
+
+	ath_reg_wr_nf(PCIE_RESET_ADDRESS, 4);	// Pull endpoint out of reset
+	udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+	if (((ath_reg_rd(PCIE_RESET_ADDRESS)) & 0x1) == 0x0) {
+		prmsg("*** Warning *** : PCIe WLAN Module not found !!!\n");
+	}
+
+#ifdef PCIE2_APP_ADDRESS
+	pci_rc2_init_board();
+#endif
+
+#ifndef COMPRESSED_UBOOT
+	/*
+	 * Now, configure for u-boot tools
+	 */
+
+	hose.first_busno = 0;
+	hose.last_busno = 0xff;
+
+	/* System space */
+	pci_set_region(	&hose.regions[0],
+			0x80000000,
+			0x00000000,
+			32 * 1024 * 1024,
+			PCI_REGION_MEM | PCI_REGION_MEMORY);
+
+	/* PCI memory space */
+	pci_set_region(	&hose.regions[1],
+			0x10000000,
+			0x10000000,
+			128 * 1024 * 1024,
+			PCI_REGION_MEM);
+
+	hose.region_count = 2;
+
+	pci_register_hose(&hose);
+
+	pci_set_ops(	&hose,
+			pci_hose_read_config_byte_via_dword,
+			pci_hose_read_config_word_via_dword,
+			ath_pci_read_config,
+			pci_hose_write_config_byte_via_dword,
+			pci_hose_write_config_word_via_dword,
+			ath_pci_write_config);
+#endif
+	plat_dev_init();
+#endif /* CONFIG_ATH_EMULATION */
+
+	PCI_INIT_RETURN;
+}
+
+#ifdef PCIE2_APP_ADDRESS
+void
+pci_rc2_init_board (void)
+{
+	uint32_t	cmd;
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_PCIE2_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_PCIE2_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY2_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE2_RESET_ADDRESS, 0);	// Put endpoint in reset
+	udelay(100000);
+
+	ath_reg_rmw_set(RST_MISC2_ADDRESS, RST_MISC2_PERSTN_RCPHY2_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET_PCIE_PHY_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET_PCIE_RESET_SET(1));
+	udelay(10000);
+
+	ath_reg_wr_nf(PCIE2_APP_ADDRESS, PCIE2_APP_PCIE2_BAR_MSN_SET(1) |
+					PCIE2_APP_CFG_BE_SET(0xf) |
+					PCIE2_APP_SLV_RESP_ERR_MAP_SET(0x3f) |
+					PCIE2_APP_LTSSM_ENABLE_SET(1));
+
+	cmd = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;
+
+	ath_local_write_config_rc2(PCI_COMMAND, 4, cmd);
+	ath_local_write_config_rc2(0x20, 4, 0x1ff01000);
+	ath_local_write_config_rc2(0x24, 4, 0x1ff01000);
+
+	ath_reg_wr_nf(PCIE2_RESET_ADDRESS, 4);	// Pull endpoint out of reset
+	udelay(100000);
+
+	/*
+	 * Check if the WLAN PCI-E H/W is present, If the
+	 * WLAN H/W is not present, skip the PCI platform
+	 * initialization code and return
+	 */
+	if (((ath_reg_rd(PCIE2_RESET_ADDRESS)) & 0x1) == 0x0) {
+		prmsg("*** Warning *** : PCIe WLAN Module not found !!!\n");
+		return;
+	}
+}
+#endif
diff --git a/board/atheros/common/athr_ar8033_phy.c b/board/atheros/common/athr_ar8033_phy.c
new file mode 100644
index 0000000000..4ae169b1b2
--- /dev/null
+++ b/board/atheros/common/athr_ar8033_phy.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2010, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athrs_ar8033_phy.h"
+
+
+void
+athrs_ar8033_mgmt_init(void)
+{
+    uint32_t rddata;
+
+
+    rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+             ~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+    rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+    ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+    ath_reg_rmw_clear(GPIO_OE_ADDRESS, ATH_GPIO);
+
+    ath_reg_rmw_clear(GPIO_OE_ADDRESS, ATH_GPIO17);
+
+
+    rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+             ~ (GPIO_FUNCTION4_MASK);
+
+    rddata |= (GPIO_FUNCTION4_ENABLE);
+
+    ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+
+#ifdef ATH_MDC_GPIO
+    rddata = ath_reg_rd(GPIO_OUT_FUNCTION3_ADDRESS) &
+           ~ (GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_MASK);
+
+    rddata |= GPIO_OUT_FUNCTION3_ENABLE_GPIO_14_SET(0x21);
+
+    ath_reg_wr(GPIO_OUT_FUNCTION3_ADDRESS, rddata);
+#endif
+
+}
+
+int
+athrs_ar8033_phy_setup(void  *arg)
+{
+
+    return 0;
+}
+
+int
+athrs_ar8033_phy_is_fdx(int ethUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   if (SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(phy_hw_status) == 1) {
+        return 1;
+    } else if (SGMII_MAC_RX_CONFIG_DUPLEX_MODE_GET(phy_hw_status) == 0) {
+        return 0;
+    }
+
+    return 0;
+
+}
+
+int
+athrs_ar8033_phy_is_link_alive(int phyUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   if (SGMII_MAC_RX_CONFIG_LINK_GET(phy_hw_status))
+        return 1;
+    else
+        return 0;
+
+  }
+
+int
+athrs_ar8033_phy_is_up(int ethUnit)
+{
+   int phy_hw_status = 0x0;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+    if (SGMII_MAC_RX_CONFIG_LINK_GET(phy_hw_status))
+        return 1;
+    else
+        return 0;
+
+
+}
+int
+athrs_ar8033_phy_speed(int ethUnit)
+{
+   int phy_hw_status = 0x0,speed;
+
+   phy_hw_status = ath_reg_rd(SGMII_MAC_RX_CONFIG_ADDRESS);
+
+   speed = ((phy_hw_status & (3 << 10)) >> 10);
+
+   switch (speed) {
+        case 0:
+                return _10BASET;
+                break;
+        case 1:
+                return _100BASET;
+                break;
+        case 2:
+                return _1000BASET;
+                break;
+        default:
+                return -1;
+                break;
+   }
+
+   return -1;
+
+}
+
+
+int
+athrs_ar8033_reg_init(void *arg)
+{
+
+
+	athrs_ar8033_mgmt_init();
+	phy_reg_write(0x1,0x5, 0x1f, 0x101);
+
+
+
+	printf("%s: Done %x \n",__func__, phy_reg_read(0x1,0x5,0x1f));
+
+	return 0;
+}
diff --git a/board/atheros/common/athr_s27_phy.c b/board/atheros/common/athr_s27_phy.c
new file mode 100755
index 0000000000..e1cc56080c
--- /dev/null
+++ b/board/atheros/common/athr_s27_phy.c
@@ -0,0 +1,877 @@
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athr_s27_phy.h"
+
+/* PHY selections and access functions */
+
+typedef enum {
+    PHY_SRCPORT_INFO,
+    PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+    PHY_SRCPORT_NONE,
+    PHY_SRCPORT_VLANTAG,
+    PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define MODULE_NAME "ATHRS27"
+
+/*
+ * Track per-PHY port information.
+ */
+
+
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+
+   {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY4_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+
+#define ATHR_GLOBALREGBASE    0
+
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athrs27_phy_is_link_alive(int phyUnit);
+uint32_t athrs27_reg_read(uint32_t reg_addr);
+void athrs27_reg_write(uint32_t reg_addr, uint32_t reg_val);
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr);
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data);
+
+
+void athrs27_powersave_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0x29);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x36c0);
+
+}
+void athrs27_sleep_off(int phy_addr)
+{
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_ADDRESS,0xb);
+    s27_wr_phy(phy_addr,ATHR_DEBUG_PORT_DATA,0x3c00);
+}
+
+void athrs27_force_100M(int phyAddr,int duplex)
+{
+   /*
+    *  Force MDI and MDX to alternate ports
+    *  Phy 0,2 and 4 -- MDI
+    *  Phy 1 and 3 -- MDX
+    */
+
+    if(phyAddr%2) {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+    }
+    else {
+        s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+    }
+
+    s27_wr_phy(phyAddr,0x1d,0x29);
+    s27_wr_phy(phyAddr,0x1e,0x0);
+    s27_wr_phy(phyAddr,0x10,0xc60);
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0xa000|(duplex << 8)));
+}
+
+void athrs27_force_10M(int phyAddr,int duplex)
+{
+
+    athrs27_powersave_off(phyAddr);
+    athrs27_sleep_off(phyAddr);
+
+    s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,(0x8000 |(duplex << 8)));
+}
+
+int athrs27_reg_init(void)
+{
+#if S27_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+
+    /* if using header for register configuration, we have to     */
+    /* configure s27 register after frame transmission is enabled */
+    athrs27_reg_rmw(0x8,(1<<28));  /* Set WAN port is connected to GE0 */
+
+#if defined(S27_FORCE_100M)
+    athrs27_force_100M(ATHR_PHY4_ADDR,1);
+#elif  defined(S27_FORCE_10M)
+    athrs27_force_10M(ATHR_PHY4_ADDR,1);
+#else
+    s27_wr_phy(ATHR_PHY4_ADDR,ATHR_PHY_CONTROL,0x9000);
+
+#endif
+#ifdef S27_PHY_DEBUG
+    printf(MODULE_NAME":OPERATIONAL_MODE_REG0:%x\n",athrs27_reg_read(OPERATIONAL_MODE_REG0));
+    printf(MODULE_NAME":REG 0x4-->:%x\n",athrs27_reg_read(0x4));
+    printf(MODULE_NAME":REG 0x2c-->:%x\n",athrs27_reg_read(0x2c));
+    printf(MODULE_NAME":REG 0x8-->:%x\n",athrs27_reg_read(0x8));
+#endif
+
+    return 0;
+}
+
+int athrs27_reg_init_lan(void)
+{
+    int i = 60;
+#if S26_PHY_DEBUG
+    uint32_t rd_val;
+#endif
+    int       phyUnit;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+
+
+    /* reset switch */
+    printf(MODULE_NAME ": resetting s27\n");
+    athrs27_reg_write(0x0, athrs27_reg_read(0x0)|0x80000000);
+
+    while(i--) {
+        sysMsDelay(100);
+        if(!(athrs27_reg_read(0x0)&0x80000000))
+            break;
+    }
+    printf(MODULE_NAME ": s27 reset done\n");
+    athrs27_reg_write(PORT_STATUS_REGISTER0,0x4e);
+
+    athrs27_reg_rmw(OPERATIONAL_MODE_REG0,(1<<6));  /* Set GMII mode */
+
+    if (is_emu() || is_wasp()) {
+       athrs27_reg_rmw(0x2c,((1<<26)| (1<<16) | 0x1)); /* FiX ME: EBU debug */
+    }
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+#if defined(S27_FORCE_100M)
+        athrs27_force_100M(phyAddr,1);
+#elif defined(S27_FORCE_10M)
+        athrs27_force_10M(phyAddr,1);
+#else
+        s27_wr_phy(phyAddr,ATHR_PHY_CONTROL,0x9000);
+#endif
+
+#if S27_PHY_DEBUG
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_FUNC_CONTROL);
+        printf("S27 ATHR_PHY_FUNC_CONTROL (%d):%x\n",phyAddr,rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_ID1);
+        printf("S27 PHY ID  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+        printf("S27 PHY CTRL  (%d) :%x\n",phyAddr, rd_val);
+        rd_val = s27_rd_phy(phyAddr,ATHR_PHY_STATUS);
+        printf("S27 ATHR PHY STATUS  (%d) :%x\n",phyAddr, rd_val);
+#endif
+    }
+
+    /*
+     * status[1:0]=2'h2;   - (0x10 - 1000 Mbps , 0x01 - 100Mbps, 0x0 - 10 Mbps)
+     * status[2]=1'h1;     - Tx Mac En
+     * status[3]=1'h1;     - Rx Mac En
+     * status[4]=1'h1;     - Tx Flow Ctrl En
+     * status[5]=1'h1;     - Rx Flow Ctrl En
+     * status[6]=1'h1;     - Duplex Mode
+     */
+    athrs27_reg_write(PORT_STATUS_REGISTER1, 0x200);  /* LAN - 1 */
+    athrs27_reg_write(PORT_STATUS_REGISTER2, 0x200);  /* LAN - 2 */
+    athrs27_reg_write(PORT_STATUS_REGISTER3, 0x200);  /* LAN - 3 */
+    athrs27_reg_write(PORT_STATUS_REGISTER4, 0x200);  /* LAN - 4 */
+
+    if (is_emu()) {
+        athrs27_reg_write(PORT_STATUS_REGISTER1, 0x4C);  /* LAN - 1 */
+        athrs27_reg_write(PORT_STATUS_REGISTER2, 0x4c);  /* LAN - 2 */
+        athrs27_reg_write(PORT_STATUS_REGISTER3, 0x4c);  /* LAN - 3 */
+        athrs27_reg_write(PORT_STATUS_REGISTER4, 0x4c);  /* LAN - 4 */
+    }
+
+    /* QM Control */
+    athrs27_reg_write(0x38, 0xc000050e);
+
+    /*
+     * status[11]=1'h0;    - CPU Disable
+     * status[7] = 1'b1;   - Learn One Lock
+     * status[14] = 1'b0;  - Learn Enable
+     */
+#ifdef ATHEROS_HEADER_EN
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4804);
+#else
+   /* Atheros Header Disable */
+    athrs27_reg_write(PORT_CONTROL_REGISTER0, 0x4004);
+#endif
+
+    /* Tag Priority Mapping */
+    athrs27_reg_write(0x70, 0xfa50);
+
+    /* Enable ARP packets to CPU port */
+    athrs27_reg_write(S27_ARL_TBL_CTRL_REG,(athrs27_reg_read(S27_ARL_TBL_CTRL_REG) | 0x100000));
+
+   /* Enable Broadcast packets to CPU port */
+    athrs27_reg_write(S27_FLD_MASK_REG,(athrs27_reg_read(S27_FLD_MASK_REG) |
+                           S27_ENABLE_CPU_BROADCAST | S27_ENABLE_CPU_BCAST_FWD ));
+
+    return 0;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs27_phy_is_link_alive(int phyUnit)
+{
+    uint16_t phyHwStatus;
+    uint32_t phyBase;
+    uint32_t phyAddr;
+
+    phyBase = ATHR_PHYBASE(phyUnit);
+    phyAddr = ATHR_PHYADDR(phyUnit);
+    phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+    if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+        return TRUE;
+
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs27_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+BOOL
+athrs27_phy_setup(int ethUnit)
+{
+    int       phyUnit;
+    uint16_t  phyHwStatus;
+    uint16_t  timeout;
+    int       liveLinks = 0;
+    uint32_t  phyBase = 0;
+    BOOL      foundPhy = FALSE;
+    uint32_t  phyAddr = 0;
+//#if S27_PHY_DEBUG
+    uint32_t  rd_val = 0;
+//#endif
+    uint32_t  ar7240_revid;
+
+
+    /* See if there's any configuration data for this enet */
+    /* start auto negogiation on each phy */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+
+        foundPhy = TRUE;
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+        if (!is_emu()) {
+           s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+
+           s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+        }
+        else  {
+		printf("############ is emulation ############\n");
+
+           if(ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN) {
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,ATHR_ADVERTISE_ALL);
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+           else {
+
+               s27_wr_phy(phyAddr, ATHR_AUTONEG_ADVERT,(ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE |
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL));
+               s27_wr_phy(phyAddr,0x9, 0x0); //donot advertise 1000Mbps mode
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,0x0);
+               s27_wr_phy(phyAddr, ATHR_PHY_CONTROL,ATHR_CTRL_AUTONEGOTIATION_ENABLE
+                         | ATHR_CTRL_SOFTWARE_RESET);
+           }
+       }
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_CONTROL);
+       printf("%s ATHR_PHY_CONTROL %d:0x%x\n",__func__,phyAddr,rd_val);
+       rd_val = s27_rd_phy(phyAddr,ATHR_PHY_SPEC_STATUS);
+       printf("%s ATHR_PHY_SPEC_STAUS %d:0x%x\n",__func__,phyAddr,rd_val);
+    }
+    if (!foundPhy) {
+        return FALSE; /* No PHY's configured for this ethUnit */
+    }
+
+    /*
+     * After the phy is reset, it takes a little while before
+     * it can respond properly.
+     */
+    if (ethUnit == ENET_UNIT_LAN)
+        sysMsDelay(100);// changed by lsz, sysMsDelay(1000);
+    else
+        sysMsDelay(300);// changed by lsz, sysMsDelay(3000);
+
+    /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+        if (ATHR_ETHUNIT(phyUnit) == ENET_UNIT_WAN)
+            continue;
+
+        timeout=20;
+        for (;;) {
+            phyHwStatus =  s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+
+            if (ATHR_RESET_DONE(phyHwStatus)) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Neg Success\n", phyUnit));
+                break;
+            }
+            if (timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+            if (--timeout == 0) {
+                DRV_PRINT(DRV_DEBUG_PHYSETUP,
+                          ("Port %d, Negogiation timeout\n", phyUnit));
+                break;
+            }
+
+            sysMsDelay(150);
+        }
+        /* extend the cable length */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x14);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xf52);
+
+       /* Force Class A setting phys */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 4);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xebbb);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 5);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x2c47);
+
+        /* fine-tune PHYs */
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x3c);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0x1c1);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_ADDRESS, 0x37);
+        s27_wr_phy(phyUnit, ATHR_DEBUG_PORT_DATA, 0xd600);
+
+
+#ifdef S27_VER_1_0
+        /* turn off power saving */
+        s27_wr_phy(phyUnit, 29, 41);
+        s27_wr_phy(phyUnit, 30, 0);
+        printf("def_ S27_VER_1_0\n");
+#endif
+    }
+
+    /*
+     * All PHYs have had adequate time to autonegotiate.
+     * Now initialize software status.
+     *
+     * It's possible that some ports may take a bit longer
+     * to autonegotiate; but we can't wait forever.  They'll
+     * get noticed by mv_phyCheckStatusChange during regular
+     * polling activities.
+     */
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+            liveLinks++;
+            ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+        } else {
+            ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+        }
+        DRV_PRINT(DRV_DEBUG_PHYSETUP,
+            ("eth%d: Phy Specific Status=%4.4x\n",
+            ethUnit,
+            s27_rd_phy(ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS)));
+    }
+
+    return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs27_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs27_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (ethUnit == ENET_UNIT_LAN)
+        return TRUE;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            phyBase = ATHR_PHYBASE(phyUnit);
+            phyAddr = ATHR_PHYADDR(phyUnit);
+
+            do {
+                phyHwStatus = s27_rd_phy (phyAddr, ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            } while(--ii);
+            if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+/******************************************************************************
+*
+* athrs27_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               ATHR_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               ATHR_PHY_SPEED_1000T;
+*/
+
+int
+athrs27_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+    int       phySpeed;
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        phySpeed = _10BASET;
+
+        if (athrs27_phy_is_link_alive(phyUnit)) {
+
+            do {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                              ATHR_PHY_SPEC_STATUS);
+                        if(phyHwStatus & ATHR_STATUS_RESOVLED)
+                                break;
+                sysMsDelay(10);
+            }while(--ii);
+
+            phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                           ATHER_STATUS_LINK_SHIFT);
+
+            switch(phyHwStatus) {
+            case 0:
+                phySpeed = _10BASET;
+		break;
+            case 1:
+                phySpeed = _100BASET;
+		break;
+            case 2:
+                phySpeed = _1000BASET;
+		break;
+            default:
+                printf("Unkown speed read!\n");
+            }
+        }
+
+        phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x18);
+
+        if(phySpeed == _100BASET) {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0xba8);
+        } else {
+            phy_reg_write(1,phyAddr, ATHR_DEBUG_PORT_DATA, 0x2ea);
+        }
+    }
+
+    if (ethUnit == ENET_UNIT_LAN)
+         phySpeed = _1000BASET;
+
+    return phySpeed;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs27_phy_is_up(int ethUnit)
+{
+
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+    int           phyUnit;
+
+    for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+        if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+            continue;
+        }
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                linkCount++;
+            } else {
+                lostLinks++;
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+                                               ethUnit, phyUnit));
+                printf("enet%d port%d down\n",ethUnit, phyUnit);
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+            /* Check for reset complete */
+            if(is_emu())
+            {
+                phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+                if(phyAddr%2) {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x820);
+                }
+                else {
+                    s27_wr_phy(phyAddr,ATHR_PHY_FUNC_CONTROL,0x800);
+                }
+
+                if((phyHwStatus & 0x4)==0)
+                {
+                   s27_wr_phy(phyAddr,0x9,0x0);
+                   if(phyAddr !=0x4)
+                       s27_wr_phy(phyAddr,0x4,0x41);
+                   s27_wr_phy(phyAddr,0x0,0x9000);
+                }
+            }
+
+            phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+             phyHwControl = s27_rd_phy(phyAddr, ATHR_PHY_CONTROL);
+             phyHwStatus = s27_rd_phy(phyAddr, ATHR_PHY_STATUS);
+
+            /* Check for AutoNegotiation complete */
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                phyHwStatus = s27_rd_phy(phyAddr,
+                                           ATHR_PHY_SPEC_STATUS);
+
+                if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                gainedLinks++;
+                linkCount++;
+                printf("enet%d port%d up\n",ethUnit, phyUnit);
+                DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+                                               ethUnit, phyUnit));
+                lastStatus->isPhyAlive = TRUE;
+                }
+            }
+        }
+    }
+    return (linkCount);
+}
+
+unsigned int athrs27_reg_read(unsigned int s27_addr)
+{
+    unsigned int addr_temp;
+    unsigned int s27_rd_csr_low, s27_rd_csr_high, s27_rd_csr;
+    unsigned int data,unit = 0;
+    unsigned int phy_address, reg_address;
+
+    addr_temp = s27_addr >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp()|| is_qca953x() ) {
+        unit = 1;
+    }
+
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+    reg_address = ((addr_temp << 1) & 0x1e);
+    s27_rd_csr_low = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+
+    reg_address = reg_address | 0x1;
+    s27_rd_csr_high = (uint32_t) phy_reg_read(unit,phy_address, reg_address);
+    s27_rd_csr = (s27_rd_csr_high << 16) | s27_rd_csr_low ;
+
+    return(s27_rd_csr);
+}
+
+void athrs27_reg_write(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    unsigned int addr_temp;
+    unsigned int data;
+    unsigned int phy_address, reg_address,unit = 0;
+
+    addr_temp = (s27_addr ) >>2;
+    data = addr_temp >> 7;
+
+    phy_address = 0x1f;
+    reg_address = 0x10;
+
+    if (is_ar7240()) {
+        unit = 0;
+    }
+    else if(is_ar7241() || is_ar7242() || is_wasp() || is_qca953x()) {
+        unit = 1;
+    }
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    phy_address = (0x17 & ((addr_temp >> 4) | 0x10));
+
+    reg_address = (((addr_temp << 1) & 0x1e) | 0x1);
+    data = (s27_write_data >> 16) & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+    reg_address = ((addr_temp << 1) & 0x1e);
+    data = s27_write_data  & 0xffff;
+    phy_reg_write(unit,phy_address, reg_address, data);
+
+}
+
+void athrs27_reg_rmw(unsigned int s27_addr, unsigned int s27_write_data)
+{
+    int val = athrs27_reg_read(s27_addr);
+    athrs27_reg_write(s27_addr,(val | s27_write_data));
+}
+
+unsigned int s27_rd_phy(unsigned int phy_addr, unsigned int reg_addr)
+{
+
+     unsigned int rddata, i = 100;
+
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = (rddata & 0x0) | (reg_addr<<16)
+              | (phy_addr<<21) | (1<<27)
+              | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg:%X rddata:%X\n",
+                __func__,phy_addr,reg_addr,rddata);
+    /* Read the data from phy */
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & 0xffff;
+    return(rddata);
+}
+void s27_wr_phy(unsigned int phy_addr, unsigned int reg_addr, unsigned int write_data)
+{
+    unsigned int rddata,i = 100;
+
+    /* MDIO_CMD is set for read */
+
+    rddata = athrs27_reg_read(0x98);
+
+    rddata = (rddata & 0x0) | (write_data & 0xffff)
+               | (reg_addr<<16) | (phy_addr<<21)
+               | (0<<27) | (1<<30) | (1<<31) ;
+
+    athrs27_reg_write(0x98, rddata);
+
+    rddata = athrs27_reg_read(0x98);
+    rddata = rddata & (1<<31);
+
+    /* Check MDIO_BUSY status */
+    while(rddata && --i){
+        rddata = athrs27_reg_read(0x98);
+        rddata = rddata & (1<<31);
+    }
+    if(i <= 0)
+      printf("ERROR:%s failed:phy:%d reg%X\n",__func__,phy_addr,reg_addr);
+
+}
+
+int athrs27_mdc_check()
+{
+    int i;
+
+    for (i=0; i<4000; i++) {
+        if(athrs27_reg_read(0x10c) != 0x18007fff)
+            return -1;
+    }
+    return 0;
+}
diff --git a/board/atheros/common/athr_s27_phy.h b/board/atheros/common/athr_s27_phy.h
new file mode 100755
index 0000000000..69540189db
--- /dev/null
+++ b/board/atheros/common/athr_s27_phy.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS27_PHY_H
+#define _ATHRS27_PHY_H
+
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_FUNC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+#define ATHR_PHY_INTR_ENABLE             0x12
+#define ATHR_PHY_INTR_STATUS             0x13
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+#define ATHR_ADVERTISE_1000HALF		      0x0100
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DUPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+#define OPERATIONAL_MODE_REG0                0x4
+
+/* S27 CSR Registers */
+
+#define PORT_STATUS_REGISTER0                0x0100
+#define PORT_STATUS_REGISTER1                0x0200
+#define PORT_STATUS_REGISTER2                0x0300
+#define PORT_STATUS_REGISTER3                0x0400
+#define PORT_STATUS_REGISTER4                0x0500
+#define PORT_STATUS_REGISTER5                0x0600
+
+#define RATE_LIMIT_REGISTER0                 0x010C
+#define RATE_LIMIT_REGISTER1                 0x020C
+#define RATE_LIMIT_REGISTER2                 0x030C
+#define RATE_LIMIT_REGISTER3                 0x040C
+#define RATE_LIMIT_REGISTER4                 0x050C
+#define RATE_LIMIT_REGISTER5                 0x060C
+
+#define PORT_CONTROL_REGISTER0               0x0104
+#define PORT_CONTROL_REGISTER1               0x0204
+#define PORT_CONTROL_REGISTER2               0x0304
+#define PORT_CONTROL_REGISTER3               0x0404
+#define PORT_CONTROL_REGISTER4               0x0504
+#define PORT_CONTROL_REGISTER5               0x0604
+
+#define CPU_PORT_REGISTER                    0x0078
+#define MDIO_CTRL_REGISTER                   0x0098
+
+#define S27_ARL_TBL_FUNC_REG0                0x0050
+#define S27_ARL_TBL_FUNC_REG1                0x0054
+#define S27_ARL_TBL_FUNC_REG2                0x0058
+#define S27_FLD_MASK_REG                     0x002c
+#define S27_ARL_TBL_CTRL_REG                 0x005c
+#define S27_GLOBAL_INTR_REG                  0x10
+#define S27_GLOBAL_INTR_MASK_REG             0x14
+
+
+#define S27_ENABLE_CPU_BROADCAST             (1 << 26)
+#define S27_ENABLE_CPU_BCAST_FWD             (1 << 25)
+
+#define PHY_LINK_CHANGE_REG		     0x4
+#define PHY_LINK_UP		             0x400
+#define PHY_LINK_DOWN		             0x800
+#define PHY_LINK_DUPLEX_CHANGE		     0x2000
+#define PHY_LINK_SPEED_CHANGE		     0x4000
+#define PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+/* SWITCH QOS REGISTERS */
+
+#define ATHR_QOS_PORT_0			0x110 /* CPU PORT */
+#define ATHR_QOS_PORT_1			0x210
+#define ATHR_QOS_PORT_2			0x310
+#define ATHR_QOS_PORT_3			0x410
+#define ATHR_QOS_PORT_4			0x510
+
+#define ATHR_ENABLE_TOS                 (1 << 16)
+
+#define ATHR_QOS_MODE_REGISTER          0x030
+#define ATHR_QOS_FIXED_PRIORITY        ((0 << 31) | (0 << 28))
+#define ATHR_QOS_WEIGHTED              ((1 << 31) | (0 << 28)) /* Fixed weight 8,4,2,1 */
+#define ATHR_QOS_MIXED                 ((1 << 31) | (1 << 28)) /* Q3 for managment; Q2,Q1,Q0 - 4,2,1 */
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+#define mdelay(_x)      sysMsDelay(_x)
+
+#undef S27_VER_1_0
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+typedef struct {
+    uint16_t    reserved0  :2;
+    uint16_t    priority   :2;
+    uint16_t    type       :4;
+    uint16_t    broadcast  :1;
+    uint16_t    from_cpu   :1;
+    uint16_t    reserved1  :2;
+    uint16_t    port_num   :4;
+}at_header_t;
+
+#define ATHR_HEADER_LEN 2
+
+#endif // _ATH_HEADER_CONF
+
+typedef enum {
+    PORT_EG_UNMODIFIED = 0,  /**<  egress transmit packets unmodified */
+    PORT_EG_UNTAGGED,        /**<  egress transmit packets without vlan tag */
+    PORT_EG_TAGGED,          /**<  egress transmit packets with vlan tag */
+} port_1q_egmode_t;
+
+extern void set_packet_inspection_flag(int flag);
+
+#endif
diff --git a/board/atheros/common/athrs17_lpbk.c b/board/atheros/common/athrs17_lpbk.c
new file mode 100644
index 0000000000..81e0e17d82
--- /dev/null
+++ b/board/atheros/common/athrs17_lpbk.c
@@ -0,0 +1,290 @@
+// ----------------------------------
+// S17 Initialization
+// author : subha@atheros.com
+// adapted: Abishek Goda <Abishek.Goda at atheros dot com>
+// ----------------------------------
+
+//#include <prototypes.h>
+//#include <gmac_defines.h>
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+#include "phy.h"
+#include "athrs17_phy.h"
+
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+#ifdef ATH_RGMII_CAL
+
+# define ATHR_PHY_MAX 1
+
+#if 0
+void s17_phy_write( unsigned int phy_address,
+                    unsigned int reg_address,
+                    unsigned int write_data ) {
+
+    unsigned int rddata;
+    unsigned int address;
+
+    address = ((phy_address << 8) & 0x1f00) | (reg_address & 0x1f);
+
+    reg_write(GE0_MAC_MII_MGMT_CFG, 0x7);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+    reg_write(GE0_MAC_MII_MGMT_ADDR, address);
+    reg_write(GE0_MAC_MII_MGMT_CNTR, write_data);
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+}
+
+unsigned int s17_phy_read(unsigned int phy_address, unsigned int reg_address) {
+
+    unsigned int rddata;
+    unsigned int address;
+    unsigned int phy_rddata;
+
+    address = ((phy_address << 8) & 0x1f00) | (reg_address & 0x1f);
+
+    reg_write(GE0_MAC_MII_MGMT_CFG, 0x7);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+    reg_write(GE0_MAC_MII_MGMT_ADDR, address);
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x1);
+
+    rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    while(rddata){
+        rddata = reg_read(GE0_MAC_MII_MGMT_PSTAT) & 0x1;
+    }
+
+    phy_rddata = reg_read(GE0_MAC_MII_MGMT_STAT);
+    reg_write(GE0_MAC_MII_MGMT_CMD, 0x0);
+
+    return(phy_rddata);
+
+}
+
+void s17_reg_write(unsigned int reg_addr, unsigned int reg_val) {
+
+    unsigned int reg_word_addr;
+    unsigned int phy_addr;
+    unsigned int phy_val;
+    unsigned int phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    /* bit16-8 of reg address          */
+    phy_val = (unsigned int) ((reg_word_addr >> 8) & 0x3ff);
+    s17_phy_write(phy_addr, phy_reg, phy_val);
+
+    /* For S17 registers such as ARL and VLAN, since they include BUSY bit   */
+    /* in higher address, we should write the lower 16-bit register then the */
+    /* higher one */
+
+    /* write register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    phy_val = (unsigned int) (reg_val & 0xffff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    phy_val = (unsigned int) ((reg_val >> 16) & 0xffff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+}
+
+unsigned int s17_reg_read(unsigned int reg_addr)
+{
+    unsigned int reg_word_addr;
+    unsigned int phy_addr, tmp_val, reg_val;
+    unsigned int phy_val;
+    unsigned int phy_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    /* bit16-8 of reg address */
+    phy_val = (unsigned int) ((reg_word_addr >> 8) & 0x3ff);
+    s17_phy_write( phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    reg_val = (unsigned int) s17_phy_read( phy_addr, phy_reg);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);  /* bit7-5 of reg address */
+    phy_reg = (unsigned int) (reg_word_addr & 0x1f); /* bit4-0 of reg address */
+    tmp_val = (unsigned int) s17_phy_read( phy_addr, phy_reg);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;
+}
+#endif
+
+void s17_reg_rmw(unsigned int reg_addr, unsigned int reg_val)
+{
+
+    reg_val |= athrs17_reg_read(reg_addr);
+    athrs17_reg_write(reg_addr,reg_val);
+}
+
+void init_s17(void)
+{
+    int phyUnit = 0;
+    int phyBase = 0;
+    int phyAddr = 0;
+    unsigned int rddata;
+
+    athrs17_reg_write(0x624 , 0x003f3f3f);
+    athrs17_reg_write(0x10  , 0x40000000);
+    athrs17_reg_write(0x4   , 0x07500000);
+    athrs17_reg_write(0xc   , 0x01000000);
+    athrs17_reg_write(0x7c  , 0x000000fe); // 1gbps
+    //athrs17_reg_write(0x7c  , 0x0000007d); // 100 mbps
+    //athrs17_reg_write(0x7c  , 0x0000007c); // 10 mbps
+
+    for (phyUnit= 0; phyUnit <= ATHR_PHY_MAX; phyUnit++)
+    {
+        phyBase = 0;
+        phyAddr = phyUnit;
+        // To enable loopback on a phy
+        // rddata = s17_phy_read(phyAddr, 0x0);
+        // s17_phy_write(phyAddr, 0x0, (rddata | (1 << 14)));
+        /* For 100M waveform */
+        phy_reg_write(0, phyAddr, 0x1d, 0x18);
+        phy_reg_write(0, phyAddr, 0x1e, 0x02ea);
+        /* Turn On Gigabit Clock */
+        phy_reg_write(0, phyAddr, 0x1d, 0x3d);
+        phy_reg_write(0, phyAddr, 0x1e, 0x48a0);
+
+    }
+
+    /* Enable flow control */
+    s17_reg_rmw(0x80,0x30);
+    s17_reg_rmw(0x84,0x30);
+    s17_reg_rmw(0x88,0x30);
+    s17_reg_rmw(0x8c,0x30);
+    s17_reg_rmw(0x90,0x30);
+}
+
+void vlan_config(void)
+{
+    athrs17_reg_write(S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+    athrs17_reg_write(S17_P0VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+    athrs17_reg_write(S17_P1VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+    athrs17_reg_write(S17_P2VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P3LOOKUP_CTRL_REG, 0x00140017);
+    athrs17_reg_write(S17_P3VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+    athrs17_reg_write(S17_P4VLAN_CTRL0_REG, 0x10001);
+
+    athrs17_reg_write(S17_P5LOOKUP_CTRL_REG, 0x00140040);
+    athrs17_reg_write(S17_P5VLAN_CTRL0_REG, 0x20001);
+
+    athrs17_reg_write(S17_P6LOOKUP_CTRL_REG, 0x00140020);
+    athrs17_reg_write(S17_P6VLAN_CTRL0_REG, 0x20001);
+
+}
+
+void init_s17_lpbk(void)
+{
+    int phyUnit = 0;
+    int phyBase = 0;
+    int phyAddr = 0;
+    unsigned int rddata;
+
+#ifdef ATH_S17_MAC0_SGMII
+    athrs17_reg_write(0x4   , 0x080080);
+    athrs17_reg_write(0xc   , 0x07600000);
+    athrs17_reg_write(0x94  , 0x000000fe); // 1gbps
+    athrs17_reg_write(0x624 , 0x007f7f7f);
+    printf ("Vlan config...\n");
+    vlan_config();
+#else
+    athrs17_reg_write(0x624 , 0x003f3f3f);
+    athrs17_reg_write(0x4   , 0x07500000);
+    athrs17_reg_write(0xc   , 0x01000000);
+#endif
+    athrs17_reg_write(0x10  , 0x4000000);
+    athrs17_reg_write(0x7c  , 0x000000fe); // 1gbps
+    //athrs17_reg_write(0x7c  , 0x0000007d); // 100 mbps
+    //athrs17_reg_write(0x7c  , 0x0000007c); // 10 mbps
+
+    phyBase = 0;
+#ifdef ATH_S17_MAC0_SGMII
+    phyAddr = 4;
+#else
+    phyAddr = 0;
+#endif
+    // To enable loopback on single phy
+    phy_reg_write(0, phyAddr, 0x0, 0xc140);
+    for(rddata=0; rddata<1000; rddata++);
+    phy_reg_write(0, phyAddr, 0x0, 0x4140);
+    for(rddata=0; rddata<1000; rddata++);
+    rddata = phy_reg_read(0, phyAddr, 0x0);
+#ifdef DEBUG
+    printf("s17 phy0 register value 0x%08x\n", rddata);
+#endif
+    // power down other phys
+#ifdef ATH_S17_MAC0_SGMII
+    phy_reg_write(0, 0x0, 0x0, 0x8800);
+#else
+    phy_reg_write(0, 0x4, 0x0, 0x8800);
+#endif
+    phy_reg_write(0, 0x1, 0x0, 0x8800);
+    phy_reg_write(0, 0x2, 0x0, 0x8800);
+    phy_reg_write(0, 0x3, 0x0, 0x8800);
+    /* For 100M waveform */
+    phy_reg_write(0, phyAddr, 0x1d, 0x18);
+    phy_reg_write(0, phyAddr, 0x1e, 0x02ea);
+    /* Turn On Gigabit Clock */
+    phy_reg_write(0, phyAddr, 0x1d, 0x3d);
+    phy_reg_write(0, phyAddr, 0x1e, 0x48a0);
+
+    /* Enable flow control */
+    s17_reg_rmw(0x80,0x30);
+    s17_reg_rmw(0x84,0x30);
+    s17_reg_rmw(0x88,0x30);
+    s17_reg_rmw(0x8c,0x30);
+    s17_reg_rmw(0x90,0x30);
+}
+
+#endif /* #ifdef RGMII_CAL */
diff --git a/board/atheros/common/athrs17_phy.c b/board/atheros/common/athrs17_phy.c
new file mode 100644
index 0000000000..e64aa7c1b1
--- /dev/null
+++ b/board/atheros/common/athrs17_phy.c
@@ -0,0 +1,713 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright  2007 Atheros Communications, Inc.,  All Rights Reserved.
+ */
+
+/*
+ * Manage the atheros ethernet PHY.
+ *
+ * All definitions in this file are operating system independent!
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+#include "athrs17_phy.h"
+
+/* PHY selections and access functions */
+typedef enum {
+	PHY_SRCPORT_INFO,
+	PHY_PORTINFO_SIZE,
+} PHY_CAP_TYPE;
+
+typedef enum {
+	PHY_SRCPORT_NONE,
+	PHY_SRCPORT_VLANTAG,
+	PHY_SRCPORT_TRAILER,
+} PHY_SRCPORT_TYPE;
+
+#define DRV_LOG(DBG_SW, X0, X1, X2, X3, X4, X5, X6)
+#define DRV_MSG(x,a,b,c,d,e,f)
+#define DRV_PRINT(DBG_SW,X)
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+
+#define ENET_UNIT_GE0 0
+#define ENET_UNIT_GE1 1
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+#define ATHR_IND_PHY 4
+
+#define MODULE_NAME "ATHRS17"
+#define S17_PHY_DEBUG 1
+extern int xmii_val;
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+#if defined(ATH_S17_MAC0_SGMII)
+#define ENET_UNIT            ENET_UNIT_GE1
+#define ENET_UNIT_WAN        ENET_UNIT_GE0
+#else
+#define ENET_UNIT            ENET_UNIT_GE0
+#define ENET_UNIT_WAN        ENET_UNIT_GE1
+#endif
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+static athrPhyInfo_t athrPhyInfo[] = {
+	{
+		TRUE,   /* phy port 0 -- LAN port 0 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY0_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 1 -- LAN port 1 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY1_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 2 -- LAN port 2 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY2_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 3 -- LAN port 3 */
+		FALSE,
+		ENET_UNIT,
+		0,
+		ATHR_PHY3_ADDR,
+		ATHR_LAN_PORT_VLAN
+	},
+	{
+		TRUE,   /* phy port 4 -- WAN port or LAN port 4 */
+		FALSE,
+#if defined(CONFIG_ATH_S17_WAN) || defined (ATH_S17_MAC0_SGMII)
+		ENET_UNIT_WAN,
+#else
+		ENET_UNIT,
+#endif
+		0,
+		ATHR_PHY4_ADDR,
+		ATHR_LAN_PORT_VLAN   /* Send to all ports */
+	},
+	{
+		FALSE,  /* phy port 5 -- CPU port (no RJ45 connector) */
+		TRUE,
+		ENET_UNIT,
+		0,
+		0x00,
+		ATHR_LAN_PORT_VLAN    /* Send to all ports */
+	},
+};
+
+static uint8_t athr17_init_flag = 0;
+
+//#define ATHR_PHY_MAX (sizeof(ipPhyInfo) / sizeof(ipPhyInfo[0]))
+#define ATHR_PHY_MAX 5
+
+/* Range of valid PHY IDs is [MIN..MAX] */
+#define ATHR_ID_MIN 0
+#define ATHR_ID_MAX (ATHR_PHY_MAX-1)
+
+/* Convenience macros to access myPhyInfo */
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit)	\
+	(ATHR_IS_ENET_PORT(phyUnit) &&		\
+	 ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_GE0))
+
+/* Forward references */
+BOOL athrs17_phy_is_link_alive(int phyUnit);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+static void phy_mode_setup(void);
+
+#define sysMsDelay(_x) udelay((_x) * 1000)
+
+static void phy_mode_setup(void)
+{
+#ifdef ATHRS17_VER_1_0
+	/*work around for phy4 rgmii mode*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+	/*rx delay*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+	/*tx delay*/
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+	phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+#endif
+}
+/*
+ * V-lan configuration given by Switch team
+ * Vlan 1:PHY0,1,2,3 and Mac 0 of s17
+ * Vlam 2:PHY4 and Mac 6 of s17
+ */
+
+void athrs17_vlan_config()
+{
+	athrs17_reg_write(S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+	athrs17_reg_write(S17_P0VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+	athrs17_reg_write(S17_P1VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+	athrs17_reg_write(S17_P2VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P3LOOKUP_CTRL_REG, 0x00140017);
+	athrs17_reg_write(S17_P3VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+	athrs17_reg_write(S17_P4VLAN_CTRL0_REG, 0x10001);
+
+	athrs17_reg_write(S17_P5LOOKUP_CTRL_REG, 0x00140040);
+	athrs17_reg_write(S17_P5VLAN_CTRL0_REG, 0x20001);
+
+	athrs17_reg_write(S17_P6LOOKUP_CTRL_REG, 0x00140020);
+	athrs17_reg_write(S17_P6VLAN_CTRL0_REG, 0x20001);
+
+
+}
+
+void athrs17_reg_init_wan(void)
+{
+
+#ifdef ATH_S17_MAC0_SGMII
+	athrs17_reg_write(S17_P6PAD_MODE_REG,0x07600000);
+
+#else
+	athrs17_reg_write(S17_P6PAD_MODE_REG,
+           athrs17_reg_read(S17_P6PAD_MODE_REG)|S17_MAC6_SGMII_EN);
+#endif
+	athrs17_reg_write(S17_P6STATUS_REG, S17_PORT_STATUS_AZ_DEFAULT);
+	athrs17_reg_write(S17_SGMII_CTRL_REG , 0xc74164d0); /* SGMII control */
+
+        athrs17_vlan_config();
+	printf("%s done\n",__func__);
+
+}
+
+void athrs17_reg_init()
+{
+	int phy_addr = 0;
+
+	/* if using header for register configuration, we have to     */
+	/* configure s17 register after frame transmission is enabled */
+
+	if (athr17_init_flag)
+		return;
+	if (is_drqfn()) {
+		athrs17_reg_write(S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN);
+		athrs17_reg_write(S17_SGMII_CTRL_REG , 0xc74164d0); /* SGMII control  */
+        } else {
+		athrs17_reg_write(S17_GLOFW_CTRL1_REG,	0x7f7f7f7f);
+		/*
+                 * If defined S17 Mac0 sgmii val of 0x4(S17_P0PAD_MODE_REG)
+                 * should be configured as 0x80
+                 */
+#ifdef ATH_S17_MAC0_SGMII
+		athrs17_reg_write(S17_P0PAD_MODE_REG,	0x80080);
+#else
+		athrs17_reg_write(S17_P0PAD_MODE_REG,	0x07680000);
+#endif
+		athrs17_reg_write(S17_P6PAD_MODE_REG,	0x01000000);
+
+
+	}
+/*
+ * Values suggested by the swich team when s17 in sgmii configuration
+ * operates in forced mode.
+ * 0x10(S17_PWS_REG)=0x602613a0
+ */
+#ifdef ATH_SGMII_FORCED_MODE
+	athrs17_reg_write(S17_PWS_REG, 0x602613a0);
+#else
+	athrs17_reg_write(S17_PWS_REG,	0x40000000);
+#endif
+	athrs17_reg_write(S17_P0STATUS_REG,	 0x0000007e);
+
+	/* AR8327/AR8328 v1.0 fixup */
+	if ((athrs17_reg_read(0x0) & 0xffff) == 0x1201) {
+		for (phy_addr = 0x0; phy_addr <= ATHR_PHY_MAX; phy_addr++) {
+			/* For 100M waveform */
+			phy_reg_write(0, phy_addr, 0x1d, 0x0);
+			phy_reg_write(0, phy_addr, 0x1e, 0x02ea);
+			/* Turn On Gigabit Clock */
+			phy_reg_write(0, phy_addr, 0x1d, 0x3d);
+			phy_reg_write(0, phy_addr, 0x1e, 0x68a0);
+		}
+	}
+#if CONFIG_S17_SWMAC6_CONNECTED
+        printf ("Configuring Mac6 of s17 to slave scorpion\n");
+	athrs17_reg_write(S17_P6PAD_MODE_REG, S17_MAC6_RGMII_EN | S17_MAC6_RGMII_TXCLK_DELAY | \
+                              S17_MAC6_RGMII_RXCLK_DELAY | (1 << S17_MAC6_RGMII_TXCLK_SHIFT) | \
+                              (2 << S17_MAC6_RGMII_RXCLK_SHIFT));
+	athrs17_reg_write(S17_P6STATUS_REG, 0x7e);
+        athrs17_vlan_config();
+#endif
+	athr17_init_flag = 1;
+	printf("%s: complete\n",__func__);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athrs17_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+
+	phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS)
+		return TRUE;
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athrs17_phy_setup(int ethUnit)
+{
+	int       phyUnit;
+	uint16_t  phyHwStatus;
+	uint16_t  timeout;
+	int       liveLinks = 0;
+	uint32_t  phyBase = 0;
+	BOOL      foundPhy = FALSE;
+	uint32_t  phyAddr = 0;
+
+	/* See if there's any configuration data for this enet */
+	/* start auto negogiation on each phy */
+	if (is_drqfn())
+		ethUnit=0;
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		foundPhy = TRUE;
+		phyBase = ATHR_PHYBASE(phyUnit);
+		phyAddr = ATHR_PHYADDR(phyUnit);
+
+		phy_reg_write(phyBase, phyAddr, ATHR_AUTONEG_ADVERT,
+				ATHR_ADVERTISE_ALL);
+
+		phy_reg_write(phyBase, phyAddr, ATHR_1000BASET_CONTROL,
+				ATHR_ADVERTISE_1000FULL);
+
+		/* Reset PHYs*/
+		phy_reg_write(phyBase, phyAddr, ATHR_PHY_CONTROL,
+				ATHR_CTRL_AUTONEGOTIATION_ENABLE
+				| ATHR_CTRL_SOFTWARE_RESET);
+
+	}
+
+	if (!foundPhy) {
+		return FALSE; /* No PHY's configured for this ethUnit */
+	}
+
+	/*
+	 * After the phy is reset, it takes a little while before
+	 * it can respond properly.
+	 */
+	sysMsDelay(1000);
+
+
+	/*
+	 * Wait up to 3 seconds for ALL associated PHYs to finish
+	 * autonegotiation.  The only way we get out of here sooner is
+	 * if ALL PHYs are connected AND finish autonegotiation.
+	 */
+	for (phyUnit=0; (phyUnit < ATHR_PHY_MAX) /*&& (timeout > 0) */; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		timeout=20;
+		for (;;) {
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+
+			if (ATHR_RESET_DONE(phyHwStatus)) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Neg Success\n", phyUnit));
+				break;
+			}
+			if (timeout == 0) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Negogiation timeout\n", phyUnit));
+				break;
+			}
+			if (--timeout == 0) {
+				DRV_PRINT(DRV_DEBUG_PHYSETUP,
+						("Port %d, Negogiation timeout\n", phyUnit));
+				break;
+			}
+
+			sysMsDelay(150);
+		}
+	}
+
+	/*
+	 * All PHYs have had adequate time to autonegotiate.
+	 * Now initialize software status.
+	 *
+	 * It's possible that some ports may take a bit longer
+	 * to autonegotiate; but we can't wait forever.  They'll
+	 * get noticed by mv_phyCheckStatusChange during regular
+	 * polling activities.
+	 */
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+#if 0
+		/* Enable RGMII */
+		phy_reg_write(0,phyUnit,0x1d,0x12);
+		phy_reg_write(0,phyUnit,0x1e,0x8);
+		/* Tx delay on PHY */
+		phy_reg_write(0,phyUnit,0x1d,0x5);
+		phy_reg_write(0,phyUnit,0x1e,0x100);
+
+		/* Rx delay on PHY */
+		phy_reg_write(0,phyUnit,0x1d,0x0);
+		phy_reg_write(0,phyUnit,0x1e,0x8000);
+#endif
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+			liveLinks++;
+			ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+		} else {
+			ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+		}
+
+		DRV_PRINT(DRV_DEBUG_PHYSETUP,
+				("eth%d: Phy Specific Status=%4.4x\n",
+				 ethUnit,
+				 phy_reg_read(ATHR_PHYBASE(phyUnit),
+					 ATHR_PHYADDR(phyUnit),
+					 ATHR_PHY_SPEC_STATUS)));
+	}
+	phy_mode_setup();
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athrs17_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athrs17_phy_is_fdx(int ethUnit)
+{
+	int       phyUnit;
+	uint32_t  phyBase;
+	uint32_t  phyAddr;
+	uint16_t  phyHwStatus;
+	int       ii = 200;
+
+
+	if (is_drqfn())
+		ethUnit = 0;
+
+
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+
+			phyBase = ATHR_PHYBASE(phyUnit);
+			phyAddr = ATHR_PHYADDR(phyUnit);
+
+			do {
+				phyHwStatus = phy_reg_read (phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+				if(phyHwStatus & ATHR_STATUS_RESOVLED)
+					break;
+				sysMsDelay(10);
+			} while(--ii);
+
+			if (phyHwStatus & ATHER_STATUS_FULL_DEPLEX)
+				return TRUE;
+		}
+	}
+
+	if (ethUnit == ENET_UNIT_GE0 || ethUnit == ENET_UNIT_GE1)
+		return TRUE;
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athrs17_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS: _10BASET, _100BASETX, _1000BASET
+*/
+
+int
+athrs17_phy_speed(int ethUnit)
+{
+	int       phyUnit;
+	uint16_t  phyHwStatus;
+	uint32_t  phyBase;
+	uint32_t  phyAddr;
+	int       ii = 200;
+
+	if ((ethUnit == ENET_UNIT_GE0) || (ethUnit == ENET_UNIT_GE1))
+		return _1000BASET;
+
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		if (athrs17_phy_is_link_alive(phyUnit)) {
+
+			phyBase = ATHR_PHYBASE(phyUnit);
+			phyAddr = ATHR_PHYADDR(phyUnit);
+
+			do {
+				phyHwStatus = phy_reg_read(phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+				if(phyHwStatus & ATHR_STATUS_RESOVLED)
+					break;
+				sysMsDelay(10);
+			} while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+			phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+					ATHER_STATUS_LINK_SHIFT);
+
+			switch(phyHwStatus) {
+			case 0: return _10BASET;
+			case 1: return _100BASET;
+			case 2: return _1000BASET;
+			default: printf("Unkown speed read!\n");
+			}
+		}
+
+	}
+
+	return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athrs17_phy_is_up(int ethUnit)
+{
+	int           phyUnit;
+	uint16_t      phyHwStatus, phyHwControl;
+	athrPhyInfo_t *lastStatus;
+	int           linkCount   = 0;
+	int           lostLinks   = 0;
+	int           gainedLinks = 0;
+	uint32_t      phyBase;
+	uint32_t      phyAddr;
+
+	if (is_drqfn())
+		ethUnit = 0;
+	for (phyUnit=0; phyUnit < ATHR_PHY_MAX; phyUnit++) {
+		if (!ATHR_IS_ETHUNIT(phyUnit, ethUnit)) {
+			continue;
+		}
+
+		phyBase = ATHR_PHYBASE(phyUnit);
+		phyAddr = ATHR_PHYADDR(phyUnit);
+
+		lastStatus = &athrPhyInfo[phyUnit];
+
+		if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+			/* See if we've lost link */
+			if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+				linkCount++;
+			} else {
+				lostLinks++;
+				DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d down\n",
+							ethUnit, phyUnit));
+				lastStatus->isPhyAlive = FALSE;
+			}
+		} else { /* last known link status was DEAD */
+			/* Check for reset complete */
+			phyHwStatus = phy_reg_read(phyBase, phyAddr, ATHR_PHY_STATUS);
+			if (!ATHR_RESET_DONE(phyHwStatus)) {
+				continue;
+			}
+
+			phyHwControl = phy_reg_read(phyBase, phyAddr, ATHR_PHY_CONTROL);
+			/* Check for AutoNegotiation complete */
+			if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+					|| ATHR_AUTONEG_DONE(phyHwStatus)) {
+				phyHwStatus = phy_reg_read(phyBase, phyAddr,
+						ATHR_PHY_SPEC_STATUS);
+
+				if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+					gainedLinks++;
+					linkCount++;
+					DRV_PRINT(DRV_DEBUG_PHYCHANGE,("\nenet%d port%d up\n",
+								ethUnit, phyUnit));
+					lastStatus->isPhyAlive = TRUE;
+				}
+			}
+		}
+	}
+
+	return (linkCount);
+
+}
+
+uint32_t
+athrs17_reg_read(uint32_t reg_addr)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr, tmp_val, reg_val;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as MIBs, since it is read/clear, we should */
+	/* read the lower 16-bit register then the higher one */
+
+	/* read register in lower address */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	reg_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	tmp_val = (uint32_t) phy_reg_read(0, phy_addr, phy_reg);
+	reg_val |= (tmp_val << 16);
+
+	return reg_val;
+}
+
+void
+athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+	uint32_t reg_word_addr;
+	uint32_t phy_addr;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* change reg_addr to 16-bit word address, 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+	/* configure register high address */
+	phy_addr = 0x18;
+	phy_reg = 0x0;
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as ARL and VLAN, since they include BUSY bit */
+	/* in lower address, we should write the higher 16-bit register then the */
+	/* lower one */
+
+	/* read register in higher address */
+	reg_word_addr++;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+
+	/* write register in lower address */
+	reg_word_addr--;
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+	phy_val = (uint16_t) (reg_val & 0xffff);
+	phy_reg_write(0, phy_addr, phy_reg, phy_val);
+}
diff --git a/board/atheros/common/athrs17_phy.h b/board/atheros/common/athrs17_phy.h
new file mode 100644
index 0000000000..8ffe6136b7
--- /dev/null
+++ b/board/atheros/common/athrs17_phy.h
@@ -0,0 +1,553 @@
+#ifndef _ATHRS17_PHY_H
+#define _ATHRS17_PHY_H
+
+/*****************/
+/* PHY Registers */
+/*****************/
+#define ATHR_PHY_CONTROL                 0
+#define ATHR_PHY_STATUS                  1
+#define ATHR_PHY_ID1                     2
+#define ATHR_PHY_ID2                     3
+#define ATHR_AUTONEG_ADVERT              4
+#define ATHR_LINK_PARTNER_ABILITY        5
+#define ATHR_AUTONEG_EXPANSION           6
+#define ATHR_NEXT_PAGE_TRANSMIT          7
+#define ATHR_LINK_PARTNER_NEXT_PAGE      8
+#define ATHR_1000BASET_CONTROL           9
+#define ATHR_1000BASET_STATUS            10
+#define ATHR_PHY_SPEC_CONTROL            16
+#define ATHR_PHY_SPEC_STATUS             17
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/* ATHR_PHY_CONTROL fields */
+#define ATHR_CTRL_SOFTWARE_RESET                    0x8000
+#define ATHR_CTRL_SPEED_LSB                         0x2000
+#define ATHR_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define ATHR_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define ATHR_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define ATHR_CTRL_SPEED_MSB                         0x0040
+
+#define ATHR_RESET_DONE(phy_control)                   \
+    (((phy_control) & (ATHR_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define ATHR_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define ATHR_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (ATHR_STATUS_AUTO_NEG_DONE)) ==                    \
+        (ATHR_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define ATHR_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define ATHR_LINK_100BASETX                   0x0080
+#define ATHR_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define ATHR_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define ATHR_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_STATUS_RESOVLED                  0x0800
+
+/*phy debug port  register */
+#define ATHER_DEBUG_SERDES_REG                5
+
+/* Serdes debug fields */
+#define ATHER_SERDES_BEACON                   0x0100
+
+/* S17 CSR Registers */
+
+#define S17_ENABLE_CPU_BROADCAST             (1 << 26)
+
+#define S17_PHY_LINK_CHANGE_REG		     0x4
+#define S17_PHY_LINK_UP		             0x400
+#define S17_PHY_LINK_DOWN		             0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE		     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE		     0x4000
+#define S17_PHY_LINK_INTRS			     (PHY_LINK_UP | PHY_LINK_DOWN | PHY_LINK_DUPLEX_CHANGE | PHY_LINK_SPEED_CHANGE)
+
+//defines from athrs17_phy.h driver
+
+#define S17_MASK_CTRL_REG               0x0000
+#define S17_P0PAD_MODE_REG              0x0004
+#define S17_P5PAD_MODE_REG              0x0008
+#define S17_P6PAD_MODE_REG              0x000c
+#define S17_PWS_REG                     0x0010
+#define S17_GLOBAL_INT0_REG             0x0020
+#define S17_GLOBAL_INT1_REG             0x0024
+#define S17_GLOBAL_INTMASK0             0x0028
+#define S17_GLOBAL_INTMASK1             0x002c
+#define S17_MODULE_EN_REG               0x0030
+#define S17_MIB_REG                     0x0034
+#define S17_INTF_HIADDR_REG             0x0038
+#define S17_MDIO_CTRL_REG               0x003c
+#define S17_BIST_CTRL_REG               0x0040
+#define S17_BIST_REC_REG                0x0044
+#define S17_SERVICE_REG                 0x0048
+#define S17_LED_CTRL0_REG               0x0050
+#define S17_LED_CTRL1_REG               0x0054
+#define S17_LED_CTRL2_REG               0x0058
+#define S17_LED_CTRL3_REG               0x005c
+#define S17_MACADDR0_REG                0x0060
+#define S17_MACADDR1_REG                0x0064
+#define S17_MAX_FRAME_SIZE_REG          0x0078
+#define S17_P0STATUS_REG                0x007c
+#define S17_P1STATUS_REG                0x0080
+#define S17_P2STATUS_REG                0x0084
+#define S17_P3STATUS_REG                0x0088
+#define S17_P4STATUS_REG                0x008c
+#define S17_P5STATUS_REG                0x0090
+#define S17_P6STATUS_REG                0x0094
+#define S17_HDRCTRL_REG                 0x0098
+#define S17_P0HDRCTRL_REG               0x009c
+#define S17_P1HDRCTRL_REG               0x00A0
+#define S17_P2HDRCTRL_REG               0x00a4
+#define S17_P3HDRCTRL_REG               0x00a8
+#define S17_P4HDRCTRL_REG               0x00ac
+#define S17_P5HDRCTRL_REG               0x00b0
+#define S17_P6HDRCTRL_REG               0x00b4
+#define S17_SGMII_CTRL_REG              0x00e0
+#define S17_EEE_CTRL_REG		0x0100
+
+/* ACL Registers */
+#define S17_ACL_FUNC0_REG               0x0400
+#define S17_ACL_FUNC1_REG               0x0404
+#define S17_ACL_FUNC2_REG               0x0408
+#define S17_ACL_FUNC3_REG               0x040c
+#define S17_ACL_FUNC4_REG               0x0410
+#define S17_ACL_FUNC5_REG               0x0414
+#define S17_PRIVATE_IP_REG              0x0418
+#define S17_P0VLAN_CTRL0_REG            0x0420
+#define S17_P0VLAN_CTRL1_REG            0x0424
+#define S17_P1VLAN_CTRL0_REG            0x0428
+#define S17_P1VLAN_CTRL1_REG            0x042c
+#define S17_P2VLAN_CTRL0_REG            0x0430
+#define S17_P2VLAN_CTRL1_REG            0x0434
+#define S17_P3VLAN_CTRL0_REG            0x0438
+#define S17_P3VLAN_CTRL1_REG            0x043c
+#define S17_P4VLAN_CTRL0_REG            0x0440
+#define S17_P4VLAN_CTRL1_REG            0x0444
+#define S17_P5VLAN_CTRL0_REG            0x0448
+#define S17_P5VLAN_CTRL1_REG            0x044c
+#define S17_P6VLAN_CTRL0_REG            0x0450
+#define S17_P6VLAN_CTRL1_REG            0x0454
+
+/* Table Lookup Registers */
+#define S17_ATU_DATA0_REG               0x0600
+#define S17_ATU_DATA1_REG               0x0604
+#define S17_ATU_DATA2_REG               0x0608
+#define S17_ATU_FUNC_REG                0x060C
+#define S17_VTU_FUNC0_REG               0x0610
+#define S17_VTU_FUNC1_REG               0x0614
+#define S17_ARL_CTRL_REG                0x0618
+#define S17_GLOFW_CTRL0_REG             0x0620
+#define S17_GLOFW_CTRL1_REG             0x0624
+#define S17_GLOLEARN_LIMIT_REG          0x0628
+#define S17_TOS_PRIMAP_REG0             0x0630
+#define S17_TOS_PRIMAP_REG1             0x0634
+#define S17_TOS_PRIMAP_REG2             0x0638
+#define S17_TOS_PRIMAP_REG3             0x063c
+#define S17_TOS_PRIMAP_REG4             0x0640
+#define S17_TOS_PRIMAP_REG5             0x0644
+#define S17_TOS_PRIMAP_REG6             0x0648
+#define S17_TOS_PRIMAP_REG7             0x064c
+#define S17_VLAN_PRIMAP_REG0            0x0650
+#define S17_LOOP_CHECK_REG              0x0654
+#define S17_P0LOOKUP_CTRL_REG           0x0660
+#define S17_P0PRI_CTRL_REG              0x0664
+#define S17_P0LEARN_LMT_REG             0x0668
+#define S17_P1LOOKUP_CTRL_REG           0x066c
+#define S17_P1PRI_CTRL_REG              0x0670
+#define S17_P1LEARN_LMT_REG             0x0674
+#define S17_P2LOOKUP_CTRL_REG           0x0678
+#define S17_P2PRI_CTRL_REG              0x067c
+#define S17_P2LEARN_LMT_REG             0x0680
+#define S17_P3LOOKUP_CTRL_REG           0x0684
+#define S17_P3PRI_CTRL_REG              0x0688
+#define S17_P3LEARN_LMT_REG             0x068c
+#define S17_P4LOOKUP_CTRL_REG           0x0690
+#define S17_P4PRI_CTRL_REG              0x0694
+#define S17_P4LEARN_LMT_REG             0x0698
+#define S17_P5LOOKUP_CTRL_REG           0x069c
+#define S17_P5PRI_CTRL_REG              0x06a0
+#define S17_P5LEARN_LMT_REG             0x06a4
+#define S17_P6LOOKUP_CTRL_REG           0x06a8
+#define S17_P6PRI_CTRL_REG              0x06ac
+#define S17_P6LEARN_LMT_REG             0x06b0
+#define S17_GLO_TRUNK_CTRL0_REG         0x0700
+#define S17_GLO_TRUNK_CTRL1_REG         0x0704
+#define S17_GLO_TRUNK_CTRL2_REG         0x0708
+
+/* Queue Management Registers */
+#define S17_PORT0_HOL_CTRL0		0x0970
+#define S17_PORT0_HOL_CTRL1		0x0974
+#define S17_PORT1_HOL_CTRL0		0x0978
+#define S17_PORT1_HOL_CTRL1		0x097c
+#define S17_PORT2_HOL_CTRL0		0x0980
+#define S17_PORT2_HOL_CTRL1		0x0984
+#define S17_PORT3_HOL_CTRL0		0x0988
+#define S17_PORT3_HOL_CTRL1		0x098c
+#define S17_PORT4_HOL_CTRL0		0x0990
+#define S17_PORT4_HOL_CTRL1		0x0994
+#define S17_PORT5_HOL_CTRL0		0x0998
+#define S17_PORT5_HOL_CTRL1		0x099c
+#define S17_PORT6_HOL_CTRL0		0x09a0
+#define S17_PORT6_HOL_CTRL1		0x09a4
+
+/* Port flow control registers */
+#define S17_P0_FLCTL_REG		0x09b0
+#define S17_P1_FLCTL_REG		0x09b4
+#define S17_P2_FLCTL_REG		0x09b8
+#define S17_P3_FLCTL_REG		0x09bc
+#define S17_P4_FLCTL_REG		0x09c0
+#define S17_P5_FLCTL_REG		0x09c4
+
+/* Packet Edit registers */
+#define S17_PKT_EDIT_CTRL		0x0c00
+#define S17_P0Q_REMAP_REG0		0x0c40
+#define S17_P0Q_REMAP_REG1		0x0c44
+#define S17_P1Q_REMAP_REG0		0x0c48
+#define S17_P2Q_REMAP_REG0		0x0c4c
+#define S17_P3Q_REMAP_REG0		0x0c50
+#define S17_P4Q_REMAP_REG0		0x0c54
+#define S17_P5Q_REMAP_REG0		0x0c58
+#define S17_P5Q_REMAP_REG1		0x0c5c
+#define S17_P6Q_REMAP_REG0		0x0c60
+#define S17_P6Q_REMAP_REG1		0x0c64
+#define S17_ROUTER_VID0			0x0c70
+#define S17_ROUTER_VID1			0x0c74
+#define S17_ROUTER_VID2			0x0c78
+#define S17_ROUTER_VID3			0x0c7c
+#define S17_ROUTER_EG_VLAN_MODE		0x0c80
+
+/* L3 Registers */
+#define S17_HROUTER_CTRL_REG            0x0e00
+#define S17_HROUTER_PBCTRL0_REG         0x0e04
+#define S17_HROUTER_PBCTRL1_REG         0x0e08
+#define S17_HROUTER_PBCTRL2_REG         0x0e0c
+#define S17_WCMP_HASH_TABLE0_REG        0x0e10
+#define S17_WCMP_HASH_TABLE1_REG        0x0e14
+#define S17_WCMP_HASH_TABLE2_REG        0x0e18
+#define S17_WCMP_HASH_TABLE3_REG        0x0e1c
+#define S17_WCMP_NHOP_TABLE0_REG        0x0e20
+#define S17_WCMP_NHOP_TABLE1_REG        0x0e24
+#define S17_WCMP_NHOP_TABLE2_REG        0x0e28
+#define S17_WCMP_NHOP_TABLE3_REG        0x0e2c
+#define S17_ARP_ENTRY_CTRL_REG          0x0e30
+#define S17_ARP_USECNT_REG              0x0e34
+#define S17_HNAT_CTRL_REG               0x0e38
+#define S17_NAPT_ENTRY_CTRL0_REG        0x0e3c
+#define S17_NAPT_ENTRY_CTRL1_REG        0x0e40
+#define S17_NAPT_USECNT_REG             0x0e44
+#define S17_ENTRY_EDIT_DATA0_REG        0x0e48
+#define S17_ENTRY_EDIT_DATA1_REG        0x0e4c
+#define S17_ENTRY_EDIT_DATA2_REG        0x0e50
+#define S17_ENTRY_EDIT_DATA3_REG        0x0e54
+#define S17_ENTRY_EDIT_CTRL_REG         0x0e58
+#define S17_HNAT_PRIVATE_IP_REG         0x0e5c
+
+/* MIB counters */
+#define S17_MIB_PORT0			0x1000
+#define S17_MIB_PORT1			0x1100
+#define S17_MIB_PORT2			0x1200
+#define S17_MIB_PORT3			0x1300
+#define S17_MIB_PORT4			0x1400
+#define S17_MIB_PORT5			0x1500
+#define S17_MIB_PORT6			0x1600
+
+#define S17_MIB_RXBROAD			0x0
+#define S17_MIB_RXPAUSE			0x4
+#define S17_MIB_RXMULTI			0x8
+#define S17_MIB_RXFCSERR		0xC
+#define S17_MIB_RXALIGNERR		0x10
+#define S17_MIB_RXUNDERSIZE		0x14
+#define S17_MIB_RXFRAG			0x18
+#define S17_MIB_RX64B			0x1C
+#define S17_MIB_RX128B			0x20
+#define S17_MIB_RX256B			0x24
+#define S17_MIB_RX512B			0x28
+#define S17_MIB_RX1024B			0x2C
+#define S17_MIB_RX1518B			0x30
+#define S17_MIB_RXMAXB			0x34
+#define S17_MIB_RXTOOLONG		0x38
+#define S17_MIB_RXBYTE1			0x3C
+#define S17_MIB_RXBYTE2			0x40
+#define S17_MIB_RXOVERFLOW		0x4C
+#define S17_MIB_FILTERED		0x50
+#define S17_MIB_TXBROAD			0x54
+#define S17_MIB_TXPAUSE			0x58
+#define S17_MIB_TXMULTI			0x5C
+#define S17_MIB_TXUNDERRUN		0x60
+#define S17_MIB_TX64B			0x64
+#define S17_MIB_TX128B			0x68
+#define S17_MIB_TX256B			0x6c
+#define S17_MIB_TX512B			0x70
+#define S17_MIB_TX1024B			0x74
+#define S17_MIB_TX1518B			0x78
+#define S17_MIB_TXMAXB			0x7C
+#define S17_MIB_TXOVERSIZE		0x80
+#define S17_MIB_TXBYTE1			0x84
+#define S17_MIB_TXBYTE2			0x88
+#define S17_MIB_TXCOL			0x8C
+#define S17_MIB_TXABORTCOL		0x90
+#define S17_MIB_TXMULTICOL		0x94
+#define S17_MIB_TXSINGLECOL		0x98
+#define S17_MIB_TXEXCDEFER		0x9C
+#define S17_MIB_TXDEFER			0xA0
+#define S17_MIB_TXLATECOL		0xA4
+
+/* Register fields */
+#define S17_CHIPID_V1_0			0x1201
+#define S17_CHIPID_V1_1			0x1202
+
+#define S17_MAC0_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC0_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC0_MAC_MII_EN		(1 << 2)
+#define S17_MAC0_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC0_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC0_MAC_GMII_EN		(1 << 6)
+#define S17_MAC0_SGMII_EN		(1 << 7)
+#define S17_MAC0_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC0_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC0_PHY_MII_EN		(1 << 10)
+#define S17_MAC0_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC0_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC0_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC0_PHY_GMII_EN		(1 << 14)
+#define S17_MAC0_RGMII_RXCLK_SHIFT	20
+#define S17_MAC0_RGMII_TXCLK_SHIFT	22
+#define S17_MAC0_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC0_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC0_RGMII_EN		(1 << 26)
+
+#define S17_MAC5_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC5_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC5_MAC_MII_EN		(1 << 2)
+#define S17_MAC5_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC5_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC5_PHY_MII_EN		(1 << 10)
+#define S17_MAC5_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC5_RGMII_RXCLK_SHIFT	20
+#define S17_MAC5_RGMII_TXCLK_SHIFT	22
+#define S17_MAC5_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC5_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC5_RGMII_EN		(1 << 26)
+
+#define S17_MAC6_MAC_MII_RXCLK_SEL	(1 << 0)
+#define S17_MAC6_MAC_MII_TXCLK_SEL	(1 << 1)
+#define S17_MAC6_MAC_MII_EN		(1 << 2)
+#define S17_MAC6_MAC_GMII_RXCLK_SEL	(1 << 4)
+#define S17_MAC6_MAC_GMII_TXCLK_SEL	(1 << 5)
+#define S17_MAC6_MAC_GMII_EN		(1 << 6)
+#define S17_MAC6_SGMII_EN		(1 << 7)
+#define S17_MAC6_PHY_MII_RXCLK_SEL	(1 << 8)
+#define S17_MAC6_PHY_MII_TXCLK_SEL	(1 << 9)
+#define S17_MAC6_PHY_MII_EN		(1 << 10)
+#define S17_MAC6_PHY_MII_PIPE_SEL	(1 << 11)
+#define S17_MAC6_PHY_GMII_RXCLK_SEL	(1 << 12)
+#define S17_MAC6_PHY_GMII_TXCLK_SEL	(1 << 13)
+#define S17_MAC6_PHY_GMII_EN		(1 << 14)
+#define S17_PHY4_GMII_EN		(1 << 16)
+#define S17_PHY4_RGMII_EN		(1 << 17)
+#define S17_PHY4_MII_EN			(1 << 18)
+#define S17_MAC6_RGMII_RXCLK_SHIFT	20
+#define S17_MAC6_RGMII_TXCLK_SHIFT	22
+#define S17_MAC6_RGMII_RXCLK_DELAY	(1 << 24)
+#define S17_MAC6_RGMII_TXCLK_DELAY	(1 << 25)
+#define S17_MAC6_RGMII_EN		(1 << 26)
+
+#define S17_SPEED_10M			(0 << 0)
+#define S17_SPEED_100M			(1 << 0)
+#define S17_SPEED_1000M			(2 << 0)
+#define S17_TXMAC_EN			(1 << 2)
+#define S17_RXMAC_EN			(1 << 3)
+#define S17_TX_FLOW_EN			(1 << 4)
+#define S17_RX_FLOW_EN			(1 << 5)
+#define S17_DUPLEX_FULL			(1 << 6)
+#define S17_DUPLEX_HALF			(0 << 6)
+#define S17_TX_HALF_FLOW_EN		(1 << 7)
+#define S17_LINK_EN			(1 << 9)
+#define S17_FLOW_LINK_EN		(1 << 12)
+#define S17_PORT_STATUS_DEFAULT		(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL | \
+                                        S17_TX_HALF_FLOW_EN)
+
+#define S17_PORT_STATUS_AZ_DEFAULT	(S17_SPEED_1000M | S17_TXMAC_EN | \
+                                        S17_RXMAC_EN | S17_TX_FLOW_EN | \
+                                        S17_RX_FLOW_EN | S17_DUPLEX_FULL)
+
+
+#define S17_HDRLENGTH_SEL		(1 << 16)
+#define S17_HDR_VALUE			0xAAAA
+
+#define S17_TXHDR_MODE_NO		0
+#define S17_TXHDR_MODE_MGM		1
+#define S17_TXHDR_MODE_ALL		2
+#define S17_RXHDR_MODE_NO		(0 << 2)
+#define S17_RXHDR_MODE_MGM		(1 << 2)
+#define S17_RXHDR_MODE_ALL		(2 << 2)
+
+#define S17_CPU_PORT_EN			(1 << 10)
+#define S17_PPPOE_REDIR_EN		(1 << 8)
+#define S17_MIRROR_PORT_SHIFT		4
+#define S17_IGMP_COPY_EN		(1 << 3)
+#define S17_RIP_COPY_EN			(1 << 2)
+#define S17_EAPOL_REDIR_EN		(1 << 0)
+
+#define S17_IGMP_JOIN_LEAVE_DP_SHIFT	24
+#define S17_BROAD_DP_SHIFT		16
+#define S17_MULTI_FLOOD_DP_SHIFT	8
+#define S17_UNI_FLOOD_DP_SHIFT		0
+#define S17_IGMP_JOIN_LEAVE_DPALL	(0x7f << S17_IGMP_JOIN_LEAVE_DP_SHIFT)
+#define S17_BROAD_DPALL			(0x7f << S17_BROAD_DP_SHIFT)
+#define S17_MULTI_FLOOD_DPALL		(0x7f << S17_MULTI_FLOOD_DP_SHIFT)
+#define S17_UNI_FLOOD_DPALL		(0x7f << S17_UNI_FLOOD_DP_SHIFT)
+
+#define S17_PWS_CHIP_AR8327             (1 << 30)
+
+/* S17_PHY_CONTROL fields */
+#define S17_CTRL_SOFTWARE_RESET                    0x8000
+#define S17_CTRL_SPEED_LSB                         0x2000
+#define S17_CTRL_AUTONEGOTIATION_ENABLE            0x1000
+#define S17_CTRL_RESTART_AUTONEGOTIATION           0x0200
+#define S17_CTRL_SPEED_FULL_DUPLEX                 0x0100
+#define S17_CTRL_SPEED_MSB                         0x0040
+
+/* For EEE_CTRL_REG */
+#define S17_LPI_DISABLE_P1		     (1 << 4)
+#define S17_LPI_DISABLE_P2		     (1 << 6)
+#define S17_LPI_DISABLE_P3		     (1 << 8)
+#define S17_LPI_DISABLE_P4		     (1 << 10)
+#define S17_LPI_DISABLE_P5		     (1 << 12)
+#define S17_LPI_DISABLE_ALL		     0x1550
+
+/* For MMD register control */
+#define S17_MMD_FUNC_ADDR			(0 << 14)
+#define S17_MMD_FUNC_DATA			(1 << 14)
+#define S17_MMD_FUNC_DATA_2			(2 << 14)
+#define S17_MMD_FUNC_DATA_3			(3 << 14)
+
+/* For phyInfo_t azFeature */
+#define S17_8023AZ_PHY_ENABLED			(1 << 0)
+#define S17_8023AZ_PHY_LINKED                   (1 << 1)
+
+/* Queue Management registe fields */
+#define S17_HOL_CTRL0_LAN		0x2a008888 /* egress priority 8, eg_portq = 0x2a */
+#define S17_HOL_CTRL0_WAN		0x2a666666 /* egress priority 6, eg_portq = 0x2a */
+#define S17_HOL_CTRL1_DEFAULT		0xc6	   /* enable HOL control */
+
+/* Packet Edit register fields */
+#define S17_ROUTER_EG_UNMOD		0x0	/* unmodified */
+#define S17_ROUTER_EG_WOVLAN		0x1	/* without VLAN */
+#define S17_ROUTER_EG_WVLAN		0x2	/* with VLAN */
+#define S17_ROUTER_EG_UNTOUCH		0x3	/* untouched */
+#define S17_ROUTER_EG_MODE_DEFAULT	0x01111111 /* all ports without VLAN */
+
+#define S17_RESET_DONE(phy_control)                   \
+    (((phy_control) & (S17_CTRL_SOFTWARE_RESET)) == 0)
+
+/* Phy status fields */
+#define S17_STATUS_AUTO_NEG_DONE                   0x0020
+
+#define S17_AUTONEG_DONE(ip_phy_status)                   \
+    (((ip_phy_status) &                                  \
+        (S17_STATUS_AUTO_NEG_DONE)) ==                    \
+        (S17_STATUS_AUTO_NEG_DONE))
+
+/* Link Partner ability */
+#define S17_LINK_100BASETX_FULL_DUPLEX       0x0100
+#define S17_LINK_100BASETX                   0x0080
+#define S17_LINK_10BASETX_FULL_DUPLEX        0x0040
+#define S17_LINK_10BASETX                    0x0020
+
+/* Advertisement register. */
+#define S17_ADVERTISE_NEXT_PAGE              0x8000
+#define S17_ADVERTISE_ASYM_PAUSE             0x0800
+#define S17_ADVERTISE_PAUSE                  0x0400
+#define S17_ADVERTISE_100FULL                0x0100
+#define S17_ADVERTISE_100HALF                0x0080
+#define S17_ADVERTISE_10FULL                 0x0040
+#define S17_ADVERTISE_10HALF                 0x0020
+
+#define S17_ADVERTISE_ALL (S17_ADVERTISE_ASYM_PAUSE | S17_ADVERTISE_PAUSE | \
+                            S17_ADVERTISE_10HALF | S17_ADVERTISE_10FULL | \
+                            S17_ADVERTISE_100HALF | S17_ADVERTISE_100FULL)
+
+/* 1000BASET_CONTROL */
+#define S17_ADVERTISE_1000FULL               0x0200
+
+/* Phy Specific status fields */
+#define S17_STATUS_LINK_MASK                0xC000
+#define S17_STATUS_LINK_SHIFT               14
+#define S17_STATUS_FULL_DEPLEX              0x2000
+#define S17_STATUS_LINK_PASS                 0x0400
+#define S17_STATUS_RESOLVED                  0x0800
+#define S17_STATUS_LINK_10M			 0
+#define S17_STATUS_LINK_100M			 1
+#define S17_STATUS_LINK_1000M			 2
+
+#define S17_GLOBAL_INT_PHYMASK		     (1 << 15)
+
+#define S17_PHY_LINK_UP		     0x400
+#define S17_PHY_LINK_DOWN		     0x800
+#define S17_PHY_LINK_DUPLEX_CHANGE	     0x2000
+#define S17_PHY_LINK_SPEED_CHANGE	     0x4000
+
+/* For Port flow control registers */
+#define S17_PORT_FLCTL_XON_DEFAULT		(0x3a << 16)
+#define S17_PORT_FLCTL_XOFF_DEFAULT		(0x4a)
+
+/* Module enable Register */
+#define S17_MODULE_L3_EN		(1 << 2)
+#define S17_MODULE_ACL_EN		(1 << 1)
+#define S17_MODULE_MIB_EN		(1 << 0)
+
+/* MIB Function Register 1 */
+#define S17_MIB_FUNC_ALL		(3 << 24)
+#define S17_MIB_CPU_KEEP		(1 << 20)
+#define S17_MIB_BUSY			(1 << 17)
+#define S17_MIB_AT_HALF_EN		(1 << 16)
+#define S17_MIB_TIMER_DEFAULT		0x100
+
+#define S17_MAC_MAX			7
+
+
+#ifndef BOOL
+#define BOOL    int
+#endif
+
+/*add feature define here*/
+//#define FULL_FEATURE
+
+#ifdef CONFIG_AR7242_S17_PHY
+#undef HEADER_REG_CONF
+#undef HEADER_EN
+#endif
+
+void athrs17_reg_init(void);
+int athrs17_phy_is_up(int unit);
+int athrs17_phy_is_fdx(int unit);
+int athrs17_phy_speed(int unit);
+BOOL athrs17_phy_setup(int unit);
+
+#endif
diff --git a/board/atheros/common/athrs_ar8033_phy.h b/board/atheros/common/athrs_ar8033_phy.h
new file mode 100644
index 0000000000..8d9b383b21
--- /dev/null
+++ b/board/atheros/common/athrs_ar8033_phy.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2010, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS_8033_PHY_H
+#define _ATHRS_8033_PHY_H
+
+#define BOOL int
+
+
+/* Phy Specific status fields */
+#define ATHER_STATUS_LINK_MASK                0xC000
+#define ATHER_STATUS_LINK_SHIFT               14
+#define ATHER_STATUS_FULL_DEPLEX              0x2000
+#define ATHR_STATUS_LINK_PASS                 0x0400
+#define ATHR_LATCH_LINK_PASS                  0x0004
+
+/* Advertisement register. */
+#define ATHR_ADVERTISE_NEXT_PAGE              0x8000
+#define ATHR_ADVERTISE_ASYM_PAUSE             0x0800
+#define ATHR_ADVERTISE_PAUSE                  0x0400
+#define ATHR_ADVERTISE_100FULL                0x0100
+#define ATHR_ADVERTISE_100HALF                0x0080
+#define ATHR_ADVERTISE_10FULL                 0x0040
+#define ATHR_ADVERTISE_10HALF                 0x0020
+
+#define ATHR_ADVERTISE_ALL (ATHR_ADVERTISE_ASYM_PAUSE | ATHR_ADVERTISE_PAUSE | \
+                            ATHR_ADVERTISE_10HALF | ATHR_ADVERTISE_10FULL | \
+                            ATHR_ADVERTISE_100HALF | ATHR_ADVERTISE_100FULL)
+
+
+#ifdef ATH_MDC_GPIO
+#define ATH_GPIO	14
+#define GPIO_FUNCTION4_MASK	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK)
+
+#define GPIO_FUNCTION4_ENABLE	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20))
+
+
+
+#else
+#define GPIO_FUNCTION4_MASK	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |\
+		 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK)
+
+#define GPIO_FUNCTION4_ENABLE	(GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) | \
+			 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21))
+
+#define ATH_GPIO	19
+#endif
+
+#define ATH_GPIO17	17
+
+/*
+ *  Atheros header defines
+ */
+#ifndef _ATH_HEADER_CONF
+#define _ATH_HEADER_CONF
+
+
+
+#define ATHR_HEADER_LEN 2
+
+typedef enum {
+    NORMAL_PACKET,
+    RESERVED0,
+    MIB_1ST,
+    RESERVED1,
+    RESERVED2,
+    READ_WRITE_REG,
+    READ_WRITE_REG_ACK,
+    RESERVED3
+} AT_HEADER_TYPE;
+
+#endif // _ATH_HEADER_CONF
+
+#endif
diff --git a/board/atheros/common/athrs_vir_phy.c b/board/atheros/common/athrs_vir_phy.c
new file mode 100644
index 0000000000..b2f9b5e317
--- /dev/null
+++ b/board/atheros/common/athrs_vir_phy.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define MODULE_NAME "ATHRS_VIR_PHY"
+
+#define TRUE    1
+#define FALSE   0
+#define BOOL	int
+
+/* Forward references */
+BOOL athr_vir_phy_is_link_alive(int phyUnit);
+
+
+/******************************************************************************
+*
+* athr_vir_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_vir_phy_is_link_alive(int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_vir_phy_setup(int ethUnit)
+{
+    return 0;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_vir_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    return TRUE;
+}
+
+/******************************************************************************
+*
+* athr_vir_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_vir_phy_speed(int ethUnit,int phyUnit)
+{
+    return _1000BASET;
+}
+
+/*****************************************************************************
+*
+* athr_vir_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_vir_phy_is_up(int ethUnit)
+{
+    return 1;
+
+}
+/* Place holders */
+
+int
+athr_vir_reg_init(void *arg)
+{
+   return 0;
+}
diff --git a/board/atheros/common/athrsf1_phy.c b/board/atheros/common/athrsf1_phy.c
new file mode 100755
index 0000000000..598fc91123
--- /dev/null
+++ b/board/atheros/common/athrsf1_phy.c
@@ -0,0 +1,433 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <config.h>
+#include <linux/types.h>
+#include <common.h>
+#include <miiphy.h>
+#include "phy.h"
+#include <asm/addrspace.h>
+#include "ar7240_soc.h"
+#include "athrsf1_phy.h"
+
+#define MODULE_NAME "ATHRSF1_PHY"
+
+#define ATHR_LAN_PORT_VLAN          1
+#define ATHR_WAN_PORT_VLAN          2
+#define ENET_UNIT_LAN 1
+#define ENET_UNIT_WAN 0
+
+#define TRUE    1
+#define FALSE   0
+
+#define ATHR_PHY_MAX 5
+#define ATHR_PHY0_ADDR   0x0
+#define ATHR_PHY1_ADDR   0x1
+#define ATHR_PHY2_ADDR   0x2
+#define ATHR_PHY3_ADDR   0x3
+#define ATHR_PHY4_ADDR   0x4
+
+#define ATHR_DEBUG_PORT_ADDRESS          29
+#define ATHR_DEBUG_PORT_DATA             30
+
+/*
+ * Track per-PHY port information.
+ */
+typedef struct {
+    BOOL   isEnetPort;       /* normal enet port */
+    BOOL   isPhyAlive;       /* last known state of link */
+    int    ethUnit;          /* MAC associated with this phy port */
+    uint32_t phyBase;
+    uint32_t phyAddr;          /* PHY registers associated with this phy port */
+    uint32_t VLANTableSetting; /* Value to be written to VLAN table */
+} athrPhyInfo_t;
+
+/*
+ * Per-PHY information, indexed by PHY unit number.
+ */
+
+static athrPhyInfo_t athrPhyInfo[] = {
+
+    {TRUE,   /* port 1 -- LAN port 1 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 2 -- LAN port 2 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY1_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 3 -- LAN port 3 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY2_ADDR,
+     ATHR_LAN_PORT_VLAN
+    },
+
+    {TRUE,   /* port 4 --  LAN port 4 */
+     FALSE,
+     ENET_UNIT_LAN,
+     0,
+     ATHR_PHY3_ADDR,
+     ATHR_LAN_PORT_VLAN   /* Send to all ports */
+    },
+
+    {TRUE,  /* port 5 -- WAN Port 5 */
+     FALSE,
+     ENET_UNIT_WAN,
+     0,
+     ATHR_PHY0_ADDR,
+     ATHR_LAN_PORT_VLAN    /* Send to all ports */
+    },
+
+    {FALSE,   /* port 0 -- cpu port 0 */
+     TRUE,
+     ENET_UNIT_LAN,
+     0,
+     0x00,
+     ATHR_LAN_PORT_VLAN
+    },
+
+};
+
+#define ATHR_IS_ENET_PORT(phyUnit) (athrPhyInfo[phyUnit].isEnetPort)
+#define ATHR_IS_PHY_ALIVE(phyUnit) (athrPhyInfo[phyUnit].isPhyAlive)
+#define ATHR_ETHUNIT(phyUnit) (athrPhyInfo[phyUnit].ethUnit)
+#define ATHR_PHYBASE(phyUnit) (athrPhyInfo[phyUnit].phyBase)
+#define ATHR_PHYADDR(phyUnit) (athrPhyInfo[phyUnit].phyAddr)
+#define ATHR_VLAN_TABLE_SETTING(phyUnit) (athrPhyInfo[phyUnit].VLANTableSetting)
+
+#define ATHR_IS_ETHUNIT(phyUnit, ethUnit) \
+            (ATHR_IS_ENET_PORT(phyUnit) &&        \
+            ATHR_ETHUNIT(phyUnit) == (ethUnit))
+
+#define ATHR_IS_WAN_PORT(phyUnit) (!(ATHR_ETHUNIT(phyUnit)==ENET_UNIT_LAN))
+
+/* Forward references */
+BOOL athr_phy_is_link_alive(int phyUnit);
+unsigned int last_phy_speed;
+
+void athr_enable_linkIntrs(int ethUnit)
+{
+    return;
+}
+
+void athr_disable_linkIntrs(int ethUnit)
+{
+	return;
+}
+void athr_auto_neg(int ethUnit,int phyUnit)
+{
+    int timeout = 0;
+    uint16_t phyHwStatus;
+
+    if(!is_emu()) {
+#if 0
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL, ATHR_ADVERTISE_1000FULL);
+#endif
+
+       printf("ATHR_AUTONEG_ADVERT:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_AUTONEG_ADVERT));
+       printf("ATHR_1000BASET_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_1000BASET_CONTROL));
+       printf("ATHR_PHY_CONTROL:%X\n",phy_reg_read(ethUnit, phyUnit,ATHR_PHY_CONTROL));
+    }
+    else {
+       phy_reg_write(ethUnit, phyUnit , ATHR_AUTONEG_ADVERT, ATHR_ADVERTISE_ALL);
+       /* Do not advertise 1000 */
+       phy_reg_write(ethUnit, phyUnit , ATHR_1000BASET_CONTROL,0x0);
+       phy_reg_write(ethUnit, phyUnit , ATHR_PHY_CONTROL, ATHR_CTRL_AUTONEGOTIATION_ENABLE | ATHR_CTRL_SOFTWARE_RESET);
+    }
+
+   /*
+     * Wait up to 3 seconds for ALL associated PHYs to finish
+     * autonegotiation.  The only way we get out of here sooner is
+     * if ALL PHYs are connected AND finish autonegotiation.
+     */
+    timeout=20;
+    for (;;) {
+        phyHwStatus = phy_reg_read(ethUnit, phyUnit, ATHR_PHY_CONTROL);
+
+        if (ATHR_RESET_DONE(phyHwStatus)) {
+            printf(MODULE_NAME": Port %d, Neg Success\n", phyUnit);
+            break;
+        }
+        if (timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+        if (--timeout == 0) {
+            printf(MODULE_NAME": Port %d, Negogiation timeout\n", phyUnit);
+            break;
+        }
+
+        mdelay(150);
+    }
+
+    printf(MODULE_NAME": unit %d phy addr %x ", ethUnit, phyUnit);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_link_alive - test to see if the specified link is alive
+*
+* RETURNS:
+*    TRUE  --> link is alive
+*    FALSE --> link is down
+*/
+BOOL
+athr_phy_is_link_alive(int phyUnit)
+{
+	uint16_t phyHwStatus;
+	uint32_t phyBase;
+	uint32_t phyAddr;
+
+	phyBase = ATHR_PHYBASE(phyUnit);
+	phyAddr = ATHR_PHYADDR(phyUnit);
+	phyHwStatus = phy_reg_read(0, phyAddr, ATHR_PHY_SPEC_STATUS);
+
+	if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_setup - reset and setup the PHY associated with
+* the specified MAC unit number.
+*
+* Resets the associated PHY port.
+*
+* RETURNS:
+*    TRUE  --> associated PHY is alive
+*    FALSE --> no LINKs on this ethernet unit
+*/
+
+BOOL
+athr_phy_setup(int ethUnit)
+{
+	int       phyUnit = 0;
+	int       liveLinks = 0;
+
+	athr_auto_neg(ethUnit,phyUnit);
+
+	if (athr_phy_is_link_alive(phyUnit)) {
+		liveLinks++;
+		ATHR_IS_PHY_ALIVE(phyUnit) = TRUE;
+	} else {
+		ATHR_IS_PHY_ALIVE(phyUnit) = FALSE;
+	}
+	return (liveLinks > 0);
+}
+
+/******************************************************************************
+*
+* athr_phy_is_fdx - Determines whether the phy ports associated with the
+* specified device are FULL or HALF duplex.
+*
+* RETURNS:
+*    1 --> FULL
+*    0 --> HALF
+*/
+int
+athr_phy_is_fdx(int ethUnit,int phyUnit)
+{
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    uint16_t  phyHwStatus;
+    int       ii = 200;
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+         phyBase = ATHR_PHYBASE(phyUnit);
+         phyAddr = ATHR_PHYADDR(phyUnit);
+
+         do {
+                phyHwStatus = phy_reg_read(ethUnit, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+                mdelay(10);
+          } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+          if (phyHwStatus & ATHER_STATUS_FULL_DUPLEX) {
+                return TRUE;
+          }
+    }
+    return FALSE;
+}
+
+/******************************************************************************
+*
+* athr_phy_speed - Determines the speed of phy ports associated with the
+* specified device.
+*
+* RETURNS:
+*               AG7240_PHY_SPEED_10T, AG7240_PHY_SPEED_100T;
+*               AG7240_PHY_SPEED_1000T;
+*/
+
+int
+athr_phy_speed(int ethUnit,int phyUnit)
+{
+    uint16_t  phyHwStatus;
+    uint32_t  phyBase;
+    uint32_t  phyAddr;
+    int       ii = 200;
+
+
+    if (athr_phy_is_link_alive(phyUnit)) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+        do {
+            phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+            mdelay(10);
+        } while((!(phyHwStatus & ATHR_STATUS_RESOVLED)) && --ii);
+
+        phyHwStatus = ((phyHwStatus & ATHER_STATUS_LINK_MASK) >>
+                       ATHER_STATUS_LINK_SHIFT);
+
+        switch(phyHwStatus) {
+        case 0:
+	    if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _10BASET;
+        case 1:
+	     if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x147);
+                last_phy_speed = phyHwStatus;
+            }
+            return _100BASET;
+        case 2:
+	      if (last_phy_speed != phyHwStatus) {
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_ADDRESS, 0x5);
+                phy_reg_write(0, phyAddr, ATHR_DEBUG_PORT_DATA, 0x0);
+                last_phy_speed = phyHwStatus;
+             }
+            return _1000BASET;
+        default:
+            printf("Unkown speed read!\n");
+        }
+    }
+
+      if (last_phy_speed != phyHwStatus)
+	{
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_ADDRESS, 0x0);
+        phy_reg_write(0, ATHR_PHYADDR(phyUnit), ATHR_DEBUG_PORT_DATA, 0x14e);
+        last_phy_speed = phyHwStatus;
+     }
+
+
+    //printf("athr_phy_speed: link down, returning 10t\n");
+    return _10BASET;
+}
+
+/*****************************************************************************
+*
+* athr_phy_is_up -- checks for significant changes in PHY state.
+*
+* A "significant change" is:
+*     dropped link (e.g. ethernet cable unplugged) OR
+*     autonegotiation completed + link (e.g. ethernet cable plugged in)
+*
+* When a PHY is plugged in, phyLinkGained is called.
+* When a PHY is unplugged, phyLinkLost is called.
+*/
+
+int
+athr_phy_is_up(int ethUnit)
+{
+    int           phyUnit;
+    uint16_t      phyHwStatus, phyHwControl;
+    athrPhyInfo_t *lastStatus;
+    int           linkCount   = 0;
+    int           lostLinks   = 0;
+    int           gainedLinks = 0;
+    uint32_t      phyBase;
+    uint32_t      phyAddr;
+
+    for (phyUnit=0; phyUnit < 1; phyUnit++) {
+
+        phyBase = ATHR_PHYBASE(phyUnit);
+        phyAddr = ATHR_PHYADDR(phyUnit);
+
+        lastStatus = &athrPhyInfo[phyUnit];
+
+        if (lastStatus->isPhyAlive) { /* last known link status was ALIVE */
+
+             phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+            /* See if we've lost link */
+            if (phyHwStatus & ATHR_STATUS_LINK_PASS) { /* check realtime link */
+                linkCount++;
+            } else {
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+            /* If realtime failed check link in latch register before
+	     * asserting link down.
+             */
+                if (phyHwStatus & ATHR_LATCH_LINK_PASS)
+                   linkCount++;
+		else
+                    lostLinks++;
+                lastStatus->isPhyAlive = FALSE;
+            }
+        } else { /* last known link status was DEAD */
+
+            /* Check for reset complete */
+
+                phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_STATUS);
+
+            if (!ATHR_RESET_DONE(phyHwStatus))
+                continue;
+
+                phyHwControl = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_CONTROL);
+
+            /* Check for AutoNegotiation complete */
+
+            if ((!(phyHwControl & ATHR_CTRL_AUTONEGOTIATION_ENABLE))
+                 || ATHR_AUTONEG_DONE(phyHwStatus)) {
+                    phyHwStatus = phy_reg_read(0, ATHR_PHYADDR(phyUnit),ATHR_PHY_SPEC_STATUS);
+
+                    if (phyHwStatus & ATHR_STATUS_LINK_PASS) {
+                        gainedLinks++;
+                        linkCount++;
+                        lastStatus->isPhyAlive = TRUE;
+                   }
+            }
+        }
+    }
+    return (linkCount);
+
+}
+/* Place holders */
+
+int
+athr_reg_init(void *arg)
+{
+   return 0;
+}
diff --git a/board/atheros/common/athrsf1_phy.h b/board/atheros/common/athrsf1_phy.h
new file mode 100755
index 0000000000..4495d94f76
--- /dev/null
+++ b/board/atheros/common/athrsf1_phy.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2008, Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ATHRS26_RGMII_H
+#define _ATHRS26_RGMII_H
+#define BOOL int
+#include "athr_s27_phy.h"
+int athr_phy_is_up(int unit);
+int athr_phy_is_fdx(int unit,int phyUnit);
+int athr_phy_speed(int unit,int phyUnit);
+BOOL athr_phy_setup(int unit);
+BOOL athr_phy_is_link_alive(int phyUnit);
+#endif
diff --git a/board/atheros/common/init-953x.c b/board/atheros/common/init-953x.c
new file mode 100755
index 0000000000..4f06ae3c27
--- /dev/null
+++ b/board/atheros/common/init-953x.c
@@ -0,0 +1,381 @@
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+#define CFG_DDR2_SCORPION_CAS_LATENCY	4
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_SCORPION_CAS_LATENCY == 4
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x143
+#define CFG_DDR2_MODE_VAL			0x43
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000167d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_SCORPION_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xb) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x153
+#define CFG_DDR2_MODE_VAL			0x53
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00001e7d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#endif
+
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x5) | \
+						DDR_CONFIG_TRFC_SET(0x7) | \
+						DDR_CONFIG_TRRD_SET(0x4) | \
+						DDR_CONFIG_TRP_SET(0x6) | \
+						DDR_CONFIG_TRCD_SET(0x6) | \
+						DDR_CONFIG_TRAS_SET(0x10)
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0xe) | \
+						DDR_CONFIG2_TRTP_SET(0x8) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xd) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x0
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x20
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+	prmsg("Honey Bee 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+		prmsg("16");
+		ctl_config =	CFG_DDR_CTL_CONFIG |
+				CPU_DDR_SYNC_MODE |
+				DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+				DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		prmsg("16");
+		cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+
+		ctl_config =	CFG_DDR_CTL_CONFIG |
+				CPU_DDR_SYNC_MODE |
+				DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("bit) ddr1 init\n");
+
+		break;
+	}
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x4);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, 0x782);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+
+        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+#ifdef CFG_TRAVEL_ROUTER
+	ath_reg_wr(PMU1_ADDRESS, 0x633c8168);
+#else
+	ath_reg_wr(PMU1_ADDRESS, 0x633c8178);
+#endif
+
+
+	// Set DDR2 Voltage to 1.8 volts
+	ath_reg_wr(PMU2_ADDRESS, PMU2_SWREGMSB_SET(0x40) | PMU2_PGM_SET(0x1));
+	return type;
+#else	// !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	//if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+	//	return 40 * 1000 * 1000;
+	//} else {
+		return 25 * 1000 * 1000;
+	//}
+}
+
+void
+ath_sys_frequency(uint32_t *cpu, uint32_t *ddr, uint32_t *ahb)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t pll, out_div, ref_div, nint, frac, clk_ctrl;
+#endif
+	uint32_t ref;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+
+	if (ath_cpu_freq)
+		goto done;
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	prmsg("%s: ", __func__);
+
+	clk_ctrl = ath_reg_rd(ATH_DDR_CLK_CTRL);
+
+	pll = ath_reg_rd(ATH_PLL_CONFIG);
+	out_div	= CPU_PLL_CONFIG_OUTDIV_GET(pll);
+	ref_div	= CPU_PLL_CONFIG_REFDIV_GET(pll);
+	nint	= CPU_PLL_CONFIG_NINT_GET(pll);
+	frac	= CPU_PLL_CONFIG_NFRAC_GET(pll);
+	pll = ref >> 6;
+	frac	= frac * pll / ref_div;
+	prmsg("cpu apb ");
+	ath_cpu_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(clk_ctrl) + 1);
+
+	pll = ath_reg_rd(ATH_DDR_PLL_CONFIG);
+	out_div	= DDR_PLL_CONFIG_OUTDIV_GET(pll);
+	ref_div	= DDR_PLL_CONFIG_REFDIV_GET(pll);
+	nint	= DDR_PLL_CONFIG_NINT_GET(pll);
+	frac	= DDR_PLL_CONFIG_NFRAC_GET(pll);
+	pll = ref >> 10;
+	frac	= frac * pll / ref_div;
+	prmsg("ddr apb ");
+	ath_ddr_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(clk_ctrl) + 1);
+
+	if (CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ath_ahb_freq = ath_ddr_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	} else {
+		ath_ahb_freq = ath_cpu_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	}
+#endif
+	prmsg("cpu %u ddr %u ahb %u\n",
+		ath_cpu_freq / 1000000,
+		ath_ddr_freq / 1000000,
+		ath_ahb_freq / 1000000);
+done:
+	*cpu = ath_cpu_freq;
+	*ddr = ath_ddr_freq;
+	*ahb = ath_ahb_freq;
+}
diff --git a/board/atheros/common/init-955x.c b/board/atheros/common/init-955x.c
new file mode 100644
index 0000000000..93b2c1b0e5
--- /dev/null
+++ b/board/atheros/common/init-955x.c
@@ -0,0 +1,458 @@
+#include <common.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+#define ATH_MAX_DDR_SIZE		(256 * 1024 * 1024)
+#define ATH_DDR_SIZE_INCR		(4 * 1024 * 1024)
+
+int
+ath_ddr_find_size(void)
+{
+	uint8_t  *p = (uint8_t *)KSEG1, pat = 0x77;
+	int i;
+
+#define max_i		(ATH_MAX_DDR_SIZE / ATH_DDR_SIZE_INCR)
+
+	*p = pat;
+
+	/*
+	 * DDR wraps around. Write a pattern to 0x0000_0000. Write an
+	 * address pattern at 4M, 8M, 16M etc. and check when
+	 * 0x0000_0000 gets overwritten.
+	 */
+	for(i = 1; (i < max_i); i++) {
+		*(p + i * ATH_DDR_SIZE_INCR) = (uint8_t)(i);
+		if (*p != pat) {
+			break;
+		}
+	}
+
+	return ((i < max_i) ? (i * ATH_DDR_SIZE_INCR) : ATH_MAX_DDR_SIZE);
+}
+
+inline int
+ath_ram_type(uint32_t bs)
+{
+	if (RST_BOOTSTRAP_DDR_SELECT_GET(bs)) {
+		return ATH_MEM_DDR1;
+	} else {
+		return ATH_MEM_DDR2;
+	}
+}
+
+#define CFG_DDR2_SCORPION_CAS_LATENCY	4
+
+#ifdef CONFIG_TB614
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x1)
+#else
+#	define DDR_CONFIG2_SWAP_A26_A27_VAL	(0x0)
+#endif
+
+#if CFG_DDR2_SCORPION_CAS_LATENCY == 4
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x1) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x8) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x143
+#define CFG_DDR2_MODE_VAL			0x43
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x0000167d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+
+#elif CFG_DDR2_SCORPION_CAS_LATENCY == 5
+
+#define CFG_DDR2_CONFIG_VAL			DDR_CONFIG_CAS_LATENCY_MSB_SET(0x1) | \
+						DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x4) | \
+						DDR_CONFIG_TMRD_SET(0xf) | \
+						DDR_CONFIG_TRFC_SET(0x15) | \
+						DDR_CONFIG_TRRD_SET(0x7) | \
+						DDR_CONFIG_TRP_SET(0x9) | \
+						DDR_CONFIG_TRCD_SET(0x9) | \
+						DDR_CONFIG_TRAS_SET(0x1b)
+
+#define CFG_DDR2_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_SWAP_A26_A27_SET(DDR_CONFIG2_SWAP_A26_A27_VAL) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0xb) | \
+						DDR_CONFIG2_TWTR_SET(0x15) | \
+						DDR_CONFIG2_TRTP_SET(0x9) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0x1) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+
+#define CFG_DDR2_CONFIG3_VAL			0x0000000a
+#define CFG_DDR2_EXT_MODE_VAL			0x402
+#define CFG_DDR2_MODE_VAL_INIT			0x153
+#define CFG_DDR2_MODE_VAL			0x53
+#define CFG_DDR2_TAP_VAL			0x10
+#define CFG_DDR2_EN_TWL_VAL			0x00001e7d
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#endif
+
+#define CFG_DDR1_CONFIG_VAL			DDR_CONFIG_OPEN_PAGE_SET(0x1) | \
+						DDR_CONFIG_CAS_LATENCY_SET(0x7) | \
+						DDR_CONFIG_TMRD_SET(0x5) | \
+						DDR_CONFIG_TRFC_SET(0x7) | \
+						DDR_CONFIG_TRRD_SET(0x4) | \
+						DDR_CONFIG_TRP_SET(0x6) | \
+						DDR_CONFIG_TRCD_SET(0x6) | \
+						DDR_CONFIG_TRAS_SET(0x10)
+
+#define CFG_DDR1_CONFIG2_VAL			DDR_CONFIG2_HALF_WIDTH_LOW_SET(0x1) | \
+						DDR_CONFIG2_GATE_OPEN_LATENCY_SET(0x6) | \
+						DDR_CONFIG2_TWTR_SET(0xe) | \
+						DDR_CONFIG2_TRTP_SET(0x8) | \
+						DDR_CONFIG2_TRTW_SET(0xe) | \
+						DDR_CONFIG2_TWR_SET(0xd) | \
+						DDR_CONFIG2_CKE_SET(0x1) | \
+						DDR_CONFIG2_CNTL_OE_EN_SET(0x1) | \
+						DDR_CONFIG2_BURST_LENGTH_SET(0x8)
+#define CFG_DDR1_CONFIG3_VAL			0x0
+#define CFG_DDR1_EXT_MODE_VAL			0x0
+#define CFG_DDR1_MODE_VAL_INIT			0x133
+#define CFG_DDR1_MODE_VAL			0x33
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16	0xffff
+#define CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32	0xff
+#define CFG_DDR1_TAP_VAL			0x20
+
+#define CFG_DDR_CTL_CONFIG			DDR_CTL_CONFIG_SRAM_TSEL_SET(0x1) | \
+						DDR_CTL_CONFIG_GE0_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_GE1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_USB_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_PCIE_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_WMAC_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC1_SRAM_SYNC_SET(0x1) | \
+						DDR_CTL_CONFIG_MISC_SRC2_SRAM_SYNC_SET(0x1)
+
+int /* ram type */
+ath_ddr_initial_config(uint32_t refresh)
+{
+#if !defined(CONFIG_ATH_NAND_BR) && !defined(CONFIG_ATH_EMULATION)
+	int		ddr_config, ddr_config2, ddr_config3, ext_mod, mod_val,
+			mod_val_init, cycle_val, tap_val, type, ctl_config;
+	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
+	uint32_t	bootstrap;
+
+	prmsg("\nsri\n");
+	prmsg("Scorpion 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+
+	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
+
+	switch(type = ath_ram_type(bootstrap)) {
+	case ATH_MEM_DDR2:
+		ddr_config	= CFG_DDR2_CONFIG_VAL;
+		ddr_config2	= CFG_DDR2_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR2_CONFIG3_VAL;
+		ext_mod		= CFG_DDR2_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR2_MODE_VAL_INIT;
+		mod_val		= CFG_DDR2_MODE_VAL;
+		tap_val		= CFG_DDR2_TAP_VAL;
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);
+		udelay(10);
+		prmsg("%s(%d): (", __func__, __LINE__);
+
+		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+			prmsg("32");
+			ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1);
+
+			cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_32;
+		} else {
+			prmsg("16");
+			ctl_config =	CFG_DDR_CTL_CONFIG |
+					DDR_CTL_CONFIG_PAD_DDR2_SEL_SET(0x1) |
+					DDR_CTL_CONFIG_HALF_WIDTH_SET(0x1);
+
+			cycle_val = CFG_DDR2_RD_DATA_THIS_CYCLE_VAL_16;
+		}
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+
+		prmsg("bit) ddr2 init\n");
+		udelay(10);
+		break;
+	case ATH_MEM_DDR1:
+		ddr_config	= CFG_DDR1_CONFIG_VAL;
+		ddr_config2	= CFG_DDR1_CONFIG2_VAL;
+		ddr_config3	= CFG_DDR1_CONFIG3_VAL;
+		ext_mod		= CFG_DDR1_EXT_MODE_VAL;
+		mod_val_init	= CFG_DDR1_MODE_VAL_INIT;
+		mod_val		= CFG_DDR1_MODE_VAL;
+		tap_val		= CFG_DDR1_TAP_VAL;
+
+		prmsg("%s(%d): (", __func__, __LINE__);
+		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+			prmsg("32");
+                        ctl_config = CFG_DDR_CTL_CONFIG;
+			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32;
+		} else {
+			prmsg("16");
+			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
+                        ctl_config = 0;
+		}
+
+		ctl_config |= CPU_DDR_SYNC_MODE;
+
+		ath_reg_wr_nf(DDR_CTL_CONFIG_ADDRESS, ctl_config);
+		udelay(10);
+		prmsg("bit) ddr1 init\n");
+
+		break;
+	}
+#if 0
+	if (*pll == PLL_MAGIC) {
+		uint32_t cas = pll[5];
+		if (cas == 3 || cas == 4) {
+			cas = (cas * 2) + 2;
+			ddr_config &= ~(DDR_CONFIG_CAS_LATENCY_MSB_MASK |
+					DDR_CONFIG_CAS_LATENCY_MASK);
+			ddr_config |= DDR_CONFIG_CAS_LATENCY_SET(cas & 0x7) |
+				DDR_CONFIG_CAS_LATENCY_MSB_SET((cas >> 3) & 1);
+
+			cas = pll[5];
+
+			ddr_config2 &= ~DDR_CONFIG2_GATE_OPEN_LATENCY_MASK;
+			ddr_config2 |= DDR_CONFIG2_GATE_OPEN_LATENCY_SET((2 * cas) + 1);
+
+			if (type == ATH_MEM_DDR2) {
+				uint32_t tmp;
+				tmp = ath_reg_rd(DDR2_CONFIG_ADDRESS);
+				tmp &= ~DDR2_CONFIG_DDR2_TWL_MASK;
+				tmp |= DDR2_CONFIG_DDR2_TWL_SET(cas == 3 ? 3 : 5);
+				ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, tmp);
+			}
+
+			mod_val = (cas == 3 ? 0x33 : 0x43);
+			mod_val_init = 0x100 | mod_val;
+		}
+	}
+#endif
+
+	ath_reg_wr_nf(DDR_RD_DATA_THIS_CYCLE_ADDRESS, cycle_val);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST_ADDRESS, 0x74444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_BURST2_ADDRESS, 0x44444444);
+	udelay(100);
+	ath_reg_wr_nf(DDR_AHB_MASTER_TIMEOUT_MAX_ADDRESS, 0xfffff);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG_ADDRESS, ddr_config);
+	udelay(100);
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2);
+	udelay(100);
+	ath_reg_wr(DDR_CONFIG_3_ADDRESS, ddr_config3);
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR2_CONFIG_ADDRESS, CFG_DDR2_EN_TWL_VAL);
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_CONFIG2_ADDRESS, ddr_config2 | 0x80);	// CKE Enable
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x10);	// EMR2
+		udelay(10);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x20);	// EMR3
+		udelay(10);
+	}
+
+	if (type == ATH_MEM_DDR1 || type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL); // EMR DLL enable, Reduced Driver Impedance control, Differential DQS disabled
+		udelay(100);
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(10);
+	}
+
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val_init);
+	udelay(1000);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1);	// MR Write
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x8);	// Precharge
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x4);	// Auto Refresh
+	udelay(10);
+
+	// Issue MRS to remove DLL out-of-reset
+	ath_reg_wr_nf(DDR_MODE_REGISTER_ADDRESS, mod_val);
+	udelay(100);
+
+	ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x1); // MR write
+	udelay(100);
+
+	if (type == ATH_MEM_DDR2) {
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, 0x782);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_EXTENDED_MODE_REGISTER_ADDRESS, CFG_DDR2_EXT_MODE_VAL);
+		udelay(100);
+
+		ath_reg_wr_nf(DDR_CONTROL_ADDRESS, 0x2); // EMR write
+		udelay(100);
+	}
+
+	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
+	udelay(100);
+
+        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
+
+	if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
+		ath_reg_wr (TAP_CONTROL_2_ADDRESS, tap_val);
+		ath_reg_wr (TAP_CONTROL_3_ADDRESS, tap_val);
+	}
+
+	ath_reg_wr(PMU1_ADDRESS, 0x233c8178);
+	ath_reg_wr(PMU2_ADDRESS, 0x10380000);
+
+	return type;
+#else	// !nand flash and !emulation
+	return 0;
+#endif
+}
+
+int
+ath_uart_freq(void)
+{
+	if (ath_reg_rd(RST_BOOTSTRAP_ADDRESS) & RST_BOOTSTRAP_REF_CLK_MASK) {
+		return 40 * 1000 * 1000;
+	} else {
+		return 25 * 1000 * 1000;
+	}
+}
+
+void
+ath_sys_frequency(uint32_t *cpu, uint32_t *ddr, uint32_t *ahb)
+{
+#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t pll, out_div, ref_div, nint, frac, clk_ctrl;
+#endif
+	uint32_t ref;
+	static uint32_t ath_cpu_freq, ath_ddr_freq, ath_ahb_freq;
+
+	if (ath_cpu_freq)
+		goto done;
+
+#ifdef CONFIG_ATH_EMULATION
+	ath_cpu_freq = 80000000;
+	ath_ddr_freq = 80000000;
+	ath_ahb_freq = 40000000;
+#else
+	prmsg("%s: ", __func__);
+
+	clk_ctrl = ath_reg_rd(ATH_DDR_CLK_CTRL);
+
+#if 0
+	pll = ath_reg_rd(CPU_DPLL2_ADDRESS);
+	if (CPU_DPLL2_LOCAL_PLL_GET(pll)) {
+		out_div	= CPU_DPLL2_OUTDIV_GET(pll);
+
+		pll = ath_reg_rd(CPU_DPLL_ADDRESS);
+		nint = CPU_DPLL_NINT_GET(pll);
+		frac = CPU_DPLL_NFRAC_GET(pll);
+		ref_div = CPU_DPLL_REFDIV_GET(pll);
+		pll = ref >> 18;
+		frac	= frac * pll / ref_div;
+		prmsg("cpu srif ");
+	} else {
+#endif
+		pll = ath_reg_rd(ATH_PLL_CONFIG);
+		out_div	= CPU_PLL_CONFIG_OUTDIV_GET(pll);
+		ref_div	= CPU_PLL_CONFIG_REFDIV_GET(pll);
+		nint	= CPU_PLL_CONFIG_NINT_GET(pll);
+		frac	= CPU_PLL_CONFIG_NFRAC_GET(pll);
+		pll = ref >> 6;
+		frac	= frac * pll / ref_div;
+		prmsg("cpu apb ");
+//	}
+	ath_cpu_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_CPU_POST_DIV_GET(clk_ctrl) + 1);
+
+#if 0
+	pll = ath_reg_rd(DDR_DPLL2_ADDRESS);
+	if (DDR_DPLL2_LOCAL_PLL_GET(pll)) {
+		out_div	= DDR_DPLL2_OUTDIV_GET(pll);
+
+		pll = ath_reg_rd(DDR_DPLL_ADDRESS);
+		nint = DDR_DPLL_NINT_GET(pll);
+		frac = DDR_DPLL_NFRAC_GET(pll);
+		ref_div = DDR_DPLL_REFDIV_GET(pll);
+		pll = ref >> 18;
+		frac	= frac * pll / ref_div;
+		prmsg("ddr srif ");
+	} else {
+#endif
+		pll = ath_reg_rd(ATH_DDR_PLL_CONFIG);
+		out_div	= DDR_PLL_CONFIG_OUTDIV_GET(pll);
+		ref_div	= DDR_PLL_CONFIG_REFDIV_GET(pll);
+		nint	= DDR_PLL_CONFIG_NINT_GET(pll);
+		frac	= DDR_PLL_CONFIG_NFRAC_GET(pll);
+		pll = ref >> 10;
+		frac	= frac * pll / ref_div;
+		prmsg("ddr apb ");
+//	}
+	ath_ddr_freq = (((nint * (ref / ref_div)) + frac) >> out_div) /
+			(CPU_DDR_CLOCK_CONTROL_DDR_POST_DIV_GET(clk_ctrl) + 1);
+
+	if (CPU_DDR_CLOCK_CONTROL_AHBCLK_FROM_DDRPLL_GET(clk_ctrl)) {
+		ath_ahb_freq = ath_ddr_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	} else {
+		ath_ahb_freq = ath_cpu_freq /
+			(CPU_DDR_CLOCK_CONTROL_AHB_POST_DIV_GET(clk_ctrl) + 1);
+	}
+#endif
+		ath_cpu_freq = 720 * 1000000;
+		ath_ddr_freq = 600 * 1000000;
+		ath_ahb_freq = 200 * 1000000;
+	prmsg("cpu %u ddr %u ahb %u\n",
+		ath_cpu_freq / 1000000,
+		ath_ddr_freq / 1000000,
+		ath_ahb_freq / 1000000);
+done:
+	*cpu = ath_cpu_freq;
+	*ddr = ath_ddr_freq;
+	*ahb = ath_ahb_freq;
+
+}
diff --git a/board/atheros/common/phy.h b/board/atheros/common/phy.h
new file mode 100644
index 0000000000..b285078e1e
--- /dev/null
+++ b/board/atheros/common/phy.h
@@ -0,0 +1,17 @@
+#ifndef _PHY_H
+#define _PHY_H
+
+#include <config.h>
+
+#define ath_gmac_unit2name(_unit) (_unit ?  "eth1" : "eth0")
+
+extern int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg);
+extern int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+
+#define phy_reg_read(base, addr, reg)	\
+	ath_gmac_miiphy_read(ath_gmac_unit2name(base), addr, reg)
+
+#define phy_reg_write(base, addr, reg, data)	\
+	ath_gmac_miiphy_write(ath_gmac_unit2name(base), addr, reg, data)
+
+#endif
diff --git a/board/atheros/common/qca-eth-953x.c b/board/atheros/common/qca-eth-953x.c
new file mode 100755
index 0000000000..b81d0c4ea1
--- /dev/null
+++ b/board/atheros/common/qca-eth-953x.c
@@ -0,0 +1,681 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-953x.h"
+#include "qca-eth-953x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if defined(CONFIG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+uint16_t ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg);
+void  ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+
+#ifdef  CFG_ATHRS27_PHY
+#define is_s27() 1
+
+#else
+#define is_s27() 0
+
+#endif
+#ifdef  CFG_ATHRS27_PHY
+extern void athrs27_reg_init(void);
+extern void athrs27_reg_init_wan(void);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+		f = mac->fifo_rx[mac->next_rx];
+		if (ath_gmac_rx_owned_by_dma(f)) {
+			/* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
+			   then move to desciprot where the packet is available */
+			dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+			if (!dmaed_pkt) {
+				break ;
+			} else {
+				if (f->is_empty == 1) {
+					while (count < NO_OF_RX_FIFOS) {
+						if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+							mac->next_rx = 0;
+						}
+						f = mac->fifo_rx[mac->next_rx];
+						/*
+						 * Break on valid data in the desc by checking
+						 * empty bit.
+						 */
+						if (!f->is_empty) {
+							count = 0;
+							break;
+						}
+						count++;
+					}
+				}
+			}
+		}
+
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x231);
+	//ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
+	if ((mac->mac_unit == 1)) {
+		printf("Honey Bee ---->  MAC 1 S27 PHY*\n");
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+	mgmt_cfg_val = 2;
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+	}
+
+	if (is_vir_phy()) {
+		printf("Honey Bee ---->VIR PHY*\n");
+
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+						ETH_XMII_RX_DELAY_SET(2) |
+						ETH_XMII_TX_DELAY_SET(1) |
+						ETH_XMII_GIGE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+		return;
+	}
+	if (is_s27()) {
+	mgmt_cfg_val = 2;
+	printf("Scorpion ---->S27 PHY*\n");
+		ath_reg_wr(ETH_CFG_ADDRESS, ETH_CFG_MII_GE0_SET(1)|
+                                        ETH_CFG_MII_GE0_SLAVE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+	}
+
+
+
+
+}
+
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf("GMAC: cfg1 0x%x cfg2 0x%x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+	eeprom = ath_gmac_mac_addr_loc();
+
+	if (strcmp(dev->name, "eth0") == 0) {
+		memcpy(mac, eeprom, 6);
+	} else if (strcmp(dev->name, "eth1") == 0) {
+		eeprom += 6;
+		memcpy(mac, eeprom, 6);
+	} else {
+		printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+		return;
+	}
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+		mac[0] = 0xba;
+		mac[1] = 0xbe;
+		mac[2] = 0xfa;
+		mac[3] = 0xce;
+		mac[4] = 0x08;
+		mac[5] = 0x41;
+		/*printf("No valid address in Flash. Using fixed address\n");*/
+	} else {
+		printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+	}
+}
+
+void
+athr_mgmt_init(void)
+{
+
+#ifdef CONFIG_MGMT_INIT
+	uint32_t rddata;
+
+	rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 19));
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 17));
+
+
+	rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+		~ (GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |
+		GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+
+	rddata |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) |
+	GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+
+	ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+#endif
+	printf ("%s ::done\n",__func__);
+}
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+
+	printf("%s...\n", __func__);
+
+	/* Switch Analog and digital reset seq */
+	mask = ATH_RESET_GE1_PHY |  ATH_RESET_GE0_PHY;
+	ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+
+	udelay(1000 * 100);
+	mask = ATH_RESET_GE1_PHY ;
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+
+	udelay(1000 * 100);
+	mask = ATH_RESET_GE0_PHY ;
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+	udelay(100);
+
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO);
+
+
+			printf("%s: reset mask:0x%x\n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		eth_register(dev[i]);
+#if defined(CONFIG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CFG_ATHRS27_PHY
+			printf("S27 reg init\n");
+			athrs27_reg_init();
+			mask = ATH_RESET_GE0_MAC;
+                        ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			printf("VIRPhy reg init \n");
+			athr_vir_reg_init();
+#endif
+		} else {
+#ifdef  CFG_ATHRS27_PHY
+			printf("S27 reg init\n");
+			athrs27_reg_init_lan();
+			mask = ATH_RESET_GE1_MAC;
+                        ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+#endif
+
+		}
+
+		ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+                                | ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if defined(CONFIG_CMD_MII)
+uint16_t
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+	return val;
+}
+
+void
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_CMD_MII */
diff --git a/board/atheros/common/qca-eth-953x.h b/board/atheros/common/qca-eth-953x.h
new file mode 100755
index 0000000000..8cd29cc507
--- /dev/null
+++ b/board/atheros/common/qca-eth-953x.h
@@ -0,0 +1,349 @@
+#ifndef __QCA_ETH_953X_H
+#define __QCA_ETH_953X_H
+
+#include <linux/types.h>
+
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_GE0		(1<<10)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_ONLY_MODE	(1<<6)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif /* __QCA_ETH_953X_H */
diff --git a/board/atheros/common/qca-eth-953x_phy.h b/board/atheros/common/qca-eth-953x_phy.h
new file mode 100755
index 0000000000..f30d1f7be3
--- /dev/null
+++ b/board/atheros/common/qca-eth-953x_phy.h
@@ -0,0 +1,73 @@
+#ifndef _QCA_ETH_953x_PHY_H
+#define _QCA_ETH_953x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CFG_ATHRS27_PHY
+extern int athrs27_phy_setup(int ethUnit);
+extern int athrs27_phy_is_up(int ethUnit);
+extern int athrs27_phy_is_fdx(int ethUnit);
+extern int athrs27_phy_speed(int ethUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CFG_ATHRS27_PHY
+                        athrs27_phy_setup(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+
+#ifdef CFG_ATHRS27_PHY
+                        *link = athrs27_phy_is_up(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CFG_ATHRS27_PHY
+                        *duplex = athrs27_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CFG_ATHRS27_PHY
+			 *speed = athrs27_phy_speed(unit);
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+
+}
+
+#endif /* _QCA_ETH_953x_PHY_H */
diff --git a/board/atheros/common/qca-eth-955x.c b/board/atheros/common/qca-eth-955x.c
new file mode 100644
index 0000000000..2aaa570669
--- /dev/null
+++ b/board/atheros/common/qca-eth-955x.c
@@ -0,0 +1,977 @@
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#ifdef CONFIG_ATH_NAND_BR
+#include <nand.h>
+#endif
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+#define SGMII_LINK_WAR_MAX_TRY 10
+
+#if defined(CONFIG_CMD_MII)
+#include <miiphy.h>
+#endif
+#define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+
+uint16_t ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg);
+void  ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
+extern void ath_sys_frequency(uint32_t *, uint32_t *, uint32_t *);
+
+#ifndef CFG_ATH_GMAC_NMACS
+#define CFG_ATH_GMAC_NMACS	1
+#endif /* CFG_ATH_GMAC_NMACS */
+
+ath_gmac_mac_t *ath_gmac_macs[CFG_ATH_GMAC_NMACS];
+
+
+#ifdef CONFIG_VIR_PHY
+extern int athr_vir_phy_setup(int unit);
+extern int athr_vir_phy_is_up(int unit);
+extern int athr_vir_phy_is_fdx(int unit);
+extern int athr_vir_phy_speed(int unit);
+extern void athr_vir_reg_init(void);
+#endif
+#ifdef  CONFIG_ATHRS17_PHY
+extern void athrs17_reg_init(void);
+extern void athrs17_reg_init_wan(void);
+#endif
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATH_NAND_BR
+
+#define ATH_ETH_MAC_READ_SIZE 4096
+extern unsigned long long
+ath_nand_get_cal_offset(const char *ba);
+#endif
+
+static int
+ath_gmac_send(struct eth_device *dev, volatile void *packet, int length)
+{
+	int i;
+
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+
+	ath_gmac_desc_t *f = mac->fifo_tx[mac->next_tx];
+
+	f->pkt_size = length;
+	f->res1 = 0;
+	f->pkt_start_addr = virt_to_phys(packet);
+
+	ath_gmac_tx_give_to_dma(f);
+	flush_cache((u32) packet, length);
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, virt_to_phys(f));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, ATH_TXE);
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		udelay(10);
+		if (!ath_gmac_tx_owned_by_dma(f))
+			break;
+	}
+	if (i == MAX_WAIT)
+		printf("Tx Timed out\n");
+
+	f->pkt_start_addr = 0;
+	f->pkt_size = 0;
+
+	if (++mac->next_tx >= NO_OF_TX_FIFOS)
+		mac->next_tx = 0;
+
+	return (0);
+}
+
+static int ath_gmac_recv(struct eth_device *dev)
+{
+	int length;
+	ath_gmac_desc_t *f;
+	ath_gmac_mac_t *mac;
+	volatile int dmaed_pkt=0;
+	int count = 0;
+
+	mac = (ath_gmac_mac_t *)dev->priv;
+
+	for (;;) {
+	     f = mac->fifo_rx[mac->next_rx];
+        if (ath_gmac_rx_owned_by_dma(f)) {
+	 /* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
+	    then move to desciprot where the packet is available */
+	   dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+            if (!dmaed_pkt) {
+	        break ;
+              } else {
+                if (f->is_empty == 1) {
+                    while ( count < NO_OF_RX_FIFOS ) {
+                        if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+                            mac->next_rx = 0;
+                        }
+                        f = mac->fifo_rx[mac->next_rx];
+                        /*
+                         * Break on valid data in the desc by checking
+                         *  empty bit.
+                         */
+                        if (!f->is_empty){
+                            count = 0;
+                            break;
+                        }
+                        count++;
+                    }
+               }
+            }
+	}
+
+		length = f->pkt_size;
+
+		NetReceive(NetRxPackets[mac->next_rx] , length - 4);
+		flush_cache((u32) NetRxPackets[mac->next_rx] , PKTSIZE_ALIGN);
+
+		ath_gmac_reg_wr(mac,0x194,1);
+		ath_gmac_rx_give_to_dma(f);
+
+		if (++mac->next_rx >= NO_OF_RX_FIFOS)
+			mac->next_rx = 0;
+	}
+
+	if (!(ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL))) {
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(f));
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 1);
+	}
+
+	return (0);
+}
+
+void ath_gmac_mii_setup(ath_gmac_mac_t *mac)
+{
+	u32 mgmt_cfg_val;
+
+	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
+
+	if ((is_s17()  && mac->mac_unit == 0) || is_drqfn()) {
+		printf("Scorpion  ----> S17 PHY *\n");
+		mgmt_cfg_val = 7;
+#ifndef ATH_RGMII_CAL
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+			     ETH_XMII_RX_DELAY_SET(2)  |
+			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+#else
+        rgmii_cal_alg()
+#endif
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+	}
+
+	if (is_ar8033 () && mac->mac_unit == 1) {
+	printf("Scorpion ---->8033 PHY*\n");
+
+		mgmt_cfg_val = 7;
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+		return;
+        }
+        if (is_vir_phy()) {
+	printf("Scorpion ---->VIR PHY*\n");
+
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(3)|
+					ETH_CFG_RGMII_GE0_SET(1));
+		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
+			     ETH_XMII_RX_DELAY_SET(2)  |
+			     ETH_XMII_TX_DELAY_SET(1)  |
+					     ETH_XMII_GIGE_SET(1));
+		udelay(1000);
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
+		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
+
+                return;
+	}
+
+
+
+}
+
+void
+athrs_sgmii_res_cal(void)
+{
+	unsigned int read_data, read_data_otp, otp_value, otp_per_val, rbias_per;
+	unsigned int read_data_spi;
+	unsigned int *address_spi = (unsigned int *)0xbffffffc;
+	unsigned int rbias_pos_or_neg, res_cal_val;
+	unsigned int sgmii_pos, sgmii_res_cal_value;
+	unsigned int reversed_sgmii_value, use_value;
+
+	ath_reg_wr(OTP_INTF2_ADDRESS, 0x7d);
+	ath_reg_wr(OTP_LDO_CONTROL_ADDRESS, 0x0);
+
+	while (ath_reg_rd(OTP_LDO_STATUS_ADDRESS) & OTP_LDO_STATUS_POWER_ON_MASK);
+
+	read_data = ath_reg_rd(OTP_MEM_0_ADDRESS + 4);
+
+	while (!(ath_reg_rd(OTP_STATUS0_ADDRESS) & OTP_STATUS0_EFUSE_READ_DATA_VALID_MASK));
+
+	read_data_otp = ath_reg_rd(OTP_STATUS1_ADDRESS);
+
+	if (read_data_otp & 0x1fff) {
+		read_data = read_data_otp;
+	} else {
+		read_data_spi = *(address_spi);
+		if ((read_data_spi & 0xffff0000) == 0x5ca10000) {
+			read_data = read_data_spi;
+		} else {
+			read_data = read_data_otp;
+		}
+	}
+
+	if (read_data & 0x00001000) {
+		otp_value = (read_data & 0xfc0) >> 6;
+	} else {
+		otp_value = read_data & 0x3f;
+	}
+
+	if (otp_value > 31) {
+		otp_per_val = 63 - otp_value;
+		rbias_pos_or_neg = 1;
+	} else {
+		otp_per_val = otp_value;
+		rbias_pos_or_neg = 0;
+	}
+
+	rbias_per = otp_per_val * 15;
+
+	if (rbias_pos_or_neg == 1) {
+		res_cal_val = (rbias_per + 34) / 21;
+		sgmii_pos = 1;
+	} else {
+		if (rbias_per > 34) {
+			res_cal_val = (rbias_per - 34) / 21;
+			sgmii_pos = 0;
+		} else {
+			res_cal_val = (34 - rbias_per) / 21;
+			sgmii_pos = 1;
+		}
+	}
+
+	if (sgmii_pos == 1) {
+		sgmii_res_cal_value = 8 + res_cal_val;
+	} else {
+		sgmii_res_cal_value = 8 - res_cal_val;
+	}
+
+	reversed_sgmii_value = 0;
+	use_value = 0x8;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) >> 3);
+	use_value = 0x4;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) >> 1);
+	use_value = 0x2;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) << 1);
+	use_value = 0x1;
+	reversed_sgmii_value = reversed_sgmii_value | ((sgmii_res_cal_value & use_value) << 3);
+
+	reversed_sgmii_value &= 0xf;
+
+	printf("%s: cal value = 0x%x\n", __func__, reversed_sgmii_value);
+
+	// To Check the locking of the SGMII PLL
+
+	read_data = (ath_reg_rd(SGMII_SERDES_ADDRESS) &
+				~SGMII_SERDES_RES_CALIBRATION_MASK) |
+			SGMII_SERDES_RES_CALIBRATION_SET(reversed_sgmii_value);
+
+	ath_reg_wr(SGMII_SERDES_ADDRESS, read_data);
+
+
+	ath_reg_wr(ETH_SGMII_SERDES_ADDRESS,
+			ETH_SGMII_SERDES_EN_LOCK_DETECT_MASK |
+			ETH_SGMII_SERDES_PLL_REFCLK_SEL_MASK |
+			ETH_SGMII_SERDES_EN_PLL_MASK);
+
+	ath_reg_rmw_set(SGMII_SERDES_ADDRESS,
+			SGMII_SERDES_CDR_BW_SET(3) |
+			SGMII_SERDES_TX_DR_CTRL_SET(1) |
+			SGMII_SERDES_PLL_BW_SET(1) |
+			SGMII_SERDES_EN_SIGNAL_DETECT_SET(1) |
+			SGMII_SERDES_FIBER_SDO_SET(1) |
+			SGMII_SERDES_VCO_REG_SET(3));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_MASK);
+	udelay(25);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_MASK);
+
+	while (!(ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_MASK));
+}
+
+
+static void athr_gmac_sgmii_setup()
+{
+	int status = 0, count = 0;
+
+#ifdef ATH_SGMII_FORCED_MODE
+        ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_SPEED_SEL1_SET(1) |
+                                           MR_AN_CONTROL_PHY_RESET_SET(1)  |
+                                           MR_AN_CONTROL_DUPLEX_MODE_SET(1));
+        udelay(10);
+
+        ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
+                                          SGMII_CONFIG_FORCE_SPEED_SET(1) |
+                                          SGMII_CONFIG_SPEED_SET(2));
+
+        printf ("SGMII in forced mode\n");
+#else
+
+	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1)
+                                      |MR_AN_CONTROL_PHY_RESET_SET(1));
+
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1));
+#endif
+/*
+ * SGMII reset sequence suggested by systems team.
+ */
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_RX_CLK_N_RESET);
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
+                                    |SGMII_RESET_TX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_125M_N_SET(1)
+                                    |SGMII_RESET_RX_CLK_N_SET(1)
+                                    |SGMII_RESET_TX_CLK_N_SET(1));
+
+        ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+	/*
+	 * WAR::Across resets SGMII link status goes to weird
+	 * state.
+	 * if 0xb8070058 (SGMII_DEBUG register) reads other then 0x1f or 0x10
+	 * for sure we are in bad  state.
+	 * Issue a PHY reset in MR_AN_CONTROL_ADDRESS to keep going.
+	 */
+	status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	while (!(status == 0xf || status == 0x10)) {
+
+		ath_reg_rmw_set(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		udelay(100);
+		ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
+		if (count++ == SGMII_LINK_WAR_MAX_TRY) {
+			printf ("Max resets limit reached exiting...\n");
+			break;
+		}
+		status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
+	}
+
+	printf("%s SGMII done\n",__func__);
+
+}
+
+static void ath_gmac_hw_start(ath_gmac_mac_t *mac)
+{
+
+
+#ifndef ATH_RGMII_CAL /* Moved after mii_setup since these registers are touched in RGMII cal code */
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+
+#ifdef ATH_RGMII_CAL
+	if(mac->mac_unit)
+	{
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_1000));
+	} else {
+
+
+		ath_gmac_reg_rmw_set(mac, ATH_MAC_CFG2, (ATH_MAC_CFG2_PAD_CRC_EN |
+					ATH_MAC_CFG2_LEN_CHECK | ATH_MAC_CFG2_IF_10_100));
+	}
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+#endif
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_2, 0xAAA0555);
+
+	ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_4, 0x3ffff);
+	/*
+	 * Setting Drop CRC Errors, Pause Frames,Length Error frames
+	 * and Multi/Broad cast frames.
+	 */
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0x7eccf);
+
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+
+	printf(": cfg1 %#x cfg2 %#x\n", ath_gmac_reg_rd(mac, ATH_MAC_CFG1),
+			ath_gmac_reg_rd(mac, ATH_MAC_CFG2));
+
+
+}
+
+static int ath_gmac_check_link(ath_gmac_mac_t *mac)
+{
+	int link, duplex, speed;
+
+	ath_gmac_phy_link(mac->mac_unit, &link);
+	ath_gmac_phy_duplex(mac->mac_unit, &duplex);
+	ath_gmac_phy_speed(mac->mac_unit, &speed);
+
+	mac->link = link;
+
+	if(!mac->link) {
+		printf("%s link down\n",mac->dev->name);
+		return 0;
+	}
+
+	switch (speed)
+	{
+		case _1000BASET:
+			ath_gmac_set_mac_if(mac, 1);
+			ath_gmac_reg_rmw_set(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_GIGE_SET(1) |
+                                           ETH_SGMII_CLK_SEL_SET(1));
+			}
+
+			break;
+
+		case _100BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 1);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+                        if (is_ar8033() && mac->mac_unit == 1) {
+	ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(1));
+			}
+
+			break;
+
+		case _10BASET:
+			ath_gmac_set_mac_if(mac, 0);
+			ath_gmac_set_mac_speed(mac, 0);
+			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
+
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(19) |
+                                           ETH_SGMII_PHASE1_COUNT_SET(19));
+			}
+
+			break;
+
+		default:
+			printf("Invalid speed detected\n");
+			return 0;
+	}
+
+	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed))
+		return 1;
+
+	mac->duplex = duplex;
+	mac->speed = speed;
+
+	printf("dup %d speed %d\n", duplex, speed);
+
+	ath_gmac_set_mac_duplex(mac,duplex);
+
+	return 1;
+}
+
+/*
+ * For every command we re-setup the ring and start with clean h/w rx state
+ */
+static int ath_gmac_clean_rx(struct eth_device *dev, bd_t * bd)
+{
+
+	int i;
+	ath_gmac_desc_t *fr;
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
+
+	if (!ath_gmac_check_link(mac))
+		return 0;
+
+	mac->next_rx = 0;
+
+        ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+        ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		fr = mac->fifo_rx[i];
+		fr->pkt_start_addr = virt_to_phys(NetRxPackets[i]);
+		flush_cache((u32) NetRxPackets[i], PKTSIZE_ALIGN);
+		ath_gmac_rx_give_to_dma(fr);
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, virt_to_phys(mac->fifo_rx[0]));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, ATH_RXE);	/* rx start */
+	udelay(1000 * 1000);
+
+
+	return 1;
+
+}
+
+static int ath_gmac_alloc_fifo(int ndesc, ath_gmac_desc_t ** fifo)
+{
+	int i;
+	u32 size;
+	uchar *p = NULL;
+
+	size = sizeof(ath_gmac_desc_t) * ndesc;
+	size += CFG_CACHELINE_SIZE - 1;
+
+	if ((p = malloc(size)) == NULL) {
+		printf("Cant allocate fifos\n");
+		return -1;
+	}
+
+	p = (uchar *) (((u32) p + CFG_CACHELINE_SIZE - 1) &
+			~(CFG_CACHELINE_SIZE - 1));
+	p = UNCACHED_SDRAM(p);
+
+	for (i = 0; i < ndesc; i++)
+		fifo[i] = (ath_gmac_desc_t *) p + i;
+
+	return 0;
+}
+
+static int ath_gmac_setup_fifos(ath_gmac_mac_t *mac)
+{
+	int i;
+
+	if (ath_gmac_alloc_fifo(NO_OF_TX_FIFOS, mac->fifo_tx))
+		return 1;
+
+	for (i = 0; i < NO_OF_TX_FIFOS; i++) {
+		mac->fifo_tx[i]->next_desc = (i == NO_OF_TX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_tx[0]) : virt_to_phys(mac->fifo_tx[i + 1]);
+		ath_gmac_tx_own(mac->fifo_tx[i]);
+	}
+
+	if (ath_gmac_alloc_fifo(NO_OF_RX_FIFOS, mac->fifo_rx))
+		return 1;
+
+	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
+		mac->fifo_rx[i]->next_desc = (i == NO_OF_RX_FIFOS - 1) ?
+			virt_to_phys(mac->fifo_rx[0]) : virt_to_phys(mac->fifo_rx[i + 1]);
+	}
+
+	return (1);
+}
+
+static void ath_gmac_halt(struct eth_device *dev)
+{
+	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
+        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
+	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
+}
+
+#ifdef CONFIG_ATH_NAND_BR
+
+unsigned char *
+ath_eth_mac_addr(unsigned char *sectorBuff)
+{
+	ulong   off, size;
+	nand_info_t *nand;
+	unsigned char ret;
+
+	/*
+	 * caldata partition is of 128k
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = ATH_ETH_MAC_READ_SIZE; /* To read 4k setting size as 4k */
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return NULL;
+	}
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+	ret = nand_read(nand, (loff_t)off, &size, (u_char *)sectorBuff);
+	printf(" %d bytes %s: %s\n", size,
+			"read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return NULL;
+	}
+
+	return sectorBuff;
+}
+
+#else  /* CONFIG_ATH_NAND_BR */
+
+unsigned char *
+ath_gmac_mac_addr_loc(void)
+{
+	extern flash_info_t flash_info[];
+
+#ifdef BOARDCAL
+	/*
+	 ** BOARDCAL environmental variable has the address of the cal sector
+	 */
+
+	return ((unsigned char *)BOARDCAL);
+
+#else
+	/* MAC address is store in the 2nd 4k of last sector */
+	return ((unsigned char *)
+			(KSEG1ADDR(ATH_SPI_BASE) + (4 * 1024) +
+			 flash_info[0].size - (64 * 1024) /* sector_size */ ));
+#endif
+}
+
+#endif  /* CONFIG_ATH_NAND_BR */
+
+static void ath_gmac_get_ethaddr(struct eth_device *dev)
+{
+	unsigned char *eeprom;
+	unsigned char *mac = dev->enetaddr;
+#ifndef CONFIG_ATH_EMULATION
+
+#ifdef CONFIG_ATH_NAND_BR
+	unsigned char sectorBuff[ATH_ETH_MAC_READ_SIZE];
+
+	eeprom = ath_eth_mac_addr(sectorBuff);
+	if(eeprom == NULL) {
+		/* mac address will be set to default mac address */
+		mac[0] = 0xff;
+	}
+	else {
+#else  /* CONFIG_ATH_NAND_BR */
+		eeprom = ath_gmac_mac_addr_loc();
+#endif  /* CONFIG_ATH_NAND_BR */
+
+		if (strcmp(dev->name, "eth0") == 0) {
+			memcpy(mac, eeprom, 6);
+		} else if (strcmp(dev->name, "eth1") == 0) {
+			eeprom += 6;
+			memcpy(mac, eeprom, 6);
+		} else {
+			printf("%s: unknown ethernet device %s\n", __func__, dev->name);
+			return;
+		}
+#ifdef CONFIG_ATH_NAND_BR
+	}
+#endif  /* CONFIG_ATH_NAND_BR */
+	/* Use fixed address if the above address is invalid */
+	if (mac[0] != 0x00 || (mac[0] == 0xff && mac[5] == 0xff))
+#else
+	if (1)
+#endif
+	{
+		mac[0] = 0x00;
+		mac[1] = 0x03;
+		mac[2] = 0x7f;
+		mac[3] = 0x09;
+		mac[4] = 0x0b;
+		mac[5] = 0xad;
+		printf("No valid address in Flash. Using fixed address\n");
+	} else {
+		printf("Fetching MAC Address from 0x%p\n", __func__, eeprom);
+	}
+}
+
+void
+athr_mgmt_init(void)
+{
+
+#ifdef CONFIG_MGMT_INIT
+	uint32_t rddata;
+
+	rddata = ath_reg_rd(GPIO_IN_ENABLE3_ADDRESS)&
+		~GPIO_IN_ENABLE3_MII_GE1_MDI_MASK;
+	rddata |= GPIO_IN_ENABLE3_MII_GE1_MDI_SET(19);
+	ath_reg_wr(GPIO_IN_ENABLE3_ADDRESS, rddata);
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 19));
+
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 17));
+
+
+	rddata = ath_reg_rd(GPIO_OUT_FUNCTION4_ADDRESS) &
+		~ (GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK |
+		GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK);
+
+	rddata |= GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_SET(0x20) |
+	GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_SET(0x21);
+
+	ath_reg_wr(GPIO_OUT_FUNCTION4_ADDRESS, rddata);
+#endif
+	printf ("%s ::done\n",__func__);
+}
+
+int ath_gmac_enet_initialize(bd_t * bis)
+{
+	struct eth_device *dev[CFG_ATH_GMAC_NMACS];
+	u32 mask, mac_h, mac_l;
+	int i;
+
+	printf("%s...\n", __func__);
+
+	athrs_sgmii_res_cal();
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		if ((dev[i] = (struct eth_device *) malloc(sizeof (struct eth_device))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		if ((ath_gmac_macs[i] = (ath_gmac_mac_t *) malloc(sizeof (ath_gmac_mac_t))) == NULL) {
+			puts("malloc failed\n");
+			return 0;
+		}
+
+		memset(ath_gmac_macs[i], 0, sizeof(ath_gmac_macs[i]));
+		memset(dev[i], 0, sizeof(dev[i]));
+
+		sprintf(dev[i]->name, "eth%d", i);
+		ath_gmac_get_ethaddr(dev[i]);
+
+		ath_gmac_macs[i]->mac_unit = i;
+		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
+		ath_gmac_macs[i]->dev = dev[i];
+
+		dev[i]->iobase = 0;
+		dev[i]->init = ath_gmac_clean_rx;
+		dev[i]->halt = ath_gmac_halt;
+		dev[i]->send = ath_gmac_send;
+		dev[i]->recv = ath_gmac_recv;
+		dev[i]->priv = (void *)ath_gmac_macs[i];
+	}
+
+#if !defined(CONFIG_ATH_NAND_BR)
+	ath_reg_rmw_set(RST_RESET_ADDRESS,  RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_ARESET_SET(1));
+	udelay(100);
+#endif
+	ath_reg_rmw_set(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1));
+	udelay(1000 * 100);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_ETH_SGMII_RESET_SET(1) | RST_RESET_EXTERNAL_RESET_SET(1));
+	udelay(1000 * 100);
+
+	for (i = 0;i < CFG_ATH_GMAC_NMACS;i++) {
+
+		ath_gmac_reg_rmw_set(ath_gmac_macs[i], ATH_MAC_CFG1, ATH_MAC_CFG1_SOFT_RST
+				| ATH_MAC_CFG1_RX_RST | ATH_MAC_CFG1_TX_RST);
+
+		if(!i) {
+			mask = (ATH_RESET_GE0_MAC | ATH_RESET_GE1_MAC);
+
+			mask = mask | ATH_RESET_GE0_MDIO | ATH_RESET_GE1_MDIO;
+
+			printf("%s: reset mask:%x \n", __func__, mask);
+
+			ath_reg_rmw_set(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			ath_reg_rmw_clear(RST_RESET_ADDRESS, mask);
+			udelay(1000 * 100);
+
+			udelay(10 * 1000);
+		}
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE) || defined ATH_MDC_GPIO
+		if (!i)
+			athr_mgmt_init();
+
+		if (ath_gmac_macs[i]->mac_unit == 0)
+                        continue;
+#endif
+		eth_register(dev[i]);
+#if defined(CONFIG_CMD_MII)
+		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+#endif
+		ath_gmac_mii_setup(ath_gmac_macs[i]);
+
+		/* if using header for register configuration, we have to     */
+		/* configure s26 register after frame transmission is enabled */
+
+		if (ath_gmac_macs[i]->mac_unit == 0) { /* WAN Phy */
+#ifdef  CONFIG_ATHRS17_PHY
+			athrs17_reg_init();
+#endif
+
+#ifdef CONFIG_VIR_PHY
+			printf("VIRPhy reg init \n");
+			athr_vir_reg_init();
+#endif
+
+		} else {
+#ifdef CONFIG_ATHR_8033_PHY
+			printf("AR8033 PHY init \n");
+			athrs_ar8033_reg_init(NULL);
+
+#endif
+
+#if defined(CONFIG_MGMT_INIT) && defined (CONFIG_ATHR_SWITCH_ONLY_MODE)
+			athrs17_reg_init();
+
+#elif defined (CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			athrs17_reg_init_wan();
+#endif
+		}
+#ifdef CONFIG_ATHRS_GMAC_SGMII
+	/*
+         * MAC unit 1 or drqfn package call sgmii setup.
+	 */
+	if (i == 1 || is_drqfn())
+		athr_gmac_sgmii_setup();
+#endif
+		ath_gmac_hw_start(ath_gmac_macs[i]);
+		ath_gmac_setup_fifos(ath_gmac_macs[i]);
+
+
+
+		udelay(100 * 1000);
+
+		{
+			unsigned char *mac = dev[i]->enetaddr;
+
+			printf("%s: %02x:%02x:%02x:%02x:%02x:%02x\n", dev[i]->name,
+					mac[0] & 0xff, mac[1] & 0xff, mac[2] & 0xff,
+					mac[3] & 0xff, mac[4] & 0xff, mac[5] & 0xff);
+		}
+		mac_l = (dev[i]->enetaddr[4] << 8) | (dev[i]->enetaddr[5]);
+		mac_h = (dev[i]->enetaddr[0] << 24) | (dev[i]->enetaddr[1] << 16) |
+			(dev[i]->enetaddr[2] << 8) | (dev[i]->enetaddr[3] << 0);
+
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR1, mac_l);
+		ath_gmac_reg_wr(ath_gmac_macs[i], ATH_GE_MAC_ADDR2, mac_h);
+
+
+	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
+		printf("%s up\n",dev[i]->name);
+	}
+
+
+	return 1;
+}
+
+#if defined(CONFIG_CMD_MII)
+uint16_t
+ath_gmac_miiphy_read(char *devname, uint32_t phy_addr, uint8_t reg)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg, val;
+	volatile int           rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, ATH_MGMT_CMD_READ);
+
+	do
+	{
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	}while(rddata && --ii);
+
+	if(ii==0)
+		printf("Error!!! Leave ath_gmac_miiphy_read without polling correct status!\n");
+
+	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
+
+	return val;
+}
+
+void
+ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
+{
+	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
+	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	volatile int rddata;
+	uint16_t      ii = 0xFFFF;
+
+
+	/*
+	 * Check for previous transactions are complete. Added to avoid
+	 * race condition while running at higher frequencies.
+	 */
+	do {
+		udelay(5);
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("ERROR:%s:%d transaction failed\n",__func__,__LINE__);
+
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_ADDRESS, addr);
+	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CTRL, data);
+
+	do {
+		rddata = ath_gmac_reg_rd(mac, ATH_MII_MGMT_IND) & 0x1;
+	} while (rddata && --ii);
+
+	if (ii == 0)
+		printf("Error!!! Leave ath_gmac_miiphy_write without polling correct status!\n");
+}
+#endif		/* CONFIG_CMD_MII */
diff --git a/board/atheros/common/qca-eth-955x.h b/board/atheros/common/qca-eth-955x.h
new file mode 100644
index 0000000000..0a86c1c496
--- /dev/null
+++ b/board/atheros/common/qca-eth-955x.h
@@ -0,0 +1,407 @@
+#ifndef _AGxxxx_H
+#define _AGxxxx_H
+
+#include <linux/types.h>
+
+#ifdef ATH_RGMII_CAL
+#define rgmii_cal_alg()    rgmii_calib(mac);
+#else
+#define rgmii_cal_alg()
+#endif
+
+/*
+ * h/w descriptor
+ */
+typedef struct {
+	uint32_t	pkt_start_addr,
+			is_empty	:  1,
+			res1		: 10,
+			ftpp_override	:  5,
+			res2		:  4,
+			pkt_size	: 12,
+			next_desc;
+} ath_gmac_desc_t;
+
+#define NO_OF_TX_FIFOS			8
+#define NO_OF_RX_FIFOS			8
+
+typedef struct {
+	ath_gmac_desc_t		*fifo_tx[NO_OF_TX_FIFOS],
+				*fifo_rx[NO_OF_RX_FIFOS];
+	struct eth_device	*dev;
+	uint32_t		next_tx,
+				next_rx,
+				link,
+				duplex,
+				speed,
+				mac_unit,
+				mac_base;
+} ath_gmac_mac_t;
+
+#define ath_gmac_reg_wr(_mac, _x, _y)	ath_reg_wr(((_x) + _mac->mac_base), (_y))
+#define ath_gmac_reg_rd(_mac, _x)	ath_reg_rd(((_x) + _mac->mac_base))
+
+#define ath_gmac_reg_rmw_set(_mac, _x, _y)	\
+	ath_reg_rmw_set(((_x) + _mac->mac_base ), (_y))
+#define ath_gmac_reg_rmw_clear(_mac, _x, _y)	\
+	ath_reg_rmw_clear(((_x) + _mac->mac_base), (_y))
+
+#ifdef COMPRESSED_UBOOT
+#define _1000BASET		1000
+#define _100BASET		100
+#define _10BASET		10
+#endif /* #ifdef COMPRESSED_UBOOT */
+
+/*
+ * spd is _1000BASET, _100BASET etc. defined in include/miiphy.h
+ */
+#define mii_reg(_mac)	(ATH_MII0_CTRL + ((_mac)->mac_unit * 4))
+#define mii_if(_mac)	(((_mac)->mac_unit == 0) ? mii0_if : mii1_if)
+
+#define ath_gmac_set_mii_ctrl_speed(_mac, _spd)	do {	\
+	ath_reg_rmw_clear(mii_reg(_mac), (3 << 4));	\
+	ath_reg_rmw_set(mii_reg(_mac), ((_spd) << 4));	\
+} while (0)
+
+#if defined (CFG_MII0_GMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_MII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RGMII)
+#	define ath_gmac_get_mii_if()	0
+#elif defined (CFG_MII0_RMII)
+#	define ath_gmac_get_mii_if()	0
+#endif
+
+#define MAX_WAIT			1000
+
+/*
+ * Config/Mac Register definitions
+ */
+#define ATH_MAC_CFG1			0x00
+#define ATH_MAC_CFG2			0x04
+#define ATH_MAC_IFCTL			0x38
+
+/*
+ * fifo control registers
+ */
+#define ATH_MAC_FIFO_CFG_0		0x48
+#define ATH_MAC_FIFO_CFG_1		0x4c
+#define ATH_MAC_FIFO_CFG_2		0x50
+#define ATH_MAC_FIFO_CFG_3		0x54
+#define ATH_MAC_FIFO_CFG_4		0x58
+
+#define ATH_MAC_FIFO_CFG_5		0x5c
+#define ATH_BYTE_PER_CLK_EN		(1 << 19)
+
+#define ATH_MAC_FIFO_RAM_0		0x60
+#define ATH_MAC_FIFO_RAM_1		0x64
+#define ATH_MAC_FIFO_RAM_2		0x68
+#define ATH_MAC_FIFO_RAM_3		0x6c
+#define ATH_MAC_FIFO_RAM_4		0x70
+#define ATH_MAC_FIFO_RAM_5		0x74
+#define ATH_MAC_FIFO_RAM_6		0x78
+#define ATH_MAC_FIFO_RAM_7		0x7c
+
+/*
+ * fields
+ */
+#define ATH_MAC_CFG1_SOFT_RST		(1 << 31)
+#define ATH_MAC_CFG1_RX_RST		(1 << 19)
+#define ATH_MAC_CFG1_TX_RST		(1 << 18)
+#define ATH_MAC_CFG1_LOOPBACK		(1 << 8)
+#define ATH_MAC_CFG1_RX_EN		(1 << 2)
+#define ATH_MAC_CFG1_TX_EN		(1 << 0)
+
+#define ATH_MAC_CFG2_FDX		(1 << 0)
+#define ATH_MAC_CFG2_PAD_CRC_EN		(1 << 2)
+#define ATH_MAC_CFG2_LEN_CHECK		(1 << 4)
+#define ATH_MAC_CFG2_HUGE_FRAME_EN	(1 << 5)
+#define ATH_MAC_CFG2_IF_1000		(1 << 9)
+#define ATH_MAC_CFG2_IF_10_100		(1 << 8)
+
+#define ATH_MAC_IFCTL_SPEED		(1 << 16)
+
+/*
+ * DMA (tx/rx) register defines
+ */
+#define ATH_DMA_TX_CTRL			0x180
+#define ATH_DMA_TX_DESC			0x184
+#define ATH_DMA_TX_STATUS		0x188
+#define ATH_DMA_RX_CTRL			0x18c
+#define ATH_DMA_RX_DESC			0x190
+#define ATH_DMA_RX_STATUS		0x194
+#define ATH_DMA_INTR_MASK		0x198
+#define ATH_DMA_INTR			0x19c
+
+/*
+ * tx/rx ctrl and status bits
+ */
+#define ATH_TXE				(1 << 0)
+#define ATH_TX_STATUS_PKTCNT_SHIFT	16
+#define ATH_TX_STATUS_PKT_SENT		0x1
+#define ATH_TX_STATUS_URN		0x2
+#define ATH_TX_STATUS_BUS_ERROR		0x8
+
+#define ATH_RXE				(1 << 0)
+
+#define ATH_RX_STATUS_PKTCNT_MASK	0xff0000
+#define ATH_RX_STATUS_PKT_RCVD		(1 << 0)
+#define ATH_RX_STATUS_OVF		(1 << 2)
+#define ATH_RX_STATUS_BUS_ERROR		(1 << 3)
+
+/*
+ * Int and int mask
+ */
+#define ATH_INTR_TX			(1 << 0)
+#define ATH_INTR_TX_URN			(1 << 1)
+#define ATH_INTR_TX_BUS_ERROR		(1 << 3)
+#define ATH_INTR_RX			(1 << 4)
+#define ATH_INTR_RX_OVF			(1 << 6)
+#define ATH_INTR_RX_BUS_ERROR		(1 << 7)
+
+/*
+ * MII registers
+ */
+#define ATH_MAC_MII_MGMT_CFG		0x20
+#define ATH_MGMT_CFG_CLK_DIV_20		0x07
+
+#define ATH_MII_MGMT_CMD		0x24
+#define ATH_MGMT_CMD_READ		0x1
+
+#define ATH_MII_MGMT_ADDRESS		0x28
+#define ATH_ADDR_SHIFT			8
+
+#define ATH_MII_MGMT_CTRL		0x2c
+#define ATH_MII_MGMT_STATUS		0x30
+
+#define ATH_MII_MGMT_IND		0x34
+#define ATH_MGMT_IND_BUSY		(1 << 0)
+#define ATH_MGMT_IND_INVALID		(1 << 2)
+
+#define ATH_GE_MAC_ADDR1		0x40
+#define ATH_GE_MAC_ADDR2		0x44
+
+/*
+ * Ethernet config registers
+ */
+#define ATH_ETH_CFG			0x18070000
+#define ATH_ETH_CFG_RGMII_GE0		(1<<0)
+#define ATH_ETH_CFG_MII_GE0		(1<<1)
+#define ATH_ETH_CFG_GMII_GE0		(1<<2)
+#define ATH_ETH_CFG_RMII_GE0		(1<<10)
+#define ATH_ETH_CFG_RMII_HISPD_GE0	(1<<11)
+#define ATH_ETH_CFG_RMII_MASTER_MODE	(1<<12)
+#define ATH_ETH_CFG_MII_GE0_MASTER	(1<<3)
+#define ATH_ETH_CFG_MII_GE0_SLAVE	(1<<4)
+#define ATH_ETH_CFG_GE0_ERR_EN		(1<<5)
+#define ATH_ETH_CFG_SW_ONLY_MODE	(1<<6)
+#define ATH_ETH_CFG_SW_PHY_SWAP		(1<<7)
+#define ATH_ETH_CFG_SW_PHY_ADDR_SWAP	(1<<8)
+#define ATH_ETH_CFG_RXD_DELAY		(1 << 14)
+#define ATH_ETH_CFG_RDV_DELAY		(1 << 16)
+#define ATH_ETH_SWITCH_CLK_SPARE	0x18050024
+
+#define ETH_XMII_TX_INVERT_MSB                                       31
+#define ETH_XMII_TX_INVERT_LSB                                       31
+#define ETH_XMII_TX_INVERT_MASK                                      0x80000000
+#define ETH_XMII_TX_INVERT_GET(x)                                    (((x) & ETH_XMII_TX_INVERT_MASK) >> ETH_XMII_TX_INVERT_LSB)
+#define ETH_XMII_TX_INVERT_SET(x)                                    (((x) << ETH_XMII_TX_INVERT_LSB) & ETH_XMII_TX_INVERT_MASK)
+#define ETH_XMII_TX_INVERT_RESET                                     0x0 // 0
+#define ETH_XMII_GIGE_QUAD_MSB                                       30
+#define ETH_XMII_GIGE_QUAD_LSB                                       30
+#define ETH_XMII_GIGE_QUAD_MASK                                      0x40000000
+#define ETH_XMII_GIGE_QUAD_GET(x)                                    (((x) & ETH_XMII_GIGE_QUAD_MASK) >> ETH_XMII_GIGE_QUAD_LSB)
+#define ETH_XMII_GIGE_QUAD_SET(x)                                    (((x) << ETH_XMII_GIGE_QUAD_LSB) & ETH_XMII_GIGE_QUAD_MASK)
+#define ETH_XMII_GIGE_QUAD_RESET                                     0x0 // 0
+#define ETH_XMII_RX_DELAY_MSB                                        29
+#define ETH_XMII_RX_DELAY_LSB                                        28
+#define ETH_XMII_RX_DELAY_MASK                                       0x30000000
+#define ETH_XMII_RX_DELAY_GET(x)                                     (((x) & ETH_XMII_RX_DELAY_MASK) >> ETH_XMII_RX_DELAY_LSB)
+#define ETH_XMII_RX_DELAY_SET(x)                                     (((x) << ETH_XMII_RX_DELAY_LSB) & ETH_XMII_RX_DELAY_MASK)
+#define ETH_XMII_RX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_TX_DELAY_MSB                                        27
+#define ETH_XMII_TX_DELAY_LSB                                        26
+#define ETH_XMII_TX_DELAY_MASK                                       0x0c000000
+#define ETH_XMII_TX_DELAY_GET(x)                                     (((x) & ETH_XMII_TX_DELAY_MASK) >> ETH_XMII_TX_DELAY_LSB)
+#define ETH_XMII_TX_DELAY_SET(x)                                     (((x) << ETH_XMII_TX_DELAY_LSB) & ETH_XMII_TX_DELAY_MASK)
+#define ETH_XMII_TX_DELAY_RESET                                      0x0 // 0
+#define ETH_XMII_GIGE_MSB                                            25
+#define ETH_XMII_GIGE_LSB                                            25
+#define ETH_XMII_GIGE_MASK                                           0x02000000
+#define ETH_XMII_GIGE_GET(x)                                         (((x) & ETH_XMII_GIGE_MASK) >> ETH_XMII_GIGE_LSB)
+#define ETH_XMII_GIGE_SET(x)                                         (((x) << ETH_XMII_GIGE_LSB) & ETH_XMII_GIGE_MASK)
+#define ETH_XMII_GIGE_RESET                                          0x0 // 0
+#define ETH_XMII_OFFSET_PHASE_MSB                                    24
+#define ETH_XMII_OFFSET_PHASE_LSB                                    24
+#define ETH_XMII_OFFSET_PHASE_MASK                                   0x01000000
+#define ETH_XMII_OFFSET_PHASE_GET(x)                                 (((x) & ETH_XMII_OFFSET_PHASE_MASK) >> ETH_XMII_OFFSET_PHASE_LSB)
+#define ETH_XMII_OFFSET_PHASE_SET(x)                                 (((x) << ETH_XMII_OFFSET_PHASE_LSB) & ETH_XMII_OFFSET_PHASE_MASK)
+#define ETH_XMII_OFFSET_PHASE_RESET                                  0x0 // 0
+#define ETH_XMII_OFFSET_COUNT_MSB                                    23
+#define ETH_XMII_OFFSET_COUNT_LSB                                    16
+#define ETH_XMII_OFFSET_COUNT_MASK                                   0x00ff0000
+#define ETH_XMII_OFFSET_COUNT_GET(x)                                 (((x) & ETH_XMII_OFFSET_COUNT_MASK) >> ETH_XMII_OFFSET_COUNT_LSB)
+#define ETH_XMII_OFFSET_COUNT_SET(x)                                 (((x) << ETH_XMII_OFFSET_COUNT_LSB) & ETH_XMII_OFFSET_COUNT_MASK)
+#define ETH_XMII_OFFSET_COUNT_RESET                                  0x0 // 0
+#define ETH_XMII_PHASE1_COUNT_MSB                                    15
+#define ETH_XMII_PHASE1_COUNT_LSB                                    8
+#define ETH_XMII_PHASE1_COUNT_MASK                                   0x0000ff00
+#define ETH_XMII_PHASE1_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE1_COUNT_MASK) >> ETH_XMII_PHASE1_COUNT_LSB)
+#define ETH_XMII_PHASE1_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE1_COUNT_LSB) & ETH_XMII_PHASE1_COUNT_MASK)
+#define ETH_XMII_PHASE1_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_PHASE0_COUNT_MSB                                    7
+#define ETH_XMII_PHASE0_COUNT_LSB                                    0
+#define ETH_XMII_PHASE0_COUNT_MASK                                   0x000000ff
+#define ETH_XMII_PHASE0_COUNT_GET(x)                                 (((x) & ETH_XMII_PHASE0_COUNT_MASK) >> ETH_XMII_PHASE0_COUNT_LSB)
+#define ETH_XMII_PHASE0_COUNT_SET(x)                                 (((x) << ETH_XMII_PHASE0_COUNT_LSB) & ETH_XMII_PHASE0_COUNT_MASK)
+#define ETH_XMII_PHASE0_COUNT_RESET                                  0x1 // 1
+#define ETH_XMII_ADDRESS                                             0x18050028
+
+
+
+#define ETH_CFG_ETH_SPARE_MSB                                        31
+#define ETH_CFG_ETH_SPARE_LSB                                        22
+#define ETH_CFG_ETH_SPARE_MASK                                       0xffc00000
+#define ETH_CFG_ETH_SPARE_GET(x)                                     (((x) & ETH_CFG_ETH_SPARE_MASK) >> ETH_CFG_ETH_SPARE_LSB)
+#define ETH_CFG_ETH_SPARE_SET(x)                                     (((x) << ETH_CFG_ETH_SPARE_LSB) & ETH_CFG_ETH_SPARE_MASK)
+#define ETH_CFG_ETH_SPARE_RESET                                      0x0 // 0
+#define ETH_CFG_ETH_TXEN_DELAY_MSB                                   21
+#define ETH_CFG_ETH_TXEN_DELAY_LSB                                   20
+#define ETH_CFG_ETH_TXEN_DELAY_MASK                                  0x00300000
+#define ETH_CFG_ETH_TXEN_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_TXEN_DELAY_MASK) >> ETH_CFG_ETH_TXEN_DELAY_LSB)
+#define ETH_CFG_ETH_TXEN_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_TXEN_DELAY_LSB) & ETH_CFG_ETH_TXEN_DELAY_MASK)
+#define ETH_CFG_ETH_TXEN_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_TXD_DELAY_MSB                                    19
+#define ETH_CFG_ETH_TXD_DELAY_LSB                                    18
+#define ETH_CFG_ETH_TXD_DELAY_MASK                                   0x000c0000
+#define ETH_CFG_ETH_TXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_TXD_DELAY_MASK) >> ETH_CFG_ETH_TXD_DELAY_LSB)
+#define ETH_CFG_ETH_TXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_TXD_DELAY_LSB) & ETH_CFG_ETH_TXD_DELAY_MASK)
+#define ETH_CFG_ETH_TXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_ETH_RXDV_DELAY_MSB                                   17
+#define ETH_CFG_ETH_RXDV_DELAY_LSB                                   16
+#define ETH_CFG_ETH_RXDV_DELAY_MASK                                  0x00030000
+#define ETH_CFG_ETH_RXDV_DELAY_GET(x)                                (((x) & ETH_CFG_ETH_RXDV_DELAY_MASK) >> ETH_CFG_ETH_RXDV_DELAY_LSB)
+#define ETH_CFG_ETH_RXDV_DELAY_SET(x)                                (((x) << ETH_CFG_ETH_RXDV_DELAY_LSB) & ETH_CFG_ETH_RXDV_DELAY_MASK)
+#define ETH_CFG_ETH_RXDV_DELAY_RESET                                 0x0 // 0
+#define ETH_CFG_ETH_RXD_DELAY_MSB                                    15
+#define ETH_CFG_ETH_RXD_DELAY_LSB                                    14
+#define ETH_CFG_ETH_RXD_DELAY_MASK                                   0x0000c000
+#define ETH_CFG_ETH_RXD_DELAY_GET(x)                                 (((x) & ETH_CFG_ETH_RXD_DELAY_MASK) >> ETH_CFG_ETH_RXD_DELAY_LSB)
+#define ETH_CFG_ETH_RXD_DELAY_SET(x)                                 (((x) << ETH_CFG_ETH_RXD_DELAY_LSB) & ETH_CFG_ETH_RXD_DELAY_MASK)
+#define ETH_CFG_ETH_RXD_DELAY_RESET                                  0x0 // 0
+#define ETH_CFG_RMII_GE0_MASTER_MSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_LSB                                  12
+#define ETH_CFG_RMII_GE0_MASTER_MASK                                 0x00001000
+#define ETH_CFG_RMII_GE0_MASTER_GET(x)                               (((x) & ETH_CFG_RMII_GE0_MASTER_MASK) >> ETH_CFG_RMII_GE0_MASTER_LSB)
+#define ETH_CFG_RMII_GE0_MASTER_SET(x)                               (((x) << ETH_CFG_RMII_GE0_MASTER_LSB) & ETH_CFG_RMII_GE0_MASTER_MASK)
+#define ETH_CFG_RMII_GE0_MASTER_RESET                                0x1 // 1
+#define ETH_CFG_MII_CNTL_SPEED_MSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_LSB                                   11
+#define ETH_CFG_MII_CNTL_SPEED_MASK                                  0x00000800
+#define ETH_CFG_MII_CNTL_SPEED_GET(x)                                (((x) & ETH_CFG_MII_CNTL_SPEED_MASK) >> ETH_CFG_MII_CNTL_SPEED_LSB)
+#define ETH_CFG_MII_CNTL_SPEED_SET(x)                                (((x) << ETH_CFG_MII_CNTL_SPEED_LSB) & ETH_CFG_MII_CNTL_SPEED_MASK)
+#define ETH_CFG_MII_CNTL_SPEED_RESET                                 0x0 // 0
+#define ETH_CFG_RMII_GE0_MSB                                         10
+#define ETH_CFG_RMII_GE0_LSB                                         10
+#define ETH_CFG_RMII_GE0_MASK                                        0x00000400
+#define ETH_CFG_RMII_GE0_GET(x)                                      (((x) & ETH_CFG_RMII_GE0_MASK) >> ETH_CFG_RMII_GE0_LSB)
+#define ETH_CFG_RMII_GE0_SET(x)                                      (((x) << ETH_CFG_RMII_GE0_LSB) & ETH_CFG_RMII_GE0_MASK)
+#define ETH_CFG_RMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_GE0_SGMII_MSB                                        6
+#define ETH_CFG_GE0_SGMII_LSB                                        6
+#define ETH_CFG_GE0_SGMII_MASK                                       0x00000040
+#define ETH_CFG_GE0_SGMII_GET(x)                                     (((x) & ETH_CFG_GE0_SGMII_MASK) >> ETH_CFG_GE0_SGMII_LSB)
+#define ETH_CFG_GE0_SGMII_SET(x)                                     (((x) << ETH_CFG_GE0_SGMII_LSB) & ETH_CFG_GE0_SGMII_MASK)
+#define ETH_CFG_GE0_SGMII_RESET                                      0x0 // 0
+#define ETH_CFG_GE0_ERR_EN_MSB                                       5
+#define ETH_CFG_GE0_ERR_EN_LSB                                       5
+#define ETH_CFG_GE0_ERR_EN_MASK                                      0x00000020
+#define ETH_CFG_GE0_ERR_EN_GET(x)                                    (((x) & ETH_CFG_GE0_ERR_EN_MASK) >> ETH_CFG_GE0_ERR_EN_LSB)
+#define ETH_CFG_GE0_ERR_EN_SET(x)                                    (((x) << ETH_CFG_GE0_ERR_EN_LSB) & ETH_CFG_GE0_ERR_EN_MASK)
+#define ETH_CFG_GE0_ERR_EN_RESET                                     0x0 // 0
+#define ETH_CFG_MII_GE0_SLAVE_MSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_LSB                                    4
+#define ETH_CFG_MII_GE0_SLAVE_MASK                                   0x00000010
+#define ETH_CFG_MII_GE0_SLAVE_GET(x)                                 (((x) & ETH_CFG_MII_GE0_SLAVE_MASK) >> ETH_CFG_MII_GE0_SLAVE_LSB)
+#define ETH_CFG_MII_GE0_SLAVE_SET(x)                                 (((x) << ETH_CFG_MII_GE0_SLAVE_LSB) & ETH_CFG_MII_GE0_SLAVE_MASK)
+#define ETH_CFG_MII_GE0_SLAVE_RESET                                  0x0 // 0
+#define ETH_CFG_MII_GE0_MASTER_MSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_LSB                                   3
+#define ETH_CFG_MII_GE0_MASTER_MASK                                  0x00000008
+#define ETH_CFG_MII_GE0_MASTER_GET(x)                                (((x) & ETH_CFG_MII_GE0_MASTER_MASK) >> ETH_CFG_MII_GE0_MASTER_LSB)
+#define ETH_CFG_MII_GE0_MASTER_SET(x)                                (((x) << ETH_CFG_MII_GE0_MASTER_LSB) & ETH_CFG_MII_GE0_MASTER_MASK)
+#define ETH_CFG_MII_GE0_MASTER_RESET                                 0x0 // 0
+#define ETH_CFG_GMII_GE0_MSB                                         2
+#define ETH_CFG_GMII_GE0_LSB                                         2
+#define ETH_CFG_GMII_GE0_MASK                                        0x00000004
+#define ETH_CFG_GMII_GE0_GET(x)                                      (((x) & ETH_CFG_GMII_GE0_MASK) >> ETH_CFG_GMII_GE0_LSB)
+#define ETH_CFG_GMII_GE0_SET(x)                                      (((x) << ETH_CFG_GMII_GE0_LSB) & ETH_CFG_GMII_GE0_MASK)
+#define ETH_CFG_GMII_GE0_RESET                                       0x0 // 0
+#define ETH_CFG_MII_GE0_MSB                                          1
+#define ETH_CFG_MII_GE0_LSB                                          1
+#define ETH_CFG_MII_GE0_MASK                                         0x00000002
+#define ETH_CFG_MII_GE0_GET(x)                                       (((x) & ETH_CFG_MII_GE0_MASK) >> ETH_CFG_MII_GE0_LSB)
+#define ETH_CFG_MII_GE0_SET(x)                                       (((x) << ETH_CFG_MII_GE0_LSB) & ETH_CFG_MII_GE0_MASK)
+#define ETH_CFG_MII_GE0_RESET                                        0x0 // 0
+#define ETH_CFG_RGMII_GE0_MSB                                        0
+#define ETH_CFG_RGMII_GE0_LSB                                        0
+#define ETH_CFG_RGMII_GE0_MASK                                       0x00000001
+#define ETH_CFG_RGMII_GE0_GET(x)                                     (((x) & ETH_CFG_RGMII_GE0_MASK) >> ETH_CFG_RGMII_GE0_LSB)
+#define ETH_CFG_RGMII_GE0_SET(x)                                     (((x) << ETH_CFG_RGMII_GE0_LSB) & ETH_CFG_RGMII_GE0_MASK)
+#define ETH_CFG_RGMII_GE0_RESET                                      0x0 // 0
+#define ETH_CFG_ADDRESS                                              0x18070000
+
+
+
+
+/*
+ * ownership of descriptors between DMA and cpu
+ */
+#define ath_gmac_rx_owned_by_dma(_ds)	((_ds)->is_empty == 1)
+#define ath_gmac_rx_give_to_dma(_ds)	((_ds)->is_empty = 1)
+#define ath_gmac_tx_owned_by_dma(_ds)	((_ds)->is_empty == 0)
+#define ath_gmac_tx_give_to_dma(_ds)	((_ds)->is_empty = 0)
+#define ath_gmac_tx_own(_ds)		((_ds)->is_empty = 1)
+
+/*
+ * link settings
+ */
+#define ath_gmac_set_mac_duplex(_mac, _fdx)	do {	\
+	if ((_fdx)) {					\
+		ath_gmac_reg_rmw_set(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	} else {					\
+		ath_gmac_reg_rmw_clear(_mac,		\
+			ATH_MAC_CFG2, ATH_MAC_CFG2_FDX);\
+	}						\
+} while (0)
+
+#define ath_gmac_set_mac_if(_mac, _isXGMII)	do {		\
+	ath_gmac_reg_rmw_clear(_mac, ATH_MAC_CFG2,		\
+				ATH_MAC_CFG2_IF_1000 |		\
+				ATH_MAC_CFG2_IF_10_100);	\
+	if ((_isXGMII)) {					\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_1000);		\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_FIFO_CFG_5,	\
+				ATH_BYTE_PER_CLK_EN);		\
+	} else {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_CFG2,	\
+				ATH_MAC_CFG2_IF_10_100);	\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_FIFO_CFG_5,\
+				ATH_BYTE_PER_CLK_EN);		\
+	}							\
+} while (0)
+
+#define ath_gmac_set_mac_speed(_mac, _is100)	do {		\
+	if ((_is100)) {						\
+		ath_gmac_reg_rmw_set(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	} else {						\
+		ath_gmac_reg_rmw_clear(_mac, ATH_MAC_IFCTL,	\
+					ATH_MAC_IFCTL_SPEED);	\
+	}							\
+} while (0)
+
+#endif
diff --git a/board/atheros/common/qca-eth-955x_phy.h b/board/atheros/common/qca-eth-955x_phy.h
new file mode 100644
index 0000000000..3f498aa732
--- /dev/null
+++ b/board/atheros/common/qca-eth-955x_phy.h
@@ -0,0 +1,102 @@
+#ifndef _QCA_ETH_955x_PHY_H
+#define _QCA_ETH_955x_PHY_H
+#include <miiphy.h>
+
+
+#ifdef CONFIG_ATHR_8033_PHY
+extern int athrs_ar8033_reg_init(void *arg);
+extern int athrs_ar8033_phy_setup(void  *arg);
+extern int athrs_ar8033_phy_is_fdx(int ethUnit);
+extern int athrs_ar8033_phy_is_link_alive(int phyUnit);
+extern int athrs_ar8033_phy_is_up(int ethUnit);
+extern int athrs_ar8033_phy_speed(int ethUnit,int phyUnit);
+#endif
+
+#ifdef CONFIG_ATHRS17_PHY
+extern int athrs17_phy_setup(int ethUnit);
+extern int athrs17_phy_is_up(int ethUnit);
+extern int athrs17_phy_is_fdx(int ethUnit);
+extern int athrs17_phy_speed(int ethUnit);
+#endif
+
+static inline void ath_gmac_phy_setup(int unit)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			athrs17_phy_setup(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			athr_vir_phy_setup(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			athrs17_phy_setup(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_link(int unit, int *link)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*link = athrs17_phy_is_up(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*link = athr_vir_phy_is_up(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*link = athrs_ar8033_phy_is_up(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*link = athrs17_phy_is_up(unit);
+#endif
+
+		}
+}
+
+static inline void ath_gmac_phy_duplex(int unit, int *duplex)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*duplex = athrs17_phy_is_fdx(unit);
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*duplex = athr_vir_phy_is_fdx(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*duplex = athrs_ar8033_phy_is_fdx(unit);
+#endif
+#if defined(CONFIG_ATHRS17_PHY) && !defined(CFG_DUAL_PHY_SUPPORT)
+			*duplex = athrs17_phy_is_fdx(unit);
+#endif
+		}
+}
+
+static inline void ath_gmac_phy_speed(int unit, int *speed)
+{
+#ifdef CONFIG_ATHRS17_PHY
+		if (unit == 0) {
+			*speed = _1000BASET;
+		} else
+#endif
+		{
+#ifdef CONFIG_VIR_PHY
+			*speed = athr_vir_phy_speed(unit);
+#endif
+#ifdef CONFIG_ATHR_8033_PHY
+			*speed = athrs_ar8033_phy_speed(unit, 5);
+#endif
+
+#if defined(CONFIG_ATHRS17_PHY) && !defined (CFG_DUAL_PHY_SUPPORT)
+			*speed = _1000BASET;
+#endif
+		}
+}
+
+#endif /* _QCA_ETH_955x_PHY_H */
diff --git a/board/atheros/common/rgmii-cal-955x.c b/board/atheros/common/rgmii-cal-955x.c
new file mode 100644
index 0000000000..0ffcf782f6
--- /dev/null
+++ b/board/atheros/common/rgmii-cal-955x.c
@@ -0,0 +1,600 @@
+//#include <gmac_defines.h>
+//#include <prototypes.h>
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/types.h>
+
+#include <atheros.h>
+#include "qca-eth-955x.h"
+#include "qca-eth-955x_phy.h"
+
+#ifdef ATH_RGMII_CAL
+
+#define NUM_DESCRIPTORS		10	//Number of packets to be looped back
+#define node_tx_buf_len		100	// No of bytes per packet to be looped back
+
+#define DEBUG		0
+#define DEBUG_1	1
+
+#define GE0_PEMSTAT_RBYT	(0x9c + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RPKT	(0xA0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFCS	(0xA4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RMCA	(0xA8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RBCA	(0xAC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXCF	(0xB0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXPF	(0xB4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RXUO	(0xB8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RALN	(0xBC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFLR	(0xC0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCDE	(0xC4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RCSE	(0xC8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RUND	(0xCC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_ROVR	(0xD0 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RFRG	(0xD4 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RJBR	(0xD8 + ATH_GE0_BASE)
+#define GE0_PEMSTAT_RDRP	(0xDC + ATH_GE0_BASE)
+#define GE0_PEMSTAT_TPKT	(0xE0 + ATH_GE0_BASE)
+
+#define NUM_DESCS 10
+
+void init_s17_lpbk(void);
+uint32_t athrs17_reg_read(uint32_t reg_addr);
+void athrs17_reg_write(uint32_t reg_addr, uint32_t reg_val);
+
+int results[5] = { 0, 1, 1, 1, 0 };
+
+int find;
+
+void big_del(void)
+{
+	int i;
+	for (i = 0; i < 10000; i++) ;
+}
+
+// This should tell us what the best of the 4 values is. It should also tell us what the longest sequence is.
+// Since only four bits are used the best of 4 values can be easily arrived at by a truth table.
+// Presently we have an algorithm though.
+int find_value(void)
+{
+	int i;
+	int start_ok = 9;
+	int end_ok = 9;
+	int longest_start_ok = 0;
+	int longest_end_ok = 0;
+	int longest_ok_cnt = -1;
+	int first = 0;
+
+	for (i = 0; i < 5; i++) {
+#if DEBUG
+		printf("results [%d]: %d\n", i, results[i]);
+#endif
+		if (results[i] == 1) {
+			if (start_ok == 9) {
+				start_ok = i;
+				if (first == 0) {
+					longest_start_ok = i;
+					longest_end_ok = i;
+					first = 1;
+				}
+			}
+		}
+		if (results[i] == 0) {
+			if (end_ok == 9) {
+				end_ok = i - 1;
+			}
+			if ((end_ok - start_ok) > longest_ok_cnt) {
+				longest_start_ok = start_ok;
+				longest_end_ok = end_ok;
+				longest_ok_cnt = (end_ok - start_ok);
+			}
+			start_ok = 9;
+			end_ok = 9;
+		}
+	}
+
+#if DEBUG
+	printf("FINAL VALUE - ");
+#endif
+	find = (longest_end_ok + longest_start_ok) / 2;
+#if DEBUG
+	printf("find - %d\n", find);
+	printf("FINAL OK COUNT - %d\n", longest_ok_cnt + 1);
+#endif
+	return (longest_ok_cnt + 1);
+}
+
+int pkt_compare_data(void)
+{
+	unsigned int i, j;
+	//unsigned int k,rddata;
+	unsigned int node_rx_buf_len;
+	//unsigned int * node_tx_desc_ptr = (unsigned int *) 0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int error = 0;
+	unsigned pkt_err[NUM_DESCS];
+
+	node_rx_buf_len = (*(node_rx_desc_ptr + 0x1) & 0xfff) - 0x4;
+	// node_tx_buf_len = *(node_tx_desc_ptr + (NUM_DESCS-1)*0x3+0x1) & 0xfff;
+
+	for (j = 0; j < NUM_DESCS; j++) {
+		node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+		pkt_err[j] = 0;
+		for (i = 0; i < (node_rx_buf_len / 4); i++) {
+			if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+				error = error + 0x1;
+				pkt_err[j] = 1;
+			}
+		}
+		//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+	}
+	if (error == 0) {
+		return 0;
+	} else {
+		for (j = 0; j < NUM_DESCS; j++) {
+			node_rx_buf_len = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & 0xfff) - 0x4;
+			if (pkt_err[j] == 1) {
+#if DEBUG
+				printf("PKT %d\n", j);
+				printf("---------------------------------\n");
+
+				for (i = 0; i < (node_rx_buf_len / 4); i++) {
+					//if(((*(node_rx_buf_addr + i )) != *(node_tx_buf_addr + i)))
+					if (((*(node_rx_buf_addr + i + (j * 0x100))) != *(node_tx_buf_addr + i))) {
+						printf("->");
+					} else {
+						printf("  ");
+					}
+					printf("%x", (*(node_rx_buf_addr + i + (j * 0x100))));
+					printf("  ");
+					printf("%x\n", (*(node_tx_buf_addr + i)));
+				}
+				printf("---------------------------------\n");
+#endif
+			}
+			//node_rx_buf_addr = node_rx_buf_addr + 0x100;
+		}
+		return 1;
+	}
+}
+
+void rgmii_calib(ath_gmac_mac_t * mac)
+{
+
+	unsigned int i;
+	unsigned int j;
+	unsigned int k, l, m;
+	unsigned int rddata, error = 0;
+	unsigned int node_rx_buf_len = 1600;
+	unsigned int node_rx_buf_len1;
+	unsigned int *node_tx_desc_ptr = (unsigned int *)0xa0280000;
+	unsigned int *node_rx_desc_ptr = (unsigned int *)0xa0380000;
+	unsigned int *node_rx_buf_addr = (unsigned int *)0xa0580000;
+	unsigned int *node_tx_buf_addr = (unsigned int *)0xa0680000;
+	unsigned int *node_comp_result = (unsigned int *)0xa0200000;
+	unsigned int s17_tx_pkt = 0;
+	unsigned int s17_rx_pkt = 0;
+	unsigned int to;
+	unsigned int pass = 1;
+	unsigned int fail = 0;
+	int lgst = 0;
+	int old_lgst = 0;
+	unsigned int xmii[16];
+	unsigned int eth_cfg[16];
+	unsigned int xmii_val = 0;
+	unsigned int eth_cfg_val = 1;
+	unsigned int tx_fix = 0;
+
+
+	// GIGE Enable
+	ath_reg_wr(ETH_XMII_ADDRESS,	ETH_XMII_TX_INVERT_SET(0x1) |
+					ETH_XMII_RX_DELAY_SET(0x2) |
+					ETH_XMII_TX_DELAY_SET(0x1) |
+					ETH_XMII_GIGE_SET(0x1));
+
+	while ((ath_reg_rd(SGMII_SERDES_ADDRESS) & SGMII_SERDES_LOCK_DETECT_STATUS_SET(1)) == 0) {
+		printf("TEST: WAIT FOR LOCK\n");
+	}
+
+	big_del();
+
+	// MAC INITS
+	// RGMII Enable on GE0
+	//eth_init();
+	init_s17_lpbk();
+	athrs17_reg_write(0x30, 1);
+
+	ath_reg_wr(ETH_CFG_ADDRESS,	ETH_CFG_ETH_RXDV_DELAY_SET(0x3) |
+					ETH_CFG_ETH_RXD_DELAY_SET(0x3) |
+					ETH_CFG_RGMII_GE0_SET(0x1));
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_GE0_MAC_RESET_MASK);	// Bringing GE0 out of RESET
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG2, 0x7235);	//for 1000mbps
+	//ath_reg_wr(GE0_MAC_CONFIG_2,0x7135);  //for 100mbps
+	ath_gmac_reg_wr(mac, ATH_MAC_IFCTL, 0x00000);
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+	//ath_reg_wr(GE0_MAC_CONFIG_1,0x105);  // For MAC Loopback
+	ath_gmac_reg_wr(mac, ATH_DMA_INTR_MASK, 0);	// Disable interrupt mask
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR1, 0x003fffff);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_GE_MAC_ADDR2, 0xfffe0000);	//ethernet mac address
+	ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, 0x6);	//clock/20= 2MHz
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);	// Enable the FIFO modules
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_1, 0x10ffff);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_3, 0x1f00140);
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_4, 0x1000);
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0xbefff); //enable drop
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_5, 0xfffff);	//for 1000Mbps
+	//ath_reg_wr(GE0_FIFO_CFG_REG_5, 0x7ffff);//for 100Mbps
+
+	//************
+	// PACKETS
+	//***********
+
+	// Initialise Data in Memory for TX and RX
+	for (i = 0; i < node_tx_buf_len; i++)
+		*(node_tx_buf_addr + i) = i | (i + 1) << 8 | (i + 2) << 16 | (i + 3) << 24;
+
+#if DEBUG
+	printf("TEST: Inits Done\n");
+#endif
+	// Set Up Transmit Descriptor Table
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_tx_desc_ptr + (i * 0x3)) = ((unsigned int)node_tx_buf_addr & 0x0fffffff);
+		*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff);
+		else
+			*(node_tx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_tx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_DESC, ((unsigned int)node_tx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_TX_STATUS, 0xfffffff);	// clear dma status
+
+	for (i = 0; i < NUM_DESCRIPTORS; i++) {
+		*(node_rx_desc_ptr + (i * 0x3)) = ((unsigned int)node_rx_buf_addr & 0x0fffffff);
+		*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		if (i == (NUM_DESCRIPTORS - 1))
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff);
+		else
+			*(node_rx_desc_ptr + (i * 0x3) + 0x2) = ((unsigned int)node_rx_desc_ptr & 0x0fffffff) + (i * 0xc) + 0xc;
+		node_rx_buf_addr = node_rx_buf_addr + 0x100;
+
+	}
+
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_DESC, ((unsigned int)node_rx_desc_ptr & 0x0fffffff));
+	ath_gmac_reg_wr(mac, ATH_DMA_RX_STATUS, 0xfffffff);	// clear dma status
+
+	k = 0;
+
+	// Enable TX and RX MAC
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, 0x005);
+
+	// This routine will go through 16 combinations to find the best value for TX_DELAY, GIGE_QUAD, TX_INVERT
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if (l < 4) {
+			// GIGE Enable and TX_DELAY
+			rddata = ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 1
+		// TX_INVERT  - 0
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 8) && (l > 3)) {
+			// GIGE Enable and TX_DELAY & GIGE_QUAD
+			rddata = ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 12) && (l > 7)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		// GIGE_QUAD  - 0
+		// TX_INVERT  - 1
+		// TX_DELAY   - 0,1,2,3
+		if ((l < 16) && (l > 11)) {
+			// GIGE Enable and TX_DELAY and TX_INVERT and GIGE_QUAD
+			rddata = ETH_XMII_TX_INVERT_SET(0x1) |
+				ETH_XMII_GIGE_QUAD_SET(0x1) |
+				ETH_XMII_GIGE_SET(0x1) |
+				ETH_XMII_TX_DELAY_SET(l);
+			ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+			rddata = ath_reg_rd(ETH_XMII_ADDRESS);
+#if DEBUG
+			printf("TEST: ETH_XMII - 0x%08x\n", rddata);
+#endif
+		}
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+
+		rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+		rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT - 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT - 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+#if DEBUG
+			printf("TEST: PACKET COMPARISON PASS\n");
+#endif
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+			}
+		}
+	}
+#if DEBUG_1
+	printf("TEST: FINAL REG VAL after TX Calibration - 0x%08x\n", xmii_val);
+#endif
+	tx_fix = xmii_val;
+
+	old_lgst = 0;
+
+	// Using the previously arrived at value of TX Calib we calibrate RX DELAYS. For this we use RX DAT and EN Delays
+	for (l = 0; l < 16; l++) {
+		// initialize pass. this will be made zero if there is a failure in packet reception compare
+		pass = 1;
+		// fail due to checks in rx etc. this is not the same as !pass
+		fail = 0;
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: Initial ETH_CFG - 0x%08x\n", rddata);
+#endif
+
+		// RXD_DELAY  - l / 4 -> 0, 1, 2, 3
+		// RXEN_DELAY - l / 4 -> 0, 1, 2, 3
+		// RX_DELAY   - l & 3 -> 0, 1, 2, 3
+		ath_reg_rmw_clear(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_MASK |
+					ETH_CFG_ETH_RXD_DELAY_MASK);
+		ath_reg_rmw_set(ETH_CFG_ADDRESS,
+					ETH_CFG_ETH_RXDV_DELAY_SET(l / 4) |
+					ETH_CFG_ETH_RXD_DELAY_SET(l / 4));
+		rddata = ath_reg_rd(ETH_CFG_ADDRESS);
+#if DEBUG
+		printf("TEST: ETH_CFG - 0x%08x\n", rddata);
+#endif
+		eth_cfg[l] = rddata;
+		rddata = tx_fix | ETH_XMII_RX_DELAY_SET(l);
+		ath_reg_wr(ETH_XMII_ADDRESS, rddata);
+
+		xmii[l] = rddata;
+
+		// counts when to print out counter stats
+		k++;
+		// Set Up Receive Descriptor Table
+		node_rx_buf_len = 0x0;
+		ath_gmac_reg_wr(mac, ATH_DMA_RX_CTRL, 0x1);	// enable dma rx
+		ath_gmac_reg_wr(mac, ATH_DMA_TX_CTRL, 0x1);	// enable dma tx
+
+		rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != (1 << 31))
+			rddata = (*(node_tx_desc_ptr + (NUM_DESCRIPTORS - 1) * 0x3 + 0x1) & (1 << 31));
+#if DEBUG
+		printf("TEST: Tx Done \n");
+#endif
+
+		to = 0;
+		rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+		while (rddata != 0x0) {
+			rddata = (*(node_rx_desc_ptr + (NUM_DESCS - 1) * 0x3 + 0x1) & (1 << 31));
+			to++;
+			if (to > 100000) {
+#if DEBUG
+				printf("TEST: ERROR!! Atleast 1 packet in GE0 not seen.\n");
+#endif
+				// This check for RX.
+				pass = 0;
+				fail = 1;
+				break;
+			}
+		}
+#if DEBUG
+		printf("TEST: Rx Done \n");
+#endif
+
+		if (k % 1 == 0) {
+			for (j = GE0_PEMSTAT_RBYT; j <= GE0_PEMSTAT_RDRP; j = j + 4) {
+				rddata = ath_reg_rd(j);
+				switch (j) {
+#if DEBUG
+				case GE0_PEMSTAT_RPKT:
+					printf("TEST: RPKT 0x%08x\n", rddata);
+					break;
+				case GE0_PEMSTAT_TPKT:
+					printf("TEST: TPKT 0x%08x\n", rddata);
+					break;
+#endif
+				}
+			}
+#ifdef ATH_S17_MAC0_SGMII
+			s17_rx_pkt = athrs17_reg_read(0x163c) + (athrs17_reg_read(0x1640) << 16);
+#else
+			s17_rx_pkt = athrs17_reg_read(0x103c) + (athrs17_reg_read(0x1040) << 16);
+#endif
+#if DEBUG
+			printf("TEST: RPKT in S17 0x%08x\n", s17_rx_pkt);
+#endif
+#ifdef ATH_S17_MAC0_SGMII
+			s17_tx_pkt = athrs17_reg_read(0x1684) + (athrs17_reg_read(0x1688) << 16);
+#else
+			s17_tx_pkt = athrs17_reg_read(0x1084) + (athrs17_reg_read(0x1088) << 16);
+#endif
+#if DEBUG
+			printf("TEST: TPKT in S17 0x%08x\n", s17_tx_pkt);
+#endif
+			// Compare BYTES in TX
+			if (s17_tx_pkt != 0x410) {
+#if DEBUG
+				printf("TEST: PKTS @ S17 - 0x%08x\n", rddata);
+#endif
+				pass = 0;
+				fail = 1;
+			}
+
+		}
+		if (fail == 0) {
+			error = pkt_compare_data();
+		}
+		if (error == 0) {
+			//printf("TEST: PACKET COMPARISON PASS\n");
+		} else {
+#if DEBUG
+			printf("TEST: ERROR!! PACKET COMPARISON FAIL\n");
+#endif
+			fail = 1;
+			// Different from TX. This ensures packets are received back properly for a valid config.
+			pass = 0;
+		}
+
+		for (i = 0; i < NUM_DESCRIPTORS; i++) {
+			*(node_tx_desc_ptr + (i * 0x3) + 0x1) = (node_tx_buf_len & 0x7fffffff);
+			*(node_rx_desc_ptr + (i * 0x3) + 0x1) = (node_rx_buf_len & 0xfff) | (1 << 31);
+		}
+
+		// populate results and find the optimum value of programming
+		// For every set of 4 configurations find longest valid configs and number.
+		results[(l % 4)] = pass;
+		if (((l % 4) == 3)) {
+			lgst = find_value();
+			if (lgst > old_lgst) {
+				old_lgst = lgst;
+				xmii_val = xmii[(l - 3) + find];
+				eth_cfg_val = eth_cfg[(l - 3) + find];
+			}
+		}
+	}
+	// And write to these registers.
+#if DEBUG_1
+	printf("TEST: FINAL XMII VAL after RX Calibration - 0x%08x\n", xmii_val);
+#endif
+	ath_reg_wr(ETH_XMII_ADDRESS, xmii_val);
+#if DEBUG_1
+	printf("TEST: FINAL ETH_CFG VAL after RX Calibration - 0x%08x\n", eth_cfg_val);
+#endif
+	ath_reg_wr(ETH_CFG_ADDRESS, eth_cfg_val);
+	ath_gmac_reg_wr(mac,ATH_MAC_CFG1,1<<31);
+
+}
+
+#endif /* #ifdef RGMII_CAL */
diff --git a/board/atheros/common/serial.c b/board/atheros/common/serial.c
new file mode 100644
index 0000000000..f33a572cc6
--- /dev/null
+++ b/board/atheros/common/serial.c
@@ -0,0 +1,88 @@
+#include <asm/addrspace.h>
+#include <asm/types.h>
+#include <config.h>
+#include <atheros.h>
+
+int serial_init(void)
+{
+//#if !defined(CONFIG_ATH_EMULATION)
+	uint32_t div, val;
+
+	div = ath_uart_freq() / (16 * CONFIG_BAUDRATE);
+#ifdef CONFIG_SCO_SLAVE_CONNECTED
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0xcbf410u);
+#else
+	val = ath_reg_rd(GPIO_OE_ADDRESS) & (~0xcffc10u);
+#endif
+	ath_reg_wr(GPIO_OE_ADDRESS, val);
+
+	ath_reg_rmw_set(GPIO_OUT_FUNCTION2_ADDRESS,
+			GPIO_OUT_FUNCTION2_ENABLE_GPIO_10_SET(0x16));
+
+	ath_reg_rmw_clear(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0xff));
+
+	ath_reg_rmw_set(GPIO_IN_ENABLE0_ADDRESS,
+			GPIO_IN_ENABLE0_UART_SIN_SET(0x9));
+
+	//val = ath_reg_rd(GPIO_OUT_ADDRESS) | 0xcffc10u;
+	//ath_reg_wr(GPIO_OUT_ADDRESS, val);
+
+	val = ath_reg_rd(GPIO_SPARE_ADDRESS);
+	ath_reg_wr(GPIO_SPARE_ADDRESS, (val | 0x8402));
+
+	//ath_reg_wr(GPIO_OUT_ADDRESS, 0x2f);
+
+	/*
+	 * set DIAB bit
+	 */
+	ath_uart_wr(OFS_LINE_CONTROL, 0x80);
+
+	/* set divisor */
+	ath_uart_wr(OFS_DIVISOR_LSB, (div & 0xff));
+	ath_uart_wr(OFS_DIVISOR_MSB, ((div >> 8) & 0xff));
+
+	/* clear DIAB bit*/
+	ath_uart_wr(OFS_LINE_CONTROL, 0x00);
+
+	/* set data format */
+	ath_uart_wr(OFS_DATA_FORMAT, 0x3);
+
+	ath_uart_wr(OFS_INTR_ENABLE, 0);
+//#endif
+	return 0;
+}
+
+int serial_tstc (void)
+{
+	return(ath_uart_rd(OFS_LINE_STATUS) & 0x1);
+}
+
+u8 serial_getc(void)
+{
+	while(!serial_tstc());
+
+	return ath_uart_rd(OFS_RCV_BUFFER);
+}
+
+
+void serial_putc(u8 byte)
+{
+	if (byte == '\n') serial_putc ('\r');
+
+	while (((ath_uart_rd(OFS_LINE_STATUS)) & 0x20) == 0x0);
+
+	ath_uart_wr(OFS_SEND_BUFFER, byte);
+}
+
+void serial_setbrg (void)
+{
+}
+
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
diff --git a/board/atheros/common/tap-953x.S b/board/atheros/common/tap-953x.S
new file mode 100755
index 0000000000..d0aad027d8
--- /dev/null
+++ b/board/atheros/common/tap-953x.S
@@ -0,0 +1,183 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+	li	a0,	0xbd001f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd001f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0x0000ffff
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd001f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd001f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd001f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd001f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
+ /* end of file */
diff --git a/board/atheros/common/tap-955x.S b/board/atheros/common/tap-955x.S
new file mode 100644
index 0000000000..65179f055d
--- /dev/null
+++ b/board/atheros/common/tap-955x.S
@@ -0,0 +1,185 @@
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <atheros.h>
+
+.globl ath_ddr_tap_cal
+	.type	ath_ddr_tap_cal,	@function
+	.text
+	.align 4
+ath_ddr_tap_cal:
+
+	li	a0,	0xbd007f00
+	sw	zero,	0x0(a0)			// Place where the tap values are saved and used for SWEEP
+	sw	zero,	0x4(a0)			// Place where the number of passing taps are saved.
+	sw	zero,	0x14(a0)		// Place where the last pass tap value is stored
+	li	a1,	0xaa55aa55		// Indicates that the First pass tap value is not found
+	sw	a1,	0x10(a0)		// Place where the First pass tap value is stored
+	nop
+
+	li	a0,	0xb8060000		// RESET_BASE_ADDRESS
+	lw	a1,	0x1c(a0)		// Reading the RST_RESET_ADDRESS
+	li	a2,	0x08000000		// Setting the RST_RESET_RTC_RESET
+	or	a1,	a1,	a2
+	sw	a1,	0x1c(a0)
+
+	li	a3,	0xffffffff
+	xor	a2,	a2,	a3
+	and	a1,	a1,	a2
+	sw	a1,	0x1c(a0)		// Taking the RTC out of RESET
+	nop
+
+	li	a0,	0xb8107000		// RTC_BASE_ADDRESS
+	li	a1,	0x1
+	sw	a1,	0x0040(a0)		// RTC_SYNC_RESET_ADDRESS
+
+	li	a2,	0x2
+
+_poll_for_RTC_ON:
+	lw	a1,	0x0044(a0)		// RTC_SYNC_STATUS_ADDRESS
+	and	a1,	a2,	a1
+	bne	a1,	a2,	_poll_for_RTC_ON
+
+
+_CHANGE_TAPS:
+
+	li	t0,	0xbd007f00		// Read the current value of the TAP for programming
+	lw	t1,	0x0(t0)
+	li	t2,	0x00000000
+	or	t3,	t1,	t2
+
+
+	li	t0,	0xb8000000		// DDR_BASE_ADDRESS
+
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	li	t1,	0x00000010		// Running the test 8 times
+	sw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+
+	li	t1,	0xfa5de83f		// 4 Row Address Bits, 4 Column Address Bits, 2 BA bits
+	sw	t1,	0x002c(t0)		// PERF_MASK_ADDR_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0070(t0)		// PERF_COMP_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0040(t0)		// PERF_COMP_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0078(t0)		// PERF_COMP_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0034(t0)		// PERF_MASK_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x006c(t0)		// PERF_MASK_AHB_GE0_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x003c(t0)		// PERF_MASK_AHB_GE1_0_ADDRESS
+
+	li	t1,	0x545fc332
+	sw	t1,	0x0074(t0)		// PERF_MASK_AHB_GE1_1_ADDRESS
+
+	li	t1,	0xaba03ccd
+	sw	t1,	0x0038(t0)		// PERF_COMP_AHB_GE0_0_ADDRESS
+
+	li	t1,	0x00000001
+	sw	t1,	0x011c(t0)		// DDR_BIST_ADDRESS
+
+	li	t2,	0x1
+_bist_done_poll:
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	and	t1,	t1,	t2
+	bne	t1,	t2,	_bist_done_poll
+
+	lw	t1,	0x0120(t0)		// DDR_BIST_STATUS_ADDRESS
+	li	t4,	0x000001fe
+	and	t2,	t1,	t4
+	srl	t2,	t2,	0x1		// no. of Pass Runs
+
+	li	t5,	0x00000000
+	sw	t5,	0x011c(t0)		//DDR_BIST_ADDRESS	- Stop the DDR BIST test
+
+	li	t5,	0x0001fe00
+	and	t5,	t5,	t1
+	bnez	t5,	_iterate_tap		// This is a redundant compare but nevertheless - Comparing the FAILS
+
+	lw	t1,	0x0068(t0)		// PERF_COMP_ADDR_1_ADDRESS
+	li	t3,	0x000001fe
+	and	t3,	t3,	t1
+	srl	t3,	t3,	0x1		// No. of runs in the config register.
+
+	bne	t3,	t2,	_iterate_tap
+
+pass_tap:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x4(t0)
+
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	li	t2,	0xaa55aa55
+	beq	t1,	t2,	_first_pass
+	nop
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x4(t0)
+	nop
+	b	_iterate_tap
+	nop
+
+_first_pass:
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t0,	0xbd007f10
+	sw	t1,	0x0(t0)
+	sw	t1,	0x4(t0)
+	nop
+
+_iterate_tap:
+
+	li	t0,	0xbd007f00
+	lw	t1,	0x0(t0)
+	li	t2,	0x3f
+	beq	t1,	t2,	_STOP_TEST
+	nop
+	addiu	t1,	t1,	0x1
+	sw	t1,	0x0(t0)
+	nop
+	b	_CHANGE_TAPS
+
+_STOP_TEST:
+	li	t0,	0xbd007f00
+	lw	t1,	0x4(t0)
+	bnez	t1,	_load_center_tap
+	nop
+	li	t3,	0x8			// Default Tap to be used
+	b	_load_tap_into_reg
+
+_load_center_tap:
+	li	t0,	0xbd007f10
+	lw	t1,	0x0(t0)
+	lw	t2,	0x4(t0)
+	add	t3,	t1,	t2
+	srl	t3,	t3,	0x1
+	li	t4,	0x3f
+	and	t3,	t3,	t4
+
+_load_tap_into_reg:
+	li	t0,	0xb8000000
+	sw	t3,	0x1c(t0)		// TAP_CONTROL_0_ADDRESS
+	sw	t3,	0x20(t0)		// TAP_CONTROL_1_ADDRESS
+	sw	t3,	0x24(t0)		// TAP_CONTROL_2_ADDRESS
+	sw	t3,	0x28(t0)		// TAP_CONTROL_3_ADDRESS
+
+	jr	ra
+	nop
+
+ /* end of file */
diff --git a/board/atheros/scoemu/Makefile b/board/atheros/scoemu/Makefile
new file mode 100644
index 0000000000..7bb150b1b0
--- /dev/null
+++ b/board/atheros/scoemu/Makefile
@@ -0,0 +1,73 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/955x.o
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/scoemu/config.mk b/board/atheros/scoemu/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/atheros/scoemu/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/atheros/scoemu/flash.c b/board/atheros/scoemu/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/scoemu/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/scoemu/scoemu.c b/board/atheros/scoemu/scoemu.c
new file mode 100644
index 0000000000..7ac5b6ca4c
--- /dev/null
+++ b/board/atheros/scoemu/scoemu.c
@@ -0,0 +1,121 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(x)	strcpy(s, x)
+#	define CHECKBOARD_PARAMS	char *s
+#else
+#	define prmsg	printf
+#	define CHECKBOARD_PARAMS	void
+#endif
+
+void
+ath_usb_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	if (RST_BOOTSTRAP_REF_CLK_GET(ath_reg_rd(RST_BOOTSTRAP_ADDRESS)) == 0) {
+		ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+			ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(2));
+	} else {
+		ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+			ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+			SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	}
+
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) |
+		RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_PHY_RESET_SET(1)));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_PHY_ARESET_SET(1)));
+	udelay(1000);
+	ath_reg_wr(RST_RESET_ADDRESS,
+		ath_reg_rd(RST_RESET_ADDRESS) &
+		unset(RST_RESET_USB_HOST_RESET_SET(1)));
+	udelay(1000);
+	if ((ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf) == 0) {
+		/* Only for WASP 1.0 */
+		ath_reg_wr(0xb8116c84 ,
+			ath_reg_rd(0xb8116c84) & unset(1<<20));
+	}
+}
+
+void ath_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32;
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 &  ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	/* Switching regulator settings */
+	ath_reg_wr_nf(0x18116c40, 0x633c8176); /* AR_PHY_PMU1 */
+#if !defined(CONFIG_ATH_NAND_BR)
+	if (ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf) {
+		if (type == 2) {
+			// ddr1
+			ath_reg_wr_nf(0x18116c44, 0x10000000); /* AR_PHY_PMU2 */
+		} else {
+			// ddr2 & sdram
+			ath_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+		}
+	} else {
+		ath_reg_wr_nf(0x18116c44, 0x10380000); /* AR_PHY_PMU2 */
+	}
+#endif
+
+	ath_usb_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	reg32 = ath_ddr_find_size();
+
+	return reg32;
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(CHECKBOARD_PARAMS)
+{
+	prmsg("U-boot Scorpion Emulation\n");
+	return 0;
+}
diff --git a/board/atheros/scoemu/u-boot.lds b/board/atheros/scoemu/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/scoemu/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/atheros/tb6xx/Makefile b/board/atheros/tb6xx/Makefile
new file mode 100644
index 0000000000..057f11eac1
--- /dev/null
+++ b/board/atheros/tb6xx/Makefile
@@ -0,0 +1,73 @@
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	=			\
+	$(BOARD).o		\
+	flash.o			\
+	../common/init-955x.o	\
+	../common/serial.o	\
+	../common/ath_pci.o	\
+	../common/qca-eth-955x.o
+
+ifeq ($(BOOT_FROM_NAND),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifeq ($(ATH_DUAL_FLASH),1)
+OBJS	+= ../common/ath_nand.o ../../../drivers/nand/nand_ids.o
+endif
+
+ifndef BOOT_FROM_NAND
+OBJS	+= ../common/ath_flash.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG2), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s17_hwaccel)
+OBJS	+= ../common/athrs17_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s16)
+OBJS	+= ../common/athrs16_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f1e)
+OBJS	+= ../common/athrsf1_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _f2e)
+OBJS	+= ../common/athrsf2_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _vir)
+OBJS	+= ../common/athrs_vir_phy.o
+endif
+
+ifeq ($(ETH_CONFIG), _s27)
+OBJS	+= ../common/athr_s27_phy.o
+endif
+
+SOBJS	= ../common/955x.o ../common/tap-955x.S
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/atheros/tb6xx/config.mk b/board/atheros/tb6xx/config.mk
new file mode 100755
index 0000000000..38e0f11ed0
--- /dev/null
+++ b/board/atheros/tb6xx/config.mk
@@ -0,0 +1,19 @@
+# ROM version
+ifdef BOOT_FROM_NAND
+TEXT_BASE = 0xa0100000
+else
+ifeq ($(COMPRESSED_UBOOT),1)
+TEXT_BASE = 0x80010000
+BOOTSTRAP_TEXT_BASE = 0x9f000000
+else
+TEXT_BASE = 0x9f000000
+endif
+endif
+# TEXT_BASE = 0xbf000000
+
+# SDRAM version
+# TEXT_BASE = 0x80000000
+
+# RAM version
+# TEXT_BASE = 0x83fc0000
+# TEXT_BASE = 0x80100000
diff --git a/board/atheros/tb6xx/flash.c b/board/atheros/tb6xx/flash.c
new file mode 100644
index 0000000000..ffcbf7fe4f
--- /dev/null
+++ b/board/atheros/tb6xx/flash.c
@@ -0,0 +1,32 @@
+#include <common.h>
+#include <config.h>
+#include <asm/types.h>
+#include <flash.h>
+
+#ifndef CONFIG_ATH_NAND_BR
+/*
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long
+flash_get_geom (flash_info_t *flash_info)
+{
+	int i;
+
+	/* XXX this is hardcoded until we figure out how to read flash id */
+
+	flash_info->flash_id = FLASH_M25P64;
+	flash_info->size = CFG_FLASH_SIZE; /* bytes */
+	flash_info->sector_count = flash_info->size / CFG_FLASH_SECTOR_SIZE;
+
+	for (i = 0; i < flash_info->sector_count; i++) {
+		flash_info->start[i] = CFG_FLASH_BASE +
+					(i * CFG_FLASH_SECTOR_SIZE);
+		flash_info->protect[i] = 0;
+	}
+
+	printf ("flash size %dMB, sector count = %d\n",
+			FLASH_SIZE, flash_info->sector_count);
+
+	return (flash_info->size);
+}
+#endif /* CONFIG_ATH_NAND_BR */
diff --git a/board/atheros/tb6xx/tb6xx.c b/board/atheros/tb6xx/tb6xx.c
new file mode 100644
index 0000000000..6e1995a6bf
--- /dev/null
+++ b/board/atheros/tb6xx/tb6xx.c
@@ -0,0 +1,126 @@
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <config.h>
+#include <version.h>
+#include <atheros.h>
+
+extern int ath_ddr_initial_config(uint32_t refresh);
+extern int ath_ddr_find_size(void);
+
+#ifdef COMPRESSED_UBOOT
+#	define prmsg(x)	strcpy(s, x)
+#	define CHECKBOARD_PARAMS	char *s
+#else
+#	define prmsg	printf
+#	define CHECKBOARD_PARAMS	void
+#endif
+
+void
+ath_usb1_initial_config(void)
+{
+#define unset(a)	(~(a))
+
+	ath_reg_wr_nf(SWITCH_CLOCK_SPARE_ADDRESS,
+		ath_reg_rd(SWITCH_CLOCK_SPARE_ADDRESS) |
+		SWITCH_CLOCK_SPARE_USB_REFCLK_FREQ_SEL_SET(5));
+	udelay(1000);
+
+	ath_reg_rmw_set(RST_RESET_ADDRESS,
+				RST_RESET_USB_PHY_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_HOST_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET_ADDRESS, RST_RESET_USB_PHY_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB1_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+void
+ath_usb2_initial_config(void)
+{
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_MODE_SET(1));
+	udelay(10);
+	ath_reg_rmw_set(RST_RESET2_ADDRESS,
+				RST_RESET2_USB_PHY2_SUSPEND_OVERRIDE_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_RESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_ARESET_SET(1));
+	udelay(1000);
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_HOST2_RESET_SET(1));
+	udelay(1000);
+
+	ath_reg_rmw_clear(RST_RESET2_ADDRESS, RST_RESET2_USB_PHY2_PLL_PWD_EXT_SET(1));
+	udelay(10);
+
+	ath_reg_rmw_set(RST_RESET2_ADDRESS, RST_RESET2_USB2_EXT_PWR_SEQ_SET(1));
+	udelay(10);
+}
+
+
+void ath_gpio_config(void)
+{
+#if 0
+	/* Disable clock obs */
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) & 0xffe7e0ff));
+	/* Enable eth Switch LEDs */
+#ifdef CONFIG_K31
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xd8));
+#else
+	ath_reg_wr (AR7240_GPIO_FUNC, (ath_reg_rd(AR7240_GPIO_FUNC) | 0xfa));
+#endif
+#endif
+}
+
+int
+ath_mem_config(void)
+{
+	unsigned int type, reg32, *tap;
+	extern uint32_t *ath_ddr_tap_cal(void);
+
+#if !defined(CONFIG_ATH_EMULATION)
+	type = ath_ddr_initial_config(CFG_DDR_REFRESH_VAL);
+
+	tap = ath_ddr_tap_cal();
+	prmsg("tap = 0x%p\n", tap);
+
+	tap = (uint32_t *)0xbd007f10;
+	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
+
+	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
+	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
+		tap[0], tap[2], tap[2], tap[3]);
+
+	/* Take WMAC out of reset */
+	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
+	reg32 = reg32 & ~RST_RESET_RTC_RESET_SET(1);
+	ath_reg_wr_nf(RST_RESET_ADDRESS, reg32);
+
+	ath_usb1_initial_config();
+	ath_usb2_initial_config();
+
+	ath_gpio_config();
+#endif /* !defined(CONFIG_ATH_EMULATION) */
+
+	return ath_ddr_find_size();
+}
+
+long int initdram(int board_type)
+{
+	return (ath_mem_config());
+}
+
+int	checkboard(CHECKBOARD_PARAMS)
+{
+	prmsg("U-boot Scorpion\n");
+	return 0;
+}
diff --git a/board/atheros/tb6xx/u-boot.lds b/board/atheros/tb6xx/u-boot.lds
new file mode 100755
index 0000000000..c255264a5c
--- /dev/null
+++ b/board/atheros/tb6xx/u-boot.lds
@@ -0,0 +1,42 @@
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	. = ALIGN(16);
+	_gp = .;
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
-- 
2.24.0

